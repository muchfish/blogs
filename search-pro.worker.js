const nt="ENTRIES",V="KEYS",T="VALUES",F="";class D{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===F)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==F).join("")}value(){return E(this._path).node.get(F)}result(){switch(this._type){case T:return this.value();case V:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],ot=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return W(e,t,s,n,i,1,o,""),n},W=(e,t,s,n,o,u,i,r)=>{const h=u*i;t:for(const c of e.keys())if(c===F){const d=o[h-1];d<=s&&n.set(r,[e.get(c),d])}else{let d=u;for(let l=0;l<c.length;++l,++d){const p=c[l],f=i*d,g=f-i;let a=o[f];const m=Math.max(0,d-s-1),y=Math.min(i-1,d+s);for(let _=m;_<y;++_){const b=p!==t[_],z=o[g+_]+ +b,A=o[g+_+1]+1,w=o[f+_]+1,L=o[f+_+1]=Math.min(z,A,w);L<a&&(a=L)}if(a>s)continue t}W(e.get(c),t,s,n,o,d,i,r+c)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=O(n);for(const i of o.keys())if(i!==F&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ut(this._tree,t)}entries(){return new D(this,nt)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return ot(this._tree,t,s)}get(t){const s=I(this._tree,t);return s!==void 0?s.get(F):void 0}has(t){const s=I(this._tree,t);return s!==void 0&&s.has(F)}keys(){return new D(this,V)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,M(this._tree,t).set(F,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=M(this._tree,t);return n.set(F,s(n.get(F))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=M(this._tree,t);let o=n.get(F);return o===void 0&&n.set(F,o=s()),o}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==F&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},I=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==F&&t.startsWith(s))return I(e.get(s),t.slice(s.length))},M=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==F&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const h=e.get(u);if(r===u.length)e=h;else{const c=new Map;c.set(u.slice(r),h),e.set(t.slice(n,n+r),c),e.delete(u),e=c}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ut=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(F),s.size===0)R(n);else if(s.size===1){const[o,u]=s.entries().next().value;$(n,o,u)}}},R=e=>{if(e.length===0)return;const[t,s]=O(e);if(t.delete(s),t.size===0)R(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==F&&$(e.slice(0,-1),n,o)}},$=(e,t,s)=>{if(e.length===0)return;const[n,o]=O(e);n.set(o+t,s),n.delete(o)},O=e=>e[e.length-1],it=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},rt=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,S="or",q="and",ct="and_not",lt=(e,t)=>{e.includes(t)||e.push(t)},P=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},G=({score:e},{score:t})=>t-e,ht=()=>new Map,k=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},N=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,dt={[S]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),P(n.terms,u)}}return e},[q]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);P(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[ct]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},at=(e,t,s,n,o,u)=>{const{k:i,b:r,d:h}=u;return Math.log(1+(s-t+.5)/(t+.5))*(h+e*(i+1)/(e+i*(1-r+r*n/o)))},ft=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},H=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},gt=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const o=e._index.fetch(n,ht),u=o.get(t);u==null||u.get(s)==null?H(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},mt={k:1.2,b:.7,d:.5},pt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(rt),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof(console==null?void 0:console[e])=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:S,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:mt},Ft={combineWith:q,prefix:(e,t,s)=>t===s.length-1},_t={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},yt={..._t,...U},Y=(e,t=S)=>{if(e.length===0)return new Map;const s=t.toLowerCase();return e.reduce(dt[s])||new Map},B=(e,t,s,n,o,u,i,r,h=new Map)=>{if(o==null)return h;for(const c of Object.keys(u)){const d=u[c],l=e._fieldIds[c],p=o.get(l);if(p==null)continue;let f=p.size;const g=e._avgFieldLength[l];for(const a of p.keys()){if(!e._documentIds.has(a)){gt(e,l,a,s),f-=1;continue}const m=i?i(e._documentIds.get(a),s,e._storedFields.get(a)):1;if(!m)continue;const y=p.get(a),_=e._fieldLength.get(a)[l],b=at(y,f,e._documentCount,_,g,r),z=n*d*m*b,A=h.get(a);if(A){A.score+=z,lt(A.terms,t);const w=N(A.match,s);w?w.push(c):A.match[s]=[c]}else h.set(a,{score:z,terms:[t],match:{[s]:[c]}})}}return h},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((a,m)=>({...a,[m]:N(n.boost,m)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:h}=n,{fuzzy:c,prefix:d}={...J.weights,...i},l=e._index.get(t.term),p=B(e,t.term,t.term,1,l,o,u,h);let f,g;if(t.prefix&&(f=e._index.atPrefix(t.term)),t.fuzzy){const a=t.fuzzy===!0?.2:t.fuzzy,m=a<1?Math.min(r,Math.round(t.term.length*a)):a;m&&(g=e._index.fuzzyGet(t.term,m))}if(f)for(const[a,m]of f){const y=a.length-t.term.length;if(!y)continue;g==null||g.delete(a);const _=d*a.length/(a.length+.3*y);B(e,t.term,a,_,m,o,u,h,p)}if(g)for(const a of g.keys()){const[m,y]=g.get(a);if(!y)continue;const _=c*a.length/(a.length+y);B(e,t.term,a,_,m,o,u,h,p)}return p},X=(e,t,s={})=>{if(typeof t!="string"){const d={...s,...t,queries:void 0},l=t.queries.map(p=>X(e,p,d));return Y(l,d.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:h}=i,c=r(t).flatMap(d=>h(d)).filter(d=>!!d).map(ft(i)).map(d=>At(e,d,i));return Y(c,i.combineWith)},K=(e,t,s={})=>{const n=X(e,t,s),o=[];for(const[u,{score:i,terms:r,match:h}]of n){const c=r.length,d={id:e._documentIds.get(u),score:i*c,terms:Object.keys(h),match:h};Object.assign(d,e._storedFields.get(u)),(s.filter==null||s.filter(d))&&o.push(d)}return o.sort(G),o},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of K(e,t,s)){const r=i.join(" "),h=n.get(r);h!=null?(h.score+=u,h.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:h}]of n)o.push({suggestion:u,terms:r,score:i/h});return o.sort(G),o};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if((t==null?void 0:t.fields)==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?yt:t.autoVacuum;this._options={...pt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...Ft,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:h,serializationVersion:c},d)=>{if(c!==1&&c!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const l=new Et(d);l._documentCount=t,l._nextId=s,l._documentIds=k(n),l._idToShortId=new Map,l._fieldIds=o,l._fieldLength=k(u),l._avgFieldLength=i,l._storedFields=k(r),l._dirtCount=h||0,l._index=new C;for(const[p,f]of l._documentIds)l._idToShortId.set(f,p);for(const[p,f]of e){const g=new Map;for(const a of Object.keys(f)){let m=f[a];c===1&&(m=m.ds),g.set(parseInt(a,10),k(m))}l._index.set(p,g)}return l},Q=Object.entries,wt=Object.fromEntries,j=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(c,d=!1)=>{let l="";i===0?l=c.length>20?`… ${c.slice(-20)}`:c:d?l=c.length+i>100?`${c.slice(0,100-i)}… `:c:l=c.length>20?`${c.slice(0,20)} … ${c.slice(-20)}`:c,l&&o.push(l),i+=l.length,d||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let h=s.indexOf(n,u);if(h===-1)return null;for(;h>=0;){const c=h+n.length;if(r(e.slice(u,h)),u=c,i>100)break;h=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},Z=/[\u4e00-\u9fa5]/g,tt=(e={})=>({fuzzy:.2,prefix:!0,processTerm:t=>{const s=t.match(Z)||[],n=t.replace(Z,"").toLowerCase();return n?[n,...s]:[...s]},...e}),xt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),kt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),et=(e,t,s={})=>{const n={};return K(t,e,tt({boost:{h:2,t:1,c:4},...s})).forEach(o=>{const{id:u,terms:i,score:r}=o,h=u.includes("@"),c=u.includes("#"),[d,l]=u.split(/[#@]/),{contents:p}=n[d]??={title:"",contents:[]};if(h)p.push([{type:"customField",key:d,index:l,display:i.map(f=>o.c.map(g=>j(g,f))).flat().filter(f=>f!==null)},r]);else{const f=i.map(g=>j(o.h,g)).filter(g=>g!==null);if(f.length&&p.push([{type:c?"heading":"title",key:d,...c&&{anchor:l},display:f},r]),"t"in o)for(const g of o.t){const a=i.map(m=>j(g,m)).filter(m=>m!==null);a.length&&p.push([{type:"text",key:d,...c&&{anchor:l},display:a},r])}}}),Q(n).sort(([,o],[,u])=>"max"==="total"?xt(o,u):kt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=it(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},st=(e,t,s={})=>Ct(t,e,tt(s)).map(({suggestion:n})=>n),v=wt(Q(JSON.parse("{\"/\":{\"documentCount\":792,\"nextId\":792,\"documentIds\":{\"0\":\"v-8daa1a0e\",\"1\":\"v-8daa1a0e#关于网站\",\"2\":\"v-8daa1a0e#关于作者\",\"3\":\"v-8daa1a0e#占个位\",\"4\":\"v-8daa1a0e#star-趋势\",\"5\":\"v-184f4da6\",\"6\":\"v-2e3eac9e\",\"7\":\"v-4bc4557f\",\"8\":\"v-4bc4557f#三分钟搭建一个博客网站\",\"9\":\"v-4bc4557f#准备运行环境\",\"10\":\"v-4bc4557f#创建项目模板\",\"11\":\"v-4bc4557f#创建过程\",\"12\":\"v-4bc4557f#访问\",\"13\":\"v-4bc4557f#效果\",\"14\":\"v-4bc4557f#项目启动命令\",\"15\":\"v-4bc4557f#发布到github\",\"16\":\"v-4bc4557f#修改deploy-docs-yml\",\"17\":\"v-4bc4557f#修改config-ts\",\"18\":\"v-4bc4557f#共享项目到github\",\"19\":\"v-4bc4557f#从master新建分支gh-pages-推送新分支到github\",\"20\":\"v-4bc4557f#github上开源\",\"21\":\"v-4bc4557f#配置github-pages\",\"22\":\"v-4bc4557f#更新博客只在master分支上改-不要动gh-pages分支\",\"23\":\"v-4bc4557f#修复-编辑此页-功能链接跳转不对问题\",\"24\":\"v-4bc4557f#踩坑\",\"25\":\"v-4bc4557f@0\",\"26\":\"v-4bc4557f@1\",\"27\":\"v-e287e936\",\"28\":\"v-e287e936#_1-流程图\",\"29\":\"v-e287e936#_2-序列图\",\"30\":\"v-e287e936#_3-类图\",\"31\":\"v-e287e936#_4-状态图\",\"32\":\"v-e287e936#_5-实体关系图\",\"33\":\"v-e287e936#_6-用户旅程图\",\"34\":\"v-e287e936#_7-甘特图\",\"35\":\"v-e287e936#_8-饼图\",\"36\":\"v-e287e936#_9-象限图\",\"37\":\"v-e287e936#_10-需求图\",\"38\":\"v-e287e936#_11-gitgraph-git-图表\",\"39\":\"v-e287e936#_12-c4-图\",\"40\":\"v-e287e936#c4-系统上下文图-c4context\",\"41\":\"v-e287e936#c4-容器图-c4container\",\"42\":\"v-e287e936#c4-组件图-c4component\",\"43\":\"v-e287e936#c4-动态图-c4dynamic\",\"44\":\"v-e287e936#c4-部署图-c4deployment\",\"45\":\"v-e287e936#_13思维导图\",\"46\":\"v-e287e936#_14-时间线图\",\"47\":\"v-e287e936#_15zenuml\",\"48\":\"v-e287e936#_16-桑基图\",\"49\":\"v-e287e936#_17-xy-图表\",\"50\":\"v-e287e936#_18-框图文档\",\"51\":\"v-e287e936#_19-数据包图\",\"52\":\"v-61022ca6\",\"53\":\"v-61022ca6#有哪些常用的命令行性能监控和故障处理工具\",\"54\":\"v-61022ca6#操作系统工具\",\"55\":\"v-61022ca6#jdk工具\",\"56\":\"v-61022ca6#arthas工具\",\"57\":\"v-61022ca6#了解哪些可视化的性能监控和故障处理工具\",\"58\":\"v-61022ca6#_1-visualvm\",\"59\":\"v-61022ca6#_2-jconsole\",\"60\":\"v-61022ca6#_3-java-mission-control-jmc\",\"61\":\"v-61022ca6#_4-visualvm-profiler\",\"62\":\"v-61022ca6#_5-grafana\",\"63\":\"v-61022ca6#_6-prometheus\",\"64\":\"v-61022ca6#_7-elastic-stack-elk-stack\",\"65\":\"v-61022ca6#_8-new-relic\",\"66\":\"v-61022ca6#_9-appdynamics\",\"67\":\"v-61022ca6#_10-dynatrace\",\"68\":\"v-61022ca6#_11-glowroot\",\"69\":\"v-61022ca6#_12-pinpoint\",\"70\":\"v-61022ca6#总结表格\",\"71\":\"v-61022ca6#jvm的常见参数配置知道哪些\",\"72\":\"v-61022ca6#内存管理参数\",\"73\":\"v-61022ca6#垃圾回收参数\",\"74\":\"v-61022ca6#性能调优参数\",\"75\":\"v-61022ca6#调试和监控参数\",\"76\":\"v-61022ca6#其他常见参数\",\"77\":\"v-61022ca6#有做过jvm调优吗\",\"78\":\"v-61022ca6#_1-收集信息和分析\",\"79\":\"v-61022ca6#_2-设置基准线\",\"80\":\"v-61022ca6#_3-分析问题和瓶颈\",\"81\":\"v-61022ca6#_4-制定调优策略\",\"82\":\"v-61022ca6#_5-实施调优和测试\",\"83\":\"v-61022ca6#_6-监控和优化\",\"84\":\"v-61022ca6#有实际调优过吗\",\"85\":\"v-61022ca6#线上服务cpu占用过高怎么排查\",\"86\":\"v-61022ca6#内存飙高问题怎么排查\",\"87\":\"v-61022ca6#频繁-minor-gc-怎么办\",\"88\":\"v-61022ca6#频繁full-gc怎么办\",\"89\":\"v-61022ca6#有没有处理过内存泄漏问题-是如何定位的\",\"90\":\"v-61022ca6#有没有处理过oom问题\",\"91\":\"v-308fde42\",\"92\":\"v-308fde42#能说一下jvm的内存区域吗\",\"93\":\"v-308fde42#说一下jdk1-6、1-7、1-8内存区域的变化\",\"94\":\"v-308fde42#jdk-1-6\",\"95\":\"v-308fde42#jdk-1-7\",\"96\":\"v-308fde42#jdk-1-8\",\"97\":\"v-308fde42#详细变化对比\",\"98\":\"v-308fde42#永久代-permgen-与元空间-metaspace\",\"99\":\"v-308fde42#字符串常量池\",\"100\":\"v-308fde42#运行时常量池\",\"101\":\"v-308fde42#总结\",\"102\":\"v-308fde42#字符串常量池和运行时常量池有啥区别\",\"103\":\"v-308fde42#字符串常量池-1\",\"104\":\"v-308fde42#运行时常量池-1\",\"105\":\"v-308fde42#区别总结\",\"106\":\"v-308fde42#上面的代码示例中int-a-10不应该存放在栈中吗\",\"107\":\"v-308fde42#运行时常量池和栈中的局部变量\",\"108\":\"v-308fde42#解释-int-a-10\",\"109\":\"v-308fde42#修正后的解释和示例代码\",\"110\":\"v-308fde42#总结-1\",\"111\":\"v-308fde42#为什么使用元空间替代永久代作为方法区的实现\",\"112\":\"v-308fde42#使用元空间替代永久代的原因\",\"113\":\"v-308fde42#客观原因\",\"114\":\"v-308fde42#主观原因\",\"115\":\"v-308fde42#元空间的优势\",\"116\":\"v-308fde42#总结-2\",\"117\":\"v-308fde42#对象创建的过程了解吗\",\"118\":\"v-308fde42#什么是指针碰撞-什么是空闲列表\",\"119\":\"v-308fde42#什么是tlab-thread-local-allocation-buffer\",\"120\":\"v-308fde42#jvm-里-new-对象时-堆会发生抢占吗-jvm是怎么设计来保证线程安全的\",\"121\":\"v-308fde42#能说一下对象的内存布局吗\",\"122\":\"v-308fde42#对象怎么访问定位\",\"123\":\"v-308fde42#什么是内存溢出、内存泄漏\",\"124\":\"v-308fde42#能手写内存溢出的例子吗\",\"125\":\"v-308fde42#内存泄漏可能由哪些原因导致呢\",\"126\":\"v-308fde42#如何判断对象仍然存活\",\"127\":\"v-308fde42#java中可作为gc-roots的对象有哪几种\",\"128\":\"v-308fde42#说一下对象有哪几种引用\",\"129\":\"v-308fde42#finalize-方法了解吗-有什么作用\",\"130\":\"v-308fde42#java堆的内存分区了解吗\",\"131\":\"v-308fde42#垃圾收集算法了解吗\",\"132\":\"v-308fde42#说一下新生代的区域划分\",\"133\":\"v-308fde42#minor-gc-young-gc、major-gc-old-gc、mixed-gc、full-gc都是什么意思\",\"134\":\"v-308fde42#minor-gc-young-gc什么时候触发\",\"135\":\"v-308fde42#什么时候会触发full-gc\",\"136\":\"v-308fde42#对象什么时候会进入老年代\",\"137\":\"v-308fde42#知道有哪些垃圾收集器吗\",\"138\":\"v-308fde42#什么是stop-the-world-什么是-oopmap-什么是安全点\",\"139\":\"v-308fde42#能详细说一下cms收集器的垃圾收集过程吗\",\"140\":\"v-308fde42#g1垃圾收集器了解吗\",\"141\":\"v-308fde42#g1垃圾收集器的关键特点\",\"142\":\"v-308fde42#g1垃圾收集器的工作阶段\",\"143\":\"v-308fde42#g1垃圾收集器的优势\",\"144\":\"v-308fde42#g1垃圾收集器的配置参数\",\"145\":\"v-308fde42#总结-3\",\"146\":\"v-308fde42#有了cms-为什么还要引入g1\",\"147\":\"v-308fde42#cms的局限性\",\"148\":\"v-308fde42#g1垃圾收集器的优势-1\",\"149\":\"v-308fde42#总结-4\",\"150\":\"v-308fde42#你们线上用的什么垃圾收集器-为什么要用它\",\"151\":\"v-308fde42#常见的垃圾收集器\",\"152\":\"v-308fde42#为什么选择某种垃圾收集器\",\"153\":\"v-308fde42#使用g1的理由\",\"154\":\"v-308fde42#使用zgc的理由\",\"155\":\"v-308fde42#大公司和常见应用中的选择\",\"156\":\"v-308fde42#总结-5\",\"157\":\"v-308fde42#垃圾收集器应该如何选择\",\"158\":\"v-308fde42#关键考虑因素\",\"159\":\"v-308fde42#常见垃圾收集器选项\",\"160\":\"v-308fde42#选择垃圾收集器的步骤\",\"161\":\"v-308fde42#总结-6\",\"162\":\"v-308fde42#对象一定分配在堆中吗-有没有了解逃逸分析技术\",\"163\":\"v-308fde42#对象分配的基本概念\",\"164\":\"v-308fde42#逃逸分析-escape-analysis\",\"165\":\"v-308fde42#逃逸分析的应用示例\",\"166\":\"v-308fde42#jvm参数和逃逸分析\",\"167\":\"v-308fde42#逃逸分析的优势\",\"168\":\"v-308fde42#总结-7\",\"169\":\"v-308fde42#逃逸分析中标量替换的工作原理是怎样的\",\"170\":\"v-308fde42#标量替换的工作原理\",\"171\":\"v-308fde42#示例代码\",\"172\":\"v-308fde42#原始代码\",\"173\":\"v-308fde42#优化后的代码-标量替换效果\",\"174\":\"v-308fde42#jvm参数\",\"175\":\"v-308fde42#总结-8\",\"176\":\"v-1ea3b38e\",\"177\":\"v-1ea3b38e#什么是jvm\",\"178\":\"v-1ea3b38e#jvm的主要功能\",\"179\":\"v-1ea3b38e#jvm的结构\",\"180\":\"v-1ea3b38e#jvm的工作过程\",\"181\":\"v-1ea3b38e#jvm的跨平台特性\",\"182\":\"v-0a5fb23e\",\"183\":\"v-0a5fb23e#能说一下类的生命周期吗\",\"184\":\"v-0a5fb23e#_1-加载-loading\",\"185\":\"v-0a5fb23e#_2-验证-verification\",\"186\":\"v-0a5fb23e#_3-准备-preparation\",\"187\":\"v-0a5fb23e#_4-解析-resolution\",\"188\":\"v-0a5fb23e#_5-初始化-initialization\",\"189\":\"v-0a5fb23e#_6-使用-using\",\"190\":\"v-0a5fb23e#_7-卸载-unloading\",\"191\":\"v-0a5fb23e#类加载的过程知道吗\",\"192\":\"v-0a5fb23e#_1-获取二进制字节流\",\"193\":\"v-0a5fb23e#_2-转换为方法区的运行时数据结构\",\"194\":\"v-0a5fb23e#_3-创建class对象\",\"195\":\"v-0a5fb23e#详细描述\",\"196\":\"v-0a5fb23e#加载阶段结束后\",\"197\":\"v-0a5fb23e#小结\",\"198\":\"v-0a5fb23e#类加载器有哪些\",\"199\":\"v-0a5fb23e#_1-启动类加载器-bootstrap-classloader\",\"200\":\"v-0a5fb23e#_2-扩展类加载器-extension-classloader\",\"201\":\"v-0a5fb23e#_3-应用程序类加载器-application-classloader\",\"202\":\"v-0a5fb23e#_4-自定义类加载器-custom-classloader\",\"203\":\"v-0a5fb23e#类加载器的层次结构\",\"204\":\"v-0a5fb23e#示例代码\",\"205\":\"v-0a5fb23e#什么是双亲委派机制\",\"206\":\"v-0a5fb23e#工作原理\",\"207\":\"v-0a5fb23e#双亲委派机制的优点\",\"208\":\"v-0a5fb23e#为什么要用双亲委派机制\",\"209\":\"v-0a5fb23e#_1-确保类的唯一性和一致性\",\"210\":\"v-0a5fb23e#_2-避免重复加载类\",\"211\":\"v-0a5fb23e#_3-加载类的安全性\",\"212\":\"v-0a5fb23e#_4-统一类加载规则\",\"213\":\"v-0a5fb23e#_5-支持模块化开发和扩展性\",\"214\":\"v-0a5fb23e#如何破坏双亲委派机制\",\"215\":\"v-0a5fb23e#_1-自定义类加载器\",\"216\":\"v-0a5fb23e#_2-直接调用classloader-loadclass方法\",\"217\":\"v-0a5fb23e#_3-修改classloader类的defineclass方法\",\"218\":\"v-0a5fb23e#_4-osgi等框架\",\"219\":\"v-0a5fb23e#_5-应用服务器-如tomcat-的类加载策略\",\"220\":\"v-0a5fb23e#_6-thread-currentthread-setcontextclassloader\",\"221\":\"v-0a5fb23e#历史上有哪几次双亲委派机制的破坏\",\"222\":\"v-0a5fb23e#第一次破坏\",\"223\":\"v-0a5fb23e#第二次破坏\",\"224\":\"v-0a5fb23e#第三次破坏\",\"225\":\"v-0a5fb23e#你觉得应该怎么实现一个热部署功能\",\"226\":\"v-0a5fb23e#_1-使用合适的类加载器\",\"227\":\"v-0a5fb23e#_2-监视类文件的变化\",\"228\":\"v-0a5fb23e#_3-动态加载新的类\",\"229\":\"v-0a5fb23e#_4-更新已加载类的实例\",\"230\":\"v-0a5fb23e#_5-卸载旧的类\",\"231\":\"v-0a5fb23e#_6-错误处理和回滚\",\"232\":\"v-0a5fb23e#_7-测试和验证\",\"233\":\"v-0a5fb23e#为什么自定义类加载器-有时是重写loadclass方法-有时是重写findclass方法-有时是重写defineclass方法\",\"234\":\"v-0a5fb23e#tomcat的类加载机制了解吗\",\"235\":\"v-5a86df84\",\"236\":\"v-5a86df84#java-中-io-流分为几种\",\"237\":\"v-5a86df84#既然有了字节流-为什么还要有字符流\",\"238\":\"v-5a86df84#bio、nio、aio\",\"239\":\"v-1312876c\",\"240\":\"v-1312876c#jdk1-8都有哪些新特性\",\"241\":\"v-1312876c#lambda-表达式了解多少\",\"242\":\"v-1312876c#java8有哪些内置函数式接口\",\"243\":\"v-1312876c#optional了解吗\",\"244\":\"v-1312876c#stream-流用过吗\",\"245\":\"v-c07f430a\",\"246\":\"v-c07f430a#java语言有哪些特点\",\"247\":\"v-c07f430a#jvm、jdk-和-jre-有什么区别\",\"248\":\"v-c07f430a#说说什么是跨平台性-原理是什么\",\"249\":\"v-c07f430a#什么是字节码-采用字节码的好处是什么\",\"250\":\"v-c07f430a#为什么说-java-语言-编译与解释并存\",\"251\":\"v-7a4439e4\",\"252\":\"v-7a4439e4#说下什么是java的spi机制\",\"253\":\"v-6ea29174\",\"254\":\"v-6ea29174#什么是反射\",\"255\":\"v-6ea29174#反射的应用场景\",\"256\":\"v-6ea29174#反射的实现原理\",\"257\":\"v-7b1507c1\",\"258\":\"v-7b1507c1#java有哪些数据类型\",\"259\":\"v-7b1507c1#什么是自动类型转换、强制类型转换\",\"260\":\"v-7b1507c1#什么是自动拆箱-封箱\",\"261\":\"v-7b1507c1#和-有什么区别\",\"262\":\"v-7b1507c1#switch-是否能作用在-byte-long-string上\",\"263\":\"v-7b1507c1#break-continue-return-的区别及作用\",\"264\":\"v-7b1507c1#用最有效率的方法计算2乘以8\",\"265\":\"v-7b1507c1#说说自增自减运算\",\"266\":\"v-3c7dde24\",\"267\":\"v-3c7dde24#string-是-java-基本数据类型吗-可以被继承吗\",\"268\":\"v-3c7dde24#string和stringbuilder、stringbuffer\",\"269\":\"v-3c7dde24#string-str1-new-string-abc-和string-str2-abc-和-区别\",\"270\":\"v-3c7dde24#string不是不可变类吗-字符串拼接是如何实现的\",\"271\":\"v-3c7dde24#intern方法有什么作用\",\"272\":\"v-3c7dde24#integer-a-127-integer-b-127-integer-c-128-integer-d-128-相等吗\",\"273\":\"v-3c7dde24#string怎么转成integer的-原理\",\"274\":\"v-3c7dde24#object-类的常见方法\",\"275\":\"v-f4f1fe14\",\"276\":\"v-f4f1fe14#什么是序列化-什么是反序列化\",\"277\":\"v-f4f1fe14#说说有哪些常见的序列化方式\",\"278\":\"v-d796f946\",\"279\":\"v-d796f946#java-中异常层级结构\",\"280\":\"v-d796f946#异常的处理机制\",\"281\":\"v-d796f946#finally一定会执行吗\",\"282\":\"v-d796f946#三道经典异常处理代码题\",\"283\":\"v-7452d982\",\"284\":\"v-7452d982#什么是泛型\",\"285\":\"v-7452d982#泛型的使用方法\",\"286\":\"v-7452d982#泛型常用的通配符有哪些\",\"287\":\"v-7452d982#什么是泛型擦除\",\"288\":\"v-a015b2a8\",\"289\":\"v-a015b2a8#说一下你对注解的理解\",\"290\":\"v-0fc5aa7c\",\"291\":\"v-0fc5aa7c#java中实现map接口的有哪些类\",\"292\":\"v-0fc5aa7c#遍历hashmap的几种方法\",\"293\":\"v-3f68359b\",\"294\":\"v-3f68359b#面向对象和面向过程的区别\",\"295\":\"v-3f68359b#面向对象有哪些特性\",\"296\":\"v-3f68359b#重载-overload-和重写-override-的区别\",\"297\":\"v-3f68359b#访问修饰符public、private、protected、以及不写-默认-时的-区别\",\"298\":\"v-3f68359b#this关键字有什么作用\",\"299\":\"v-3f68359b#抽象类-abstract-class-和接口-interface-有什么区别\",\"300\":\"v-3f68359b#成员变量与局部变量的区别有哪些\",\"301\":\"v-3f68359b#静态变量和实例变量的区别-静态方法、实例方法呢\",\"302\":\"v-3f68359b#final关键字有什么作用\",\"303\":\"v-3f68359b#final、finally、finalize的区别\",\"304\":\"v-3f68359b#和-equals-的区别\",\"305\":\"v-3f68359b#hashcode与-equals\",\"306\":\"v-3f68359b#java是值传递-还是引用传递\",\"307\":\"v-3f68359b#什么是深拷贝和浅拷贝\",\"308\":\"v-3f68359b#java-创建对象有哪几种方式\",\"309\":\"v-3f68359b#java内部类为什么推荐用静态类\",\"310\":\"v-3f68359b#示例\",\"311\":\"v-3f68359b#非静态内部类\",\"312\":\"v-3f68359b#静态内部类\",\"313\":\"v-3f68359b#总结\",\"314\":\"v-e28e0b1c\",\"315\":\"v-e28e0b1c#说一下你对java内存模型-jmm-的理解\",\"316\":\"v-e28e0b1c#说说你对原子性、可见性、有序性的理解\",\"317\":\"v-e28e0b1c#分析下面几行代码的原子性\",\"318\":\"v-e28e0b1c#原子性、可见性、有序性都应该怎么保证呢\",\"319\":\"v-e28e0b1c#那说说什么是指令重排\",\"320\":\"v-e28e0b1c#指令重排有限制吗-happens-before了解吗\",\"321\":\"v-e28e0b1c#as-if-serial又是什么-单线程的程序一定是顺序的吗\",\"322\":\"v-e28e0b1c#volatile实现原理了解吗\",\"323\":\"v-e28e0b1c#volatile怎么保证可见性的呢\",\"324\":\"v-e28e0b1c#volatile怎么保证有序性的呢\",\"325\":\"v-9eb56fc8\",\"326\":\"v-9eb56fc8#threadlocal是什么\",\"327\":\"v-9eb56fc8#你在工作中用到过threadlocal吗\",\"328\":\"v-9eb56fc8#threadlocal怎么实现的呢\",\"329\":\"v-9eb56fc8#threadlocal-内存泄露是怎么回事\",\"330\":\"v-9eb56fc8#那怎么解决内存泄漏问题呢\",\"331\":\"v-9eb56fc8#为什么key还要设计成弱引用\",\"332\":\"v-9eb56fc8#threadlocalmap的结构了解吗\",\"333\":\"v-9eb56fc8#threadlocalmap怎么解决hash冲突的\",\"334\":\"v-9eb56fc8#threadlocalmap扩容机制了解吗\",\"335\":\"v-9eb56fc8#父子线程怎么共享数据\",\"336\":\"v-9eb56fc8#inheritablethreadlocal原理是什么呢\",\"337\":\"v-9eb56fc8#还有什么其它办法-ttl\",\"338\":\"v-acbe6806\",\"339\":\"v-acbe6806#并行跟并发有什么区别\",\"340\":\"v-acbe6806#说说什么是进程和线程\",\"341\":\"v-acbe6806#说说线程有几种创建方式\",\"342\":\"v-acbe6806#为什么调用start-方法时会执行run-方法-那怎么不直接调用run-方法\",\"343\":\"v-acbe6806#thread和runnable有什么区别\",\"344\":\"v-acbe6806#线程有哪些常用的调度方法\",\"345\":\"v-acbe6806#线程有几种状态\",\"346\":\"v-acbe6806#blocked和waiting有什么区别\",\"347\":\"v-acbe6806#waiting和terminated有什么区别\",\"348\":\"v-acbe6806#什么是线程上下文切换\",\"349\":\"v-acbe6806#线程上下文切换通常发生在以下几种情况下\",\"350\":\"v-acbe6806#守护线程了解吗\",\"351\":\"v-acbe6806#线程间有哪些通信方式\",\"352\":\"v-3d48b51b\",\"353\":\"v-3d48b51b#countdownlatch-倒计数器-了解吗\",\"354\":\"v-3d48b51b#cyclicbarrier-同步屏障-了解吗\",\"355\":\"v-3d48b51b#重要注意事项\",\"356\":\"v-3d48b51b#cyclicbarrier和countdownlatch有什么区别\",\"357\":\"v-3d48b51b#semaphore-信号量-了解吗\",\"358\":\"v-3d48b51b#解释\",\"359\":\"v-3d48b51b#重要注意事项-1\",\"360\":\"v-3d48b51b#exchanger-了解吗\",\"361\":\"v-3d48b51b#代码示例\",\"362\":\"v-3d48b51b#解释-1\",\"363\":\"v-3d48b51b#重要注意事项-2\",\"364\":\"v-3d48b51b#说说你对completablefuture的理解\",\"365\":\"v-3d48b51b#_1-引言\",\"366\":\"v-3d48b51b#_2-基本概念\",\"367\":\"v-3d48b51b#_2-1-创建-completablefuture\",\"368\":\"v-3d48b51b#_3-任务完成后的回调\",\"369\":\"v-3d48b51b#_3-1-thenapply\",\"370\":\"v-3d48b51b#_3-2-thenaccept\",\"371\":\"v-3d48b51b#_3-3-thenrun\",\"372\":\"v-3d48b51b#_4-组合多个-completablefuture\",\"373\":\"v-3d48b51b#_4-1-thencompose\",\"374\":\"v-3d48b51b#_4-2-thencombine\",\"375\":\"v-3d48b51b#_4-3-allof\",\"376\":\"v-3d48b51b#_5-处理异常\",\"377\":\"v-3d48b51b#_5-1-exceptionally\",\"378\":\"v-3d48b51b#_5-2-handle\",\"379\":\"v-3d48b51b#_6-超时控制\",\"380\":\"v-3d48b51b#_6-1-ortimeout\",\"381\":\"v-3d48b51b#_6-2-completeontimeout\",\"382\":\"v-3d48b51b#_7-并行执行多个任务\",\"383\":\"v-3d48b51b#示例\",\"384\":\"v-3d48b51b#_8-真实场景应用\",\"385\":\"v-3d48b51b#_8-1-并行获取数据\",\"386\":\"v-3d48b51b#_9-总结\",\"387\":\"v-3d48b51b#completablefuture的线程池设置\",\"388\":\"v-3d48b51b#_1-使用默认线程池\",\"389\":\"v-3d48b51b#_2-指定自定义线程池\",\"390\":\"v-3d48b51b#_2-1-创建自定义线程池\",\"391\":\"v-3d48b51b#_2-2-使用自定义线程池\",\"392\":\"v-3d48b51b#_3-完整示例\",\"393\":\"v-3d48b51b#_4-线程池类型\",\"394\":\"v-3d48b51b#_4-1-固定大小线程池\",\"395\":\"v-3d48b51b#_4-2-缓存线程池\",\"396\":\"v-3d48b51b#_4-3-单线程池\",\"397\":\"v-3d48b51b#_4-4-调度线程池\",\"398\":\"v-3d48b51b#_5-异步任务链中的线程池\",\"399\":\"v-7ee9fffc\",\"400\":\"v-7ee9fffc#说说阻塞队列是怎么实现的\",\"401\":\"v-d64e3d96\",\"402\":\"v-d64e3d96#什么是线程池\",\"403\":\"v-d64e3d96#_1-线程池的基本概念\",\"404\":\"v-d64e3d96#_2-线程池的优势\",\"405\":\"v-d64e3d96#_3-java中的线程池实现\",\"406\":\"v-d64e3d96#_3-1-常见的线程池类型\",\"407\":\"v-d64e3d96#_4-线程池的使用示例\",\"408\":\"v-d64e3d96#_5-线程池的配置参数\",\"409\":\"v-d64e3d96#_6-自定义线程池\",\"410\":\"v-d64e3d96#为什么说频繁创建和销毁线程的开销大\",\"411\":\"v-d64e3d96#_1-系统资源消耗\",\"412\":\"v-d64e3d96#_1-1-内存开销\",\"413\":\"v-d64e3d96#_1-2-操作系统资源\",\"414\":\"v-d64e3d96#_2-cpu消耗\",\"415\":\"v-d64e3d96#_2-1-线程上下文切换\",\"416\":\"v-d64e3d96#_2-2-同步开销\",\"417\":\"v-d64e3d96#_3-jvm的开销\",\"418\":\"v-d64e3d96#_3-1-垃圾回收\",\"419\":\"v-d64e3d96#_3-2-jit优化\",\"420\":\"v-d64e3d96#能说说工作中线程池的应用吗\",\"421\":\"v-d64e3d96#_1-web服务器\",\"422\":\"v-d64e3d96#场景描述\",\"423\":\"v-d64e3d96#解决方案\",\"424\":\"v-d64e3d96#代码示例\",\"425\":\"v-d64e3d96#_2-数据库连接池\",\"426\":\"v-d64e3d96#场景描述-1\",\"427\":\"v-d64e3d96#解决方案-1\",\"428\":\"v-d64e3d96#代码示例-1\",\"429\":\"v-d64e3d96#_3-并行数据处理\",\"430\":\"v-d64e3d96#场景描述-2\",\"431\":\"v-d64e3d96#解决方案-2\",\"432\":\"v-d64e3d96#代码示例-2\",\"433\":\"v-d64e3d96#_4-异步任务执行\",\"434\":\"v-d64e3d96#场景描述-3\",\"435\":\"v-d64e3d96#解决方案-3\",\"436\":\"v-d64e3d96#代码示例-3\",\"437\":\"v-d64e3d96#_5-定时任务\",\"438\":\"v-d64e3d96#场景描述-4\",\"439\":\"v-d64e3d96#解决方案-4\",\"440\":\"v-d64e3d96#代码示例-4\",\"441\":\"v-d64e3d96#能简单说一下线程池的工作流程吗\",\"442\":\"v-d64e3d96#_1-线程池初始化\",\"443\":\"v-d64e3d96#_2-任务提交\",\"444\":\"v-d64e3d96#_3-任务执行\",\"445\":\"v-d64e3d96#_4-任务执行完成\",\"446\":\"v-d64e3d96#_5-线程池关闭\",\"447\":\"v-d64e3d96#线程池的完整工作流程\",\"448\":\"v-d64e3d96#线程池主要参数有哪些\",\"449\":\"v-d64e3d96#线程池的拒绝策略有哪些\",\"450\":\"v-d64e3d96#线程池有哪几种工作队列\",\"451\":\"v-d64e3d96#线程池提交execute和submit有什么区别\",\"452\":\"v-d64e3d96#线程池怎么关闭知道吗\",\"453\":\"v-d64e3d96#线程池的线程数应该怎么配置\",\"454\":\"v-d64e3d96#线程池是怎么实现线程复用的\",\"455\":\"v-d64e3d96#有哪几种常见的线程池\",\"456\":\"v-d64e3d96#能说一下四种常见线程池的原理吗\",\"457\":\"v-d64e3d96#_1-fixedthreadpool-固定大小线程池\",\"458\":\"v-d64e3d96#_2-cachedthreadpool-缓存线程池\",\"459\":\"v-d64e3d96#_3-singlethreadexecutor-单线程线程池\",\"460\":\"v-d64e3d96#_4-scheduledthreadpool-定时任务线程池\",\"461\":\"v-d64e3d96#线程池异常怎么处理知道吗\",\"462\":\"v-d64e3d96#_1-捕获并处理异常\",\"463\":\"v-d64e3d96#_2-自定义线程池\",\"464\":\"v-d64e3d96#_3-使用-uncaughtexceptionhandler\",\"465\":\"v-d64e3d96#_4-使用自定义-rejectedexecutionhandler\",\"466\":\"v-d64e3d96#_5-使用-completablefuture-处理异步任务\",\"467\":\"v-d64e3d96#_6-使用-callable-和-future\",\"468\":\"v-d64e3d96#能说一下线程池有几种状态吗\",\"469\":\"v-d64e3d96#_1-running\",\"470\":\"v-d64e3d96#_2-shutdown\",\"471\":\"v-d64e3d96#_3-stop\",\"472\":\"v-d64e3d96#_4-tidying\",\"473\":\"v-d64e3d96#_5-terminated\",\"474\":\"v-d64e3d96#状态转换图\",\"475\":\"v-d64e3d96#线程池如何实现参数的动态修改\",\"476\":\"v-d64e3d96#线程池调优了解吗\",\"477\":\"v-d64e3d96#你能设计实现一个线程池吗\",\"478\":\"v-d64e3d96#单机线程池执行断电了应该怎么处理\",\"479\":\"v-d64e3d96#线程池并发调用api-有个调用特别耗时-怎么优化\",\"480\":\"v-d64e3d96#fork-join框架了解吗\",\"481\":\"v-6c2a75a6\",\"482\":\"v-6c2a75a6#synchronized用过吗-怎么使用\",\"483\":\"v-6c2a75a6#synchronized的实现原理\",\"484\":\"v-6c2a75a6#synchronized是怎么加锁的呢\",\"485\":\"v-6c2a75a6#synchronized锁住的是什么呢\",\"486\":\"v-6c2a75a6#除了原子性-synchronized可见性-有序性-可重入性怎么实现\",\"487\":\"v-6c2a75a6#synchronized怎么保证可见性\",\"488\":\"v-6c2a75a6#synchronized怎么保证有序性\",\"489\":\"v-6c2a75a6#synchronized怎么实现可重入的呢\",\"490\":\"v-6c2a75a6#锁升级-synchronized优化了解吗\",\"491\":\"v-6c2a75a6#synchronized做了哪些优化\",\"492\":\"v-6c2a75a6#锁升级的过程是什么样的\",\"493\":\"v-6c2a75a6#偏向锁\",\"494\":\"v-6c2a75a6#轻量级锁\",\"495\":\"v-6c2a75a6#说说synchronized和reentrantlock的区别\",\"496\":\"v-6c2a75a6#aqs了解多少\",\"497\":\"v-6c2a75a6#reentrantlock实现原理\",\"498\":\"v-6c2a75a6#公平锁-fairsync\",\"499\":\"v-6c2a75a6#非公平锁-nonfairsync\",\"500\":\"v-6c2a75a6#lock-的执行过程\",\"501\":\"v-6c2a75a6#reentrantlock怎么实现公平锁的\",\"502\":\"v-6c2a75a6#什么是cas\",\"503\":\"v-6c2a75a6#cas-有什么问题-如何解决\",\"504\":\"v-6c2a75a6#aba-问题\",\"505\":\"v-6c2a75a6#怎么解决aba问题\",\"506\":\"v-6c2a75a6#循环性能开销\",\"507\":\"v-6c2a75a6#怎么解决循环性能开销问题\",\"508\":\"v-6c2a75a6#只能保证一个变量的原子操作\",\"509\":\"v-6c2a75a6#java有哪些保证原子性的方法-如何保证多线程下i-结果正确\",\"510\":\"v-6c2a75a6#原子操作类了解多少\",\"511\":\"v-6c2a75a6#atomicinteger-的原理\",\"512\":\"v-6c2a75a6#线程死锁了解吗-该如何避免\",\"513\":\"v-6c2a75a6#死锁问题怎么排查呢\",\"514\":\"v-6e53a4e6\",\"515\":\"v-6e53a4e6#arraylist和linkedlist有什么区别\",\"516\":\"v-6e53a4e6#arraylist的扩容机制了解吗\",\"517\":\"v-6e53a4e6#arraylist怎么序列化的知道吗-为什么用transient修饰数组\",\"518\":\"v-6e53a4e6#为什么最arraylist不直接序列化元素数组呢\",\"519\":\"v-6e53a4e6#那arraylist怎么序列化呢\",\"520\":\"v-6e53a4e6#快速失败-fail-fast-和安全失败-fail-safe-了解吗\",\"521\":\"v-6e53a4e6#实现arraylist线程安全有哪几种方法\",\"522\":\"v-6e53a4e6#copyonwritearraylist了解多少\",\"523\":\"v-6e53a4e6#数据拷贝的过程中-有其它线程写入数据怎么办\",\"524\":\"v-bacc6c9c\",\"525\":\"v-bacc6c9c#能说一下hashmap的数据结构吗\",\"526\":\"v-bacc6c9c#你对红黑树了解多少-为什么不用二叉树-平衡树呢\",\"527\":\"v-bacc6c9c#什么是红黑树\",\"528\":\"v-bacc6c9c#为什么不用二叉树\",\"529\":\"v-bacc6c9c#为什么不用平衡二叉树\",\"530\":\"v-bacc6c9c#红黑树怎么保持平衡的知道吗\",\"531\":\"v-bacc6c9c#hashmap的put流程知道吗\",\"532\":\"v-bacc6c9c#hashmap怎么查找元素的呢\",\"533\":\"v-bacc6c9c#hashmap的哈希-扰动函数是怎么设计的\",\"534\":\"v-bacc6c9c#为什么哈希-扰动函数能降hash碰撞\",\"535\":\"v-bacc6c9c#为什么hashmap的容量是2的倍数呢\",\"536\":\"v-bacc6c9c#如果初始化hashmap-传一个17的值-new-hashmap-它会怎么处理\",\"537\":\"v-bacc6c9c#你还知道哪些哈希函数的构造方法呢\",\"538\":\"v-bacc6c9c#解决哈希冲突有哪些方法呢\",\"539\":\"v-bacc6c9c#为什么hashmap链表转红黑树的阈值为8呢\",\"540\":\"v-bacc6c9c#扩容在什么时候呢-为什么扩容因子是0-75\",\"541\":\"v-bacc6c9c#那么为什么选择了0-75作为hashmap的默认加载因子呢\",\"542\":\"v-bacc6c9c#hashmap扩容机制了解吗\",\"543\":\"v-bacc6c9c#jdk1-8对hashmap主要做了哪些优化呢-为什么\",\"544\":\"v-bacc6c9c#你能自己设计实现一个hashmap吗\",\"545\":\"v-bacc6c9c#hashmap-是线程安全的吗-多线程下会有什么问题\",\"546\":\"v-bacc6c9c#有什么办法能解决hashmap线程不安全的问题呢\",\"547\":\"v-bacc6c9c#能说一下concurrenthashmap的具体实现吗\",\"548\":\"v-bacc6c9c#jdk1-7-分段锁\",\"549\":\"v-bacc6c9c#jdk1-8-cas-synchronized\",\"550\":\"v-bacc6c9c#hashmap-内部节点是有序的吗\",\"551\":\"v-bacc6c9c#讲讲-linkedhashmap-怎么实现有序的\",\"552\":\"v-bacc6c9c#讲讲-treemap-怎么实现有序的\",\"553\":\"v-2765b328\",\"554\":\"v-2765b328#讲讲hashset的底层实现\",\"555\":\"v-1267ad3b\",\"556\":\"v-1267ad3b#说说有哪些常见集合\",\"557\":\"v-2eb47ff2\",\"558\":\"v-2eb47ff2#_1-1-什么是docker\",\"559\":\"v-2eb47ff2#_1-1-1-应用部署的环境问题\",\"560\":\"v-2eb47ff2#_1-1-2-docker解决依赖兼容问题\",\"561\":\"v-2eb47ff2#_1-1-3-docker解决操作系统环境差异\",\"562\":\"v-2eb47ff2#_1-1-4-小结\",\"563\":\"v-2eb47ff2#_1-2-docker和虚拟机的区别\",\"564\":\"v-2eb47ff2#_1-3-docker架构\",\"565\":\"v-2eb47ff2#_1-3-1-镜像和容器\",\"566\":\"v-2eb47ff2#_1-3-2-dockerhub\",\"567\":\"v-2eb47ff2#_1-3-3-docker架构\",\"568\":\"v-2eb47ff2#_1-3-4-小结\",\"569\":\"v-2eb47ff2#_1-4-安装docker\",\"570\":\"v-2eb47ff2#_2-1-镜像操作\",\"571\":\"v-2eb47ff2#_2-1-1-镜像名称\",\"572\":\"v-2eb47ff2#_2-1-2-镜像命令\",\"573\":\"v-2eb47ff2#_2-1-3-案例1-拉取、查看镜像\",\"574\":\"v-2eb47ff2#_2-1-4-案例2-保存、导入镜像\",\"575\":\"v-2eb47ff2#_2-1-5-练习\",\"576\":\"v-2eb47ff2#_2-2-容器操作\",\"577\":\"v-2eb47ff2#_2-2-1-容器相关命令\",\"578\":\"v-2eb47ff2#_2-2-2-案例-创建并运行一个容器\",\"579\":\"v-2eb47ff2#_2-2-3-案例-进入容器-修改文件\",\"580\":\"v-2eb47ff2#_2-2-4-小结\",\"581\":\"v-2eb47ff2#_2-3-数据卷-容器数据管理\",\"582\":\"v-2eb47ff2#_2-3-1-什么是数据卷\",\"583\":\"v-2eb47ff2#_2-3-2-数据集操作命令\",\"584\":\"v-2eb47ff2#_2-3-3-创建和查看数据卷\",\"585\":\"v-2eb47ff2#_2-3-4-挂载数据卷\",\"586\":\"v-2eb47ff2#_2-3-5-案例-给nginx挂载数据卷\",\"587\":\"v-2eb47ff2#_2-3-6-案例-给mysql挂载本地目录\",\"588\":\"v-2eb47ff2#_2-3-7-小结\",\"589\":\"v-2eb47ff2#_3-1-镜像结构\",\"590\":\"v-2eb47ff2#_3-2-dockerfile语法\",\"591\":\"v-2eb47ff2#_3-3-构建java项目\",\"592\":\"v-2eb47ff2#_3-3-1-基于ubuntu构建java项目\",\"593\":\"v-2eb47ff2#_3-3-2-基于java8构建java项目\",\"594\":\"v-2eb47ff2#_3-4-小结\",\"595\":\"v-2eb47ff2#_4-1-初识dockercompose\",\"596\":\"v-2eb47ff2#_4-2-安装dockercompose\",\"597\":\"v-2eb47ff2#_4-3-部署微服务集群\",\"598\":\"v-2eb47ff2#_4-3-1-compose文件\",\"599\":\"v-2eb47ff2#_4-3-2-修改微服务配置\",\"600\":\"v-2eb47ff2#_4-3-3-打包\",\"601\":\"v-2eb47ff2#_4-3-4-拷贝jar包到部署目录\",\"602\":\"v-2eb47ff2#_4-3-5-部署\",\"603\":\"v-2eb47ff2#_5-1-搭建私有镜像仓库\",\"604\":\"v-2eb47ff2#_5-2-推送、拉取镜像\",\"605\":\"v-0ba2b279\",\"606\":\"v-0ba2b279#讲一下distinct的语法\",\"607\":\"v-0ba2b279#基本语法\",\"608\":\"v-0ba2b279#单字段去重\",\"609\":\"v-0ba2b279#多字段去重\",\"610\":\"v-0ba2b279#示例\",\"611\":\"v-0ba2b279#单字段去重示例\",\"612\":\"v-0ba2b279#多字段去重示例\",\"613\":\"v-0ba2b279#注意事项\",\"614\":\"v-0ba2b279#在查询中使用-distinct\",\"615\":\"v-0ba2b279#limit-语句和distinct哪个先执行\",\"616\":\"v-0ba2b279#执行顺序\",\"617\":\"v-0ba2b279#示例说明\",\"618\":\"v-0ba2b279#查询示例\",\"619\":\"v-0ba2b279#总结\",\"620\":\"v-1462249b\",\"621\":\"v-1462249b#什么是智能电网\",\"622\":\"v-1462249b#智能电网有哪些特征\",\"623\":\"v-1462249b#什么是智能变电站\",\"624\":\"v-1462249b#智能变电站与数字化变电站有什么区别\",\"625\":\"v-1462249b#智能变电站与常规变电站有什么区别\",\"626\":\"v-1462249b#智能变电站中的ied是什么\",\"627\":\"v-1462249b#现有的智能变电站-数字化变电站-网络结构模式有几种-有什么优缺点\",\"628\":\"v-1462249b#智能变电站中-三层三网-指的是什么\",\"629\":\"v-1462249b#智能变电站中-直采直跳-指的是什么\",\"630\":\"v-1462249b#现有智能变电站中高级应用功能一般有哪些-有什么特点\",\"631\":\"v-1462249b#数字化微机型继电保护与常规微机型继电保护有什么不同\",\"632\":\"v-1462249b#电阻分压式电压互感器与常规电容式电压互感器有什么不同-有什么优点\",\"633\":\"v-1462249b#磁光玻璃光学电流互感器与电磁式电流互感器有什么不同-有什么优缺点\",\"634\":\"v-1462249b#罗氏线圈电流互感器是什么样的工作原理\",\"635\":\"v-1462249b#目前用于智能变电站-数字化变电站-的电子式电流互感器有哪几种类型\",\"636\":\"v-1462249b#iec-61850通信规约是什么-有什么特点\",\"637\":\"v-1462249b#什么是通信规约-现有智能变电站-数字化变电站-有几种通信规约-分别运行于哪些地方\",\"638\":\"v-1462249b#智能变电站的网络配置过程中icd、cid、scd文件指的是什么-有什么用处\",\"639\":\"v-1462249b#智能变电站中的智能终端装置有什么作用\",\"640\":\"v-1462249b#智能变电站中的合并单元-mu-装置有什么作用\",\"641\":\"v-1462249b#双母接线方式-dmu—813电压合并单元的电压并列是如何实现的-它与常规的电压并列有什么不同点\",\"642\":\"v-7f7b1621\",\"643\":\"v-7f7b1621#_1-1-概述\",\"644\":\"v-7f7b1621#_1-1-1-掌握智能变电站调试主动权\",\"645\":\"v-7f7b1621#_1-1-2-学习配置技术的意义\",\"646\":\"v-7f7b1621#_1-2-配置技术基础\",\"647\":\"v-7f7b1621#_1-2-1-变电站通信网络和系统标准iec61850\",\"648\":\"v-7f7b1621#iec61850标准规约的产生背景及新标准的优点\",\"649\":\"v-7f7b1621#iec61850模型中配置技术相关缩略语\",\"650\":\"v-7f7b1621#iec61850装置数据模型的层次结构\",\"651\":\"v-7f7b1621#iec61850标准规约的三大服务\",\"652\":\"v-7f7b1621#制造报文规范服务mms功能\",\"653\":\"v-7f7b1621#面向通用对象的变电站事件服务goose功能\",\"654\":\"v-5a150eb4\",\"655\":\"v-5a150eb4#什么是-mybatis-它与其他-orm-框架有何不同\",\"656\":\"v-5a150eb4#mybatis-的核心组件是什么-它们各自的作用是什么\",\"657\":\"v-5a150eb4#mybatis-的工作原理是什么-简要描述一下它的执行流程。\",\"658\":\"v-5a150eb4#什么是-mapper-接口-它在-mybatis-中的作用是什么\",\"659\":\"v-5a150eb4#mybatis-中的动态-sql-是什么-你能举例说明如何使用动态-sql-吗\",\"660\":\"v-5a150eb4#如何在-mybatis-中执行批量插入操作\",\"661\":\"v-5a150eb4#mybatis-中的缓存是如何工作的-它有哪些级别\",\"662\":\"v-5a150eb4#介绍一下-mybatis-的一级缓存和二级缓-存的区别。\",\"663\":\"v-5a150eb4#如何在-mybatis-中进行参数绑定-有哪些方式可以传递参数\",\"664\":\"v-5a150eb4#mybatis-支持哪些类型的参数映射\",\"665\":\"v-5a150eb4#什么是-mybatis-的插件-plugin-你能否自定义一个插件\",\"666\":\"v-5a150eb4#mybatis-如何处理懒加载-lazy-loading-它的原理是什么\",\"667\":\"v-5a150eb4#你在项目中是如何处理-mybatis-的异常的\",\"668\":\"v-5a150eb4#如何在-mybatis-中实现分页查询\",\"669\":\"v-5a150eb4#mybatis-中的-resultmap-是什么-它有什么作用\",\"670\":\"v-5a150eb4#什么是-mybatis-的-sql-注入-你如何在-mybatis-中防止-sql-注入攻击\",\"671\":\"v-5a150eb4#mybatis-如何处理数据库事务-它支持哪些事务管理方式\",\"672\":\"v-5a150eb4#mybatis-中的-resultmap-和-resulttype-有什么区别-它们应该如何选择使用\",\"673\":\"v-5a150eb4#介绍一下-mybatis-中的-resultmap-的高级特性-比如关联映射和复杂属性映射。\",\"674\":\"v-5a150eb4#mybatis-中的-sql-日志是如何启用的-为什么在开发和调试过程中启用-sql-日志很重要\",\"675\":\"v-5a150eb4#你有在项目中使用-mybatis-generator-吗-它的作用是什么-有哪些配置选项\",\"676\":\"v-5a150eb4#mybatis-中的-typehandler-是什么-你能否自定义一个-typehandler\",\"677\":\"v-5a150eb4#mybatis-如何处理结果集的映射-它支持哪些基本类型和复杂类型的映射\",\"678\":\"v-5a150eb4#mybatis-中的动态-sql-如何处理-null-值\",\"679\":\"v-5a150eb4#如何在-mybatis-中执行存储过程-有哪些方式可以调用存储过程\",\"680\":\"v-5a150eb4#mybatis-中的连接池是如何配置的-你有什么经验可以分享吗\",\"681\":\"v-5a150eb4#什么是-mybatis-的拦截器-interceptor-你能否自定义一个拦截器\",\"682\":\"v-5a150eb4#mybatis-如何处理乐观锁和悲观锁-你在项目中是如何应用的\",\"683\":\"v-5a150eb4#你有使用-mybatis-的批量更新功能吗-它是如何工作的\",\"684\":\"v-5a150eb4#mybatis-和-spring-框架如何集成-你有集成经验吗\",\"685\":\"v-5a150eb4#在-mybatis-中-你如何执行批量删除操作\",\"686\":\"v-5a150eb4#mybatis-中的延迟加载-lazy-loading-和立即加载-eager-loading-有何区别-你何时选择使用延迟加载\",\"687\":\"v-5a150eb4#你有使用-mybatis-的二级缓存吗-在什么情况下你会选择启用二级缓存\",\"688\":\"v-5a150eb4#介绍一下-mybatis-中的-sql-脚本处理器-scripting-以及它的应用场景。\",\"689\":\"v-5a150eb4#在-mybatis-中-如何处理数据库连接的异常和超时\",\"690\":\"v-5a150eb4#mybatis-如何支持数据库的分页查询-有哪些常见的分页插件\",\"691\":\"v-5a150eb4#mybatis-中的动态-sql-如何处理动态条件-举例说明如何构建动态条件查询。\",\"692\":\"v-5a150eb4#什么是-mybatis-的乐观锁和悲观锁-你有在项目中应用过吗-请分享一下经验。\",\"693\":\"v-5a150eb4#mybatis-如何进行批量更新和批量\",\"694\":\"v-5a150eb4#mybatis-如何处理数据库字段和-java-对象之间的类型转换-你有遇到过类型转换问题吗\",\"695\":\"v-5a150eb4#mybatis-中的-sql-解析器-sql-parser-是如何工作的-它的作用是什么-你有自定义过-sql-解析器吗\",\"696\":\"v-5a150eb4#mybatis-中的-sql-构建器-sql-builder-是什么-你有使用过-mybatis-的-sql-构建器吗-能分享一些使用经验吗\",\"697\":\"v-5a150eb4#你对-mybatis-的性能调优有什么经验-你在项目中是如何优化-mybatis-的性能的\",\"698\":\"v-5a150eb4#mybatis-中的连接池和数据库连接管理是如何工作的-你有进行过连接池的配置和优化吗\",\"699\":\"v-5a150eb4#在-mybatis-中-如何处理数据库分页-你有使用过-mybatis-分页插件吗-它是如何工作的\",\"700\":\"v-5a150eb4#mybatis-中的-sql-注解是什么-它的作用是什么-你有使用过-sql-注解吗-它们与-xml-映射文件相比有什么优缺点\",\"701\":\"v-5a150eb4#什么是-mybatis-的多表查询-你有进行过复杂的多表查询吗-如何处理多表查询结果的映射\",\"702\":\"v-5a150eb4#mybatis-中的缓存机制是如何工作的-你有遇到过缓存失效的情况吗-如何处理缓存失效\",\"703\":\"v-5a150eb4#mybatis-中的动态-sql-是如何实现的-你有在项目中使用过动态-sql-吗-它的性能如何\",\"704\":\"v-5a150eb4#在你看来-mybatis-的优势是什么-它在项目中的应用场景是什么\",\"705\":\"v-5a150eb4#mybatis-如何处理数据库连接的管理和释放-它对连接池有何要求\",\"706\":\"v-5a150eb4#你对-mybatis-中的事务管理有何了解-它如何处理事务的提交和回滚\",\"707\":\"v-5a150eb4#在-mybatis-中-如何处理数据库的乐观锁和悲观锁-你有在项目中使用过这些机制吗-能分享一些应用经验吗\",\"708\":\"v-5a150eb4#mybatis-中的-resultmap-是如何定义和使用的-你有使用过复杂的-resultmap-吗-如何定义一个复杂的-resultmap\",\"709\":\"v-5a150eb4#你对-mybatis-中的延迟加载机制有何理解-它如何提高系统性能\",\"710\":\"v-5a150eb4#在-mybatis-中-如何使用动态-sql-构建动态查询语句-你有使用过动态-sql-吗-如何避免动态-sql-带来的潜在安全风险\",\"711\":\"v-5a150eb4#你有使用过-mybatis-的注解方式进行-sql-映射吗-与-xml-映射方式相比-你更倾向于使用哪一种-为什么\",\"712\":\"v-5a150eb4#mybatis-如何处理结果集的映射-你有使用过复杂的映射关系吗-如何处理复杂的结果集映射\",\"713\":\"v-5a150eb4#在-mybatis-中-如何进行性能分析和调优-你有使用过-mybatis-提供的性能分析工具吗-如何解读性能分析报告\",\"714\":\"v-5a150eb4#在你的开发经验中-mybatis-的哪些特性给你留下了深刻的印象-你认为-mybatis-在未来的发展方向是什么\",\"715\":\"v-5a150eb4#mybatis-的动态-sql-是如何实现的-你有使用过动态-sql-来构建动态查询语句吗-能分享一些实际应用的经验吗\",\"716\":\"v-5a150eb4#mybatis-中的缓存机制包括一级缓存和二级缓存-请详细说明它们的区别和工作原理。\",\"717\":\"v-5a150eb4#你有使用过-mybatis-的批量操作功能吗-它是如何实现的-在什么场景下你会选择使用批量操作\",\"718\":\"v-5a150eb4#在-mybatis-中-如何处理数据库的分页查询-你有使用过-mybatis-分页插件吗-如果不使用插件-你会采取什么样的方法来实现分页\",\"719\":\"v-5a150eb4#mybatis-中的-typehandler-是什么-它的作用是什么-你有自定义过-typehandler-吗-在什么场景下会需要自定义-typehandler\",\"720\":\"v-5a150eb4#mybatis-与-spring-框架的集成是如何实现的-你有在项目中使用过这种集成方式吗-有什么需要注意的地方\",\"721\":\"v-5a150eb4#在你的开发经验中-mybatis-的哪些功能给你带来了便利-相反-有没有遇到过-mybatis-的局限性\",\"722\":\"v-5a150eb4#你在使用-mybatis-过程中遇到过的最大挑战是什么-你是如何克服的\",\"723\":\"v-5a150eb4#mybatis-如何处理数据库的连接异常-在面对连接异常时-你有哪些应对策略\",\"724\":\"v-5a150eb4#你对-mybatis-的未来发展有什么预期-你认为-mybatis-在未来的发展中有哪些可以改进的地方\",\"725\":\"v-5a150eb4#mybatis-如何处理数据库连接的超时和重试机制-你有在项目中实践过连接超时和重试策略吗\",\"726\":\"v-5a150eb4#在你的项目中-你是如何组织和管理-mybatis-的-sql-映射文件的-有没有遇到过文件过多或难以维护的情况\",\"727\":\"v-5a150eb4#mybatis-中的-mapper-接口是如何定义和使用的-你有使用过注解方式定义-mapper-接口吗-与-xml-方式相比-你更倾向于使用哪一种\",\"728\":\"v-5a150eb4#在你的开发经验中-mybatis-的异常处理是如何应用的-你有使用过-mybatis-的异常处理机制来处理业务异常吗\",\"729\":\"v-5a150eb4#mybatis-中的批量更新操作是如何实现的-在什么场景下你会选择使用批量更新操作\",\"730\":\"v-5a150eb4#在你的项目中-你是如何进行-mybatis-的单元测试的-你认为单元测试对于-mybatis-开发的重要性是什么\",\"731\":\"v-5a150eb4#mybatis-的-sql-映射文件中-有哪些常用的标签和元素-你觉得其中哪些是最常用的-为什么\",\"732\":\"v-5a150eb4#你有在项目中使用过-mybatis-的乐观锁功能吗-它是如何工作的-在什么情况下你会选择使用乐观锁\",\"733\":\"v-5a150eb4#在-mybatis-中-如何进行-sql-的拼接和参数传递-你有遇到过-sql-注入的情况吗-如何防范-sql-注入攻击\",\"734\":\"v-5a150eb4#你认为-mybatis-框架的优势和劣势分别是什么-在选择-orm-框架时-你会优先考虑哪些因素\",\"735\":\"v-5a150eb4#在你的项目中-你是如何进行-mybatis-的性能监控和调优的-有哪些工具和技术是你常用的\",\"736\":\"v-5a150eb4#mybatis-中的动态-sql-是如何实现的-你有使用过动态-sql-来构建动态查询语句吗-能分享一些实际应用的经验吗\",\"737\":\"v-5a150eb4#mybatis-如何处理数据库连接的管理和释放-它对连接池有何要求-1\",\"738\":\"v-5a150eb4#你对-mybatis-中的事务管理有何了解-它如何处理事务的提交和回滚-1\",\"739\":\"v-5a150eb4#在-mybatis-中-如何使用注解方式定义-sql-映射-与-xml-映射方式相比-你更倾向于使用哪一种-为什么\",\"740\":\"v-5a150eb4#mybatis-的缓存机制是如何工作的-你有在项目中使用过缓存吗-在什么情况下你会选择禁用缓存\",\"741\":\"v-5a150eb4#在你的项目中-你是如何处理-mybatis-中的懒加载问题的-有没有遇到过懒加载导致的性能问题\",\"742\":\"v-5a150eb4#mybatis-的-sql-解析器是如何工作的-它的作用是什么-你有自定义过-sql-解析器吗\",\"743\":\"v-5a150eb4#你有在项目中使用过-mybatis-的连接池配置吗-你是如何进行连接池优化的\",\"744\":\"v-5a150eb4#在你的开发经验中-mybatis-与其他-orm-框架相比-有哪些优势和劣势-在选择使用-orm-框架时-你会考虑哪些因素\",\"745\":\"v-5a150eb4#mybatis-如何处理数据库连接的超时和重试机制-你有在项目中实践过连接超时和重试策略吗-1\",\"746\":\"v-5a150eb4#在你的项目中-你是如何组织和管理-mybatis-的-sql-映射文件的-有没有遇到过文件过多或难以维护的情况-1\",\"747\":\"v-5a150eb4#mybatis-中的-mapper-接口是如何定义和使用的-你有使用过注解方式定义-mapper-接口吗-与-xml-方式相比-你更倾向于使用哪一种-1\",\"748\":\"v-5a150eb4#在你的开发经验中-mybatis-的异常处理是如何应用的-你有使用过-mybatis-的异常处理机制来处理业务异常吗-1\",\"749\":\"v-5a150eb4#mybatis-中的批量更新操作是如何实现的-在什么场景下你会选择使用批量更新操作-1\",\"750\":\"v-5a150eb4#在你的项目中-你是如何进行-mybatis-的单元测试的-你认为单元测试对于-mybatis-开发的重要性是什么-1\",\"751\":\"v-5a150eb4#mybatis-的-sql-映射文件中-有哪些常用的标签和元素-你觉得其中哪些是最常用的-为什么-1\",\"752\":\"v-5a150eb4#你有在项目中使用过-mybatis-的乐观锁功能吗-它是如何工作的-在什么情况下你会选择使用乐观锁-1\",\"753\":\"v-5a150eb4#在-mybatis-中-如何进行-sql-的拼接和参数传递-你有遇到过-sql-注入的情况吗-如何防范-sql-注入攻击-1\",\"754\":\"v-5a150eb4#你认为-mybatis-框架的优势和劣势分别是什么-在选择-orm-框架时-你会优先考虑哪些因素-1\",\"755\":\"v-4f40de2a\",\"756\":\"v-4f40de2a#说说什么是mybatis\",\"757\":\"v-4f40de2a#为什么说mybatis是半自动orm映射工具-它与全自动的区别在哪里\",\"758\":\"v-4f40de2a#jdbc编程有哪些不足之处-mybatis是如何解决的\",\"759\":\"v-4f40de2a#hibernate-和-mybatis-有什么区别\",\"760\":\"v-4f40de2a#mybatis和hibernate的适用场景\",\"761\":\"v-4f40de2a#mybatis使用过程-生命周期\",\"762\":\"v-4f40de2a#mybatis生命周期\",\"763\":\"v-4f40de2a#在mapper中如何传递多个参数\",\"764\":\"v-4f40de2a#实体类属性名和表中字段名不一样-怎么办\",\"765\":\"v-4f40de2a#mybatis是否可以映射enum枚举类\",\"766\":\"v-4f40de2a#和-的区别\",\"767\":\"v-4f40de2a#模糊查询like语句该怎么写\",\"768\":\"v-4f40de2a#mybatis能执行一对一、一对多的关联查询吗\",\"769\":\"v-4f40de2a#mybatis是否支持延迟加载-原理\",\"770\":\"v-4f40de2a#如何获取生成的主键\",\"771\":\"v-4f40de2a#mybatis支持动态sql吗\",\"772\":\"v-4f40de2a#mybatis如何执行批量操作\",\"773\":\"v-4f40de2a#说说mybatis的一级、二级缓存\",\"774\":\"v-145c230d\",\"775\":\"v-e1e3da16\",\"776\":\"v-40ed10a2\",\"777\":\"v-1303aad4\",\"778\":\"v-38e624d6\",\"779\":\"v-a7f04bf8\",\"780\":\"v-4afb3595\",\"781\":\"v-2312bea9\",\"782\":\"v-23c8b0a6\",\"783\":\"v-29dee1f0\",\"784\":\"v-2e25198a\",\"785\":\"v-1af2dda2\",\"786\":\"v-4841eeda\",\"787\":\"v-425f784e\",\"788\":\"v-49056fde\",\"789\":\"v-42cb7677\",\"790\":\"v-7e1f989b\",\"791\":\"v-95912ab2\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1],\"1\":[1,6],\"2\":[1,1],\"3\":[1,1],\"4\":[2,1],\"5\":[1],\"6\":[1],\"7\":[1],\"8\":[1,6],\"9\":[1,4],\"10\":[1,8],\"11\":[1,154],\"12\":[1,4],\"13\":[1],\"14\":[1,7],\"15\":[1],\"16\":[4,6],\"17\":[3,23],\"18\":[1],\"19\":[3],\"20\":[1,8],\"21\":[2,12],\"22\":[3,8],\"23\":[3,7],\"24\":[1,2],\"25\":[null,null,1],\"26\":[null,null,1],\"27\":[1,3],\"28\":[2],\"29\":[2],\"30\":[2],\"31\":[2],\"32\":[2],\"33\":[2],\"34\":[2],\"35\":[2],\"36\":[2],\"37\":[2],\"38\":[4],\"39\":[3],\"40\":[4],\"41\":[4],\"42\":[4],\"43\":[4],\"44\":[4],\"45\":[1],\"46\":[2],\"47\":[1],\"48\":[2],\"49\":[3],\"50\":[2],\"51\":[2,59],\"52\":[1],\"53\":[2],\"54\":[1,53],\"55\":[1,23],\"56\":[1,42],\"57\":[2,7],\"58\":[2,10],\"59\":[2,14],\"60\":[6,14],\"61\":[4,8],\"62\":[2,9],\"63\":[2,8],\"64\":[5,10],\"65\":[3,12],\"66\":[2,8],\"67\":[2,11],\"68\":[2,10],\"69\":[2,8],\"70\":[1,72],\"71\":[2,6],\"72\":[1,28],\"73\":[1,23],\"74\":[1,12],\"75\":[1,22],\"76\":[1,14],\"77\":[2,4],\"78\":[2,11],\"79\":[2,9],\"80\":[2,9],\"81\":[2,15],\"82\":[2,6],\"83\":[2,12],\"84\":[2,56],\"85\":[2,32],\"86\":[2,43],\"87\":[5,61],\"88\":[3,78],\"89\":[3,160],\"90\":[2,48],\"91\":[1],\"92\":[2,73],\"93\":[6,12],\"94\":[3,37],\"95\":[3,20],\"96\":[3,19],\"97\":[1],\"98\":[5,12],\"99\":[1,10],\"100\":[1,10],\"101\":[1,17],\"102\":[2,6],\"103\":[1,38],\"104\":[1,51],\"105\":[1,31],\"106\":[5,15],\"107\":[1,15],\"108\":[6,30],\"109\":[1,19],\"110\":[1,19],\"111\":[2,15],\"112\":[1],\"113\":[1,26],\"114\":[1,28],\"115\":[1,31],\"116\":[1,23],\"117\":[2,56],\"118\":[3,35],\"119\":[6,43],\"120\":[7,38],\"121\":[2,36],\"122\":[2,27],\"123\":[3,33],\"124\":[2,54],\"125\":[2,38],\"126\":[2,38],\"127\":[3,27],\"128\":[2,50],\"129\":[4,43],\"130\":[2,52],\"131\":[2,68],\"132\":[2,35],\"133\":[9,46],\"134\":[5,30],\"135\":[3,45],\"136\":[2,31],\"137\":[2,55],\"138\":[7,38],\"139\":[2,83],\"140\":[2,16],\"141\":[1,44],\"142\":[1,41],\"143\":[1,9],\"144\":[1,12],\"145\":[1,8],\"146\":[3,9],\"147\":[1,33],\"148\":[1,43],\"149\":[1,12],\"150\":[3,7],\"151\":[1,42],\"152\":[1],\"153\":[1,15],\"154\":[1,12],\"155\":[1,14],\"156\":[1,10],\"157\":[2,6],\"158\":[1,24],\"159\":[1,61],\"160\":[1,23],\"161\":[1,7],\"162\":[3,8],\"163\":[1,15],\"164\":[4,26],\"165\":[1,27],\"166\":[1,15],\"167\":[1,10],\"168\":[1,8],\"169\":[2,12],\"170\":[1,8],\"171\":[1,3],\"172\":[1,31],\"173\":[3,33],\"174\":[1,16],\"175\":[1,6],\"176\":[1],\"177\":[2,20],\"178\":[1,23],\"179\":[1,47],\"180\":[1,12],\"181\":[1,13],\"182\":[1],\"183\":[2,23],\"184\":[4,11],\"185\":[4,11],\"186\":[4,12],\"187\":[4,11],\"188\":[4,11],\"189\":[4,11],\"190\":[4,37],\"191\":[2,7],\"192\":[2,10],\"193\":[2,9],\"194\":[2,6],\"195\":[1,31],\"196\":[1,11],\"197\":[1,6],\"198\":[2,5],\"199\":[5,17],\"200\":[5,15],\"201\":[5,17],\"202\":[5,12],\"203\":[1,13],\"204\":[1,89],\"205\":[2,15],\"206\":[1,34],\"207\":[1,65],\"208\":[2,3],\"209\":[2,9],\"210\":[2,8],\"211\":[2,5],\"212\":[2,6],\"213\":[2,14],\"214\":[2,6],\"215\":[2,106],\"216\":[3,11],\"217\":[2,5],\"218\":[2,7],\"219\":[4,15],\"220\":[4,105],\"221\":[2],\"222\":[1,26],\"223\":[1,17],\"224\":[1,25],\"225\":[2,4],\"226\":[2,8],\"227\":[2,6],\"228\":[2,11],\"229\":[2,4],\"230\":[2,5],\"231\":[2,7],\"232\":[2,17],\"233\":[5,38],\"234\":[2,54],\"235\":[1],\"236\":[5,22],\"237\":[3,22],\"238\":[4,55],\"239\":[2],\"240\":[3,45],\"241\":[3,7],\"242\":[2,10],\"243\":[2,38],\"244\":[3,105],\"245\":[1],\"246\":[2,7],\"247\":[6,44],\"248\":[3,5],\"249\":[3,15],\"250\":[5,12],\"251\":[1],\"252\":[2,85],\"253\":[1],\"254\":[2,15],\"255\":[2,8],\"256\":[1,11],\"257\":[1],\"258\":[2,53],\"259\":[3,5],\"260\":[3,4],\"261\":[3,3],\"262\":[6,24],\"263\":[5,15],\"264\":[2,6],\"265\":[2,12],\"266\":[1],\"267\":[6,30],\"268\":[3,56],\"269\":[10,20],\"270\":[3,13],\"271\":[2,8],\"272\":[11,33],\"273\":[3,10],\"274\":[3,21],\"275\":[1],\"276\":[3,53],\"277\":[2,43],\"278\":[1],\"279\":[3,14],\"280\":[2,7],\"281\":[2,15],\"282\":[1,65],\"283\":[1],\"284\":[2,7],\"285\":[2,15],\"286\":[2,19],\"287\":[2,12],\"288\":[1],\"289\":[2,56],\"290\":[1],\"291\":[2,16],\"292\":[2,7],\"293\":[1],\"294\":[2,13],\"295\":[2,21],\"296\":[6,23],\"297\":[8,19],\"298\":[2,7],\"299\":[7,42],\"300\":[2,41],\"301\":[4,29],\"302\":[2,6],\"303\":[4,42],\"304\":[4,10],\"305\":[3,32],\"306\":[3,14],\"307\":[2,24],\"308\":[3,6],\"309\":[1,32],\"310\":[1],\"311\":[1,28],\"312\":[1,28],\"313\":[1,10],\"314\":[1],\"315\":[4,32],\"316\":[4,33],\"317\":[2,19],\"318\":[4,13],\"319\":[2,34],\"320\":[4,51],\"321\":[5,14],\"322\":[2,2],\"323\":[2,10],\"324\":[2,29],\"325\":[1],\"326\":[2,29],\"327\":[2,2],\"328\":[2,14],\"329\":[3,20],\"330\":[2,3],\"331\":[2,9],\"332\":[2,43],\"333\":[2,26],\"334\":[2,82],\"335\":[2,33],\"336\":[2,48],\"337\":[3,12],\"338\":[1],\"339\":[2,10],\"340\":[2,10],\"341\":[2,12],\"342\":[5,10],\"343\":[2,25],\"344\":[2,97],\"345\":[2,31],\"346\":[2,11],\"347\":[2,7],\"348\":[2,16],\"349\":[1,15],\"350\":[2,22],\"351\":[2,56],\"352\":[1],\"353\":[4,74],\"354\":[4,15],\"355\":[1,98],\"356\":[2,46],\"357\":[4,76],\"358\":[1,25],\"359\":[1,30],\"360\":[3,16],\"361\":[1,59],\"362\":[1,19],\"363\":[1,39],\"364\":[2],\"365\":[2,8],\"366\":[2],\"367\":[4,16],\"368\":[2],\"369\":[3,14],\"370\":[3,12],\"371\":[2,11],\"372\":[3],\"373\":[3,15],\"374\":[3,17],\"375\":[3,34],\"376\":[2],\"377\":[3,22],\"378\":[3,24],\"379\":[2],\"380\":[3,24],\"381\":[3,25],\"382\":[2],\"383\":[1,70],\"384\":[2],\"385\":[3,67],\"386\":[2,2],\"387\":[2,9],\"388\":[2,17],\"389\":[2,7],\"390\":[3,16],\"391\":[2,13],\"392\":[2,58],\"393\":[2],\"394\":[3,8],\"395\":[3,8],\"396\":[3,7],\"397\":[2,8],\"398\":[2,35],\"399\":[1],\"400\":[2,43],\"401\":[1],\"402\":[2,6],\"403\":[2,12],\"404\":[2,9],\"405\":[2,5],\"406\":[3,27],\"407\":[2,59],\"408\":[2,16],\"409\":[2,70],\"410\":[2,5],\"411\":[2],\"412\":[2,11],\"413\":[3,5],\"414\":[2],\"415\":[3,9],\"416\":[2,5],\"417\":[2],\"418\":[3,6],\"419\":[3,6],\"420\":[2,4],\"421\":[2],\"422\":[1,6],\"423\":[1,5],\"424\":[1,44],\"425\":[2],\"426\":[1,4],\"427\":[1,5],\"428\":[1,66],\"429\":[2],\"430\":[1,7],\"431\":[1,5],\"432\":[1,65],\"433\":[2],\"434\":[1,8],\"435\":[1,4],\"436\":[1,47],\"437\":[2],\"438\":[1,4],\"439\":[1,4],\"440\":[1,49],\"441\":[2,7],\"442\":[2,26],\"443\":[2,18],\"444\":[2,18],\"445\":[2,8],\"446\":[2,23],\"447\":[1,16],\"448\":[2,50],\"449\":[2,24],\"450\":[2,55],\"451\":[2,39],\"452\":[2,48],\"453\":[2,47],\"454\":[2,19],\"455\":[2,42],\"456\":[2],\"457\":[4,36],\"458\":[4,43],\"459\":[4,36],\"460\":[4,29],\"461\":[2,5],\"462\":[2,23],\"463\":[2,51],\"464\":[3,26],\"465\":[3,31],\"466\":[4,14],\"467\":[5,63],\"468\":[2,12],\"469\":[2,9],\"470\":[2,13],\"471\":[2,15],\"472\":[2,15],\"473\":[2,12],\"474\":[1,2],\"475\":[2,35],\"476\":[2,54],\"477\":[2,86],\"478\":[2,33],\"479\":[4,48],\"480\":[3,174],\"481\":[1],\"482\":[3,34],\"483\":[2],\"484\":[2,12],\"485\":[2,72],\"486\":[5],\"487\":[2,7],\"488\":[2,12],\"489\":[2,12],\"490\":[3,22],\"491\":[2,33],\"492\":[2,7],\"493\":[1,47],\"494\":[1,43],\"495\":[2,42],\"496\":[2,52],\"497\":[2,9],\"498\":[2,8],\"499\":[2,11],\"500\":[2,17],\"501\":[2,50],\"502\":[2,36],\"503\":[4,4],\"504\":[2,13],\"505\":[2,29],\"506\":[1,4],\"507\":[2,5],\"508\":[1,8],\"509\":[4,10],\"510\":[2,24],\"511\":[3,32],\"512\":[3,57],\"513\":[2,23],\"514\":[1],\"515\":[2,51],\"516\":[2,41],\"517\":[3,7],\"518\":[2,6],\"519\":[2,7],\"520\":[7,68],\"521\":[2,25],\"522\":[2,37],\"523\":[3,3],\"524\":[1],\"525\":[2,32],\"526\":[4],\"527\":[2,17],\"528\":[2,11],\"529\":[2,8],\"530\":[2,6],\"531\":[2,71],\"532\":[2,51],\"533\":[3,12],\"534\":[3,8],\"535\":[2,26],\"536\":[6,7],\"537\":[2,20],\"538\":[2,23],\"539\":[2,21],\"540\":[4,6],\"541\":[3,17],\"542\":[2,9],\"543\":[4,43],\"544\":[2,7],\"545\":[4,26],\"546\":[2,19],\"547\":[2,6],\"548\":[3,30],\"549\":[3,109],\"550\":[3,13],\"551\":[4,8],\"552\":[4,13],\"553\":[1],\"554\":[2,47],\"555\":[1],\"556\":[2,3],\"557\":[1],\"558\":[2,8],\"559\":[2,21],\"560\":[3,24],\"561\":[3,52],\"562\":[3,28],\"563\":[3,34],\"564\":[3],\"565\":[3,39],\"566\":[4,21],\"567\":[3,18],\"568\":[4,17],\"569\":[3,6],\"570\":[3],\"571\":[3,17],\"572\":[3,3],\"573\":[6,19],\"574\":[6,40],\"575\":[4,23],\"576\":[2],\"577\":[3,29],\"578\":[3,33],\"579\":[5,76],\"580\":[3,18],\"581\":[5,14],\"582\":[4,21],\"583\":[3,16],\"584\":[3,39],\"585\":[4,20],\"586\":[5,44],\"587\":[5,46],\"588\":[4,22],\"589\":[3,18],\"590\":[3,27],\"591\":[2],\"592\":[3,86],\"593\":[3,50],\"594\":[3,17],\"595\":[3,50],\"596\":[3,1],\"597\":[3,32],\"598\":[4,78],\"599\":[4,35],\"600\":[3,30],\"601\":[3,15],\"602\":[4,16],\"603\":[3,4],\"604\":[4,23],\"605\":[1],\"606\":[1,10],\"607\":[1],\"608\":[1,10],\"609\":[1,12],\"610\":[1,19],\"611\":[1,9],\"612\":[1,14],\"613\":[1,12],\"614\":[2,24],\"615\":[2,12],\"616\":[1,25],\"617\":[1,19],\"618\":[1,30],\"619\":[1,11],\"620\":[1,3],\"621\":[2,21],\"622\":[2,41],\"623\":[2,20],\"624\":[2,39],\"625\":[2,54],\"626\":[2,14],\"627\":[5,41],\"628\":[4,54],\"629\":[4,14],\"630\":[3,49],\"631\":[2,66],\"632\":[3,46],\"633\":[3,80],\"634\":[2,35],\"635\":[4,37],\"636\":[4,82],\"637\":[6,30],\"638\":[5,30],\"639\":[2,37],\"640\":[4,36],\"641\":[5,29],\"642\":[1,2],\"643\":[2],\"644\":[2,50],\"645\":[3,7],\"646\":[3],\"647\":[3,11],\"648\":[1,2],\"649\":[1,123],\"650\":[1,11],\"651\":[1,6],\"652\":[1,33],\"653\":[1],\"654\":[1],\"655\":[6,31],\"656\":[4,228],\"657\":[4],\"658\":[7],\"659\":[7],\"660\":[4],\"661\":[4],\"662\":[5],\"663\":[5],\"664\":[3],\"665\":[6],\"666\":[6],\"667\":[4],\"668\":[4],\"669\":[6],\"670\":[9],\"671\":[4],\"672\":[8],\"673\":[7],\"674\":[7],\"675\":[7],\"676\":[6],\"677\":[4],\"678\":[7],\"679\":[5],\"680\":[4],\"681\":[6],\"682\":[4],\"683\":[5],\"684\":[6],\"685\":[5],\"686\":[9],\"687\":[5],\"688\":[8],\"689\":[5],\"690\":[4],\"691\":[6],\"692\":[6],\"693\":[2],\"694\":[6],\"695\":[10],\"696\":[11],\"697\":[6],\"698\":[4],\"699\":[8],\"700\":[11],\"701\":[6],\"702\":[5],\"703\":[8],\"704\":[5],\"705\":[4],\"706\":[5],\"707\":[7],\"708\":[8],\"709\":[5],\"710\":[11],\"711\":[11],\"712\":[5],\"713\":[8],\"714\":[6],\"715\":[8],\"716\":[4],\"717\":[6],\"718\":[9],\"719\":[9],\"720\":[7],\"721\":[7],\"722\":[5],\"723\":[5],\"724\":[6],\"725\":[4],\"726\":[8],\"727\":[11],\"728\":[6],\"729\":[4],\"730\":[7],\"731\":[8],\"732\":[6],\"733\":[11],\"734\":[8],\"735\":[6],\"736\":[8],\"737\":[4],\"738\":[5],\"739\":[12],\"740\":[5],\"741\":[6],\"742\":[8],\"743\":[5],\"744\":[10],\"745\":[4],\"746\":[8],\"747\":[11],\"748\":[6],\"749\":[4],\"750\":[7],\"751\":[8],\"752\":[6],\"753\":[11],\"754\":[8],\"755\":[1],\"756\":[2],\"757\":[3],\"758\":[3],\"759\":[5],\"760\":[2],\"761\":[3],\"762\":[2],\"763\":[2],\"764\":[3],\"765\":[2],\"766\":[3],\"767\":[2],\"768\":[3],\"769\":[3],\"770\":[2],\"771\":[2],\"772\":[2],\"773\":[3],\"774\":[1],\"775\":[1],\"776\":[3],\"777\":[1],\"778\":[1],\"779\":[1],\"780\":[1],\"781\":[1],\"782\":[1],\"783\":[2],\"784\":[1],\"785\":[1],\"786\":[1],\"787\":[1],\"788\":[1],\"789\":[1],\"790\":[1],\"791\":[1]},\"averageFieldLength\":[2.8409595959595935,24.94774691899637,0.07407407407407407],\"storedFields\":{\"0\":{\"h\":\"鱼塘\"},\"1\":{\"h\":\"关于网站\",\"t\":[\"欢迎来到鱼塘\",\"传送门：GitHub | Gitee。\",\"项目介绍\"]},\"2\":{\"h\":\"关于作者\",\"t\":[\"关于作者\"]},\"3\":{\"h\":\"占个位\",\"t\":[\"占个位\"]},\"4\":{\"h\":\"Star 趋势\",\"t\":[\"Stars\"]},\"5\":{\"h\":\"主页\"},\"6\":{\"h\":\"幻灯片页\"},\"7\":{\"h\":\"三分钟搭建一个博客网站\"},\"8\":{\"h\":\"三分钟搭建一个博客网站\",\"t\":[\"基于vuepress-theme-hope 和 github pages搭建\"]},\"9\":{\"h\":\"准备运行环境\",\"t\":[\"安装nodejs 下载地址\",\"安装pnpm 参考资料\"]},\"10\":{\"h\":\"创建项目模板\",\"t\":[\"pnpm create vuepress-theme-hope my-docs \"]},\"11\":{\"h\":\"创建过程\",\"t\":[\"PowerShell 7.4.0 PS C:\\\\Users\\\\daiwencheng\\\\Documents\\\\BaiduSyncdisk\\\\ob\\\\ob\\\\blogs> pnpm create vuepress-theme-hope my-docs .../Local/pnpm/store/v3/tmp/dlx-7428 | +83 ++++++++ .../Local/pnpm/store/v3/tmp/dlx-7428 | Progress: resolved 83, reused 61, downloaded 22, added 83, done ? Select a language to display / 选择显示语言 简体中文 ? 选择包管理器 pnpm 生成 package.json... ? 设置应用名称 vuepress-theme-hope-template ? 设置应用版本号 2.0.0 ? 设置应用描述 A project of vuepress-theme-hope ? 设置协议 MIT ? 项目需要用到多语言么? No ? 是否需要一个自动部署文档到 GitHub Pages 的工作流？ Yes ? 你想要创建什么类型的项目？ blog 生成模板... ? 是否初始化 Git 仓库? Yes 安装依赖... 这可能需要数分钟，请耐心等待. 我们无法正确输出子进程的进度条，所以进程可能会看似未响应 WARN 2 deprecated subdependencies found: rollup-plugin-terser@7.0.2, sourcemap-codec@1.4.8 Packages: +606 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ Progress: resolved 639, reused 409, downloaded 197, added 606, done node_modules/.pnpm/esbuild@0.19.8/node_modules/esbuild: Running postinstall script, done in 825ms devDependencies: + @vuepress/client 2.0.0-rc.0 + vue 3.3.10 + vuepress 2.0.0-rc.0 + vuepress-theme-hope 2.0.0-rc.2 The dependency was already listed in devDependencies. If you want to make it a prod dependency, then move it manually. Done in 25.3s 模板已成功生成! ? 是否想要现在启动 Demo 查看? Yes 启动开发服务器... 启动成功后，请在浏览器输入给出的开发服务器地址(默认为 'localhost:8080') > vuepress-theme-hope-template@2.0.0 docs:dev C:\\\\Users\\\\daiwencheng\\\\Documents\\\\BaiduSyncdisk\\\\ob\\\\ob\\\\blogs\\\\my-docs > vuepress dev src vite v5.0.6 dev server running at: ➜ Local: http://localhost:8080/ ➜ Network: http://10.246.84.128:8080/ \"]},\"12\":{\"h\":\"访问\",\"t\":[\"打开http://localhost:8080/ 访问\"]},\"13\":{\"h\":\"效果\"},\"14\":{\"h\":\"项目启动命令\",\"t\":[\"需要先进入项目目录 my-docs\",\"npm run docs:dev \"]},\"15\":{\"h\":\"发布到github\"},\"16\":{\"h\":\"修改 deploy-docs.yml\",\"t\":[\"on: push: branches: # 确保这是你正在使用的分支名称 - master \"]},\"17\":{\"h\":\"修改 config.ts\",\"t\":[\"export default defineUserConfig({ base: \\\"/my-docs/\\\", lang: \\\"zh-CN\\\", title: \\\"博客演示\\\", description: \\\"vuepress-theme-hope 的博客演示\\\", theme, // Enable it with pwa // shouldPrefetch: false, }); \"]},\"18\":{\"h\":\"共享项目到GitHub\"},\"19\":{\"h\":\"从master新建分支gh-pages,推送新分支到github\"},\"20\":{\"h\":\"GitHub上开源\",\"t\":[\"打开仓库my-docs\",\"打开Settings\",\"底部设置Change visibility 为change to public\"]},\"21\":{\"h\":\"配置Github Pages\",\"t\":[\"打开仓库my-docs的Settings项,选中侧边栏pages,配置部署分支为gh-pages,点击save.\",\"在actions菜单栏中应该会触发自动发布,没有的话随便修改下master分支代码,就会触发自动发布\",\"发布完成后,此时pages页会显示访问域名,点击访问即可\"]},\"22\":{\"h\":\"更新博客只在master分支上改,不要动gh-pages分支\",\"t\":[\"master 是源码分支 gh-pages是发布分支 master的代码都是ts和一些markdown文件,需要build成html文件和js才行,即gh-pages\"]},\"23\":{\"h\":\"修复\\\"编辑此页\\\"功能链接跳转不对问题\",\"t\":[\"修改theme.ts\",\"docsBranch: 文档所在分支,默认值: \\\"main\\\"\"]},\"24\":{\"h\":\"踩坑\",\"t\":[\"踩了一些坑,可以看提交记录\"]},\"25\":{\"c\":[\"前端\"]},\"26\":{\"c\":[\"JavaScript\"]},\"27\":{\"h\":\"在markdown中使用mermaid画图\",\"t\":[\"有些图渲染不出来，是因为当前版本没支持。使用typora或者其他markdown软件就能渲染出来\"]},\"28\":{\"h\":\"1.流程图\"},\"29\":{\"h\":\"2.序列图\"},\"30\":{\"h\":\"3.类图\"},\"31\":{\"h\":\"4.状态图\"},\"32\":{\"h\":\"5.实体关系图\"},\"33\":{\"h\":\"6.用户旅程图\"},\"34\":{\"h\":\"7.甘特图\"},\"35\":{\"h\":\"8.饼图\"},\"36\":{\"h\":\"9.象限图\"},\"37\":{\"h\":\"10.需求图\"},\"38\":{\"h\":\"11.Gitgraph（git） 图表\"},\"39\":{\"h\":\"12.C4 图\"},\"40\":{\"h\":\"C4 系统上下文图（C4Context）\"},\"41\":{\"h\":\"C4 容器图（C4Container）\"},\"42\":{\"h\":\"C4 组件图（C4Component）\"},\"43\":{\"h\":\"C4 动态图（C4Dynamic）\"},\"44\":{\"h\":\"C4 部署图（C4Deployment）\"},\"45\":{\"h\":\"13思维导图\"},\"46\":{\"h\":\"14.时间线图\"},\"47\":{\"h\":\"15ZenUML\"},\"48\":{\"h\":\"16.桑基图\"},\"49\":{\"h\":\"17.XY 图表\"},\"50\":{\"h\":\"18.框图文档\"},\"51\":{\"h\":\"19.数据包图\",\"t\":[\"--- title: \\\"TCP Packet\\\" --- packet-beta 0-15: \\\"Source Port\\\" 16-31: \\\"Destination Port\\\" 32-63: \\\"Sequence Number\\\" 64-95: \\\"Acknowledgment Number\\\" 96-99: \\\"Data Offset\\\" 100-105: \\\"Reserved\\\" 106: \\\"URG\\\" 107: \\\"ACK\\\" 108: \\\"PSH\\\" 109: \\\"RST\\\" 110: \\\"SYN\\\" 111: \\\"FIN\\\" 112-127: \\\"Window\\\" 128-143: \\\"Checksum\\\" 144-159: \\\"Urgent Pointer\\\" 160-191: \\\"(Options and Padding)\\\" 192-255: \\\"Data (variable length)\\\" \",\"渲染失败了\"]},\"52\":{\"h\":\"JVM调优\"},\"53\":{\"h\":\"有哪些常用的命令行性能监控和故障处理工具？\"},\"54\":{\"h\":\"操作系统工具\",\"t\":[\"工具名 称\",\"描述\",\"top\",\"实时查看系统的整体性能情况，包括CPU使用率、内存使用情况、 进程信息等\",\"vmstat\",\"监控系统的虚拟内存、进程、CPU、I/O等信息，提供实时的性能指 标\",\"iostat\",\"监控系统的磁盘I/O性能，包括磁盘读写速度、I/O等待时间等\",\"netstat\",\"监控网络连接和网络接口的状态，查看网络连接数、监听端口等信 息\",\"sar\",\"收集系统的性能数据，包括CPU、内存、磁盘、网络等指标，可以 生成报告和图表\",\"ps\",\"显示系统中的进程信息，包括进程ID、CPU使用率、内存使用情况 等\",\"ifconfig\",\"查看和配置网络接口的信息，包括IP地址、子网掩码、网关等\",\"tcpdump\",\"抓取网络数据包，用于网络故障排查和分析\",\"lsof\",\"列出系统中打开的文件和网络连接，用于查看进程使用的文件和网络资源\",\"htop\",\"类似于top，但提供更多的交互式功能和信息展示\"]},\"55\":{\"h\":\"JDK工具\",\"t\":[\"工具名 称\",\"描述\",\"jps\",\"查看Java虚拟机中的进程信息\",\"jstat\",\"监控Java虚拟机的运行情况，查看堆内存、垃圾收集、类加载等信 息\",\"jinfo\",\"查看Java虚拟机的配置信息\",\"jmap\",\"导出Java虚拟机中的内存映像\",\"jhat\",\"分析Java虚拟机中的堆转储快照\",\"jstack\",\"查看Java虚拟机中的线程堆栈信息\",\"jcmd\",\"执行各种诊断命令，包括jstat、jinfo、jmap、jstack等\"]},\"56\":{\"h\":\"Arthas工具\",\"t\":[\"工具名称\",\"描述\",\"dashboard\",\"显示Arthas的仪表盘，包括各种性能指标、JVM参数等\",\"help\",\"显示Arthas的帮助文档\",\"jad\",\"反编译Java类\",\"jvm\",\"显示JVM的信息，包括内存、线程、GC等\",\"logger\",\"控制日志输出，包括日志级别、日志文件等\",\"monitor\",\"监控方法的调用情况，包括调用次数、耗时等\",\"ognl\",\"执行OGNL表达式，用于动态修改变量值等\",\"redefine\",\"重新定义类，用于实现热部署\",\"sc\",\"查看和修改类的信息，包括类的属性、方法等\",\"thread\",\"显示线程的信息，包括线程ID、状态、堆栈等\",\"trace\",\"跟踪方法的调用情况，包括方法入参、返回值等\"]},\"57\":{\"h\":\"了解哪些可视化的性能监控和故障处理工具？\",\"t\":[\"在Java开发和运维过程中，除了命令行工具之外，还有许多可视化工具可以用于性能监控和故障处理。这些工具提供了图形界面，使得分析和诊断性能问题更加直观和方便。以下是一些常用的可视化性能监控和故障处理工具：\"]},\"58\":{\"h\":\"1. VisualVM\",\"t\":[\"主要用途：监控和分析JVM性能，包括内存使用、GC活动、线程状态等。\",\"特点：支持本地和远程监控，插件扩展功能丰富。\",\"官网：VisualVM\"]},\"59\":{\"h\":\"2. JConsole\",\"t\":[\"主要用途：监控JVM性能和资源使用情况，实时查看和管理JMX（Java Management Extensions）MBean。\",\"特点：Java自带工具，易于使用，适合基础监控。\",\"启动命令：在命令行输入 jconsole\"]},\"60\":{\"h\":\"3. Java Mission Control (JMC)\",\"t\":[\"主要用途：监控和分析Java应用的性能和运行时行为，特别是与Java Flight Recorder (JFR)配合使用。\",\"特点：提供详细的性能分析和诊断功能，适合长期监控和深度分析。\",\"官网：Java Mission Control\"]},\"61\":{\"h\":\"4. VisualVM (Profiler)\",\"t\":[\"主要用途：详细分析应用程序性能，找出热点代码和性能瓶颈。\",\"特点：可用于CPU和内存分析，提供可视化的性能报告。\",\"官网：VisualVM\"]},\"62\":{\"h\":\"5. Grafana\",\"t\":[\"主要用途：数据可视化平台，可用来监控各种系统和应用指标。\",\"特点：支持多种数据源，灵活的仪表板，适合大规模监控。\",\"官网：Grafana\"]},\"63\":{\"h\":\"6. Prometheus\",\"t\":[\"主要用途：开源监控系统和时间序列数据库，适用于系统和服务的监控。\",\"特点：强大的数据收集和查询能力，与Grafana集成效果更佳。\",\"官网：Prometheus\"]},\"64\":{\"h\":\"7. Elastic Stack (ELK Stack)\",\"t\":[\"主要用途：日志和数据分析平台，包含Elasticsearch、Logstash和Kibana。\",\"特点：强大的日志搜索和分析能力，Kibana提供丰富的可视化支持。\",\"官网：Elastic Stack\"]},\"65\":{\"h\":\"8. New Relic\",\"t\":[\"主要用途：应用性能管理（APM）工具，用于监控和优化应用性能。\",\"特点：提供详细的事务跟踪、错误监控、用户体验分析等。\",\"官网：New Relic\"]},\"66\":{\"h\":\"9. AppDynamics\",\"t\":[\"主要用途：应用性能管理和业务监控工具，帮助识别性能问题和优化应用。\",\"特点：提供端到端的性能监控、深度诊断和业务影响分析。\",\"官网：AppDynamics\"]},\"67\":{\"h\":\"10. Dynatrace\",\"t\":[\"主要用途：全栈监控解决方案，覆盖基础设施、应用、用户体验等。\",\"特点：自动化监控、智能问题检测和根因分析，支持大规模环境。\",\"官网：Dynatrace\"]},\"68\":{\"h\":\"11. Glowroot\",\"t\":[\"主要用途：开源的Java APM工具，监控和诊断Java应用的性能问题。\",\"特点：轻量级、易于部署，提供详细的性能报告。\",\"官网：Glowroot\"]},\"69\":{\"h\":\"12. Pinpoint\",\"t\":[\"主要用途：开源的APM工具，适用于大规模分布式系统的监控。\",\"特点：强大的分布式追踪能力，提供全链路的性能监控。\",\"官网：Pinpoint\"]},\"70\":{\"h\":\"总结表格\",\"t\":[\"工具\",\"主要用途\",\"特点\",\"官网\",\"VisualVM\",\"JVM性能监控和分析\",\"支持本地和远程监控，插件扩展丰富\",\"VisualVM\",\"JConsole\",\"JVM性能和资源使用监控\",\"Java自带工具，易于使用\",\"N/A\",\"Java Mission Control\",\"JVM性能和运行时行为分析\",\"与Java Flight Recorder (JFR)配合使用，适合深度分析\",\"JMC\",\"Grafana\",\"数据可视化平台\",\"支持多种数据源，灵活的仪表板\",\"Grafana\",\"Prometheus\",\"系统和服务的监控\",\"强大的数据收集和查询能力，与Grafana集成效果更佳\",\"Prometheus\",\"Elastic Stack\",\"日志和数据分析平台\",\"强大的日志搜索和分析能力，Kibana提供丰富的可视化支持\",\"Elastic Stack\",\"New Relic\",\"应用性能管理（APM）\",\"详细的事务跟踪、错误监控、用户体验分析\",\"New Relic\",\"AppDynamics\",\"应用性能管理和业务监控\",\"端到端性能监控、深度诊断、业务影响分析\",\"AppDynamics\",\"Dynatrace\",\"全栈监控解决方案\",\"自动化监控、智能问题检测和根因分析，支持大规模环境\",\"Dynatrace\",\"Glowroot\",\"开源的Java APM工具\",\"轻量级、易于部署，提供详细的性能报告\",\"Glowroot\",\"Pinpoint\",\"开源的APM工具，适用于大规模分布式系统的监控\",\"强大的分布式追踪能力，提供全链路性能监控\",\"Pinpoint\",\"这些可视化工具可以大大简化性能监控和故障处理的工作，使得开发人员和系统管理员能够更直观地理解系统的运行状况，并快速定位和解决问题。根据具体需求，可以选择合适的工具进行使用。\"]},\"71\":{\"h\":\"JVM的常见参数配置知道哪些？\",\"t\":[\"Java虚拟机（JVM）的参数配置非常重要，可以显著影响Java应用程序的性能和行为。下面是一些常见的JVM参数配置：\"]},\"72\":{\"h\":\"内存管理参数\",\"t\":[\"-Xms: 设置JVM初始化内存堆大小，例如-Xms512m。\",\"-Xmx: 设置JVM最大内存堆大小，例如-Xmx1024m。\",\"-Xmn: 设置年轻代大小，例如-Xmn256m。\",\"-XX:PermSize: 设置初始永久代大小（在Java 8及之前使用），例如-XX:PermSize=128m。\",\"-XX:MaxPermSize: 设置最大永久代大小（在Java 8及之前使用），例如-XX:MaxPermSize=256m。\",\"-XX:MetaspaceSize: 设置初始元空间大小（从Java 8开始使用），例如-XX:MetaspaceSize=128m。\",\"-XX:MaxMetaspaceSize: 设置最大元空间大小，例如-XX:MaxMetaspaceSize=256m。\"]},\"73\":{\"h\":\"垃圾回收参数\",\"t\":[\"-XX:+UseSerialGC: 使用串行垃圾回收器。\",\"-XX:+UseParallelGC: 使用并行垃圾回收器（也称为吞吐量垃圾回收器）。\",\"-XX:+UseConcMarkSweepGC: 使用并发标记-清除垃圾回收器（CMS）。\",\"-XX:+UseG1GC: 使用G1垃圾回收器。\",\"-XX:ParallelGCThreads: 设置用于并行垃圾回收的线程数，例如-XX:ParallelGCThreads=4。\",\"-XX:ConcGCThreads: 设置用于并发标记-清除垃圾回收的线程数。\",\"-XX:InitiatingHeapOccupancyPercent: 设置触发垃圾回收的堆内存占用阈值，例如-XX:InitiatingHeapOccupancyPercent=45。\"]},\"74\":{\"h\":\"性能调优参数\",\"t\":[\"-XX:+AggressiveOpts: 开启JVM的性能优化选项。\",\"-XX:+UseCompressedOops: 使用压缩指针来减少64位环境下的内存占用。\",\"-XX:+OptimizeStringConcat: 启用字符串连接优化。\",\"-XX:MaxInlineSize: 设置内联方法的最大字节码大小。\",\"-XX:+TieredCompilation: 启用分层编译模式。\"]},\"75\":{\"h\":\"调试和监控参数\",\"t\":[\"-Xdebug: 启用调试模式。\",\"-Xrunjdwp: 配置远程调试参数，例如-Xrunjdwp:transport=dt_socket,address=8000,server=y,suspend=n。\",\"-XX:+PrintGCDetails: 打印详细的垃圾回收日志。\",\"-XX:+PrintGCDateStamps: 在垃圾回收日志中包含时间戳。\",\"-Xloggc: 将垃圾回收日志输出到指定文件，例如-Xloggc:/path/to/gc.log。\"]},\"76\":{\"h\":\"其他常见参数\",\"t\":[\"-Dproperty=value: 设置系统属性，例如-Dfile.encoding=UTF-8。\",\"-server: 启用服务器模式，以获得更高的性能（默认为客户端模式）。\",\"这些参数可以根据具体的应用需求进行调整，以优化JVM的性能和资源利用率。调整时需要通过实际的测试和监控来确定最佳配置。\"]},\"77\":{\"h\":\"有做过JVM调优吗？\",\"t\":[\"JVM调优是一个系统性的过程，需要经过多个步骤来确保最佳结果。下面是一个典型的JVM调优流程：\"]},\"78\":{\"h\":\"1. 收集信息和分析\",\"t\":[\"收集应用程序信息：了解应用程序的特性、运行环境和性能需求，包括应用程序的内存使用情况、GC日志、CPU占用率等。\",\"收集JVM信息：收集JVM的配置信息、垃圾回收器日志、堆内存使用情况等。\"]},\"79\":{\"h\":\"2. 设置基准线\",\"t\":[\"制定性能指标：明确目标性能指标，例如响应时间、吞吐量、垃圾回收停顿时间等。\",\"收集基准数据：在当前配置下运行应用程序并收集性能数据，作为后续调优的基准。\"]},\"80\":{\"h\":\"3. 分析问题和瓶颈\",\"t\":[\"识别性能问题：分析收集的数据，识别性能瓶颈和问题，例如内存泄漏、频繁的垃圾回收、长时间的垃圾回收停顿等。\",\"确定调优重点：根据性能问题的严重程度和影响范围确定调优的重点和优先级。\"]},\"81\":{\"h\":\"4. 制定调优策略\",\"t\":[\"选择垃圾回收器：根据应用程序的特性和性能需求选择合适的垃圾回收器。\",\"调整内存参数：根据应用程序的内存使用情况和性能需求调整堆大小、年轻代大小、永久代（或元空间）大小等内存参数。\",\"优化垃圾回收策略：根据应用程序的内存使用模式和性能需求调整垃圾回收器的参数，例如调整触发垃圾回收的阈值、并发线程数等。\",\"优化代码和算法：通过优化Java代码和算法来减少内存使用和垃圾回收的压力。\"]},\"82\":{\"h\":\"5. 实施调优和测试\",\"t\":[\"调整配置：根据制定的调优策略修改JVM的配置参数。\",\"测试验证：在测试环境下运行调优后的应用程序并收集性能数据，验证调优效果是否达到预期的目标性能指标。\"]},\"83\":{\"h\":\"6. 监控和优化\",\"t\":[\"持续监控：持续监控应用程序的性能和运行状态，及时发现和解决性能问题。\",\"迭代优化：根据监控数据和反馈信息，持续优化应用程序和JVM的配置，以确保持续稳定的性能表现。\",\"JVM调优是一个迭代和持续改进的过程，需要综合考虑应用程序的特性、性能需求和硬件环境，通过系统性的分析和优化来达到最佳的性能和资源利用率。\"]},\"84\":{\"h\":\"有实际调优过吗？\",\"t\":[\"这是一个中规中矩的案例：电商公司的运营后台系统，偶发性的引发OOM异常，堆内存溢出。\",\"因为是偶发性的，所以第一次简单的认为就是堆内存不足导致，单方面的加大了堆内存从4G调整到8G -Xms8g。\",\"但是问题依然没有解决，只能从堆内存信息下手，通过开启了-XX:+HeapDumpOnOutOfMemoryError参数 获得堆内存的dump文件。\",\"用JProfiler 对 堆dump文件进行分析，通过JProfiler查看到占用内存最大的对象是String对象，本来想跟踪着String对象找到其引用的地方，但dump文件太大，跟踪进去的时候总是卡死，而String对象占用比较多也比较正常，最开始也没有认定就是这里的问题，于是就从线程信息里面找突破点。\",\"通过线程进行分析，先找到了几个正在运行的业务线程，然后逐一跟进业务线程看了下代码，有个方法引起了我的注意，导出订单信息。\",\"因为订单信息导出这个方法可能会有几万的数据量，首先要从数据库里面查询出来订单信息，然后把订单信息生成excel，这个过程会产生大量的String对象。\",\"为了验证自己的猜想，于是准备登录后台去测试下，结果在测试的过程中发现导出订单的按钮前端居然没有做点击后按钮置灰交互事件，后端也没有做防止重复提交，因为导出订单数据本来就非常慢，使用的人员可能发现点击后很久后页面都没反应，然后就一直点，结果就大量的请求进入到后台，堆内存产生了大量的订单对象和EXCEL对象，而且方法执行非常慢，导致这一段时间内这些对象都无法被回收，所以最终导致内存溢出。\",\"知道了问题就容易解决了，最终没有调整任何JVM参数，只是做了两个处理：\",\"在前端的导出订单按钮上加上了置灰状态，等后端响应之后按钮才可以进行点击\",\"后端代码加分布式锁，做防重处理\",\"这样双管齐下，保证导出的请求不会一直打到服务端，问题解决！\"]},\"85\":{\"h\":\"线上服务CPU占用过高怎么排查？\",\"t\":[\"首先，使用top命令列出系统各个进程的资源占用情况\",\"top \",\"通过观察CPU占用率较高的进程，可以初步确定占用CPU资源较多的进程。\",\"然后，使用top命令的-H选项，列出指定进程的线程占用资源情况\",\"top -H -p <进程ID> \",\"通过观察线程的CPU占用率，可以确定占用CPU资源较多的线程。\",\"找到对应线程ID后，可以使用printf命令将线程ID转换为16进制格式\",\"printf \\\"%x\\\\n\\\" <线程ID> \",\"将线程ID转换为16进制格式，以便在后续步骤中查找对应的线程信息\",\"最后，使用jstack命令打印出进程的所有线程信息，并查找转换为16进制的线程ID对应的线程信息\",\"jstack <进程ID> | grep <转换后的线程ID> \",\"通过分析线程的堆栈信息，可以定位到具体的业务方法，并从代码逻辑中找到问题所在\"]},\"86\":{\"h\":\"内存飙高问题怎么排查？\",\"t\":[\"排查内存飙高问题的步骤如下\",\"观察垃圾回收情况： 使用jstat命令查看垃圾回收的次数、时间等信息，每隔一秒打印一次\",\"jstat -gc <进程ID> 1000 \",\"通过观察GC次数和回收的内存空间，可以初步判断内存飙高的原因\",\"查看堆内存占用空间最大的对象类型： 使用jmap命令查看堆内存中占用空间最大的前20个对象类型\",\"jmap -histo <进程ID> | head -20 \",\"通过分析占用内存较多的对象类型，可以初步确定哪些对象占用了大量内存\",\"如果垃圾回收次数频繁且每次回收的内存空间较小，说明内存飙高是由于对象创建速度过快导致\",\"如果每次回收的内存较多，可能存在内存泄漏导致内存无法释放\",\"导出堆内存文件快照： 使用jmap命令将堆内存信息导出到文件中，以便进行离线分析\",\"jmap -dump:live,format=b,file=/home/myheapdump.hprof <进程ID> \",\"将堆内存信息保存为hprof格式的文件\",\"使用工具进行离线分析： 使用可视化工具如VisualVM等，打开导出的堆内存文件快照，通过工具提供的分析功能，查找占用内存较高的对象，并定位到创建该对象的业务代码位置\",\"从定位到的代码和业务场景中，可以进一步分析和优化问题所在\"]},\"87\":{\"h\":\"频繁 minor gc 怎么办？\",\"t\":[\"频繁的Minor GC（Young GC）可能是由于对象的存活时间较长，导致Eden区快速填满，从而触发Minor GC。这可能会影响应用程序的性能和响应时间。以下是一些应对频繁Minor GC的建议\",\"调整堆内存大小：增加堆内存的大小，可以减少Minor GC的频率。可以通过调整-Xms和-Xmx参数来增加堆内存大小。但是需要注意，过大的堆内存可能会导致GC停顿时间增加，影响系统的响应性能\",\"优化对象的生命周期：检查应用程序的代码逻辑，尽量减少对象的生命周期，避免对象在Eden区存活时间过长。可以通过合理的对象设计和资源管理来优化对象的生命周期\",\"检查对象的引用：确保对象的引用关系正确，避免出现无效的引用或者内存泄漏。特别是在使用缓存或者集合等数据结构时，需要注意及时清理不再使用的对象\",\"调整新生代的比例：可以通过调整新生代（Young Generation）和老年代（OldGeneration）的比例来减少Minor GC的频率。可以通过调整-XX:NewRatio参数来改变新生代和老年代的比例\",\"使用并行GC或者G1 GC：并行GC和G1 GC在处理Minor GC时，可以利用多线程并行处理，提高GC的效率。可以通过调整-XX:+UseParallelGC或者-XX:+UseG1GC参数来选择使用并行GC或者G1 GC\",\"使用逃逸分析和标量替换：逃逸分析可以分析对象的作用域，确定对象是否可以在栈上分配，从而减少堆内存的使用。标量替换可以将一个对象拆分为多个独立的标量，减少对象的内存占用。可以通过启用逃逸分析和标量替换来优化对象的内存分配\",\"监控和分析GC日志：通过监控和分析GC日志，可以了解GC的频率、停顿时间和内存使用情况，从而找到优化的方向。可以使用工具（如GCViewer、GCEasy等）来分析GC日志\"]},\"88\":{\"h\":\"频繁Full GC怎么办？\",\"t\":[\"Full GC的排查思路大概如下\",\"清楚从程序角度，有哪些原因导致FGC\",\"大对象 ：系统一次性加载了过多数据到内存中（比如SQL查询未做分页），导致大对象进入了老年代。\",\"内存泄漏 ：频繁创建了大量对象，但是无法被回收（比如IO对象使用完后未调用close方法释放资源），先引发FGC，最后导致OOM.\",\"程序频繁生成一些 长生命周期的对象 ，当这些对象的存活年龄超过分代年龄时便会进入老年代，最后引发FGC. （即本文中的案例）\",\"程序BUG\",\"代码中 显式调用了gc 方法，包括自己的代码甚至框架中的代码。\",\"JVM参数设置问题：包括总内存大小、新生代和老年代的大小、Eden区和S区的大小、元空间大小、垃圾回收算法等等\",\"清楚排查问题时能使用哪些工具\",\"公司的监控系统：大部分公司都会有，可全方位监控JVM的各项指标\",\"JDK的自带工具，包括jmap、jstat等常用命令\",\"# 查看堆内存各区域的使用率以及GC情况 jstat -gcutil -h20 pid 1000 # 查看堆内存中的存活对象，并按空间排序 jmap -histo pid | head -n20 # dump堆内存文件 jmap -dump:format=b,file=heap pid \",\"可视化的堆内存分析工具：JVisualVM、MAT等\",\"排查指南\",\"查看监控，以了解出现问题的时间点以及当前FGC的频率（可对比正常情况看频率是否正常）\",\"了解该时间点之前有没有程序上线、基础组件升级等情况。\",\"了解JVM的参数设置，包括：堆空间各个区域的大小设置，新生代和老年代分别采用了哪些垃圾收集器，然后分析JVM参数设置是否合理。\",\"再对步骤1中列出的可能原因做排除法，其中元空间被打满、内存泄漏、代码显式调用gc方法比较容易排查。\",\"针对大对象或者长生命周期对象导致的FGC，可通过 jmap -histo 命令并结合dump堆内存文件作进一步分析，需要先定位到可疑对象\",\"通过可疑对象定位到具体代码再次分析，这时候要结合GC原理和JVM参数设置，弄清楚可疑对象是否满足了进入到老年代的条件才能下结论\"]},\"89\":{\"h\":\"有没有处理过内存泄漏问题？是如何定位的？\",\"t\":[\"内存泄漏是内在病源，外在病症表现可能有：\",\"应用程序长时间连续运行时性能严重下降\",\"CPU 使用率飙升，甚至到 100%\",\"频繁 Full GC，各种报警，例如接口超时报警等\",\"应用程序抛出 OutOfMemoryError 错误\",\"应用程序偶尔会耗尽连接对象\",\"严重内存泄漏往往伴随频繁的 Full GC，所以分析排查内存泄漏问题首先还得从查看 Full GC 入手。主要有以下操作步骤\",\"使用 jps 查看运行的 Java 进程 ID\",\"使用 top -p [pid] 查看进程使用 CPU 和 MEM 的情况\",\"使用 top -Hp [pid] 查看进程下的所有线程占 CPU 和 MEM 的情况\",\"将线程 ID 转换为 16 进制： printf \\\"%x\\\\n\\\" [pid] ，输出的值就是线程栈信息中的 nid。\",\"例如： printf \\\"%x\\\\n\\\" 29471 ，换行输出 731f。\",\"在线程栈信息中找到对应线程号的 16 进制值，如下是 731f 线程的信息。线程栈分析可使用 Visualvm 插件 TDA\",\"\\\"Service Thread\\\" #7 daemon prio=9 os_prio=0 tid=0x00007fbe2c164000 nid=0x731f runnable [0x0000000000000000] java.lang.Thread.State: RUNNABLE \",\"抓取线程栈： jstack 29452 > 29452.txt ，可以多抓几次做个对比。\",\"使用 jstat -gcutil [pid] 5000 10 每隔 5 秒输出 GC 信息，输出 10 次，查看 YGC 和 Full GC 次数。通常会出现 YGC 不增加或增加缓慢，而 Full GC增加很快。或使用 jstat -gccause [pid] 5000 ，同样是输出 GC 摘要信息 或使用 jmap -heap [pid] 查看堆的摘要信息，关注老年代内存使用是否达到阀值，若达到阀值就会执行 Full GC\",\"如果发现 Full GC 次数太多，就很大概率存在内存泄漏了\",\"使用 jmap -histo:live [pid] 输出每个类的对象数量，内存大小(字节单位)及全限定类名\",\"生成 dump 文件，借助工具分析哪 个对象非常多，基本就能定位到问题在那了使用 jmap 生成 dump 文件\",\"# jmap -dump:live,format=b,file=29471.dump 29471 Dumping heap to /root/dump ... Heap dump file created \",\"dump 文件分析\",\"可以使用 jhat 命令分析： jhat -port 8000 29471.dump ，浏览器访问 jhat服务，端口是 8000。\",\"通常使用图形化工具分析，如 JDK 自带的 jvisualvm，从菜单 > 文件 > 装入dump 文件。\",\"或使用第三方式具分析的，如 JProfiler 也是个图形化工具，GCViewer 工具。Eclipse 或以使用 MAT 工具查看。或使用在线分析平台 GCEasy。\",\"注意：如果 dump 文件较大的话，分析会占比较大的内存\",\"在 dump 文析结果中查找存在大量的对象，再查对其的引用\"]},\"90\":{\"h\":\"有没有处理过OOM问题？\",\"t\":[\"查看错误日志\",\"首先，查看应用程序的错误日志，以查找包含OOM异常信息的记录。通常，OOM异常会被明确标记，例如\\\"OutOfMemoryError\\\"\",\"分析堆栈信息\",\"在错误日志中找到OOM异常的堆栈跟踪信息。这将指出在哪个方法和代码位置发生了问题。通常，你会看到类似以下的信息\",\"Exception in thread \\\"main\\\" java.lang.OutOfMemoryError: Java heap space at com.example.MyClass.myMethod(MyClass.java:12) \",\"根据堆栈信息，确定哪个方法或代码段导致了OOM异常\",\"内存分析工具\",\"使用内存分析工具（如MAT、VisualVM等）来检查应用程序的内存使用情况。以下是使用VisualVM的一般步骤 \",\"启动VisualVM，并连接到运行中的Java进程\",\"在VisualVM的\\\"内存\\\"选项卡下，查看堆内存使用情况、对象实例数等信息\",\"分析堆转储文件以查找内存泄漏或异常的对象\",\"检查代码\",\"根据堆栈信息定位到可能的问题代码段。检查这些代码段是否存在内存泄漏或不合理的内存使用\",\"确保对象在不再需要时被垃圾回收，避免不必要的对象引用\"]},\"91\":{\"h\":\"内存管理\"},\"92\":{\"h\":\"能说一下JVM的内存区域吗？\",\"t\":[\"JVM的内存区域分为多个部分，每个部分有其特定的用途和生命周期。主要的内存区域包括：\",\"方法区（Method Area）：\",\"作用：存储已加载的类信息、常量、静态变量、即时编译器编译后的代码等。\",\"生命周期：在JVM启动时创建，在JVM退出时销毁。\",\"特点：对于HotSpot JVM，它的一部分也被称为永久代（PermGen），从Java 8开始被移除，替换为元空间（Metaspace），元空间使用的是本地内存而不是堆内存。\",\"堆（Heap）：\",\"作用：存储对象实例和数组，所有对象都在堆上分配。\",\"生命周期：在JVM启动时创建，在JVM退出时销毁。\",\"特点：堆是垃圾回收的主要区域，可以分为新生代（Young Generation）和老年代（Old Generation），新生代又可以进一步划分为伊甸园区（Eden Space）和两个幸存者区（Survivor Space）。\",\"Java栈（Java Stack）：\",\"作用：每个线程有一个独立的Java栈，存储方法调用的局部变量、操作数栈、动态链接、方法出口等信息。\",\"生命周期：与线程相同，线程创建时创建，线程结束时销毁。\",\"特点：栈中的变量是线程私有的，不会出现线程间的数据共享问题。\",\"程序计数器（Program Counter Register）：\",\"作用：当前线程执行的字节码的行号指示器。如果当前线程正在执行的是本地方法，这个计数器的值是未定义的。\",\"生命周期：与线程相同，线程创建时创建，线程结束时销毁。\",\"特点：它是线程私有的，每个线程都有独立的程序计数器。\",\"本地方法栈（Native Method Stack）：\",\"作用：与Java栈类似，但为Native方法服务，存储本地方法的调用信息。\",\"生命周期：与线程相同，线程创建时创建，线程结束时销毁。\",\"特点：也是线程私有的，支持Native方法调用。\",\"JVM的内存区域分为方法区、堆、Java栈、程序计数器和本地方法栈。每个区域都有其特定的用途和生命周期，合理地管理这些内存区域对于JVM高效运行和垃圾回收有着至关重要的作用。\"]},\"93\":{\"h\":\"说一下JDK1.6、1.7、1.8内存区域的变化？\",\"t\":[\"在不同版本的Java开发工具包（JDK）中，Java虚拟机（JVM）的内存区域有一些重要的变化。以下是JDK 1.6、1.7和1.8之间内存区域的主要变化：\"]},\"94\":{\"h\":\"JDK 1.6\",\"t\":[\"在JDK 1.6中，JVM的内存区域主要包括：\",\"方法区（Method Area）：用于存储类结构（例如运行时常量池、字段、方法代码），由永久代（Permanent Generation, PermGen）实现。\",\"堆（Heap）：用于存储对象实例，分为新生代和老年代。\",\"Java栈（Java Stack）：每个线程有一个独立的Java栈，用于存储局部变量、操作数栈、方法返回值等。\",\"程序计数器（Program Counter Register）：每个线程有一个独立的程序计数器，用于记录当前线程执行的字节码行号。\",\"本地方法栈（Native Method Stack）：用于支持Native方法的执行。\"]},\"95\":{\"h\":\"JDK 1.7\",\"t\":[\"在JDK 1.7中，主要变化是永久代（PermGen）的逐步移除，部分数据迁移到堆中（如运行时常量池），以解决PermGen空间不足的问题：\",\"永久代逐步移除：运行时常量池（Runtime Constant Pool）从永久代移出，变为堆的一部分。\",\"字符串池移出永久代：字符串常量池被移到Java堆中，解决了因为PermGen空间不足导致的OutOfMemoryError的问题。\"]},\"96\":{\"h\":\"JDK 1.8\",\"t\":[\"在JDK 1.8中，永久代被完全移除，替换为元空间（Metaspace）：\",\"元空间（Metaspace）：用于替代永久代，存储类的元数据。元空间在本地内存中分配，不再使用堆内存，从而可以避免PermGen空间不足的问题。\",\"其他内存区域：堆、Java栈、程序计数器、本地方法栈仍然保留，功能基本不变。\"]},\"97\":{\"h\":\"详细变化对比\"},\"98\":{\"h\":\"永久代（PermGen）与元空间（Metaspace）\",\"t\":[\"JDK 1.6和1.7：永久代用于存储类元数据、方法信息等。\",\"JDK 1.8：永久代被移除，元空间用于存储类元数据。元空间在本地内存中动态扩展，不受堆内存大小限制。\"]},\"99\":{\"h\":\"字符串常量池\",\"t\":[\"JDK 1.6：字符串常量池在永久代中。\",\"JDK 1.7和1.8：字符串常量池移到Java堆中，解决了字符串常量池引起的内存管理问题。 \",\"物理上存放在堆中，逻辑上属于方法区\"]},\"100\":{\"h\":\"运行时常量池\",\"t\":[\"JDK 1.6：运行时常量池在永久代中。\",\"JDK 1.7和1.8：运行时常量池移到Java堆中，避免了永久代空间不足的问题。 \",\"物理上存放在堆中，逻辑上属于方法区\"]},\"101\":{\"h\":\"总结\",\"t\":[\"JDK 1.6：使用永久代来存储类元数据、运行时常量池和字符串常量池等。\",\"JDK 1.7：开始移除永久代，运行时常量池和字符串常量池迁移到Java堆中。\",\"JDK 1.8：永久代完全移除，使用元空间替代，用于存储类元数据，字符串常量池和运行时常量池继续在Java堆中。\",\"这些变化主要是为了改进内存管理，减少OutOfMemoryError的发生，提升JVM的性能和稳定性。\"]},\"102\":{\"h\":\"字符串常量池和运行时常量池有啥区别？\",\"t\":[\"字符串常量池和运行时常量池虽然名称相似，但它们在Java虚拟机（JVM）中的用途和实现方式有所不同。以下是它们的主要区别：\"]},\"103\":{\"h\":\"字符串常量池\",\"t\":[\"定义：\",\"字符串常量池（String Constant Pool）是一个专门用于存储字符串字面值（String literals）的区域。\",\"位置：\",\"在JDK 1.6及之前，字符串常量池位于永久代（PermGen）。\",\"从JDK 1.7开始，字符串常量池被移到Java堆（Heap）。\",\"实现：\",\"当一个字符串字面值被创建时，JVM会先检查字符串常量池中是否已经存在相同的字符串。如果存在，则返回该字符串的引用；如果不存在，则在池中创建该字符串并返回引用。\",\"可以通过调用String类的intern()方法将字符串添加到字符串常量池中。\",\"示例：\",\"String str1 = \\\"Hello\\\"; String str2 = \\\"Hello\\\"; boolean isSame = (str1 == str2); // true，因为str1和str2指向同一个字符串常量池中的对象 \"]},\"104\":{\"h\":\"运行时常量池\",\"t\":[\"定义：\",\"运行时常量池（Runtime Constant Pool）是每个类文件中的常量池（常量表）在运行时的表示形式。它包含类中所有字面值和符号引用。\",\"位置：\",\"在JDK 1.6及之前，运行时常量池也位于永久代。\",\"从JDK 1.7开始，运行时常量池被移到Java堆。\",\"实现：\",\"运行时常量池包含类加载后所需的各种常量，包括数值常量（例如整数、浮点数）、字符串常量、类和接口的符号引用、字段引用、方法引用等。\",\"运行时常量池在类加载时从类文件的常量池（Class File Constant Pool）中提取，并且在运行时为常量池中的符号引用进行解析。\",\"示例：\",\"public class Example { public static void main(String[] args) { int a = 10; // 数值常量10存储在运行时常量池中 String str = \\\"Hello\\\"; // 字符串字面值\\\"Hello\\\"存储在字符串常量池中，并且字符串常量池的引用在运行时常量池中 } } \"]},\"105\":{\"h\":\"区别总结\",\"t\":[\"用途：\",\"字符串常量池：专门用于存储字符串字面值，确保相同的字符串字面值在内存中只有一个副本，以节省内存。\",\"运行时常量池：用于存储类加载后所需的各种常量和符号引用，支持类和方法的运行。\",\"位置：\",\"字符串常量池：在JDK 1.6及之前位于永久代，从JDK 1.7开始位于堆中。\",\"运行时常量池：在JDK 1.6及之前位于永久代，从JDK 1.7开始位于堆中。\",\"内容：\",\"字符串常量池：仅包含字符串字面值。\",\"运行时常量池：包含数值常量、字符串常量、类和接口的符号引用、字段引用、方法引用等。\",\"管理机制：\",\"字符串常量池：由JVM自动管理，intern()方法可手动将字符串添加到池中。\",\"运行时常量池：在类加载时从类文件常量池中提取，并动态解析符号引用。\",\"通过上述对比，可以清晰地看出字符串常量池和运行时常量池在用途、实现和管理机制上的不同。\"]},\"106\":{\"h\":\"上面的代码示例中int a = 10不应该存放在栈中吗？\",\"t\":[\"在Java中，int a = 10; 这样的局部变量的值确实存储在Java栈中。然而，这个示例中提到的“运行时常量池”涉及的是字面值 10 这个常量的存储位置和引用机制。因此，为了更好地解释它们的区别，我们需要澄清几点：\"]},\"107\":{\"h\":\"运行时常量池和栈中的局部变量\",\"t\":[\"运行时常量池：存储类文件中的各种常量，包括字面值（如整数、浮点数）和符号引用（如类、字段、方法的符号引用）。这些常量在类加载时被加载到内存中，并用于程序运行时的各种操作。\",\"Java栈：每个线程都有一个Java栈，存储方法调用的局部变量和部分方法执行时的中间结果。\"]},\"108\":{\"h\":\"解释 int a = 10;\",\"t\":[\"在代码 int a = 10; 中：\",\"10 这个字面值：\",\"作为字面值 10，它在编译时会被存储在类文件的常量池中。\",\"在运行时，类加载器会将类文件的常量池中的字面值 10 加载到运行时常量池中。\",\"局部变量 a：\",\"a 是一个局部变量，它在方法调用时存储在当前线程的Java栈的当前栈帧中。\",\"存储过程：\",\"当执行 int a = 10; 时，运行时常量池中的字面值 10 被取出并赋值给局部变量 a，这个局部变量 a 实际上是存储在栈中的。\",\"因此，在这段代码中：\",\"字面值 10：最初存储在运行时常量池中。\",\"局部变量 a：存储在栈中，并引用运行时常量池中的 10 的值。\"]},\"109\":{\"h\":\"修正后的解释和示例代码\",\"t\":[\"public class Example { public static void main(String[] args) { int a = 10; // 数值常量10存储在运行时常量池中，局部变量a存储在Java栈中 String str = \\\"Hello\\\"; // 字符串字面值\\\"Hello\\\"存储在字符串常量池中 } } \"]},\"110\":{\"h\":\"总结\",\"t\":[\"运行时常量池：存储类加载时从类文件中提取的常量，包括字面值和符号引用。\",\"字符串常量池：专门存储字符串字面值，确保相同的字符串字面值在内存中只有一个副本。\",\"Java栈：存储方法调用的局部变量，包括方法执行的中间结果。\",\"在上述示例中，int a = 10; 中的 10 作为常量被存储在运行时常量池中，而 a 这个局部变量本身存储在Java栈中。\"]},\"111\":{\"h\":\"为什么使用元空间替代永久代作为方法区的实现？\",\"t\":[\"在JDK 1.8中，Java虚拟机（JVM）用元空间（Metaspace）替代了永久代（PermGen）来实现方法区。这一变化有多方面的原因和好处，包括规避内存溢出问题、提高性能、简化内存管理等。\"]},\"112\":{\"h\":\"使用元空间替代永久代的原因\"},\"113\":{\"h\":\"客观原因\",\"t\":[\"内存溢出问题：\",\"永久代的限制：永久代的大小在JVM启动时设定，无法动态调整。一旦应用加载了大量类或使用了大量字符串常量，永久代可能会填满，从而导致java.lang.OutOfMemoryError: PermGen space错误。虽然可以通过-XX:MaxPermSize参数调整其大小，但这增加了内存管理的复杂性。\",\"其他JVM的优势：其他JVM如J9和JRockit不会因为固定大小的永久代而遭遇内存溢出问题，只要总内存没有达到系统限制。\",\"方法行为不一致：\",\"String::intern()的影响：永久代的设计可能导致某些方法在不同JVM下表现不同，例如String::intern()方法在处理字符串常量池时可能表现出不同的性能和行为。\"]},\"114\":{\"h\":\"主观原因\",\"t\":[\"Oracle收购BEA后的整合： \",\"整合JRockit功能：Oracle收购BEA后，计划将JRockit中的优秀功能（如Java Mission Control管理工具）移植到HotSpot虚拟机中。但由于HotSpot和JRockit对方法区实现的差异，移植工作面临诸多困难。\",\"未来发展规划：为了HotSpot未来的发展，Oracle在JDK 6时就计划放弃永久代，逐步改用本地内存（Native Memory）来实现方法区。在JDK 7中，部分数据（如字符串常量池、静态变量）已移出永久代；在JDK 8中，永久代被完全废弃，改用元空间。\"]},\"115\":{\"h\":\"元空间的优势\",\"t\":[\"动态调整内存大小：\",\"避免OOM错误：元空间在本地内存中分配，可以根据需要动态增长，不受堆内存大小的限制，减少了因类加载过多而导致的内存不足问题。\",\"减少配置复杂性：不再需要手动调整类似-XX:MaxPermSize参数，简化了内存管理。\",\"改进的性能和垃圾回收：\",\"更高的回收效率：元空间利用新的垃圾回收算法，提高了回收效率，减少了Full GC的频率和停顿时间。\",\"与分代垃圾回收协同工作：元空间设计使其更好地与分代垃圾回收器协同工作，提高整体性能。\",\"统一的内存管理：\",\"简化管理：类元数据存储在本地内存中，简化了JVM的内存管理，使得内存使用更加高效和一致。\",\"更好的类加载和卸载支持：\",\"支持更多类加载和卸载：元空间提供更好的类加载和卸载支持，特别是对于大量动态生成和卸载类的应用，提高了内存利用率和性能。\"]},\"116\":{\"h\":\"总结\",\"t\":[\"使用元空间（Metaspace）替代永久代（PermGen）作为方法区的实现带来了以下好处：\",\"避免永久代空间不足问题，减少OutOfMemoryError的发生。\",\"改进性能和内存管理，提高垃圾回收效率，减少Full GC的频率和停顿时间。\",\"简化内存管理，通过动态调整减少配置的复杂性。\",\"提供更好的类加载和卸载支持，提高内存利用率和性能。\",\"整合JRockit功能，支持HotSpot的未来发展。\",\"这些改进使得JVM在性能、稳定性和可维护性方面都有显著提升，因此在JDK 1.8中引入了元空间来替代永久代。\"]},\"117\":{\"h\":\"对象创建的过程了解吗？\",\"t\":[\"当创建一个对象时，Java虚拟机（JVM）会执行以下步骤：\",\"类加载：\",\"如果该类尚未加载，则先执行类加载过程。类加载过程包括加载、验证、准备、解析和初始化阶段。\",\"分配内存：\",\"在堆内存中为对象分配内存空间。在JDK 1.7及之前的版本中，对象的内存分配是连续的，使用指针碰撞或空闲列表实现。在JDK 1.8及之后的版本中，引入了TLAB（Thread-Local Allocation Buffer）来提高内存分配的效率。\",\"初始化零值：\",\"JVM会将分配的内存空间初始化为零值，这包括基本类型的零值（如int类型的0）和引用类型的null。\",\"设置对象头：\",\"JVM会为对象设置对象头信息，包括对象的哈希码、GC分代信息、锁状态标志等。对象头的大小取决于虚拟机的具体实现和运行环境（如32位或64位JVM）。\",\"执行构造函数：\",\"执行对象的构造函数，进行对象的初始化。构造函数可以是类的直接构造函数，也可以是从父类继承而来的构造函数。构造函数会对对象的实例变量进行初始化，包括设置初始值或通过参数传递的值。\",\"返回对象引用：\",\"当构造函数执行完毕后，会返回一个指向新创建对象的引用。通过这个引用，程序可以访问和操作对象的属性和方法。\",\"总的来说，对象创建的过程包括类加载、内存分配、初始化、构造函数执行等步骤，确保对象在内存中被正确地创建和初始化。\"]},\"118\":{\"h\":\"什么是指针碰撞？什么是空闲列表？\",\"t\":[\"在 JVM 中，内存分配的方式通常是指针碰撞和空闲列表两种。\",\"指针碰撞：\",\"指针碰撞适用于 Java 堆中内存是绝对规整的情况。在这种情况下，所有已被使用的内存和空闲的内存分别放在堆的两端，中间有一个指针作为分界点指示器。\",\"JVM 通过移动指针来分配内存，将指针向空闲空间方向挪动与对象大小相等的距离即可。这种方式称为“指针碰撞”，因为指针碰到对象后会被挪动到下一个可用位置。\",\"空闲列表：\",\"空闲列表适用于 Java 堆中的内存不规整的情况。在这种情况下，已被使用的内存和空闲的内存相互交错。\",\"JVM 需要维护一个列表，记录哪些内存块是可用的。在分配内存时，JVM 会从列表中找到一块足够大的空间，划分给对象实例，并更新列表上的记录。\",\"这种分配方式称为“空闲列表”，它相对于指针碰撞更加灵活，因为不要求内存是连续的，能更好地处理内存碎片化的情况。\",\"选择使用指针碰撞还是空闲列表取决于堆内存的布局情况以及 JVM 的具体实现。指针碰撞适用于内存连续的情况，而空闲列表适用于内存不规整的情况。\",\"两种方式的选择由Java堆是否规整决定，Java堆是否规整是由选择的垃圾收集器是否具有压缩整理能力决定的\"]},\"119\":{\"h\":\"什么是TLAB（Thread-Local Allocation Buffer）\",\"t\":[\"TLAB（Thread-Local Allocation Buffer）是 Java 虚拟机（JVM）中一种用于提高多线程并发性能的技术。\",\"TLAB 是为每个线程分配的一块私有的内存区域，用于线程独立地分配对象。它的作用在于减少线程间因为对象分配而频繁竞争内存分配的情况，从而提高并发性能。\",\"TLAB 的工作原理如下：\",\"每个线程分配自己的 TLAB：当一个线程开始执行时，JVM 会为其分配一个 TLAB 区域。这个区域在堆内存中是连续的，并且是该线程私有的，其他线程无法访问。\",\"线程独立地分配对象：线程在自己的 TLAB 区域内分配对象时，无需进行同步操作，因为这个区域是私有的，不存在与其他线程的竞争。这样可以避免了多线程情况下的锁竞争，提高了分配对象的效率。\",\"TLAB 分配原则：当线程需要分配对象时，首先会在自己的 TLAB 区域中进行分配。如果该区域空间不足，JVM 会尝试为该线程重新分配更大的 TLAB 区域。只有当 TLAB 区域不够大或者无法分配时，线程才会在堆的全局空间中进行对象分配。\",\"TLAB 技术的使用可以减少多线程情况下的内存分配竞争，提高了 JVM 在并发场景下的性能表现。\"]},\"120\":{\"h\":\"JVM 里 new 对象时，堆会发生抢占吗？JVM是怎么设计来保证线程安全的？\",\"t\":[\"在 JVM 中，堆内存的分配是线程共享的，因此在多线程环境下可能会发生堆内存的抢占现象。当多个线程同时执行 new 操作创建对象时，它们会竞争堆内存的分配。\",\"为了解决多线程环境下的堆内存分配竞争问题，常见的解决方案包括：\",\"原子性操作：JVM 使用 CAS（Compare and Swap）等原子性操作来确保对共享数据的原子性访问。CAS 操作可以比较并交换共享变量的值，如果期望值与当前值一致，则更新为新值，否则重试。这样可以避免使用锁，提高了并发性能。\",\"本地线程分配缓冲（TLAB）：JVM 为每个线程预先分配一小块内存空间作为本地线程分配缓冲。线程在分配对象时，首先尝试在自己的 TLAB 中分配内存，只有当 TLAB 用尽时才会竞争堆内存。这样做可以减少线程间因为堆内存分配而发生的竞争，提高了内存分配的效率。\",\"通过这些解决方案，JVM 能够有效地处理多线程环境下的堆内存分配问题，确保线程安全和性能的平衡。\"]},\"121\":{\"h\":\"能说一下对象的内存布局吗？\",\"t\":[\"在Java中，每个对象都会被分配一块内存空间。这块内存空间包括三个主要部分：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。\",\"对象头（Header）：对象头存储了一些元数据，例如对象的哈希码、锁状态、GC（垃圾回收）相关信息等。对象头的大小在不同的JVM实现中会有所不同，通常在32位JVM中占用4个字节，而在64位JVM中占用8个字节。\",\"实例数据（Instance Data）：实例数据存储了对象的成员变量值。这些成员变量按其声明顺序存放在内存中，基本数据类型直接存储其值，引用类型则存储指向实际对象数据的指针。\",\"对齐填充（Padding）：由于虚拟机内存访问要求数据存储在特定的内存地址上，因此在实例数据之后可能会添加一些填充字节，以保证对象在内存中的起始地址是按照要求对齐的。这些填充字节的大小取决于JVM实现和操作系统的要求。\",\"总体而言，对象的内存布局可以用以下示意图表示：\",\"|-------------------| | Object Header | (Header) |-------------------| | Instance Data | (成员变量) |-------------------| | Padding | (对齐填充) |-------------------| \",\"需要注意的是，这个内存布局在不同的JVM实现中可能会有所不同。\"]},\"122\":{\"h\":\"对象怎么访问定位？\",\"t\":[\"在Java程序中，通过栈上的reference数据来操作堆上的具体对象。Java虚拟机规范中只规定了reference是一个指向对象的引用，并未具体定义如何定位和访问堆中对象的具体位置，因此对象的访问方式由虚拟机实现而定。目前主流的访问方式有使用句柄和直接指针两种：\",\"句柄访问方式：在这种方式下，Java堆中可能会划分出一块内存作为句柄池，reference中存储的是对象的句柄地址。句柄中包含了对象实例数据与类型数据各自具体的地址信息。这种方式的优势在于稳定性，即reference中存储的是稳定的句柄地址，当对象被移动时（如垃圾收集时），只需修改句柄中的实例数据指针，而不需修改reference本身。\",\"直接指针访问方式：在这种方式下，reference中存储的直接是对象地址，而不是句柄地址。这种方式的优势在于速度更快，因为避免了一次指针定位的时间开销。由于对象访问在Java中非常频繁，这种方式可以节省大量的执行成本。\",\"HotSpot虚拟机主要采用直接指针访问方式来进行对象访问，以提高执行效率。\"]},\"123\":{\"h\":\"什么是内存溢出、内存泄漏？\",\"t\":[\"内存溢出（Memory Overflow）和内存泄漏（Memory Leak）是两种不同的内存管理问题：\",\"内存溢出（Memory Overflow）：内存溢出指的是程序在申请内存时，无法获得足够的内存空间，导致无法正常执行程序。这种情况通常发生在程序需要的内存超过了系统实际可用内存的情况下。内存溢出可能会导致程序崩溃，或者出现异常错误，例如Java中的OutOfMemoryError。常见的内存溢出场景包括：递归调用层次过深、无限循环创建对象等。\",\"内存泄漏（Memory Leak）：内存泄漏指的是程序中已经不再使用的内存没有被正确释放，导致该内存无法被再次使用，最终导致程序占用的内存越来越多，甚至耗尽系统的可用内存。内存泄漏通常发生在程序中频繁动态分配内存却未及时释放，或者是持有对某些对象的引用却未能及时释放这些引用，使得垃圾回收器无法回收这些对象。长时间运行的程序中如果存在内存泄漏，可能会导致系统性能下降、程序运行速度变慢，甚至系统崩溃。\",\"内存溢出和内存泄漏都是需要注意和及时解决的内存管理问题，特别是在长时间运行、资源密集型的程序中。及时发现和修复这些问题是保证程序性能和稳定性的重要一环。\"]},\"124\":{\"h\":\"能手写内存溢出的例子吗？\",\"t\":[\"Java堆内存溢出：OutOfMemoryError\",\"import java.util.ArrayList; import java.util.List; public class HeapOverflowExample { public static void main(String[] args) { List<byte[]> list = new ArrayList<>(); try { while (true) { list.add(new byte[1000000]); // 创建一个1MB大小的字节数组对象 } } catch (OutOfMemoryError e) { System.out.println(\\\"Java堆内存溢出！\\\"); } } } \",\"在这个示例中，我们创建了一个ArrayList，然后尝试不断地向其中添加1MB大小的字节数组对象。由于没有对添加的对象进行释放，堆内存会逐渐耗尽，最终抛出OutOfMemoryError，提示Java堆内存溢出。\",\"虚拟机栈溢出：StackOverflowError\",\"public class StackOverflowExample { public static void main(String[] args) { try { recursiveMethod(0); } catch (StackOverflowError e) { System.out.println(\\\"虚拟机栈溢出！\\\"); } } public static void recursiveMethod(int i) { recursiveMethod(i + 1); // 递归调用自身 } } \",\"在这个示例中，recursiveMethod()方法会无限递归调用自身，导致虚拟机栈溢出，最终抛出StackOverflowError异常。\"]},\"125\":{\"h\":\"内存泄漏可能由哪些原因导致呢？\",\"t\":[\"内存泄漏可能由以下几种常见原因导致：\",\"未及时释放资源：例如打开文件、数据库连接、网络连接等资源后，没有在使用完毕后及时关闭，导致资源未被释放。\",\"缓存导致的引用保留：缓存通常用于临时存储对象以提高访问速度，但如果没有正确管理缓存，可能会导致不再需要的对象一直被保留在内存中。\",\"监听器和回调：注册了监听器或回调函数，但在对象不再需要时未能正确注销，导致对象仍然被引用，无法被垃圾回收器回收。\",\"静态集合：如果将对象添加到静态集合中，即使在程序的其他部分不再需要这些对象，它们仍然会被集合保留，导致内存泄漏。\",\"内部类持有外部类的引用：如果内部类持有对外部类的引用，并且生命周期比外部类长，那么即使外部类不再需要，外部类的实例也无法被垃圾回收。\",\"长时间运行的程序：长时间运行的程序可能会持续产生新对象而不释放旧对象，导致内存逐渐耗尽。\",\"ThreadLocal使用不当：ThreadLocal的弱引用导致内存泄漏也是个老生常谈的话题了，使用完ThreadLocal一 定要记得使用remove方法来进行清除\",\"综上所述，内存泄漏通常是由于程序中持续保留了不再需要的对象或资源而引起的，因此在开发过程中需要仔细管理和释放对象和资源，以避免内存泄漏问题的发生。\"]},\"126\":{\"h\":\"如何判断对象仍然存活？\",\"t\":[\"在Java中，可以通过垃圾回收器来判断对象是否仍然存活。Java的垃圾回收器使用了“引用计数”和“可达性分析”两种方法来确定对象是否可以被回收。\",\"引用计数：这种方法通过给对象添加一个引用计数器来跟踪对象的引用数量。每当有一个新的引用指向对象时，引用计数器就加一；当引用被移除时，计数器减一。如果计数器为零，则说明对象没有被引用，可以被回收。但是，Java的垃圾回收器不使用引用计数算法，因为该算法无法处理循环引用的情况。\",\"可达性分析：这是Java垃圾回收器实际使用的方法。可达性分析从一组称为“GC Roots”的初始对象开始，通过对象之间的引用关系进行遍历，找出所有能够被直接或间接引用到的对象。如果某个对象无法通过任何引用链与GC Roots相连，则说明该对象不可达，即为“垃圾对象”，可以被回收。\",\"因此，对于一个对象，只要存在一条从GC Roots到该对象的引用链，该对象就被认为是存活的；反之，则被认为是可回收的垃圾对象。\"]},\"127\":{\"h\":\"Java中可作为GC Roots的对象有哪几种？\",\"t\":[\"在Java中，以下对象可以作为GC Roots，垃圾回收器从这些对象开始进行可达性分析：\",\"虚拟机栈中的引用：虚拟机栈（Java栈）中的本地变量表和操作栈中的引用。\",\"方法区中的静态引用：方法区中的静态变量引用的对象，即静态成员变量。\",\"方法区中的常量引用：方法区中的常量引用的对象，如字符串常量池中的字符串对象。\",\"本地方法栈中的JNI（Java Native Interface）引用：JNI引用的对象，即Java代码调用本地方法时传递的对象引用。\",\"这些对象是垃圾回收器进行可达性分析的起点，通过这些对象可以遍历到所有活动对象，判断哪些对象是可达的，哪些是不可达的，从而进行垃圾回收。\"]},\"128\":{\"h\":\"说一下对象有哪几种引用？\",\"t\":[\"在Java中，根据对象的引用强度和生命周期的不同，可以将对象的引用分为以下几种类型：\",\"强引用（Strong Reference）：\",\"强引用是最常见的引用类型，如果一个对象具有强引用，垃圾回收器不会回收它。\",\"即使系统出现内存溢出，也不会回收强引用的对象，而是抛出OutOfMemoryError异常。\",\"例如：普通的对象引用赋值，例如 Object obj = new Object();\",\"软引用（Soft Reference）：\",\"软引用是一种比强引用弱一些的引用，它在系统即将发生内存溢出之前，会被垃圾回收器回收。\",\"当系统内存不足时，垃圾回收器会尝试回收软引用指向的对象，如果回收后还是没有足够的内存，才会抛出OutOfMemoryError异常。\",\"适合用于缓存的场景，例如图片缓存。\",\"弱引用（Weak Reference）：\",\"弱引用的生命周期比软引用更短，当垃圾回收器进行垃圾回收时，无论内存是否充足，弱引用都会被回收。\",\"弱引用可以防止内存泄漏，但并不能保证在某个时刻被保留。\",\"主要用于实现对象的规范映射，例如ThreadLocal和WeakHashMap。\",\"虚引用（Phantom Reference）：\",\"虚引用是最弱的引用，几乎没有直接作用。\",\"虚引用的唯一目的是在对象被垃圾回收器回收时收到一个系统通知。\",\"在Java中，通过虚引用可以跟踪对象被垃圾回收的状态，但不能通过虚引用获取对象本身。\",\"主要用于清理前的资源释放工作。\",\"使用不同类型的引用可以更灵活地管理对象的生命周期和内存使用情况，同时可以避免一些内存泄漏问题。\"]},\"129\":{\"h\":\"finalize()方法了解吗？有什么作用？\",\"t\":[\"finalize()方法是Java中的一个特殊方法，定义在Object类中，具有以下特点：\",\"方法签名：protected void finalize() throws Throwable\",\"作用：finalize()方法被用来实现对象在被垃圾回收之前，自我清理或释放资源的操作。它允许在对象被回收之前执行一些特定的清理工作，例如关闭文件、释放资源等。\",\"调用时机：垃圾回收器在回收对象之前会调用其finalize()方法，但是并不保证会调用它，因此不能依赖于finalize()方法来执行重要的清理工作。垃圾回收器调用finalize()方法的时间是不确定的，有可能在对象被回收时调用，也有可能不会被调用。\",\"缺点：finalize()方法存在一些缺点，包括无法保证及时执行、不确定性高、会影响性能等。因此，不建议过度依赖finalize()方法来进行资源释放和清理操作，推荐使用try-with-resources语句或显式地调用close()等方法来确保资源的释放。\",\"总之，finalize()方法提供了一个在对象被垃圾回收之前进行一些清理操作的机会，但由于其不确定性和性能问题，应谨慎使用，并尽量避免过度依赖。\"]},\"130\":{\"h\":\"Java堆的内存分区了解吗？\",\"t\":[\"Java堆是Java虚拟机管理的最大的一块内存区域，主要用于存放对象实例。Java堆可以根据内存分配的策略划分为不同的区域，主要包括以下几个部分：\",\"新生代（Young Generation）：\",\"新生代是Java堆的一部分，用于存放新创建的对象。\",\"新生代通常被划分为三个区域：Eden区、Survivor区（From区和To区）。\",\"大多数对象在被分配时会被分配在Eden区，然后经过一次Minor GC后，仍然存活的对象会被移动到Survivor区。\",\"Survivor区用来保存经过一次GC后仍然存活的对象，From区和To区之间会进行对象的交换。\",\"老年代（Old Generation）：\",\"老年代用于存放长期存活的对象，通常存放在老年代的对象经过多次垃圾回收后仍然存活。\",\"大多数对象从新生代晋升到老年代，经过多次Minor GC后仍然存活的对象会被晋升到老年代。\",\"永久代/元空间（Permanent Generation/Metaspace）：\",\"永久代是Java 7及以前版本的概念，用于存放类的元数据、静态变量、常量池等。\",\"从Java 8开始，永久代被元空间（Metaspace）所取代，元空间不再位于Java堆中，而是位于本地内存中，因此不再受到Java堆的大小限制。\",\"代码缓存区（Code Cache）：\",\"代码缓存区用于存放编译后的本地代码，例如JIT编译器生成的机器代码。\",\"Java堆的内存分区主要是为了优化内存的使用和垃圾回收效率，通过将不同类型的对象放置在不同的区域中，可以采用不同的垃圾回收算法和策略来对各个区域进行回收，以提高垃圾回收的效率和内存利用率。\"]},\"131\":{\"h\":\"垃圾收集算法了解吗？\",\"t\":[\"当然，垃圾收集算法是Java虚拟机用来回收不再使用的内存空间的一种技术。Java虚拟机中常见的垃圾收集算法包括以下几种：\",\"标记-清除算法（Mark and Sweep）：\",\"标记-清除算法是最基本的垃圾收集算法之一，分为两个阶段：标记阶段和清除阶段。\",\"在标记阶段，从根节点出发，标记所有能够被访问到的对象。\",\"在清除阶段，垃圾收集器会遍历整个堆，清除所有未标记的对象，释放它们所占用的内存空间。\",\"标记-清除算法存在的问题是产生大量的内存碎片，容易导致内存分配失败。同时执行效率不稳定，垃圾回收时垃圾收集器会遍历整个堆，如果堆中包含大量对象，可能执行效率降低\",\"复制算法（Copying）：\",\"复制算法将内存空间划分为两个相等大小的区域：From区和To区。\",\"在垃圾回收时，将存活的对象复制到To区，然后清空From区。\",\"复制算法适用于新生代的垃圾回收，因为新生代中的对象存活时间短，复制的开销较小。\",\"标记-整理算法（Mark and Compact）：\",\"标记-整理算法结合了标记-清除和复制算法的优点，适用于老年代的垃圾回收。\",\"在标记阶段，标记所有存活的对象，并且将存活对象向一端移动。\",\"在整理阶段，将存活对象压缩，将它们移动到内存的一端，释放出连续的内存空间。\",\"分代算法（Generational）：\",\"分代算法基于“弱分代假设”，即大多数对象的生命周期很短。\",\"根据对象的存活周期将Java堆划分为新生代和老年代两个部分，分别采用不同的垃圾回收算法和策略。\",\"新生代通常使用复制算法，老年代通常使用标记-整理算法。\",\"增量式垃圾收集算法（Incremental Garbage Collection）：\",\"增量式垃圾收集算法将垃圾回收过程分解成多个阶段，每个阶段只收集部分对象，然后让程序继续执行。\",\"这种算法可以减少垃圾回收的停顿时间，提高系统的响应速度，但会增加垃圾回收器的复杂度。\",\"以上是一些常见的垃圾收集算法，不同的算法适用于不同的场景和需求，选择合适的垃圾收集算法可以提高垃圾回收的效率和系统的性能。\"]},\"132\":{\"h\":\"说一下新生代的区域划分？\",\"t\":[\"新生代是Java堆的一部分，用于存放新创建的对象。新生代通常被划分为三个区域：Eden区、Survivor区（From区和To区）。\",\"Eden区：\",\"Eden区是新创建对象的初始分配区域，大多数对象都会被分配到Eden区。\",\"当Eden区满时，触发Minor GC（新生代垃圾回收），将Eden区中存活的对象复制到Survivor区，并清空Eden区。\",\"Survivor区：\",\"Survivor区是用于存放经过一次Minor GC后仍然存活的对象。\",\"Survivor区通常有两个，分别称为From区和To区，它们之间会进行对象的交换。\",\"在对象经过多次Minor GC后仍然存活时，会被移动到老年代，而不再留在Survivor区。\",\"在新生代中，采用复制算法进行垃圾回收。该算法将内存空间分为两个相等大小的区域（Eden区和Survivor区），在Minor GC时，将Eden区和其中一个Survivor区的存活对象复制到另一个Survivor区，同时清空原来的Eden区和使用过的Survivor区。这样，新生代的垃圾回收可以避免内存碎片的产生，提高垃圾回收的效率。\"]},\"133\":{\"h\":\"Minor GC/Young GC、Major GC/Old GC、Mixed GC、Full GC都是什么意思？\",\"t\":[\"这些术语都与Java堆的垃圾回收相关，它们表示不同类型的垃圾回收操作：\",\"Minor GC / Young GC：\",\"Minor GC（也称为Young GC）是针对新生代的垃圾回收操作。\",\"当新生代的Eden区满时，触发Minor GC。在Minor GC中，只有新生代被回收，即Eden区和Survivor区。\",\"Minor GC的目标是清理新生代中的垃圾对象，提供足够的空间给新对象分配。\",\"Major GC / Old GC：\",\"Major GC（也称为Old GC）是针对老年代的垃圾回收操作。\",\"当老年代的内存空间不足时，或者当长时间存活的对象需要晋升到老年代时，触发Major GC。\",\"Major GC的目标是清理老年代中的垃圾对象，提供足够的空间给新对象分配。\",\"Mixed GC：\",\"Mixed GC是一种混合型的垃圾回收操作，同时针对新生代和老年代进行回收。\",\"在某些情况下，垃圾收集器可能会选择执行Mixed GC，以提高整体的垃圾回收效率。\",\"Mixed GC通常会在新生代和老年代之间进行对象的晋升和迁移，以保证整个堆的空间利用率。\",\"Full GC：\",\"Full GC是一种完全的垃圾回收操作，会对整个Java堆进行回收。\",\"在某些情况下，如永久代（在Java 7及以前版本）或元空间（在Java 8及以后版本）的内存不足时，可能会触发Full GC。\",\"Full GC会对新生代和老年代以及永久代/元空间进行垃圾回收，其过程比较耗时，会导致较长时间的应用程序暂停。\"]},\"134\":{\"h\":\"Minor GC/Young GC什么时候触发？\",\"t\":[\"Minor GC（也称为Young GC）在什么时候触发取决于新生代的内存分配情况。通常情况下，触发Minor GC的时机有两个主要条件：\",\"Eden区满：\",\"当Eden区（新生代的一部分）被新对象填满时，会触发Minor GC。\",\"新对象通常会被分配到Eden区，当Eden区没有足够的空间来分配新对象时，就会触发Minor GC。\",\"Survivor区不足：\",\"在新生代中，对象经过几次Minor GC后仍然存活的对象会被晋升到老年代。\",\"当新生代的Survivor区也无法容纳存活对象时，这些对象就会被晋升到老年代。\",\"这种情况也会触发Minor GC，因为Minor GC实际上是对新生代进行垃圾回收，包括Eden区和Survivor区。\",\"因此，Minor GC通常在Eden区满或者存活对象晋升到老年代时触发。它的目标是清理新生代中的垃圾对象，以便为新对象的分配提供足够的空间。\"]},\"135\":{\"h\":\"什么时候会触发Full GC？\",\"t\":[\"Full GC（Full Garbage Collection）通常在以下情况下会触发：\",\"老年代空间不足：当老年代的内存空间不足以容纳新对象，或者老年代中的对象存活时间过长，导致老年代的内存使用率达到阈值时，会触发Full GC。\",\"Young GC之后老年代空间不足：在执行Young GC之后，如果有一批对象需要放入老年代，但老年代没有足够的内存空间存放这些对象，就会触发Full GC。\",\"空间分配担保失败（Promotion Failure）：当新生代的To区放不下从Eden和From区拷贝过来的对象，或者新生代对象的GC年龄到达阈值需要晋升到老年代，而老年代放不下时，都会触发Full GC。\",\"方法区内存空间不足：如果方法区由永久代实现，而永久代的空间不足时，也会触发Full GC。\",\"System.gc()等命令触发：手动调用System.gc()或使用类似jmap -dump等命令也会触发Full GC。\",\"Young GC之前检查老年代：当要进行Young GC时，如果发现老年代可用的连续内存空间小于新生代历次Young GC后升入老年代的对象总和的平均大小，说明本次Young GC后可能升入老年代的对象大小可能超过了老年代当前可用内存空间，这时会触发Full GC。\",\"这些情况都反映了Java应用程序在运行过程中内存管理的一些具体场景，了解这些情况可以帮助开发者更好地调优Java应用程序的内存配置和性能。\"]},\"136\":{\"h\":\"对象什么时候会进入老年代？\",\"t\":[\"长期存活的对象：长期存活的对象，如全局变量、长时间存活的缓存对象等，会逐渐晋升到老年代。对象的迭代年龄会在每次Young GC之后的对象移动操作中增加，当迭代年龄达到一定阈值（默认为15）时，对象将被移入老年代。可以通过调整-XX:MaxTenuringThreshold参数来设置这个阈值。\",\"大对象：占用大量连续内存空间的对象，如大数组或长字符串，会直接进入老年代。可以通过调整-XX:PretenureSizeThreshold参数来设置大对象的大小阈值。\",\"动态年龄判断：HotSpot虚拟机并不要求对象的年龄必须达到阈值才能晋升到老年代。如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。\",\"空间分配担保：在Young GC之后，如果新生代仍有大量对象存活，就需要老年代进行分配担保，将Survivor区无法容纳的对象直接送入老年代。这个机制避免了频繁将存活对象从新生代复制到Survivor区，提高了垃圾回收的效率。\"]},\"137\":{\"h\":\"知道有哪些垃圾收集器吗？\",\"t\":[\"Java 中常见的垃圾收集器包括：\",\"Serial收集器：这是最早的收集器之一，它是单线程的收集器，使用标记-复制算法，适用于简单的客户端应用或者测试目的。\",\"ParNew收集器：ParNew是Serial收集器的多线程版本，主要用于新生代的收集，也使用标记-复制算法。\",\"Parallel Scavenge收集器：Parallel Scavenge收集器也是针对新生代的收集器，它关注的是吞吐量，使用标记-复制算法和多线程并行的方式实现高吞吐量的垃圾收集。\",\"Serial Old收集器：Serial Old是Serial收集器的老年代版本，使用标记-整理算法，适用于简单的客户端应用或者测试目的。\",\"Parallel Old收集器：Parallel Old是Parallel Scavenge收集器的老年代版本，也是使用标记-整理算法，适用于多核服务器上的应用，通过多线程并行收集实现高吞吐量。\",\"CMS（Concurrent Mark-Sweep）收集器：CMS收集器是一种以减少停顿时间为目标的收集器，它通过并发标记和并发清除来实现低停顿时间的垃圾收集，适用于对响应时间有要求的应用。\",\"G1（Garbage-First）收集器：G1收集器是一种面向服务端应用的垃圾收集器，它将堆内存划分为多个区域，通过并发标记、整理和清理来实现高吞吐和低停顿。\",\"ZGC（Z Garbage Collector）：ZGC是一种低延迟的垃圾收集器，通过并发的方式来实现在非常短的停顿时间内完成垃圾收集。\",\"Shenandoah收集器：Shenandoah是一种低延迟的垃圾收集器，它通过在Java线程运行的情况下执行并发标记、并发整理和并发回收来实现低停顿时间。\",\"每种垃圾收集器都有其自己的特点和适用场景，选择合适的垃圾收集器取决于应用程序的性能需求和特点。在实际应用中，通常需要根据具体的场景进行选择和调优。\"]},\"138\":{\"h\":\"什么是Stop The World ? 什么是 OopMap ？什么是安全点？\",\"t\":[\"垃圾回收过程中的“Stop The World”现象指的是在执行垃圾回收时，需要暂停所有的用户线程。这个暂停的目的是为了保证对象引用更新的正确性。在这个暂停期间，虚拟机会执行垃圾回收操作，包括对象的移动等，以确保内存的正确回收和整理。\",\"在HotSpot虚拟机中，OopMap（Object-oriented Programming Map）是一种数据结构，用于记录对象内的偏移量上存储的数据类型。当类加载完成时，HotSpot会计算并记录下对象内部各个偏移量上存储的数据类型。在即时编译过程中，也会生成OopMap，并记录下栈上和寄存器里哪些位置是引用。\",\"安全点（Safe Point）是指在程序执行过程中的特定位置，垃圾收集器可以在这些位置暂停用户程序的执行，进行垃圾回收操作。这些安全点通常出现在循环的末尾、方法调用之后、可能抛出异常的位置等。在这些特定位置上，用户程序的状态是可预期的，因此可以暂停执行进行垃圾回收操作，而不会导致程序状态的不一致。\"]},\"139\":{\"h\":\"能详细说一下CMS收集器的垃圾收集过程吗？\",\"t\":[\"CMS（Concurrent Mark-Sweep）收集器是Java虚拟机（JVM）中用于垃圾收集的一种算法，旨在最小化应用程序的停顿时间。CMS收集器主要用于老年代（Tenured Generation）的垃圾收集。它的工作过程可以分为以下几个阶段：\",\"初始标记（Initial Mark）：\",\"这一阶段会暂停所有应用线程（Stop-The-World，STW）。\",\"主要标记从根集合（GC Roots）直接可达的对象。\",\"这个阶段时间较短，因为只需要标记GC Roots。\",\"并发标记（Concurrent Mark）：\",\"在这个阶段，应用线程和垃圾收集线程并发运行。\",\"垃圾收集线程从初始标记阶段标记的对象开始，遍历整个对象图，标记所有可达的对象。\",\"由于与应用线程并发运行，这个阶段不会造成显著的停顿。\",\"重新标记（Remark）：\",\"这一阶段需要再次暂停所有应用线程（STW）。\",\"由于并发标记阶段和应用线程并发运行，可能会有新创建或删除的对象，这一阶段就是为了重新标记这些对象。\",\"这个阶段也会标记由于并发标记阶段遗漏的对象，确保所有可达对象都被正确标记。\",\"并发清理（Concurrent Sweep）：\",\"这个阶段再次与应用线程并发运行。\",\"垃圾收集线程清理那些没有被标记为可达的对象，回收其占用的内存。\",\"由于是并发进行，不会导致应用线程停顿。\",\"CMS收集器有以下几个特点：\",\"低停顿：CMS收集器设计的主要目的是降低垃圾收集对应用程序的停顿时间。\",\"并发性：大部分的垃圾收集工作与应用程序并发进行。\",\"碎片化问题：CMS使用标记-清除（Mark-Sweep）算法，这可能导致内存碎片。为了应对碎片化，CMS收集器提供了并发压缩（Compacting）和类Unloading的机制。\",\"停顿时间不可预测：尽管CMS降低了停顿时间，但由于碎片化问题和并发的复杂性，有时可能会出现比预期更长的停顿。\",\"另外，CMS收集器还有一个重要的参数：CMSInitiatingOccupancyFraction，它决定了当老年代使用率达到多少时，CMS开始进行垃圾收集。通过调整这个参数，可以控制垃圾收集的频率和停顿时间。\",\"总结来说，CMS收集器通过初始标记、并发标记、重新标记和并发清理四个阶段，尽量减少垃圾收集对应用程序的影响，提升应用程序的响应速度和用户体验。然而，CMS也有其缺点，如内存碎片化问题和某些情况下的长停顿时间，需要在使用时根据具体应用场景进行调优。\"]},\"140\":{\"h\":\"G1垃圾收集器了解吗？\",\"t\":[\"G1垃圾收集器（Garbage First Garbage Collector）是Java虚拟机（JVM）中一种相对现代的垃圾收集器，旨在替代CMS（Concurrent Mark-Sweep）收集器。G1收集器专为多处理器和大内存的环境设计，目标是实现高吞吐量与低停顿时间之间的平衡。其工作过程可以概括为以下几个阶段：\"]},\"141\":{\"h\":\"G1垃圾收集器的关键特点\",\"t\":[\"分区区域（Region）：\",\"堆内存被划分为多个大小相等的区域（Region），每个区域可以是年轻代（Young Generation）或老年代（Old Generation）的一部分。这样做的目的是简化内存管理和优化垃圾收集。\",\"并发标记（Concurrent Marking）：\",\"G1收集器和CMS一样，采用了并发标记的策略，以减少应用停顿时间。\",\"并发标记阶段分为初始标记（Initial Marking）、根区域扫描（Root Region Scanning）、并发标记（Concurrent Marking）、最终标记（Remarking）和清理（Cleanup）五个子阶段。\",\"混合回收（Mixed Collections）：\",\"G1在回收过程中会同时处理年轻代和老年代的垃圾收集，称为混合回收（Mixed Collections）。这与传统的分代垃圾收集器不同，传统方法通常分为年轻代收集和老年代收集。\",\"暂停时间可控（Pause Time Control）：\",\"G1可以通过参数配置目标暂停时间（Pause Time Goals），如通过-XX:MaxGCPauseMillis参数设置，G1会根据设置的暂停时间来调整其行为。\"]},\"142\":{\"h\":\"G1垃圾收集器的工作阶段\",\"t\":[\"初始标记（Initial Mark）：\",\"标记从根对象直接可达的对象。\",\"需要STW，但时间较短。\",\"通常会与年轻代的垃圾收集（Minor GC）一起执行，以减少停顿时间。\",\"根区域扫描（Root Region Scanning）：\",\"并发标记开始前，扫描在初始标记阶段确定的根区域。\",\"这个阶段不需要暂停应用线程。\",\"并发标记（Concurrent Marking）：\",\"该阶段和应用线程并发运行，遍历对象图，标记所有可达对象。\",\"计算存活对象和各区域的存活数据。\",\"最终标记（Remark）：\",\"完成对并发标记阶段遗漏对象的标记。\",\"需要STW，但优化了停顿时间。\",\"清理（Cleanup）：\",\"重新计算各个区域的存活对象，进行垃圾回收和区域回收。\",\"一部分需要STW，但大部分是并发进行。\",\"复制（Evacuation）：\",\"这是垃圾收集的核心操作，涉及将存活对象从一个区域复制到另一个区域。\",\"主要在年轻代GC和混合GC中执行。\"]},\"143\":{\"h\":\"G1垃圾收集器的优势\",\"t\":[\"低停顿时间：通过分区和并发标记，G1在处理大堆内存时能有效控制垃圾收集的停顿时间。\",\"可预测性：G1可以根据用户设定的停顿时间目标自动调整其行为。\",\"适应性强：G1适用于多核处理器和大内存的环境，能高效管理和利用资源。\"]},\"144\":{\"h\":\"G1垃圾收集器的配置参数\",\"t\":[\"-XX:+UseG1GC：启用G1垃圾收集器。\",\"-XX:MaxGCPauseMillis=<N>：设置目标最大GC停顿时间（毫秒）。\",\"-XX:InitiatingHeapOccupancyPercent=<N>：设置在进行混合回收之前，老年代占用的堆内存百分比阈值。\",\"-XX:G1HeapRegionSize=<size>：设置每个Region的大小。\"]},\"145\":{\"h\":\"总结\",\"t\":[\"G1垃圾收集器通过分区管理、并发标记和混合回收，提供了一种平衡高吞吐量和低停顿时间的垃圾收集解决方案。它适用于现代大内存和多处理器的环境，能够自动调整行为以满足用户设定的停顿时间目标，具有高效、可预测的特点。\"]},\"146\":{\"h\":\"有了CMS，为什么还要引入G1？\",\"t\":[\"尽管CMS（Concurrent Mark-Sweep）垃圾收集器在降低垃圾收集停顿时间方面取得了显著成功，但它也存在一些局限性和缺点，这促使了G1垃圾收集器的引入。以下是引入G1垃圾收集器的主要原因：\"]},\"147\":{\"h\":\"CMS的局限性\",\"t\":[\"内存碎片化：\",\"CMS使用标记-清除算法，不会移动存活对象，因此容易导致堆内存碎片化。碎片化会导致分配大对象时频繁触发Full GC，进而导致长时间的停顿。\",\"Full GC停顿时间长：\",\"当CMS收集器无法获取足够的内存空间时，会退化为单线程的标记-整理（Mark-Compact）算法进行Full GC。这个过程会导致显著的停顿时间，尤其在大堆内存环境下。\",\"并发模式失效（Concurrent Mode Failure）：\",\"如果在CMS的并发阶段内没有足够的空闲内存，CMS会触发一次Full GC，导致长时间的应用停顿。这种情况被称为并发模式失效。\",\"调优复杂：\",\"CMS需要对许多参数进行调优（如启动阈值、线程数量等），以确保在不同工作负载下的良好表现。这增加了维护和管理的复杂性。\"]},\"148\":{\"h\":\"G1垃圾收集器的优势\",\"t\":[\"减少碎片化：\",\"G1采用了分区（Region）和标记-复制（Mark-Copy）算法，显著减少了内存碎片化问题。通过压缩阶段，可以整理内存，避免碎片化。\",\"可预测的停顿时间：\",\"G1引入了目标停顿时间设置（Pause Time Goals），允许用户通过参数-XX:MaxGCPauseMillis指定目标停顿时间。G1会动态调整垃圾收集过程，以尽量满足这个目标。\",\"自动调优：\",\"G1具有自适应调优功能，能够根据应用的运行状况自动调整垃圾收集的行为和策略，减少了手动调优的复杂性。\",\"分代式垃圾收集：\",\"G1通过混合回收（Mixed Collections）机制，在单次GC中同时处理年轻代和老年代的对象，提高了内存回收效率。\",\"并发与并行：\",\"G1除了支持并发标记外，还支持并行回收，充分利用多处理器的优势，减少垃圾收集的停顿时间。\",\"更好的大堆支持：\",\"G1设计之初即考虑了大内存环境，能够高效管理和回收大堆内存中的垃圾，适应现代应用的需求。\"]},\"149\":{\"h\":\"总结\",\"t\":[\"虽然CMS在降低停顿时间方面表现优秀，但其内存碎片化、Full GC停顿时间长和调优复杂等问题限制了其进一步的应用和发展。G1垃圾收集器通过分区管理、压缩回收、可预测停顿时间和自动调优等特性，提供了一个更加高效和灵活的垃圾收集解决方案，特别适用于大内存和多处理器的现代应用环境。G1的引入旨在克服CMS的局限性，为Java应用提供更好的性能和可预测性。\"]},\"150\":{\"h\":\"你们线上用的什么垃圾收集器？为什么要用它？\",\"t\":[\"选择合适的垃圾收集器取决于应用程序的需求、运行环境和性能目标。在生产环境中，常见的垃圾收集器有CMS、G1和ZGC。以下是一些大公司和常见应用场景中使用的垃圾收集器及其原因：\"]},\"151\":{\"h\":\"常见的垃圾收集器\",\"t\":[\"CMS（Concurrent Mark-Sweep）：\",\"使用场景：曾广泛用于响应时间要求高的应用，如Web服务器和交易系统。\",\"优点：降低了垃圾收集的停顿时间，适用于具有中等堆大小的应用。\",\"缺点：内存碎片化问题、Full GC停顿时间长、调优复杂。\",\"G1（Garbage First）：\",\"使用场景：现代化的Java应用，特别是大堆内存环境，如数据处理系统和大规模微服务架构。\",\"优点：可预测的停顿时间、减少内存碎片化、自动调优、适用于大堆内存。\",\"缺点：初期调优可能需要一定时间。\",\"ZGC（Z Garbage Collector）：\",\"使用场景：需要极低停顿时间的应用，如实时系统、大数据处理和金融系统。\",\"优点：极低停顿时间（通常在1-10毫秒范围内）、支持超大堆（数TB）、无需复杂调优。\",\"缺点：相对新，成熟度不如G1和CMS，但随着时间推移越来越成熟。\"]},\"152\":{\"h\":\"为什么选择某种垃圾收集器\"},\"153\":{\"h\":\"使用G1的理由\",\"t\":[\"可预测的低停顿时间：G1的设计目标之一就是提供可预测的低停顿时间，这对于需要保证响应时间的应用非常重要。\",\"适合大堆内存：G1通过分区管理和并发回收机制，能够高效地处理大堆内存中的垃圾。\",\"减少内存碎片：G1通过标记-复制和压缩回收，显著减少了内存碎片化问题。\",\"自动调优：G1具有自适应调优能力，可以根据运行时的表现自动调整垃圾收集策略，减少手动调优的复杂性。\"]},\"154\":{\"h\":\"使用ZGC的理由\",\"t\":[\"超低停顿时间：ZGC的设计目标是实现极低的停顿时间，通常在1-10毫秒范围内，非常适合对响应时间有严格要求的应用。\",\"支持超大堆：ZGC能够处理数TB的堆内存，适用于需要处理大量数据的应用场景。\",\"无需复杂调优：ZGC的自动管理和优化能力强，减少了对垃圾收集器的复杂调优需求。\"]},\"155\":{\"h\":\"大公司和常见应用中的选择\",\"t\":[\"大型互联网公司（如Google、Netflix）：常常使用G1或ZGC来处理大规模服务和数据处理系统，因为这些垃圾收集器能够在保持高吞吐量的同时提供可预测的低停顿时间。\",\"金融机构（如银行、证券交易所）：对停顿时间要求极高，往往选择ZGC来确保系统的实时性和低延迟。\",\"中小型Web应用：可能继续使用CMS或转向G1，特别是当需要平衡响应时间和吞吐量时。\"]},\"156\":{\"h\":\"总结\",\"t\":[\"在选择垃圾收集器时，关键是要根据应用的具体需求和运行环境来做出决策。如果需要低停顿时间和大堆内存支持，G1和ZGC是首选。G1适用于大多数现代应用，提供了可预测的低停顿时间和自动调优能力。ZGC适合需要极低停顿时间和处理超大堆内存的应用。最终的选择应根据应用的性能需求、堆内存大小和停顿时间要求来确定。\"]},\"157\":{\"h\":\"垃圾收集器应该如何选择？\",\"t\":[\"选择合适的垃圾收集器（GC）是确保Java应用程序性能和稳定性的关键。不同的GC适用于不同的应用场景和需求，以下是选择GC时需要考虑的几个关键因素和常见的垃圾收集器选项：\"]},\"158\":{\"h\":\"关键考虑因素\",\"t\":[\"停顿时间要求：\",\"低停顿时间：适用于对响应时间敏感的应用，如实时系统、交易系统、在线游戏等。\",\"高吞吐量：适用于批处理、后台任务等对响应时间不敏感的应用。\",\"堆内存大小：\",\"小到中等堆内存：几百MB到几GB。\",\"大堆内存：几十GB到几TB。\",\"并发线程数：\",\"多核处理器可以利用并行GC和并发GC。\",\"应用类型：\",\"低延迟应用：如金融交易、在线游戏。\",\"高吞吐量应用：如批处理、大数据处理。\"]},\"159\":{\"h\":\"常见垃圾收集器选项\",\"t\":[\"Serial GC：\",\"适用场景：单处理器或低并发应用、小堆内存。\",\"特点：简单、单线程、停顿时间较长，但适合内存使用较小且对GC停顿不敏感的应用。\",\"启用方式：-XX:+UseSerialGC\",\"Parallel GC（也称为Throughput GC）：\",\"适用场景：多处理器环境、大堆内存、高吞吐量应用。\",\"特点：多线程、侧重于高吞吐量，可能会有较长的停顿时间。\",\"启用方式：-XX:+UseParallelGC\",\"CMS（Concurrent Mark-Sweep）GC：\",\"适用场景：中等到大堆内存、对停顿时间敏感的应用。\",\"特点：并发标记和清理，减少停顿时间，但存在内存碎片化问题。\",\"启用方式：-XX:+UseConcMarkSweepGC\",\"G1（Garbage First）GC：\",\"适用场景：中等到大堆内存、需要可预测的低停顿时间。\",\"特点：分区管理、并发标记和压缩回收、可预测的停顿时间。\",\"启用方式：-XX:+UseG1GC\",\"关键参数：-XX:MaxGCPauseMillis=<N>（设置目标最大GC停顿时间）\",\"ZGC（Z Garbage Collector）：\",\"适用场景：非常大堆内存（数百GB到数TB）、需要极低停顿时间。\",\"特点：极低停顿时间（通常在1-10毫秒范围内）、支持超大堆内存、无需复杂调优。\",\"启用方式：-XX:+UseZGC\",\"Shenandoah GC（适用于OpenJDK）：\",\"适用场景：大堆内存、需要低停顿时间的应用。\",\"特点：并发压缩、低停顿时间。\",\"启用方式：-XX:+UseShenandoahGC\"]},\"160\":{\"h\":\"选择垃圾收集器的步骤\",\"t\":[\"评估应用需求：\",\"确定应用对停顿时间和吞吐量的要求。\",\"确定应用的堆内存大小。\",\"试验和测量：\",\"使用不同的GC选项运行应用，测量GC停顿时间、吞吐量和内存使用情况。\",\"使用JVM提供的工具（如JVisualVM、GC日志）监控和分析GC性能。\",\"调优参数：\",\"根据测量结果，调整GC参数以优化性能。\",\"例如，G1 GC可以通过调整-XX:MaxGCPauseMillis来优化停顿时间。\",\"考虑未来需求：\",\"考虑应用未来的增长和变化，选择能适应未来需求的GC。\"]},\"161\":{\"h\":\"总结\",\"t\":[\"选择合适的垃圾收集器是一个平衡应用需求、硬件资源和GC特性的过程。通过评估应用的停顿时间需求、堆内存大小和并发能力，结合实际测试和调优，可以选择最适合的垃圾收集器来优化Java应用的性能和稳定性。\"]},\"162\":{\"h\":\"对象一定分配在堆中吗？有没有了解逃逸分析技术？\",\"t\":[\"在Java中，对象的内存分配通常是在堆中进行的。然而，并非所有对象都必须分配在堆中。有些情况下，对象可以被分配在栈上或者通过逃逸分析技术进行优化。下面详细说明这些概念。\"]},\"163\":{\"h\":\"对象分配的基本概念\",\"t\":[\"堆内存（Heap Memory）：\",\"通常用于动态分配对象，生命周期不受方法调用结束的影响。\",\"GC（垃圾收集器）会负责回收堆内存中的对象。\",\"栈内存（Stack Memory）：\",\"栈用于存储局部变量和方法调用栈帧。\",\"栈内存的分配和释放由JVM自动管理，当方法调用结束时，相应的栈帧和局部变量会被释放。\"]},\"164\":{\"h\":\"逃逸分析（Escape Analysis）\",\"t\":[\"逃逸分析是一种编译时技术，用于确定对象的作用域，特别是确定对象是否会逃逸出方法的作用域。根据逃逸分析的结果，JVM可以进行一些优化，例如：\",\"栈上分配（Stack Allocation）：\",\"如果通过逃逸分析确定对象不会逃逸出当前方法，则对象可以在栈上分配而不是在堆上。这减少了GC的压力，因为栈上的对象在方法结束时自动释放。\",\"标量替换（Scalar Replacement）：\",\"如果对象不会逃逸并且可以分解为多个标量变量，编译器可以将对象的成员变量直接分配在栈上，而不分配整个对象。\",\"同步消除（Synchronization Elimination）：\",\"如果通过逃逸分析确定对象不会逃逸到多个线程中，JVM可以消除不必要的同步代码，以提高性能。\"]},\"165\":{\"h\":\"逃逸分析的应用示例\",\"t\":[\"假设有以下简单的Java方法：\",\"public class EscapeAnalysisExample { public void exampleMethod() { Point p = new Point(1, 2); // Use the point p } } class Point { int x; int y; Point(int x, int y) { this.x = x; this.y = y; } } \",\"在这个例子中，Point对象只在exampleMethod方法内部使用，没有逃逸出方法的作用域。因此，通过逃逸分析，JVM可能会优化，将Point对象分配在栈上而不是堆上。\"]},\"166\":{\"h\":\"JVM参数和逃逸分析\",\"t\":[\"JVM支持逃逸分析的参数包括：\",\"-XX:+DoEscapeAnalysis：启用逃逸分析（默认开启）。\",\"-XX:+EliminateAllocations：启用标量替换优化（需要逃逸分析）。\",\"-XX:+EliminateLocks：启用同步消除优化（需要逃逸分析）。\",\"这些参数可以在启动JVM时配置，例如：\",\"java -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:+EliminateLocks MyApplication \"]},\"167\":{\"h\":\"逃逸分析的优势\",\"t\":[\"性能提升：减少了堆内存的分配和垃圾收集，提高了程序的运行性能。\",\"降低GC压力：更多对象分配在栈上或优化掉，减少了GC的负担。\",\"减少锁开销：同步消除减少了不必要的锁开销，提高了并发性能。\"]},\"168\":{\"h\":\"总结\",\"t\":[\"虽然Java对象通常分配在堆中，但通过逃逸分析技术，JVM可以进行一系列优化，将某些对象分配在栈上或者进行标量替换，从而提升性能和减少GC的压力。这些优化技术使得Java在保持易用性的同时，也能在性能方面接近手动内存管理的编程语言。\"]},\"169\":{\"h\":\"逃逸分析中标量替换的工作原理是怎样的？\",\"t\":[\"标量替换（Scalar Replacement）是逃逸分析的一种优化技术。如果通过逃逸分析确定一个对象不会逃逸出方法的作用域，并且对象可以被分解为多个标量（如基本数据类型或其他不包含引用的变量），JVM编译器可以将对象的成员变量直接分配在栈上，而不分配整个对象。这种优化可以减少堆内存的分配和垃圾收集的压力，从而提升程序的运行性能。\"]},\"170\":{\"h\":\"标量替换的工作原理\",\"t\":[\"当一个对象在方法内部创建且使用时，编译器可以分析对象的使用情况。如果对象的所有字段都可以直接在局部变量中使用，那么编译器可以将对象的分配优化掉，只保留对象的字段作为局部变量。这些局部变量会在栈上分配，而不会在堆上创建对象。\"]},\"171\":{\"h\":\"示例代码\",\"t\":[\"以下是一个示例，展示了标量替换的概念：\"]},\"172\":{\"h\":\"原始代码\",\"t\":[\"public class ScalarReplacementExample { public void exampleMethod() { Point p = new Point(1, 2); int sum = p.x + p.y; System.out.println(sum); } class Point { int x; int y; Point(int x, int y) { this.x = x; this.y = y; } } public static void main(String[] args) { ScalarReplacementExample example = new ScalarReplacementExample(); example.exampleMethod(); } } \",\"在这个示例中，Point对象在exampleMethod方法中创建，并且只在该方法内部使用。通过标量替换优化，JVM可以将Point对象的成员变量直接分解为局部变量。\"]},\"173\":{\"h\":\"优化后的代码（标量替换效果）\",\"t\":[\"虽然这是JVM在底层进行的优化，但我们可以用手动优化的方式来展示结果：\",\"public class ScalarReplacementExample { public void exampleMethod() { // 优化：将 Point 对象的成员变量分解为局部变量 int x = 1; int y = 2; int sum = x + y; System.out.println(sum); } public static void main(String[] args) { ScalarReplacementExample example = new ScalarReplacementExample(); example.exampleMethod(); } } \",\"在这个优化后的版本中，Point对象的分配被消除了，x和y作为局部变量直接在栈上分配。这减少了堆内存分配和垃圾收集的开销。\"]},\"174\":{\"h\":\"JVM参数\",\"t\":[\"为了确保JVM进行标量替换优化，可以使用以下JVM参数：\",\"-XX:+DoEscapeAnalysis：启用逃逸分析（默认开启）。\",\"-XX:+EliminateAllocations：启用标量替换优化。\",\"-XX:+PrintEscapeAnalysis：打印逃逸分析的结果（用于调试）。\",\"例如，运行Java程序时可以使用以下命令：\",\"java -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:+PrintEscapeAnalysis ScalarReplacementExample \"]},\"175\":{\"h\":\"总结\",\"t\":[\"标量替换通过将对象的成员变量分解为局部变量并在栈上分配，避免了不必要的堆内存分配，从而提升了程序的性能。这个优化依赖于逃逸分析技术，确保对象不会逃逸出方法范围并且可以安全地进行替换。\"]},\"176\":{\"h\":\"引言\"},\"177\":{\"h\":\"什么是JVM?\",\"t\":[\"JVM，全称为Java虚拟机（Java Virtual Machine），是一个虚拟的计算机，它能够运行以字节码（bytecode）形式编写的Java程序。JVM是Java技术的核心部分，它使得Java具有跨平台特性，即“编写一次，运行在任何地方”（Write Once, Run Anywhere, WORA）。\"]},\"178\":{\"h\":\"JVM的主要功能\",\"t\":[\"加载代码：JVM从文件系统中加载Java字节码文件（.class文件），并将其转换成可以执行的机器码。\",\"内存管理：JVM负责分配和管理程序运行时所需的内存，包括堆（Heap）和栈（Stack）管理。\",\"执行代码：JVM将字节码解释或编译成本地机器码，然后执行这些代码。\",\"垃圾回收：JVM自动管理内存，通过垃圾回收机制回收不再使用的对象，防止内存泄漏。\",\"安全性管理：JVM有一套安全管理机制，能够在执行代码前对其进行验证，确保代码不会进行非法操作。\"]},\"179\":{\"h\":\"JVM的结构\",\"t\":[\"JVM的结构大致可以分为以下几个部分：\",\"类加载器子系统（Class Loader Subsystem）：负责加载.class文件，并将其转换为JVM可以使用的内部数据结构。\",\"运行时数据区（Runtime Data Area）：包括方法区（Method Area）、堆（Heap）、Java栈（Java Stack）、程序计数器（Program Counter Register）和本地方法栈（Native Method Stack）。\",\"执行引擎（Execution Engine）：负责执行字节码，包括解释器（Interpreter）和即时编译器（Just-In-Time Compiler，JIT）。\",\"本地方法接口（Native Interface）：使Java程序能够调用本地（非Java）库和函数。\",\"垃圾回收器（Garbage Collector）：负责自动回收不再使用的内存。\"]},\"180\":{\"h\":\"JVM的工作过程\",\"t\":[\"加载：通过类加载器将.class文件加载到内存中。\",\"链接：包括验证、准备和解析步骤，确保字节码文件的正确性和一致性。\",\"初始化：对类的静态变量和静态代码块进行初始化。\",\"执行：由执行引擎将字节码解释或编译为机器码并执行。\"]},\"181\":{\"h\":\"JVM的跨平台特性\",\"t\":[\"Java程序在不同平台上运行时，只需要有对应平台的JVM即可。JVM负责将字节码转换为对应平台的机器码，因此Java程序无需修改即可在不同操作系统上运行。\",\"总结来说，JVM是Java语言实现跨平台特性、内存管理、安全性等功能的关键组件。它通过加载、解释、执行Java字节码，使得Java程序能够在各种硬件和操作系统上稳定运行。\"]},\"182\":{\"h\":\"虚拟机执行\"},\"183\":{\"h\":\"能说一下类的生命周期吗？\",\"t\":[\"是的，一个类在Java虚拟机（JVM）中从加载到卸载整个生命周期包括以下七个阶段：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）。其中，验证、准备和解析三个阶段合称为连接（Linking）。以下是对每个阶段的详细解释：\"]},\"184\":{\"h\":\"1. 加载（Loading）\",\"t\":[\"描述：将类的字节码文件加载到内存中，并创建一个代表该类的Class对象。\",\"细节：JVM通过类加载器（ClassLoader）读取字节码文件（.class文件），将其转换为内存中的数据结构，并生成一个Class对象来表示该类。\"]},\"185\":{\"h\":\"2. 验证（Verification）\",\"t\":[\"描述：验证阶段主要是对字节码文件进行验证，确保其符合Java虚拟机规范。\",\"细节：这一阶段检查字节码的正确性，确保不会破坏Java语言的安全性和类型系统。例如，检查类的结构、操作码是否合法、访问控制是否正确等。\"]},\"186\":{\"h\":\"3. 准备（Preparation）\",\"t\":[\"描述：准备阶段为类的静态变量分配内存空间，并设置默认初始值。\",\"细节：在这一阶段，JVM为类变量分配内存，并初始化为默认值。例如，数值类型的变量初始化为0，引用类型初始化为null。这个阶段不会执行任何初始化代码。\"]},\"187\":{\"h\":\"4. 解析（Resolution）\",\"t\":[\"描述：解析阶段主要是将符号引用转换为直接引用。\",\"细节：符号引用是指在字节码中使用符号（如类名、方法名）来引用类、字段或方法。在解析阶段，JVM将这些符号引用转换为内存地址等直接引用。\"]},\"188\":{\"h\":\"5. 初始化（Initialization）\",\"t\":[\"描述：初始化阶段是类的主动使用阶段，会执行类构造器<clinit>()方法的过程。\",\"细节：<clinit>()方法是由编译器自动生成的类构造器，用于初始化静态变量和执行静态代码块。这个阶段是类加载的最后一步，确保类在使用前完成所有初始化工作。\"]},\"189\":{\"h\":\"6. 使用（Using）\",\"t\":[\"描述：在类被加载和初始化之后，就可以使用该类创建对象，调用类的方法等。\",\"细节：这一阶段类已经完全准备好，可以进行实例化、方法调用、字段访问等操作。这是应用程序的主要操作阶段。\"]},\"190\":{\"h\":\"7. 卸载（Unloading）\",\"t\":[\"描述：当一个类不再被引用，且没有任何活动的实例时，Java虚拟机会卸载该类。\",\"细节：JVM会在合适的时机通过垃圾回收机制回收不再使用的类的Class对象和相关资源。这个过程是自动管理的，程序员无法直接控制。\",\"示例\",\"public class MyClass { static { System.out.println(\\\"静态代码块执行\\\"); } static int staticVar = initializeStaticVar(); static int initializeStaticVar() { System.out.println(\\\"静态变量初始化\\\"); return 1; } public static void main(String[] args) { System.out.println(\\\"main方法执行\\\"); MyClass obj = new MyClass(); } } \",\"输出可能是：\",\"静态代码块执行 静态变量初始化 main方法执行 \",\"通过了解类的生命周期，我们可以更好地理解类的加载、初始化及其在内存中的管理，从而优化程序性能和内存使用。\"]},\"191\":{\"h\":\"类加载的过程知道吗？\",\"t\":[\"类加载的过程是Java虚拟机（JVM）将类的字节码文件（.class文件）加载到内存中的起点。这一过程包括以下三个主要步骤：\"]},\"192\":{\"h\":\"1. 获取二进制字节流\",\"t\":[\"通过类的全限定名（如com.example.MyClass）来获取定义此类的二进制字节流。这一步可以通过各种方式实现，如从文件系统、网络、数据库等来源获取字节流。\"]},\"193\":{\"h\":\"2. 转换为方法区的运行时数据结构\",\"t\":[\"将获取到的字节流所代表的静态存储结构（即.class文件内容）转换为方法区中的运行时数据结构。方法区是JVM中用于存储类结构信息的内存区域，包括常量池、字段和方法数据、方法代码等。\"]},\"194\":{\"h\":\"3. 创建Class对象\",\"t\":[\"在内存中生成一个代表这个类的java.lang.Class对象。这个Class对象将作为方法区中该类数据的访问入口，允许程序通过Class对象访问类的元数据和结构信息。\"]},\"195\":{\"h\":\"详细描述\",\"t\":[\"获取二进制字节流： JVM通过类加载器（ClassLoader）根据类的全限定名查找和读取相应的字节码文件。不同的类加载器可以通过不同的方式获取字节流，例如，Bootstrap ClassLoader从JRE的lib目录加载类，Application ClassLoader从应用的classpath加载类。\",\"转换为方法区的运行时数据结构： JVM将字节流解析成方法区的运行时数据结构。这些数据结构包括类的元数据（如类名、父类名、接口列表）、字段信息、方法信息、常量池等。《Java虚拟机规范》没有规定方法区的数据存储格式，这允许不同的JVM实现有自己的优化和设计。\",\"创建Class对象： JVM在堆内存中实例化一个java.lang.Class对象，用于表示和访问方法区中的类信息。每个加载的类在堆中都有一个对应的Class对象，这个对象提供了访问类元数据的接口，如通过反射机制获取类的方法和字段信息。\"]},\"196\":{\"h\":\"加载阶段结束后\",\"t\":[\"在加载阶段结束后，Java虚拟机外部的二进制字节流就按照虚拟机设定的格式存储在方法区中。方法区中的数据存储格式完全由虚拟机实现自行定义，《Java虚拟机规范》未规定此区域的具体数据结构。类型数据妥善安置在方法区之后，会在Java堆内存中实例化一个java.lang.Class类的对象，这个对象将作为程序访问方法区中的类型数据的外部接口。\"]},\"197\":{\"h\":\"小结\",\"t\":[\"加载阶段是JVM类加载机制的起点，它的主要任务是通过全限定名获取类的字节码文件，将字节码文件转换为方法区的运行时数据结构，并在堆内存中创建一个Class对象来表示该类。这个过程确保类的元数据和结构信息可以被程序访问和使用。\"]},\"198\":{\"h\":\"类加载器有哪些？\",\"t\":[\"Java中的类加载器（ClassLoader）负责将类文件加载到Java虚拟机中。主要的类加载器有以下几种：\"]},\"199\":{\"h\":\"1. 启动类加载器（Bootstrap ClassLoader）\",\"t\":[\"描述：负责加载核心Java类库，如java.lang.*、java.util.*等。这些类库通常位于<JAVA_HOME>/lib目录下。\",\"特点： \",\"是最顶层的类加载器，由C++语言实现，嵌入在JVM内部。\",\"不属于java.lang.ClassLoader的子类。\"]},\"200\":{\"h\":\"2. 扩展类加载器（Extension ClassLoader）\",\"t\":[\"描述：负责加载扩展库中的类，这些类通常位于<JAVA_HOME>/lib/ext目录或者由系统变量java.ext.dirs指定的目录中。\",\"特点： \",\"是java.lang.ClassLoader的子类，由Java实现。\",\"其父加载器是启动类加载器。\"]},\"201\":{\"h\":\"3. 应用程序类加载器（Application ClassLoader）\",\"t\":[\"描述：负责加载应用程序类路径（classpath）上的类。这些类通常是应用程序自定义的类。\",\"特点： \",\"是java.lang.ClassLoader的子类，由Java实现。\",\"其父加载器是扩展类加载器。\",\"是默认的类加载器，当你调用ClassLoader.getSystemClassLoader()时，通常返回这个类加载器。\"]},\"202\":{\"h\":\"4. 自定义类加载器（Custom ClassLoader）\",\"t\":[\"描述：由开发者根据需要自定义的类加载器，用于加载特定来源或特定方式的类。\",\"特点： \",\"需要继承java.lang.ClassLoader类并重写findClass方法。\",\"可以实现自己的类加载逻辑，比如从网络、数据库、加密文件等加载类。\"]},\"203\":{\"h\":\"类加载器的层次结构\",\"t\":[\"类加载器之间存在父子关系，形成树形层次结构。通常情况下，类加载器按照双亲委派模型（Parent Delegation Model）工作，即一个类加载请求会先委派给父类加载器处理，如果父类加载器无法加载该类，子加载器才会尝试加载。这一机制的好处是确保了核心Java类库的安全性和一致性。\"]},\"204\":{\"h\":\"示例代码\",\"t\":[\"下面是一个简单的自定义类加载器示例：\",\"import java.io.*; public class MyClassLoader extends ClassLoader { private String classPath; public MyClassLoader(String classPath) { this.classPath = classPath; } @Override protected Class<?> findClass(String name) throws ClassNotFoundException { byte[] classData = loadClassData(name); if (classData == null) { throw new ClassNotFoundException(); } return defineClass(name, classData, 0, classData.length); } private byte[] loadClassData(String className) { String fileName = classPath + className.replace('.', '/') + \\\".class\\\"; try (InputStream inputStream = new FileInputStream(fileName); ByteArrayOutputStream byteStream = new ByteArrayOutputStream()) { int nextValue = 0; while ((nextValue = inputStream.read()) != -1) { byteStream.write(nextValue); } return byteStream.toByteArray(); } catch (IOException e) { e.printStackTrace(); return null; } } public static void main(String[] args) throws Exception { MyClassLoader classLoader = new MyClassLoader(\\\"/path/to/classes/\\\"); Class<?> clazz = classLoader.loadClass(\\\"com.example.MyClass\\\"); Object obj = clazz.newInstance(); System.out.println(obj.getClass().getName()); } } \",\"在这个示例中，MyClassLoader是一个自定义类加载器，通过覆盖findClass方法实现从指定路径加载类文件。在使用时，创建MyClassLoader对象并指定类文件路径，然后通过loadClass方法加载类。\",\"通过理解和使用不同的类加载器，开发者可以控制类的加载行为，满足特定需求，如动态加载、热部署等。\"]},\"205\":{\"h\":\"什么是双亲委派机制？\",\"t\":[\"双亲委派机制（Parent Delegation Model）是Java类加载器的一种工作模式，它规定了类加载器在加载类时的顺序和方式。具体来说，类加载器在尝试加载一个类时，会先将请求委派给父类加载器，如果父类加载器无法加载该类，才会由自身进行加载。这一机制保证了Java核心类库的安全性和稳定性，避免了重复加载和冲突。下面是对双亲委派机制的详细解释：\"]},\"206\":{\"h\":\"工作原理\",\"t\":[\"当一个类加载器收到类加载请求时，按照以下步骤处理：\",\"检查是否已加载：检查当前类加载器是否已经加载过该类。如果已经加载，直接返回加载的类。\",\"委派给父加载器：如果当前类加载器尚未加载该类，将请求委派给父类加载器。\",\"父加载器处理：父类加载器接到请求后，重复步骤1和步骤2，逐级向上委派，直到引导类加载器（Bootstrap ClassLoader）。\",\"引导类加载器尝试加载：引导类加载器尝试加载核心Java类库（如java.lang.*、java.util.*）。\",\"无法加载，逐级返回：如果引导类加载器无法加载该类，返回给子加载器，由子加载器继续尝试加载。\",\"子加载器加载：如果父类加载器均无法加载该类，当前类加载器尝试自己加载该类。\",\"加载失败抛异常：如果当前类加载器仍无法加载该类，抛出ClassNotFoundException。\"]},\"207\":{\"h\":\"双亲委派机制的优点\",\"t\":[\"安全性：防止核心类库（如java.lang.Object）被自定义类加载器重复加载或篡改，确保JVM运行环境的安全和稳定。\",\"避免重复加载：通过委派机制，保证某个类只会被加载一次，从而避免了重复加载和内存浪费。\",\"确保一致性：在整个JVM中，某个类由同一个类加载器加载，保证了类的类型一致性。\",\"示例说明\",\"以下是一个示例，展示了双亲委派机制的工作流程：\",\"public class ParentDelegationExample { public static void main(String[] args) throws ClassNotFoundException { ClassLoader classLoader = ParentDelegationExample.class.getClassLoader(); System.out.println(\\\"Parent ClassLoader: \\\" + classLoader.getParent()); System.out.println(\\\"Grandparent ClassLoader: \\\" + classLoader.getParent().getParent()); } } \",\"输出\",\"Parent ClassLoader: sun.misc.Launcher$AppClassLoader@18b4aac2 Grandparent ClassLoader: sun.misc.Launcher$ExtClassLoader@1b6d3586 \",\"在上述代码中：\",\"应用程序类加载器（AppClassLoader）是ParentDelegationExample类的类加载器。\",\"AppClassLoader的父加载器是扩展类加载器（ExtClassLoader）。\",\"ExtClassLoader的父加载器是引导类加载器（Bootstrap ClassLoader），但由于Bootstrap ClassLoader是用本地代码实现的，所以显示为null。\",\"总结\",\"双亲委派机制是Java类加载器的核心机制，确保了类加载过程的安全性、一致性和高效性。通过逐级向上委派类加载请求，避免了重复加载和类冲突问题，确保了Java运行环境的稳定性。\"]},\"208\":{\"h\":\"为什么要用双亲委派机制？\",\"t\":[\"双亲委派机制是Java类加载机制的核心设计之一，它的出现主要有以下几个原因：\"]},\"209\":{\"h\":\"1. 确保类的唯一性和一致性\",\"t\":[\"双亲委派机制确保了在整个Java虚拟机中，某个类只会被加载一次。通过逐级向上委派类加载请求，当一个类加载器尝试加载一个类时，它会首先委派给父类加载器，直到到达顶层的引导类加载器。这样可以避免同一个类被多个类加载器加载导致的类型冲突，保证了类的唯一性和一致性。\"]},\"210\":{\"h\":\"2. 避免重复加载类\",\"t\":[\"双亲委派机制可以避免同一个类被多个类加载器重复加载，节省了内存空间，提高了系统性能。如果一个类已经被加载到内存中，其他类加载器再次加载同样的类时，会直接使用已加载的类，而不会重新加载。\"]},\"211\":{\"h\":\"3. 加载类的安全性\",\"t\":[\"双亲委派机制保证了核心类库由Java虚拟机的引导类加载器加载，而不是由应用程序的类加载器加载。这样可以防止用户通过自定义类库篡改核心类库，确保了Java运行环境的安全性和稳定性。\"]},\"212\":{\"h\":\"4. 统一类加载规则\",\"t\":[\"双亲委派机制定义了类加载器的委派规则，使得类加载过程更加统一和规范。这种统一的类加载规则使得Java平台的类加载行为更加可预测，降低了出现类加载相关问题的可能性，提高了系统的稳定性和可靠性。\"]},\"213\":{\"h\":\"5. 支持模块化开发和扩展性\",\"t\":[\"双亲委派机制支持模块化开发，开发者可以通过自定义类加载器加载特定的类，而不会影响核心类库和其他模块的正常运行。这种灵活的扩展机制使得Java系统可以轻松地进行功能扩展和模块化开发，提高了系统的可维护性和可扩展性。\",\"综上所述，双亲委派机制是Java类加载机制的重要设计，它通过确保类的唯一性和一致性、避免重复加载类、提高类加载安全性、统一类加载规则以及支持模块化开发和扩展性等方面，保证了Java平台的安全性、稳定性和可靠性。\"]},\"214\":{\"h\":\"如何破坏双亲委派机制？\",\"t\":[\"破坏双亲委派机制意味着绕过了Java类加载器的默认委派规则，直接使用自定义的类加载器加载类。这样做可能会导致类加载的混乱和冲突，降低系统的稳定性和安全性。以下是一些可能破坏双亲委派机制的方式：\"]},\"215\":{\"h\":\"1. 自定义类加载器\",\"t\":[\"通过编写自定义的类加载器，并在其中重写loadClass 方法，实现自己的加载逻辑，可以破坏双亲委派机制。自定义类加载器可以绕过父类加载器的委派，直接加载特定的类。\",\"以下是一个简单的代码示例，演示了如何通过自定义类加载器破坏双亲委派机制：\",\"// 自定义类加载器 public class CustomClassLoader extends ClassLoader { @Override public Class<?> loadClass(String name) throws ClassNotFoundException { // 自定义加载逻辑，绕过双亲委派机制 if (name.startsWith(\\\"java.\\\")) { // 对于Java核心类库，仍然委派给父类加载器 return super.loadClass(name); } // 加载自定义类 try { String fileName = name.replace(\\\".\\\", \\\"/\\\") + \\\".class\\\"; InputStream inputStream = getClass().getClassLoader().getResourceAsStream(fileName); if (inputStream == null) { // 如果资源不存在，则调用父类加载器加载 return super.loadClass(name); } byte[] bytes = new byte[inputStream.available()]; inputStream.read(bytes); return defineClass(name, bytes, 0, bytes.length); } catch (IOException e) { throw new ClassNotFoundException(name, e); } } // 测试方法 public static void main(String[] args) throws Exception { // 使用自定义类加载器加载类 ClassLoader customClassLoader = new CustomClassLoader(); Class<?> clazz = customClassLoader.loadClass(\\\"com.example.TestClass\\\"); // 创建类的实例 Object instance = clazz.newInstance(); // 调用类的方法 clazz.getMethod(\\\"sayHello\\\").invoke(instance); } } \",\"// 测试类 public class TestClass { public void sayHello() { System.out.println(\\\"Hello, I'm loaded by CustomClassLoader!\\\"); } } \",\"在这个示例中，我们定义了一个自定义的类加载器CustomClassLoader，重写了loadClass方法，实现了自己的加载逻辑。在加载类时，我们首先判断类名是否以\\\"java.\\\"开头，如果是则委派给父类加载器加载，否则我们自己加载该类。这样就绕过了双亲委派机制的默认规则。\",\"在测试方法中，我们使用自定义类加载器加载了一个TestClass类，并创建了它的实例，然后调用了它的sayHello方法。由于TestClass类是由自定义类加载器加载的，因此输出的信息是\\\"Hello, I'm loaded by CustomClassLoader!\\\"，而不是默认的委派加载器加载的信息。\"]},\"216\":{\"h\":\"2. 直接调用ClassLoader.loadClass方法\",\"t\":[\"在Java中，ClassLoader类提供了loadClass方法用于加载类，而且loadClass方法默认是受双亲委派机制控制的。但是，如果直接调用ClassLoader.loadClass方法，而不是通过ClassLoader的子类（如URLClassLoader）加载类，就可能绕过双亲委派机制。\"]},\"217\":{\"h\":\"3. 修改ClassLoader类的defineClass方法\",\"t\":[\"ClassLoader类的defineClass方法用于定义类并加载类的字节码。如果修改了ClassLoader类的defineClass方法，可能会绕过双亲委派机制，导致自定义的加载逻辑被执行。\"]},\"218\":{\"h\":\"4. OSGi等框架\",\"t\":[\"一些基于Java的模块化开发框架（如OSGi）提供了自己的类加载器实现，并且允许在同一个JVM中加载多个版本的相同类。这种机制与双亲委派机制有所不同，可能会破坏双亲委派机制对类的唯一性和一致性的要求。\"]},\"219\":{\"h\":\"5. 应用服务器（如Tomcat）的类加载策略\",\"t\":[\"一些Java应用服务器（如Tomcat）在实现中采用了自定义的类加载器策略，以支持应用程序的独立部署和隔离。这种情况下，可能会存在多个应用程序使用不同的类加载器加载相同的类，从而破坏了双亲委派机制。\",\"虽然以上方法可以破坏双亲委派机制，但开发者应该谨慎使用，因为这可能会导致类加载的混乱和冲突，降低系统的稳定性和安全性。在合适的情况下，可以根据具体需求采取适当的措施，但务必注意潜在的风险和影响。\"]},\"220\":{\"h\":\"6.Thread.currentThread().setContextClassLoader\",\"t\":[\"通过Thread.currentThread().setContextClassLoader方法可以设置当前线程的上下文类加载器，从而改变类加载的委派顺序，绕过双亲委派机制。这种方式可以在一定程度上实现自定义的类加载逻辑。\",\"以下是一个简单的示例代码，演示了如何使用setContextClassLoader方法绕过双亲委派机制：\",\"public class BypassClassLoader { public static void main(String[] args) throws Exception { // 创建一个自定义的类加载器 ClassLoader customClassLoader = new CustomClassLoader(); // 创建一个线程 Thread thread = new Thread(() -> { // 设置当前线程的上下文类加载器为自定义类加载器 Thread.currentThread().setContextClassLoader(customClassLoader); // 加载并使用TestClass类 try { Class<?> clazz = Thread.currentThread().getContextClassLoader().loadClass(\\\"com.example.TestClass\\\"); Object instance = clazz.newInstance(); clazz.getMethod(\\\"sayHello\\\").invoke(instance); } catch (ClassNotFoundException | IllegalAccessException | InstantiationException | NoSuchMethodException | InvocationTargetException e) { e.printStackTrace(); } }); // 启动线程 thread.start(); } } // 自定义类加载器 class CustomClassLoader extends ClassLoader { // 加载类的字节码（这里简化为返回一个固定的字节数组） private byte[] loadClassBytes() { // 这里可以根据实际需求加载类的字节码 return new byte[]{ /* 类的字节码数据 */ }; } @Override public Class<?> findClass(String name) throws ClassNotFoundException { if (\\\"com.example.TestClass\\\".equals(name)) { // 加载自定义类的字节码 byte[] bytes = loadClassBytes(); // 使用defineClass方法加载类到内存中 return defineClass(name, bytes, 0, bytes.length); } else { // 对于其他类，委派给父类加载器加载 return super.findClass(name); } } } // 测试类 class TestClass { public void sayHello() { System.out.println(\\\"Hello, I'm loaded by CustomClassLoader in a new Thread!\\\"); } } \",\"在这个示例中，我们创建了一个自定义的类加载器CustomClassLoader，然后创建了一个新的线程，并在该线程中设置了上下文类加载器为自定义类加载器。在新线程中，我们尝试加载了TestClass类，并调用了它的sayHello方法。由于设置了自定义的上下文类加载器，TestClass类会被自定义类加载器加载，而不是双亲委派机制下的默认加载流程。因此，输出的信息是\\\"Hello, I'm loaded by CustomClassLoader in a new Thread!\\\"。\"]},\"221\":{\"h\":\"历史上有哪几次双亲委派机制的破坏？\"},\"222\":{\"h\":\"第一次破坏\",\"t\":[\"在 Java JDK 1.2 之前，双亲委派机制还不存在。旧版本的 Java 中，类加载器的概念已经存在，但是由于技术限制，无法避免子类覆盖父类加载方法的可能性。为了向下兼容旧代码，JDK 1.2 引入了双亲委派模型，并在 java.lang.ClassLoader 中添加了一个新的 protected 方法 findClass()。这个方法的存在使得用户编写自己的类加载逻辑时更容易继承并重写这个方法，而不是直接重写 loadClass() 方法。\"]},\"223\":{\"h\":\"第二次破坏\",\"t\":[\"在 Java 的早期版本中，JDBC 是一个典型的例子。不同厂商提供了各自的 JDBC 实现，这些实现无法放在核心包中，只能被应用类加载器加载。但是，由于启动类加载器无法加载这些实现，因此引入了线程上下文类加载器的概念。线程上下文类加载器可以在运行时动态设置，用于加载特定线程上下文中所需的类。这样就允许了父类加载器向子类加载器发出加载请求，绕过了双亲委派模型的限制。\"]},\"224\":{\"h\":\"第三次破坏\",\"t\":[\"随着对程序动态性的追求，例如代码热替换和模块热部署，又一次破坏了双亲委派模型。OSGi 是一个典型的例子，它实现了模块化热部署，每个程序模块（称为 Bundle）都有自己的类加载器。当需要更换一个 Bundle 时，可以将 Bundle 和其对应的类加载器一起替换，从而实现了代码的热替换。在这种情况下，类加载器不再是双亲委派模型推荐的树状结构，而是更复杂的网状结构。\",\"总的来说，这些破坏都是为了解决特定的问题或实现特定的功能，但也引入了额外的复杂性。在实际开发中，我们需要根据具体情况权衡利弊，选择合适的加载策略和模型。\"]},\"225\":{\"h\":\"你觉得应该怎么实现一个热部署功能？\",\"t\":[\"实现热部署功能涉及到动态加载和卸载类，以及更新已加载类的实例。下面是一个简单的步骤来实现热部署功能：\"]},\"226\":{\"h\":\"1. 使用合适的类加载器\",\"t\":[\"为了支持热部署，需要使用自定义的类加载器来加载类。这个类加载器应该具有动态加载和卸载类的能力。通常情况下，可以使用 URLClassLoader 或者自定义的类加载器来实现这个功能。\"]},\"227\":{\"h\":\"2. 监视类文件的变化\",\"t\":[\"实现一个监视器，监视目标类文件的变化。当类文件被修改或者更新时，监视器应该能够检测到，并触发相应的热部署操作。\"]},\"228\":{\"h\":\"3. 动态加载新的类\",\"t\":[\"当监视器检测到类文件的变化时，使用自定义的类加载器动态加载新的类。可以使用 ClassLoader.defineClass 方法将类的字节码加载到内存中，并使用 Class.forName 方法加载类。\"]},\"229\":{\"h\":\"4. 更新已加载类的实例\",\"t\":[\"如果已经存在该类的实例，需要更新这些实例以反映新加载类的变化。这可能涉及到重新创建实例或者更新现有实例的状态。\"]},\"230\":{\"h\":\"5. 卸载旧的类\",\"t\":[\"在加载新的类之前，可能需要卸载旧的类以释放资源并避免内存泄漏。可以通过适当的方式销毁旧类的实例，并从类加载器的缓存中卸载旧的类。\"]},\"231\":{\"h\":\"6. 错误处理和回滚\",\"t\":[\"在实现热部署功能时，需要考虑到可能出现的错误情况，并实现相应的错误处理机制。如果出现了不可恢复的错误，可能需要回滚到之前的状态，以确保系统的稳定性和可靠性。\"]},\"232\":{\"h\":\"7. 测试和验证\",\"t\":[\"在部署热部署功能之前，需要进行充分的测试和验证，以确保功能的正确性和稳定性。特别是在生产环境中使用热部署功能时，需要格外小心，避免可能导致系统崩溃或者数据丢失的错误。\",\"综上所述，实现热部署功能需要考虑到多个方面，包括类加载器的选择、监视器的实现、动态加载和卸载类的操作、实例的更新、错误处理和回滚等。通过合理设计和实现，可以实现一个稳健和可靠的热部署功能，提高系统的灵活性和可维护性。\"]},\"233\":{\"h\":\"为什么自定义类加载器，有时是重写loadclass方法，有时是重写findClass方法，有时是重写defineClass方法？\",\"t\":[\"自定义类加载器时，有时候会重写 loadClass 方法，有时候会重写 findClass 方法，有时候会重写 defineClass 方法，这取决于不同的加载需求和加载策略。\",\"重写 loadClass 方法：\",\"当希望继承父类加载器的双亲委派行为时，通常会重写 loadClass 方法。在这种情况下，我们可以在 loadClass 方法中调用父类加载器的 loadClass 方法来委派加载类。这样做可以保持类加载的一致性和稳定性，符合双亲委派模型的设计原则。\",\"重写 findClass 方法：\",\"当希望完全掌控类的加载过程时，通常会重写 findClass 方法。在这种情况下，我们需要自己实现类的查找逻辑，通常是通过读取字节码文件并调用 defineClass 方法来加载类。重写 findClass 方法可以绕过双亲委派模型，直接由自定义类加载器加载类，适用于一些特定的加载需求，例如加载动态生成的类或者非标准位置的类。\",\"重写 defineClass 方法：\",\"当类的字节码已经在内存中，而不是从文件或网络中加载时，可能会直接重写 defineClass 方法。这种情况通常发生在自定义类加载器已经获取了类的字节码，并且希望将其加载到内存中时。重写 defineClass 方法可以直接加载类的字节码，而无需经过其他方法的中间过程。\",\"综上所述，选择重写哪个方法取决于具体的加载需求和加载策略。重写 loadClass 方法通常用于继承父类加载器的双亲委派行为，重写 findClass 方法通常用于完全掌控类的加载过程，而重写 defineClass 方法通常用于直接加载类的字节码。\"]},\"234\":{\"h\":\"Tomcat的类加载机制了解吗？\",\"t\":[\"Java 虚拟机内置的类加载器 BootstrapClassLoader、ExtClassLoader 和 AppClassLoader，以及 Tomcat 中的各个类加载器之间的关系：\",\"Tomcat采用了一种特殊的类加载器体系，以解决应用程序之间的类冲突和实现资源的共享。具体的类加载器如下：\",\"BootstrapClassLoader：这是Java虚拟机内置的类加载器，负责加载Java的核心类库，例如java.lang包、java.util包等。\",\"CommonClassLoader：Tomcat的公共类加载器，用于加载Tomcat本身的类库，比如serlvet-api.jar等。\",\"CatalinaClassLoader：作为Tomcat的Catalina容器的类加载器，主要负责加载Catalina容器相关的类库，例如Catalina.jar等。\",\"SharedClassLoader：这是Tomcat的共享类加载器，专门用于加载Tomcat的共享类库，例如Tomcat的JDBC驱动等。\",\"WebAppClassLoader：每个Web应用程序都有自己的独立的WebAppClassLoader，负责加载Web应用程序目录下的class文件。当WebAppClassLoader无法加载类时，它会将加载任务交给共享的CommonClassLoader。\",\"Tomcat在类加载机制上破坏了传统的双亲委派模型，以实现类的隔离和资源的共享。在默认的双亲委派模型下，如果多个应用程序共享同一个类加载器，那么只能加载其中一个版本的类库，而无法加载多个相同类名的不同版本，这可能导致应用程序之间的类冲突。为了解决这个问题，Tomcat提供了隔离的机制，为每个Web容器单独提供一个WebAppClassLoader类加载器。这样，每个Web应用程序都有独立的类加载器，可以加载自己的类和库，而不会与其他应用程序产生冲突。这种机制允许不同应用程序使用相同类名的不同版本，实现了类的隔离和资源的共享。\"]},\"235\":{\"h\":\"IO\"},\"236\":{\"h\":\"Java 中 IO 流分为几种?\",\"t\":[\"按照流的流向分，可以分为 输入流 和 输出流 \",\"InputStream / Reader : 所有的输入流的基类，前者是字节输入流，后者是字符输入流\",\"OutputStream / Writer : 所有输出流的基类，前者是字节输出流，后者是字符输出流\",\"按照操作单元划分，可以划分为 字节流 和 字符流\",\"按照流的角色划分为 节点流 和 处理流\"]},\"237\":{\"h\":\"既然有了字节流,为什么还要有字符流？\",\"t\":[\"字节流\",\"字节流则更适合处理二进制数据\",\"字节流以字节为单位进行输入输出，适用于处理二进制数据（例如图像、音频、视频等）或与底层设备进行通信时。字节流通常用于处理文件和网络连接中的数据传输。它们是处理数据的底层工具，提供了最基本的输入输出操作。\",\"字符流\",\"字符流更适合读取和写入文本文件\",\"字符流以字符为单位进行输入输出，适用于处理文本数据。字符流会自动处理字符编码和解码，而字节流则需要手动处理。这使得字符流在处理文本数据时更方便和高效，尤其是当涉及到国际化和本地化时、\",\"尽管字节流可以处理所有类型的数据，但为了更方便地处理文本数据，Java提供了字符流\"]},\"238\":{\"h\":\"BIO、NIO、AIO？\",\"t\":[\"BIO\",\"同步阻塞IO\",\"客户端有连接请求时服务器端就需要启动一个线程进行处理（可以使用连接池优化）\",\"JDK1.4之前的选择\",\"NIO\",\"同步非阻塞IO\",\"服务器端用一个线程处理多个连接，客户端发送的连接请求会注册到多路复用器上，多路复用器轮询到连接有IO请求就进行处理\",\"NIO工作原理\",\"应用程序（A）通过选择器（B）发起连接请求\",\"选择器（B）将通道（channel代表了服务端与客户端的连接）注册，使其成为监视对象，以便选择器可以监听多个通道的事件。\",\"当有新的连接请求到达时，选择器（B）会处理这个事件，并将新的通道（C）加入到已注册的通道列表（D）中，以备后续操作。\",\"选择器（B）不断监听通道列表（D）中通道的读写事件。\",\"当某个通道（E）有读或写事件时，选择器（B）会将该通道标记为就绪状态，并执行相应的读取或写入操作。\",\"读取或写入操作使用缓冲区（F）来处理数据，应用程序可以在缓冲区中读取或写入数据。\",\"AIO\",\"异步非阻塞IO\",\"Java 的 NIO 就是 Reactor\",\"当有事件触发时，服务器端得到通知，进行相应的处理，完成后才通知(回调)服务端程序启动线程去处理\",\"一般适用于连接数较多且连接时间较长的应用\"]},\"239\":{\"h\":\"JDK1.8新特性\"},\"240\":{\"h\":\"JDK1.8都有哪些新特性？\",\"t\":[\"接口的默认方法和静态方法 \",\"在Java 8中，接口可以包含默认方法和静态方法\",\"Lambda 表达式和函数式接口 \",\"Lambda 表达式本质上是一段匿名内部类，可以传递一段代码\",\"Lambda 允许把函数作为一个方法的参数（函数作为参数传递到方法中），使用 Lambda 表达式使代码更加简洁\",\"但是也不要滥用，否则会有可读性等问题\",\"《Effective Java》作者 Josh Bloch 建议使用 Lambda 表达式最好不要超过3行\",\"Stream API \",\"Stream API提供了一种更简洁、更易于并行处理数据集合的方式\",\"通过Stream API，我们可以对集合进行过滤、映射、排序、聚合等操作，提高了代码的可读性和简洁性\",\"新的日期和时间API \",\"Java 8引入了新的日期和时间API（java.time包），提供了更好的日期和时间处理方式\",\"新的API解决了旧的Date和Calendar类在处理日期和时间时的一些问题，并提供了更多的功能和灵活性\",\"Optional 类 \",\"Optional类是一个容器类，用于表示一个值可能存在或不存在\",\"通过Optional类，我们可以避免空指针异常，并更好地处理可能为空的值\"]},\"241\":{\"h\":\"Lambda 表达式了解多少？\",\"t\":[\"Lambda 表达式本质上是一段匿名内部类，也可以是一段可以传递的代码\",\"只有函数式接口（FunctionalInterface）才能缩写成 Lambda 表示式\"]},\"242\":{\"h\":\"Java8有哪些内置函数式接口？\",\"t\":[\"添加了 @FunctionalInterface 注解的接口 \",\"Comparator\",\"Runnable\",\"Callable\",\"Predicate\",\"Function\",\"Supplier\",\"Consumer\"]},\"243\":{\"h\":\"Optional了解吗？\",\"t\":[\"Optional 是用于防范 NullPointerException\",\"可以将 Optional 看做是包装对象（可能是 null , 也有可能非 null ）的容器\",\"当我们定义了 一个方法，这个方法返回的对象可能是空，也有可能非空的时候，我们就可以考虑用 Optional 来包装它，这也是在 Java 8 被推荐使用的做法\",\"Optional<String> optional = Optional.of(\\\"bam\\\"); optional.isPresent(); // true optional.get(); // \\\"bam\\\" optional.orElse(\\\"fallback\\\"); // \\\"bam\\\" optional.ifPresent((s) -> System.out.println(s.charAt(0))); \"]},\"244\":{\"h\":\"Stream 流用过吗？\",\"t\":[\"Stream 流，简单来说，使用 java.util.Stream 对一个包含一个或多个元素的集合做各种操作\",\"这些操作可能是 中间操作 亦或是 终端操作\",\"终端操作会返回一个结果，而中间操作会返回一个 Stream 流\",\"Stream流一般用于集合，Stream的常用操作有\",\" List<String> stringCollection = new ArrayList<>(); stringCollection.add(\\\"ddd2\\\"); stringCollection.add(\\\"aaa2\\\"); stringCollection.add(\\\"bbb1\\\"); stringCollection.add(\\\"aaa1\\\"); stringCollection.add(\\\"bbb3\\\"); stringCollection.add(\\\"ccc\\\"); stringCollection.add(\\\"bbb2\\\"); stringCollection.add(\\\"ddd1\\\"); \",\"Filter 过滤\",\"stringCollection .stream() .filter((s) -> s.startsWith(\\\"a\\\")) .forEach(System.out::println); \",\"Sorted 排序\",\" stringCollection .stream() .sorted() .filter((s) -> s.startsWith(\\\"a\\\")) .forEach(System.out::println); \",\"Map 转换\",\" stringCollection .stream() .map(String::toUpperCase) .sorted((a, b) -> b.compareTo(a)) .forEach(System.out::println); \",\"Match 匹配\",\"// 验证 list 中 string 是否有以 a 开头的, 匹配到第一个，即返回 true boolean anyStartsWithA = stringCollection .stream() .anyMatch((s) -> s.startsWith(\\\"a\\\")) boolean allStartsWithA = stringCollection .stream() .allMatch((s) -> s.startsWith(\\\"a\\\")); System.out.println(allStartsWithA); // false // 验证 list 中 string 是否都不是以 z 开头的, boolean noneStartsWithZ = stringCollection .stream() .noneMatch((s) -> s.startsWith(\\\"z\\\")) \",\"Count 计数\",\"// 先对 list 中字符串开头为 b 进行过滤，让后统计数量 long startsWithB = stringCollection .stream() .filter((s) -> s.startsWith(\\\"b\\\")) .count(); \",\"count 是一个终端操作，它能够统计 stream 流中的元素总数，返回值是 long类型\",\"Reduce归约\",\"Optional<String> reduced = stringCollection .stream() .sorted() .reduce((s1, s2) -> s1 + \\\"#\\\" + s2); \",\"Reduce 中文翻译为：减少、缩小。通过入参的 Function ，我们能够将 list归约成一个值。它的返回类型是 Optional 类型\",\"Stream的常用API\"]},\"245\":{\"h\":\"Java概述\"},\"246\":{\"h\":\"Java语言有哪些特点？\",\"t\":[\"面向对象 \",\"封装\",\"继承\",\"多态\",\"平台无关性\",\"支持多线程\",\"编译与解释并存\"]},\"247\":{\"h\":\"JVM、JDK 和 JRE 有什么区别？\",\"t\":[\"JVM\",\"Java Virtual Machine，Java虚拟机，Java程序运行在Java虚拟机上。针对不同 系统的实现（Windows，Linux，macOS）不同的JVM，因此Java语言可以实现跨平 台。\",\"JRE\",\"Java 运⾏时环境。它是运⾏已编译 Java 程序所需的所有内容的集合，包括Java 虚拟机（JVM），Java 类库，Java 命令和其他的⼀些基础构件。但是，它不能⽤于创建新程序。\",\"JDK\",\"Java Development Kit，它是功能⻬全的 Java SDK。它拥有 JRE 所拥有的⼀ 切，还有编译器（javac）和⼯具（如 javadoc 和 jdb）。它能够创建和编译程序。 简单来说，JDK包含JRE，JRE包含JVM。\"]},\"248\":{\"h\":\"说说什么是跨平台性？原理是什么?\",\"t\":[\"跨平台：一次编译，多操作系统运行\",\"实现原理：不同系统安装不同Java虚拟机\"]},\"249\":{\"h\":\"什么是字节码？采用字节码的好处是什么?\",\"t\":[\".class文件\",\"字节码能够被虚拟机识别，从而实现Java程序的跨平台性\",\"Java 程序从源代码到运行主要有三步 \",\"编译：.java ->.class\",\"解释：虚拟机执行Java字节码，.class -机器码\",\"执行 ：对应的操作系统执行二进制机器码\"]},\"250\":{\"h\":\"为什么说 Java 语言“编译与解释并存”？\",\"t\":[\"因为 Java 程序要经过先编译，后解释两个步骤 \",\"由 Java 编写的程序需要先经过编译步骤，生成字节码（ *.class 文件）\",\"这种字节码必须再经过JVM，解释成操作系统能识别的机器码，再由操作系统执行\"]},\"251\":{\"h\":\"其它\"},\"252\":{\"h\":\"说下什么是Java的SPI机制？\",\"t\":[\"Java的SPI（Service Provider Interface）机制是Java标准库提供的一种服务发现机制\",\"它允许第三方组件在不修改源代码的情况下，通过在Classpath中提供配置文件，向应用程序注入实现了特定接口的服务提供者\",\"SPI中的几个关键元素\",\"服务接口（Service Interface）： 定义了服务的契约，描述了服务提供者需要实现的接口或抽象类\",\"服务提供者（Service Provider）： 实现了服务接口的具体类，并通过配置文件等方式注册到SPI框架中\",\"服务提供者配置文件（Service Provider Configuration File）： 是一种元数据文件，通常位于META-INF/services/目录下，文件名为服务接口的全限定名。该文件包含了服务接口的实现类的全限定名，每个实现类占据一行\",\"服务加载器（Service Loader）： 是用于加载和实例化服务提供者的API。它在运行时查找并加载META-INF/services/目录下的配置文件，并根据配置文件中指定的实现类实例化相应的对象\",\"SPI机制的工作原理如下\",\"定义服务接口\",\"首先，应用程序定义一个接口，这个接口是服务的契约，规定了需要提供的功能或扩展点\",\"public interface HelloService { void sayHello(); } \",\"编写服务提供者\",\"接着，编写服务提供者，实现服务接口，并提供了具体的功能实现\",\"public class HelloServiceImpl implements HelloService { @Override public void sayHello() { System.out.println(\\\"Hello from HelloServiceImpl!\\\"); } } \",\"编写服务提供者配置文件\",\"每个服务提供者将自己的实现类配置到一个特定的配置文件中，该文件位于 META-INF/services/ 目录下，以接口的全限定名命名\",\"com.example.service.HelloServiceImpl com.example.service.HelloServiceImpl2 \",\"服务加载\",\"在应用程序运行时，Java的SPI机制会使用服务加载器加载这些配置文件，并根据文件中指定的实现类，实例化对应的服务提供者对象\",\"ServiceLoader<HelloService> loader =ServiceLoader.load(HelloService.class) \",\"服务使用\",\"ServiceLoader<HelloService> loader =ServiceLoader.load(HelloService.class) for (HelloService service : loader) { service.sayHello(); } \",\"SPI机制的优势\",\"解耦了服务的实现和调用方\",\"应用程序可以在不修改源代码的情况下，动态地替换、扩展或定制某个功能或组件的实现\",\"SPI机制的应用场景\",\"数据库驱动、日志框架、插件系统等\"]},\"253\":{\"h\":\"反射\"},\"254\":{\"h\":\"什么是反射？\",\"t\":[\"new 对象 \",\"创建对象实例的方式\",\"在编译时候就确定了类型信息\",\"反射 \",\"在运行时动态地获取类信息、创建类实例、调用类方法这时候就要用到反射\",\"通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性\",\"反射相关类 \",\"Class\",\"Method\",\"Field\",\"Constructor\"]},\"255\":{\"h\":\"反射的应用场景？\",\"t\":[\"Spring/Spring Boot、MyBatis 等等框架中都大量使用了反射机制\",\"Spring里的很多注解 ，它真正的功能实现就是利用反射 \",\"@Component\",\"@Value\"]},\"256\":{\"h\":\"反射的实现原理\",\"t\":[\"基于Java虚拟机（JVM）的类加载机制和类对象模型\",\"在Java中，每个类都有一个对应的Class对象，该对象包含了类的名称、字段、方法等信息\",\"通过反射，我们可以获取到Class对象信息，并在运行时动态地操作类和对象\"]},\"257\":{\"h\":\"基础语法\"},\"258\":{\"h\":\"Java有哪些数据类型？\",\"t\":[\"基本数据类型\",\"数值型 \",\"整数类型（byte、short、int、long）\",\"浮点类型（float、double）\",\"字符型（char）\",\"布尔型（boolean）\",\"基本类型\",\"位数\",\"字节\",\"默认值\",\"最小值\",\"最大值\",\"int\",\"32\",\"4\",\"0\",\"-2^31\",\"2^31-1\",\"short\",\"16\",\"2\",\"0\",\"-2^15\",\"2^15-1\",\"long\",\"64\",\"8\",\"0L\",\"-2^63\",\"2^63-1\",\"byte\",\"8\",\"1\",\"0\",\"-128\",\"127\",\"char\",\"16\",\"2\",\"'\\\\u0000'\",\"'\\\\u0000'\",\"'\\\\uffff'\",\"float\",\"32\",\"4\",\"0.0f\",\"1.4E-45\",\"3.4028235E38\",\"double\",\"64\",\"8\",\"0.0d\",\"4.9E-324\",\"1.7976931348623157E308\",\"boolean\",\"1\",\"false\",\"引用数据类型\",\"类（class）\",\"接口（interface）\",\"数组([])\"]},\"259\":{\"h\":\"什么是自动类型转换、强制类型转换？\",\"t\":[\"自动类型转换：把一个表数范围小的数值或变量直接赋给另一个数范围大的变量时\",\"强制类型转换：反之，需要强制转换\"]},\"260\":{\"h\":\"什么是自动拆箱/封箱？\",\"t\":[\"装箱 ：将基本类型用它们对应的引用类型包装起来\",\"拆箱 ：将包装类型转换为基本数据类型\"]},\"261\":{\"h\":\"&和&&有什么区别？\",\"t\":[\"&：短路与\",\"&&：逻辑与\"]},\"262\":{\"h\":\"switch 是否能作用在 byte/long/String上？\",\"t\":[\"Java5 以前 switch(expr)中，expr 只能是 byte、short、char、int\",\"从 Java 5 开始，Java 中引入了枚举类型， expr 也可以是 enum 类型\",\"从 Java 7 开始，expr还可以是字符串(String)，但是长整型(long)在目前所有的版本中都是不可以的\"]},\"263\":{\"h\":\"break ,continue ,return 的区别及作用？\",\"t\":[\"break 跳出整个循环，不再执行循环( 结束当前的循环体 )\",\"continue 跳出本次循环，继续执行下次循环( 结束正在执行的循环 进入下一个循环条件 )\",\"return 程序返回，不再执行下面的代码( 结束当前的方法 直接返回 )\"]},\"264\":{\"h\":\"用最有效率的方法计算2乘以8？\",\"t\":[\"2 << 3。位运算，数字的二进制位左移三位相当于乘以2的三次方。\"]},\"265\":{\"h\":\"说说自增自减运算？\",\"t\":[\"++和--运算符可以放在变量之前，也可以放在变量之后\",\"运算符放在变量之前时(前缀)，先自增/减，再赋值\",\"当运算符放在变量之后时(后缀)，先赋值，再自增/减\"]},\"266\":{\"h\":\"常用类\"},\"267\":{\"h\":\"String 是 Java 基本数据类型吗？可以被继承吗？\",\"t\":[\"String是Java基本数据类型吗？\",\"不是，引用数据类型\",\"String 类可以继承吗?\",\"不行。String类在Java中被声明为final类，这意味着它不能被继承\",\"这样设计的原因\",\"字符串的不可变性\",\"String类的不可变性使得它可以被安全地用于多线程环境下，不会出现线程安全问题\",\"任何对 String 对象的操作（如拼接、替换等）都会返回一个新的 String 对象，而不会修改原始对象的值\",\"字符串常量池的优化\",\"由于字符串是不可变的，Java可以对字符串进行缓存和共享，以提高性能和节省内存\",\"这就是通过字符串常量池来实现的，它存储了所有字符串字面量的唯一实例\",\"安全性和可靠性\",\"String类的不可变性使得它在安全性和可靠性方面更加可靠。例如，它可以被用作Map的键，因为它的哈希值是固定的\"]},\"268\":{\"h\":\"String和StringBuilder、StringBuffer？\",\"t\":[\"类名\",\"可变性\",\"线程安全性\",\"性能\",\"String\",\"不可变\",\"线程安全\",\"低\",\"StringBuffer\",\"可变\",\"线程安全\",\"低\",\"StringBuilder\",\"可变\",\"非线程安全\",\"高\",\"String类 \",\"String是不可变的，使用 private final char value[] 来存储字符串，一旦创建就不能修改其值 \",\"jdk11使用byte[]存储字符串\",\"任何对String的修改都会创建一个新的String对象\",\"String类是线程安全的，因为它的不可变性保证了多个线程可以安全地共享String对象\",\"由于不可变性的特性，对于频繁的字符串拼接操作，会产生大量的临时对象，影响性能\",\"StringBuffer类 \",\"StringBuffer是可变的，使用 char value[] 存储字符串，它的值可以被修改\",\"为了保证线程安全性，StringBuffer的方法都使用synchronized关键字进行同步，在多线程环境下，使用StringBuffer可以保证线程安全\",\"由于同步的开销，StringBuffer的性能相对较低\",\"StringBuilder类 \",\"StringBuilder是StringBuffer的非线程安全版本，它的方法没有使用synchronized关键字进行同步\",\"在单线程环境下，使用StringBuilder可以获得更好的性能\",\"在多线程环境下使用StringBuilder，需要自行保证线程安全\",\"使用建议 \",\"操作的数据量较小，可以使用String类\",\"多线程环境下操作大量的数据，需要保证线程安全，可以使用StringBuffer类\",\"单线程环境下操作大量的数据，可以使用StringBuilder类以，性能更好\"]},\"269\":{\"h\":\"String str1 = new String(\\\"abc\\\")和String str2 = \\\"abc\\\" 和 区别？\",\"t\":[\"对象创建过程 \",\"两个语句都会去字符串常量池中检查是否已经存在 “abc”，如果有则直接使用，如果没有则会在常量池中创建 “abc” 对象\",\"String str1 = new String(\\\"abc\\\") 还会通过 new String() 在堆里创建一个\\\"abc\\\" 字符串对象实例\",\"String s = new String(\\\"abc\\\")创建了几个对象？ \",\"一个或两个 \",\"如果字符串常量池已经有“abc”，则是一个；否则，两个\"]},\"270\":{\"h\":\"String不是不可变类吗？字符串拼接是如何实现的？\",\"t\":[\"String的确是不可变的，“+”的拼接操作，其实是会生成新的对象\",\"在jdk1.8之前，那么会生成多个中间对象 \",\"a和b初始化时位于字符串常量池，a+b拼接后的对象位于堆中。经过拼接新生成了String对象。如果拼接多次，那么会生成多个中间对象\",\"在Java8时JDK对“+”号拼接会编译成StringBuilder的append方法\"]},\"271\":{\"h\":\"intern方法有什么作用？\",\"t\":[\"如果当前字符串内容存在于字符串常量池（即equals()方法为true，也就是内容一样），直接返回字符串常量池中的字符串\",\"否则，将此String对象添加到池中，并返回String对象的引用\"]},\"272\":{\"h\":\"Integer a= 127，Integer b = 127；Integer c= 128，Integer d =128；相等吗?\",\"t\":[\"是a和b相等，c和d不相等 \",\"Integer a= 127这种赋值，是用到了Integer自动装箱的机制。自动装箱的时候会去缓存池里取Integer对象，没有取到才会创建新的对象\",\"如果整型字面量的值在-128到127之间，那么自动装箱时不会new新的Integer对象，而是直接引用缓存池中的Integer对象，超过范围 a1==b1的结果是false\",\"什么是Integer缓存？ \",\"因为根据实践发现大部分的数据操作都集中在值比较小的范围，因此 Integer 搞了个缓存池，默认范围是 -128 到 127，可以根据通过设置 JVM-XX:AutoBoxCacheMax=来修改缓存的最大值，最小值改不了\",\"实现的原理是int 在自动装箱的时候会调用Integer.valueOf，进而用到了IntegerCache\",\"IntegerCache是一个静态内部类， 在静态块中会初始化好缓存值\"]},\"273\":{\"h\":\"String怎么转成Integer的？原理？\",\"t\":[\"方法\",\"Integer.parseInt(String s)\",\"Integer.valueOf(String s)\",\"原理\",\"最终都调用parseInt(String s, int radix) 方法\"]},\"274\":{\"h\":\"Object 类的常见方法?\",\"t\":[\"对象比较 \",\"hashCode()\",\"equals(Object obj)\",\"对象拷贝 \",\"clone()\",\"对象转字符串 \",\"toString()\",\"多线程调度 \",\"wait()\",\"wait(long timeout)\",\"wait(long timeout,int nanos)\",\"notify()\",\"notifyAll()\",\"反射 \",\"getClass()\",\"垃圾回收 \",\"finalize\"]},\"275\":{\"h\":\"序列化\"},\"276\":{\"h\":\"什么是序列化？什么是反序列化？\",\"t\":[\"序列化 \",\"把Java对象转为二进制流，方便存储和传输\",\"反序列化 \",\"把二进制流恢复成对象\",\"Serializable接口有什么用？ \",\"用于标识类可以被序列化\",\"实现Serializable接口的类可以将对象转换为字节流进行传输和存储，实现数据的持久化和 跨平台的数据交换\",\"serialVersionUID 又有什么用 \",\"版本控制 \",\"当一个类被序列化后，如果后续对该类进行了修改，例如添加、删除或修改了类的属性、方法等，那么序列化和反序列化时可能会出现版本不一致的问题。为了避免这种问题，可以在类中显式地定义serialVersionUID字段，并确保在类的修改后，serialVersionUID的值保持不变。当反序列化时，会比较序列化类的版本号和当前类的版本号是否一致，如果不一致，则会抛出InvalidClassException异常\",\"兼容性 \",\"当一个类的实例被序列化后，如果在后续的版本中对该类进行了修改，但是仍然希望能够反序列化之前的序列化数据，那么可以通过显式地指定serialVersionUID来保持兼容性。如果新版本的类和旧版本的类具有相同的serialVersionUID，那么即使类的结构发生了变化，仍然可以成功反序列化之前的序列化数据\",\"Java 序列化不包含静态变量 \",\"Java序列化只会保存对象的非静态成员变量，不包含静态变量\",\"静态变量属于类的状态信息，在序列化时不需要保存\",\"如果有些变量不想序列化，怎么办？ \",\"使用 transient 关键字修饰\",\"transient 关键字的作用 \",\"阻止实例中那些用此关键字修饰的的变量序列化\",\"当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复\",\"transient 只能修饰变量，不能修饰类和方法\"]},\"277\":{\"h\":\"说说有哪些常见的序列化方式？\",\"t\":[\"Java对象流序列化 \",\"Java对象流序列化是Java标准库提供的一种序列化方式\",\"通过实现Serializable接口和Externalizable接口来实现对象的序列化和反序列化\",\"Java序列化可以将对象序列化为字节流，也可以将对象序列化为JSON、XML等格式\",\"JSON序列化 \",\"是一种轻量级的数据交换格式，常用于Web应用中\",\"Java中可以使用第三方库，如Jackson、Gson等，将对象序列化为JSON格式，也可以将JSON格式的数据反序列化为Java对象\",\"XML序列化 \",\"XML（Extensible Markup Language）是一种标记语言，常用于Web应用中\",\"Java中可以使用第三方库，如JAXB、XStream等，将对象序列化为XML格式，也可以将XML格式的数据反序列化为Java对象\",\"Protobuf序列化 \",\"Protobuf（Protocol Buffers）是Google开发的一种高效的序列化协议\",\"可以将结构化的数据序列化为紧凑的二进制格式\",\"Java中可以使用Google提供的protobuf-java库，将对象序列化为Protobuf格式，也可以将Protobuf格式的数据反序列化为Java对象\",\"Hessian序列化 \",\"Hessian是一种基于HTTP的轻量级二进制序列化协议\",\"可以将Java对象序列化为二进制格式，并通过HTTP协议进行传输\",\"Java中可以使用第三方库，如Hessian、Dubbo等，将对象序列化为Hessian格式，也可以将Hessian格式\\n的数据反序列化为Java对象\"]},\"278\":{\"h\":\"异常处理\"},\"279\":{\"h\":\"Java 中异常层级结构?\",\"t\":[\"Throwable \",\"Error \",\"内部错误，是程序无法处理的，比如虚拟机异常\",\"Exception \",\"CheckedException \",\"受检异常：编译器会强制检查并要求处理的异常\",\"RuntimeException \",\"运行时异常：程序运行中出现异常，比如我们熟悉的空指针、数组下标越界等等\",\"Exception\"]},\"280\":{\"h\":\"异常的处理机制？\",\"t\":[\"抛出异常 \",\"throw\",\"throws\",\"系统自动抛异常\",\"捕获异常 \",\"try catch\"]},\"281\":{\"h\":\"finally一定会执行吗？\",\"t\":[\"可能不会执行的情况\",\"程序还没有进入try语句块就因为异常导致程序终止\",\"在try块中调用了System.exit()方法：System.exit()方法会终止Java虚拟机的运行，导致程序直接退出，此时finally块中的代码不会执行\",\"在try块中发生了死循环或无限递归：如果try块中的代码导致了无限循环或无限递归，程序将无法继续执行，finally块中的代码也无法执行\",\"在try块中发生了线程死锁：如果try块中的代码导致了线程死锁，程序将无法继续执行，finally块中的代码也无法执行\"]},\"282\":{\"h\":\"三道经典异常处理代码题\",\"t\":[\"题目1：finally中正常执行（执行顺序：先finally，再catch中return）\",\"public static void main(String[] args) { System.out.println(test()); } public static int test() { try { return 1; } catch (Exception e) { return 2; } finally { System.out.print(\\\"3\\\"); } } \",\"执行结果：31\",\"解析：try、catch。finally 的基础用法，在 return 前会先执行 finally 语句块，所以是先输出 finally 里的 3，再输出 return 的 1\",\"题目2：finally中return（按finally中return的为准）\",\"public static void main(String[] args) { System.out.println(test()); } public static int test() { try { return 2; } finally { return 3; } } \",\"执行结果：3\",\"解析：try 返回前先执行 finally，结果 finally 里不按套路出牌，直接 return 了，自然也就走不到 try 里面的 return 了\",\"题目3：finally中修改try中return的值（修改是无效的）\",\"public static void main(String[] args) { System.out.println(test()); } public static int test() { int i = 0; try { i = 2; return i; } finally { i = 3; } } \",\"执行结果：2\",\"在执行 finally 之前，JVM 会先将 i 的结果暂存起来，然后 finally 执行完毕后，会返回之前暂存的结果，而不是返回 i，所以即使 i 已经被修改为 3，最终返回的还是之前暂存起来的结果 2\"]},\"283\":{\"h\":\"泛型\"},\"284\":{\"h\":\"什么是泛型？\",\"t\":[\"用于在编译时期提供类型安全的参数化类型 \",\"Java泛型是Java 5引入的一个特性\",\"通过使用泛型，可以在编写代码时指定类、接口或方法的参数和返回值的类型，从而增加代码的可读性和安全性\"]},\"285\":{\"h\":\"泛型的使用方法？\",\"t\":[\"泛型类\",\"public class ClassName <T> \",\"泛型接口\",\"public interface InterfaceName <T> \",\"泛型方法\",\"public static <T> ReturnType functionName \",\"public <T> ReturnType functionName(T arg) \"]},\"286\":{\"h\":\"泛型常用的通配符有哪些？\",\"t\":[\"?表示不确定的 java 类型\",\"T(type)表示具体的一个 java 类型\",\"K V (key value) 分别代表 java 键值中的 Key Value\",\"E (element) 代表 Element\"]},\"287\":{\"h\":\"什么是泛型擦除？\",\"t\":[\"泛型主要是为了提供编译时类型检查，而在运行时，泛型信息会被擦除，这就是泛型擦除\",\"优点：提高了代码的运行效率和与旧版本 Java 的兼容性（JDK5之前是没有泛型 ）\",\"缺点：在运行时获取泛型类型信息，以及无法使用基本类型作为泛型参数等\"]},\"288\":{\"h\":\"注解\"},\"289\":{\"h\":\"说一下你对注解的理解？\",\"t\":[\"Java注解本质上是一个标记\",\"注解可以标记在类上、方法上、属性上等，标记自身也可以设置一些值\",\"有了标记之后，我们就可以在编译或者运行阶段去识别这些标记，然后搞一些事情，这就是注解的用处\",\"AOP，使用注解作为切点就是运行期注解的应用\",\"lombok，就是注解在编译期的运行\",\"注解生命周期\",\"RetentionPolicy.SOURCE\",\"给编译器用的，不会写入 class 文件\",\"@Target(ElementType.METHOD) @Retention(RetentionPolicy.SOURCE) public @interface Override { } \",\"RetentionPolicy.CLASS\",\"会写入 class 文件，在类加载阶段丢弃，也就是运行的时候就没这个信息了\",\"没找到 \",\"RetentionPolicy.RUNTIME\",\"会写入 class 文件，永久保存，可以通过反射获取注解信息\",\"@Target({ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.PARAMETER, ElementType.FIELD, ElementType.ANNOTATION_TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface Autowired { /** * Declares whether the annotated dependency is required. * <p>Defaults to {@code true}. */ boolean required() default true; } \"]},\"290\":{\"h\":\"集合基础\"},\"291\":{\"h\":\"Java中实现Map接口的有哪些类？\",\"t\":[\"HashMap：基于哈希表实现的Map，无序，允许键和值为null。\",\"LinkedHashMap：基于哈希表和双向链表实现的Map，保持插入顺序或访问顺序。\",\"TreeMap：基于红黑树实现的有序Map，按照键的自然顺序或自定义顺序进行排序。\",\"Hashtable：基于哈希表实现的Map，线程安全，不允许键和值为null。\",\"ConcurrentHashMap：基于哈希表实现的线程安全的Map，支持高并发操作\"]},\"292\":{\"h\":\"遍历HashMap的几种方法？\",\"t\":[\"使用迭代器遍历\",\"使用for-each循环遍历键集合或值集合\",\"使用for-each循环遍历键值对\",\"使用Java 8的Stream API遍历\"]},\"293\":{\"h\":\"面向对象\"},\"294\":{\"h\":\"⾯向对象和⾯向过程的区别?\",\"t\":[\"⾯向过程\",\"面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候再一个一个的一次调用就可以。\",\"⾯向对象\",\"面向对象，把构成问题的事务分解成各个对象，而建立对象的目的也不是为了完成一个个步骤，而是为了描述某个事件在解决整个问题的过程所发生的行为。 目的是为了写出通用的代码，加强代码的重用，屏蔽差异性。\"]},\"295\":{\"h\":\"面向对象有哪些特性?\",\"t\":[\"封装 \",\"封装把⼀个对象的属性私有化，同时提供⼀些可以被外界访问的属性的⽅法\",\"继承 \",\"继承是使⽤已存在的类的定义作为基础创建新的类，新类的定义可以增加新的属性或新的方法，也可以继承父类的属性和方法。通过继承可以很方便地进行代码复用\",\"多态 \",\"所谓多态就是指程序中定义的引⽤变量所指向的具体类型和通过该引⽤变量发出的⽅法调⽤在编程时并不确定，⽽是在程序运⾏期间才确定\",\"即⼀个引⽤变量到底会指向哪个类的实例对象，该引⽤变量发出的⽅法调⽤到底是哪个类中实现的⽅法，必须在由程序运⾏期间才能决定\",\"在 Java 中有两种形式可以实现多态：继承（多个⼦类对同⼀⽅法的重写）和接⼝（实现接⼝并覆盖接⼝中同⼀⽅法）\"]},\"296\":{\"h\":\"重载（overload）和重写（override）的区别？\",\"t\":[\"方法重载和方法重写都是实现多态性的方式\",\"区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性\",\"方法重载\",\"方法名相同，形参不同（参数个数、参数类型、参数顺序满足任一）则视为重载；\",\"与返回值和修饰符无关\",\"调用方法不同，与异常类型更没关系\",\"发生在同一个类中\",\"方法重写\",\"方法名相同，形参相同\",\"基本数据类型相同，若为引用数据类型则返回值为被重写方法的返回值或是其子类\",\"重写方法不能抛出范围更大的受控异常（父类不希望子类出现更多的异常）\",\"重写方法的访问权限可以更广（子类可以扩大方法的访问范围）\",\"发生在具有继承关系的父子类中\"]},\"297\":{\"h\":\"访问修饰符public、private、protected、以及不写（默认）时的 区别?\",\"t\":[\"default (即默认，什么也不写） \",\"在同一包内可见，不使用任何修饰符。可以修饰在类、接口、变量、方法。\",\"private \",\"在同一类内可见。可以修饰变量、方法。\",\"注意：不能修饰外部类\",\"public \",\"对所有类可见。可以修饰类、接口、变量、方法\",\"protected \",\"对同一包内的类和所有子类可见。可以修饰变量、方法。\",\"注意：不能修饰外部类\"]},\"298\":{\"h\":\"this关键字有什么作用？\",\"t\":[\"指向对象本身的一个指针\",\"this的用法在Java中大体可以分为3种 \",\"普通的直接引用，this相当于是指向当前对象本身\",\"形参与成员变量名字重名，用this来区分\",\"引用本类的构造函数\"]},\"299\":{\"h\":\"抽象类(abstract class)和接口(interface)有什么区别？\",\"t\":[\"方法实现 \",\"接口中的方法默认是公开的(public)，只能定义，不能实现。从JDK 8开始，接口中的方法可以有默认实现，而抽象类可以包含非抽象的方法 \",\"如果同时实现两个接口，并且接口中定义了相同的默认方法，则必须重写方法，否则会报错\",\"在JDK 8中，接口也可以定义静态方法，并且可以直接使用接口名调用 \",\"实现类和实例不能调用静态方法\",\"JDK 9允许在接口中定义私有方法\",\"变量 \",\"接口中只能包含静态(static)和常量(final)变量，不能有其他类型的变量。而抽象类中可以包含任意类型的变量\",\"实现 \",\"一个类可以实现多个接口，但只能继承一个抽象类。接口自身可以通过extends关键字扩展多个接口\",\"方法修饰符 \",\"接口中的方法默认修饰符是public，抽象方法可以有public、protected和default修饰符。抽象方法是为了被重写，所以不能使用private修饰符\",\"设计层面 \",\"抽象类是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为规范\"]},\"300\":{\"h\":\"成员变量与局部变量的区别有哪些？\",\"t\":[\"成员变量 = 实例变量 + 静态变量（类变量）\",\"语法形式 \",\"成员变量是在类中声明的变量，可以被public、private、static等修饰符所修饰\",\"成员变量包括实例变量和静态变量（类变量） \",\"实例变量是每个对象独有的，而静态变量是类共享的\",\"局部变量是在方法中或代码块中声明的变量，不能被访问控制修饰符及static所修饰\",\"存储方式 \",\"实例变量存储在堆内存中\",\"静态变量存储在方法区（元空间）的静态存储区，所有对象共享同一份静态变量的拷贝\",\"局部变量存在栈内存中，随着方法或代码块的执行而创建和销毁\",\"生存周期 \",\"静态变量在类被加载至数据区后，只有当程序结束时才会被销毁，它的生命周期与程序的生命周期相同。\",\"实例变量即对象变量，随对象的创建而生，随对象的销毁而销毁\",\"局部变量只在方法或代码块内有效，一旦超出这个范围就不再有效\",\"默认值 \",\"非final修饰的成员变量具有默认值，而局部变量没有默认值\",\"成员变量的默认值根据其类型而定，例如整型默认为0，布尔型默认为false，引用类型默认为null\",\"局部变量在使用前必须显式地进行初始化\"]},\"301\":{\"h\":\"静态变量和实例变量的区别？静态方法、实例方法呢？\",\"t\":[\"静态变量 \",\"是被 static 修饰符修饰的变量，也称为类变量，它属于类，不属于类的任何一个对象，一个类不管创建多少个对象，静态变量在内存中有且仅有一个副本\",\"实例变量 \",\"必须依存于某一实例，需要先创建对象然后通过对象才能访问到它。静态变量可以实现让多个对象共享内存\",\"静态方法 \",\"static修饰的方法，也被称为类方法\",\"在外部调⽤静态⽅法时，可以使⽤\\\"类名.⽅法名\\\"的⽅式，也可以使⽤\\\"对象名.⽅法名\\\"的⽅式\",\"静态方法里不能访问类的非静态成员变量和方法\",\"实例⽅法 \",\"依存于类的实例\",\"需要使用\\\"对象名.⽅法名\\\"的⽅式调用\",\"可以访问类的所有成员变量和方法\"]},\"302\":{\"h\":\"final关键字有什么作用？\",\"t\":[\"被final修饰的类不可以被继承\",\"被final修饰的方法不可以被重写\",\"被final修饰的变量不可变，被final修饰的变量必须被显式第指定初始值 \",\"这里的不可变指的是变量的引用不可变，不是引用指向的内容的不可变\"]},\"303\":{\"h\":\"final、finally、finalize的区别？\",\"t\":[\"final 用于修饰变量、方法和类 \",\"final修饰的类不可被继承\",\"修饰的方法不可被重写\",\"修饰的变量不可变\",\"在 try/catch 语句中，最终一定被执行 \",\"经常被用在需要释放资源的情况下\",\"System.exit (0) 可以阻断 finally 执行\",\"finalize 是在 java.lang.Object 里定义的方法 \",\"这个方法在 gc 启动，该对象被回收的时候被调用\",\"一个对象的 finalize 方法只会被调用一次，finalize 被调用不一定会立即回收该对象 \",\"不推荐使用 \",\"有可能调用 finalize 后，该对象又不需要被回收了，然后到了真正要被回收的时候，因为前面调用过一次，所以不会再次调用 finalize 了，进而产生问题，因此不推荐使用 finalize 方法\"]},\"304\":{\"h\":\"==和 equals 的区别？\",\"t\":[\"== \",\"判断两个对象是不是同⼀个对象 \",\"基本数据类型==比较的是值\",\"引⽤数据类型==比较的是内存地址\",\"equals() \",\"判断两个对象是否相等\",\"默认情况类没有覆盖 equals() ⽅法，等价于通过“ == ”比较这两个对象\"]},\"305\":{\"h\":\"hashCode与 equals?\",\"t\":[\"什么是HashCode？ \",\"hashCode方法用于获取对象的哈希码，哈希码是一个整数，用来表示对象的唯一标识\",\"哈希码常用于哈希表等数据结构的实现中，可以快速定位对象\",\"为什么重写 quals 时必须重写 hashCode ⽅法？ \",\"这是Java的规定，主要目的是确保 Java 中的集合类（例如 HashMap、HashSet 等）能够正确地工作并保持一致性 \",\"对象相等性原则 \",\"如果两个对象根据 equals() 方法判断相等，则它们的 hashCode() 方法的返回值必须相等\",\"hashCode() 的默认⾏为是对堆上的对象产⽣独特值。如果没有重写 hashCode() ，则该class 的两个对象⽆论如何都不会相等（即使这两个对象指向相同的数据）\"]},\"306\":{\"h\":\"Java是值传递，还是引用传递？\",\"t\":[\"Java语言是值传递 \",\"当传递基本数据类型（如int、float、boolean等）时 \",\"传递的是该值的副本，对形参的修改不会影响实参\",\"当传递对象引用时 \",\"传递的是该引用的副本，而不是对象本身。因此，对形参引用的修改不会影响实参引用的指向，但可以通过引用修改对象的状态\"]},\"307\":{\"h\":\"什么是深拷贝和浅拷贝?\",\"t\":[\"浅拷贝 \",\"仅拷贝被拷贝对象的成员变量的值，也就是基本数据类型变量的值，和引用数据类型变量的地址值，而对于引用类型变量指向的堆中的对象不会拷贝。\",\"深拷贝 \",\"完全拷贝一个对象，拷贝被拷贝对象的成员变量的值，堆中的对象也会拷贝一份\",\"深拷贝是安全的 \",\"浅拷贝的话如果有引用类型，那么拷贝后对象，引用类型变量修改，会影响原对象\",\"浅拷贝如何实现呢？ \",\"Object类提供的clone()方法可以非常简单地实现对象的浅拷贝\",\"深拷贝如何实现呢？ \",\"重写克隆方法 \",\"重写克隆方法，引用类型变量单独克隆，这里可能会涉及多层递归\",\"序列化 \",\"可以先讲原对象序列化，再反序列化成拷贝对象\"]},\"308\":{\"h\":\"Java 创建对象有哪几种方式？\",\"t\":[\"new创建新对象\",\"通过反射机制\",\"采用clone机制\",\"通过序列化机制 \",\"Java中序列化可以通过实现Externalizable或者Serializable来实现\",\"或者使用json序列化\"]},\"309\":{\"h\":\"Java内部类为什么推荐用静态类\",\"t\":[\"在Java中，内部类（Inner Class）可以分为静态内部类（Static Inner Class）和非静态内部类（Non-static Inner Class）。推荐使用静态内部类的原因主要有以下几个方面：\",\"避免内存泄漏： 非静态内部类会隐式地持有其外部类实例的引用。如果内部类的生命周期超出了外部类实例的生命周期，就会导致内存泄漏。而静态内部类不会持有外部类的引用，从而避免了这个问题。\",\"独立性强： 静态内部类不依赖于外部类的实例，因此它可以独立存在，不需要通过外部类的实例来创建。这提高了类的独立性和可重用性。\",\"性能优化： 静态内部类在编译时不需要持有外部类的引用，减少了不必要的内存开销，从而提升了性能。\",\"线程安全： 静态内部类常常用于实现单例模式中的“静态内部类实现方式”，这种方式不仅实现简单，还能确保线程安全，同时具备延迟加载的特性。\"]},\"310\":{\"h\":\"示例\"},\"311\":{\"h\":\"非静态内部类\",\"t\":[\"public class OuterClass { private int outerField = 10; class InnerClass { public void print() { System.out.println(\\\"Outer field: \\\" + outerField); } } public static void main(String[] args) { OuterClass outer = new OuterClass(); InnerClass inner = outer.new InnerClass(); inner.print(); } } \",\"在这个例子中，InnerClass是非静态内部类，它持有OuterClass实例的引用。\"]},\"312\":{\"h\":\"静态内部类\",\"t\":[\"public class OuterClass { private static int outerField = 10; static class StaticInnerClass { public void print() { System.out.println(\\\"Outer field: \\\" + outerField); } } public static void main(String[] args) { StaticInnerClass inner = new StaticInnerClass(); inner.print(); } } \",\"在这个例子中，StaticInnerClass是静态内部类，它不持有OuterClass实例的引用，且可以直接访问外部类的静态成员。\"]},\"313\":{\"h\":\"总结\",\"t\":[\"使用静态内部类有助于避免内存泄漏、提高类的独立性和性能，以及确保线程安全。在设计模式中，如单例模式的实现，静态内部类也具有明显的优势。因此，除非必须使用非静态内部类，否则推荐使用静态内部类。\"]},\"314\":{\"h\":\"Java内存模型\"},\"315\":{\"h\":\"说一下你对Java内存模型（JMM）的理解 ？\",\"t\":[\"Java内存模型（Java Memory Model，JMM），是一种抽象的模型，被定义出来屏蔽各种硬件和操作系统的内存访问差异\",\"JMM定义了线程和主内存之间的抽象关系\",\"线程之间的共享变量存储在 主内存（Main Memory）中，每个线程都有一个私有的 本地内存 （Local Memory），本地内存中存储了该线程以读/写共享变量的副本 \",\"Java内存模型的抽象图\",\"本地内存是JMM的 一个抽象概念，并不真实存在，实际的线程工作模型如下图所示，其中每个线程都有自己的控制器和运算器，以及一级缓存。有些架构还有一个共享的二级缓存。这些硬件组件对应着JMM中的工作内存\",\"Java内存模型通过定义内存间的交互操作规则，例如读取、写入和同步操作，来确保多线程程序的可见性、有序性和原子性。\"]},\"316\":{\"h\":\"说说你对原子性、可见性、有序性的理解？\",\"t\":[\"原子性、有序性、可见性是并发编程中非常重要的基础概念，用于描述多线程环境下的内存访问行为，JMM的很多技术都是围绕着这三大特性展开\",\"原子性（Atomicity） \",\"原子性是指一个操作是不可分割的，要么完全执行，要么不执行。\",\"在多线程环境下，原子性保证了对共享变量的操作是原子的，不会被其他线程中断\",\"可见性（Visibility） \",\"可见性是指当一个线程对共享变量进行修改后，其他线程能够立即看到这个修改\",\"在多线程环境下，由于每个线程都有自己的本地内存，线程之间对共享变量的修改不一定能够及时同步到主内存和其他线程的本地内存中\",\"可见性保证了共享变量的修改对其他线程是可见的，即能够正确读取到最新的值\",\"有序性（Ordering） \",\"是指程序执行的顺序与代码的顺序一致\",\"在多线程环境下，由于指令重排序和编译器优化的存在，代码的执行顺序可能与代码的编写顺序不一致\",\"序性保证了程序的执行顺序与代码的顺序一致，即保证了代码的串行语义\",\"为了保证原子性、可见性和有序性，我们可以使用同步机制（如锁、volatile关键字、synchronized关键字等）来控制线程的访问和操作\"]},\"317\":{\"h\":\"分析下面几行代码的原子性？\",\"t\":[\"int i = 2; int j = i; i++; i = i + 1; \",\"第1句是基本类型赋值，是原子性操作\",\"第2句先读i的值，再赋值到j，两步操作，不能保证原子性\",\"第3和第4句其实是等效的，先读取i的值，再+1，最后赋值到i，三步操作了，不能保证原子性\"]},\"318\":{\"h\":\"原子性、可见性、有序性都应该怎么保证呢？\",\"t\":[\"原子性 \",\"使用同步机制，如synchronized关键字、Lock接口、Atomic类等，来控制对共享变量的访问和操作，确保操作是不可分割的\",\"可见性 \",\"使用volatile关键字或者同步机制，如synchronized关键字、Lock接口等，来保证对共享变量的修改对其他线程是可见的\",\"有序性 \",\"使用volatile关键字或者同步机制，如synchronized关键字、Lock接口等，来保证程序执行的顺序与代码的顺序一致\"]},\"319\":{\"h\":\"那说说什么是指令重排？\",\"t\":[\"在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排序\",\"重排序分3种类型 \",\"编译器优化的重排序 \",\"编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序\",\"指令级并行的重排序 \",\"现代处理器采用了指令级并行技术（Instruction-Level Parallelism，ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应 机器指令的执行顺序\",\"内存系统的重排序 \",\"由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行\",\"双重校验单例模式就是一个经典的指令重排的例子：Singleton instance=new Singleton() \",\"对应的JVM指令分为三步：分配内存空间-->初始化对象--->对象指向分配的内存空间\",\"经过了编译器的指令重排序，第二步和第三步就可能会重排序\",\"JMM属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证\"]},\"320\":{\"h\":\"指令重排有限制吗？happens-before了解吗？\",\"t\":[\"指令重排也是有一些限制的，有两个规则 happens-before 和 as-if-serial 来约束\",\"happens-before的定义 \",\"如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前\",\"两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照 happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么这种重排序并不非法\",\"happens-before和我们息息相关的有六大规则 \",\"程序顺序规则 \",\"一个线程中的每个操作，happens-before于该线程中的任意后续操作\",\"监视器锁规则 \",\"对一个锁的解锁，happens-before于随后对这个锁的加锁\",\"volatile变量规则 \",\"对一个volatile域的写，happens-before于任意后续对这个volatile域的读\",\"传递性 \",\"如果A happens-before B，且B happens-before C，那么A happens-beforeC\",\"start()规则 \",\"如果线程A执行操作ThreadB.start()（启动线程B），那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作\",\"join()规则 \",\"如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作 happens-before于线程A从ThreadB.join()操作成功返回\"]},\"321\":{\"h\":\"as-if-serial又是什么？单线程的程序一定是顺序的吗？\",\"t\":[\"as-if-serial语义的意思是：不管怎么重排序（编译器和处理器为了提高并行度），单线程程序的执行结果不能被改变\",\"编译器、runtime和处理器都必须遵守as-if-serial语义\",\"为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果\",\"如果操作之间不存在数据依赖关系，这些操作就可能被编译器和处理器重排序\"]},\"322\":{\"h\":\"volatile实现原理了解吗？\",\"t\":[\"volatile有两个作用，保证可见性和有序性\"]},\"323\":{\"h\":\"volatile怎么保证可见性的呢？\",\"t\":[\"相比synchronized的加锁方式来解决共享变量的内存可见性问题，volatile就是更轻量的选择，它没有上下文切换的额外开销成本\",\"volatile可以确保对某个变量的更新对其他线程马上可见 \",\"一个变量被声明为volatile时，线程在写入变量时不会把值缓存在寄存器或者其他地方，而是会把值刷新回主内存\",\"当其它线程读取该共享变量 ，会从主内存重新获取最新值，而不是使用当前线程的本地内存中的值\"]},\"324\":{\"h\":\"volatile怎么保证有序性的呢？\",\"t\":[\"重排序可以分为编译器重排序和处理器重排序，valatile保证有序性，就是通过分别限制这两种类型的重排序\",\"为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序 \",\"在每个volatile写操作的前面插入一个 StoreStore 屏障 \",\"功能：确保在屏障前的所有写操作（存储操作）都在屏障后的写操作之前被刷新到主内存中。即确保第一个存储操作的结果对后续的存储操作可见。\",\"在每个volatile写操作的后面插入一个 StoreLoad 屏障 \",\"确保在屏障前的所有写操作在屏障后的所有读操作（加载操作）之前被刷新到主内存中。即防止写操作重排序到读操作之后\",\"在每个volatile读操作的后面插入一个 LoadLoad 屏障 \",\"功能：确保在屏障前的所有读操作都完成之后，再进行屏障后的读操作。即确保第一个加载操作的结果对后续的加载操作可见。\",\"在每个volatile读操作的后面插入一个 LoadStore 屏障 \",\"功能：确保在屏障前的所有读操作都完成之后，再进行屏障后的写操作。即防止读操作重排序到写操作之后\",\"​\"]},\"325\":{\"h\":\"ThreadLocal\"},\"326\":{\"h\":\"ThreadLocal是什么？\",\"t\":[\"ThreadLocal，也就是线程本地变量\",\"创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的一个本地拷贝\",\"多个线程操作这个变量的时候，实际是操作自己本地内存里面的变量，从而起到线程隔离的作用，避免了线程 安全问题\",\"创建\",\"创建了一个ThreadLoca变量localVariable，任何一个线程都能并发访问localVariable。\",\"//创建一个ThreadLocal变量 public static ThreadLocal<String> localVariable = new ThreadLocal<>(); \",\"写入\",\"线程可以在任何地方使用localVariable，写入变量\",\"localVariable.set(\\\"鄙人张三”); \",\"读取\",\"线程在任何地方读取的都是它写入的变量。\",\" localVariable.get(); \"]},\"327\":{\"h\":\"你在工作中用到过ThreadLocal吗？\",\"t\":[\"用来做用户信息上下文的存储 \",\"存放token\"]},\"328\":{\"h\":\"ThreadLocal怎么实现的呢？\",\"t\":[\"Thread类有一个类型为ThreadLocal.ThreadLocalMap的实例变量threadLocals，每个线程都有一个属于自己的ThreadLocalMap\",\"ThreadLocalMap内部维护着Entry数组，每个Entry代表一个完整的对象，key是ThreadLocal的弱引用，value是ThreadLocal的泛型值\",\"每个线程在往ThreadLocal里设置值的时候，都是往自己的ThreadLocalMap里存，读也是以某个ThreadLocal作为引用，在自己的map里找对应的key，从而实现了线程隔离\",\"ThreadLocal本身不存储值，它只是作为一个key来让线程往ThreadLocalMap里存取值\"]},\"329\":{\"h\":\"ThreadLocal 内存泄露是怎么回事？\",\"t\":[\"ThreadLocalMap中使用的 key 为 ThreadLocal 的弱引用 \",\"弱引用：只要垃圾回收机制一运行，不管JVM的内存空间是否充足，都会回收该对象占用的内存。\",\"弱引用很容易被回收，如果ThreadLocal（ThreadLocalMap的Key）被垃圾回收器回收了，但是ThreadLocalMap生命周期和Thread是一样的，它这时候如果不被回收，就会出现这种情况：ThreadLocalMap的key没了，value还在，这 就会造成了内存泄漏问题\"]},\"330\":{\"h\":\"那怎么解决内存泄漏问题呢？\",\"t\":[\"使用完ThreadLocal后，及时调用remove()方法释放内存空间\"]},\"331\":{\"h\":\"为什么key还要设计成弱引用？\",\"t\":[\"key设计成弱引用同样是为了防止内存泄漏问题 \",\"在ThreadLocal中，每个ThreadLocal实例都对应着一个ThreadLocalMap对象，而ThreadLocalMap使用ThreadLocal实例作为键，用于存储线程局部变量的值。\",\"如果将ThreadLocal实例作为强引用存储在ThreadLocalMap中，那么即使线程不再使用某个ThreadLocal实例，该实例也无法被垃圾回收，从而可能导致内存泄漏\"]},\"332\":{\"h\":\"ThreadLocalMap的结构了解吗？\",\"t\":[\"元素数组\",\"一个table数组，存储Entry类型的元素，Entry是ThreaLocal弱引用作为key，Object作为value的结构\",\"private Entry[] table \",\"散列方法\",\"散列方法就是怎么把对应的key映射到table数组的相应下标，ThreadLocalMap用的是哈希取余法，取出key的threadLocalHashCode，然后和table数组长度减一&运算（相当于取余）\",\"int i = key.threadLocalHashCode & (table.length - 1); \",\"这里的threadLocalHashCode计算有点东西，每创建一个ThreadLocal对象，它就会新增 0x61c88647\",\"这个值很特殊，它是斐波那契数 也叫 黄金分割数\",\"hash 增量为 这个数字，带来的好处就是 hash 分布非常均匀\",\"private static final int HASH_INCREMENT = 0x61c88647; private static int nextHashCode() { return nextHashCode.getAndAdd(HASH_INCREMENT); } \"]},\"333\":{\"h\":\"ThreadLocalMap怎么解决Hash冲突的？\",\"t\":[\"开放定址法\",\"简单来说，就是这个坑被人占了，那就接着去找空着的坑，往后找一圈没找到就会从头开始找\",\"如上图所示，如果我们插入一个value=27的数据，通过 hash计算后应该落入第 4 个槽位中，而槽位 4 已经有了 Entry数据，而且Entry数据的key和当前不相等。此时就会线性向后查找，一直找到 Entry为 null的槽位才会停止查找，把元素放到空的槽中\",\"在get的时候，也会根据ThreadLocal对象的hash值，定位到table中的位置，然后判断该槽位Entry对象中的key是否和get的key一致，如果不一致，就判断下一个位置\"]},\"334\":{\"h\":\"ThreadLocalMap扩容机制了解吗？\",\"t\":[\"rehash()时机\",\"在ThreadLocalMap.set()方法的最后，如果执行完启发式清理工作后，未清理到任何数据，且当前散列数组中 Entry 的数量已经达到了列表的扩容阈值 (len*2/3) ，就开始执行 rehash() 逻辑\",\"if (!cleanSomeSlots(i, sz) && sz >= threshold) rehash(); \",\"rehash\",\"会先去清理过期的Entry\",\"然后还要根据条件判断size >= threshold - threshold / 4 也就是 size >= threshold* 3/4 来决定是否需要扩容\",\"private void rehash() { //清理过期Entry expungeStaleEntries(); // Use lower threshold for doubling to avoid hysteresis if (size >= threshold - threshold / 4) resize(); } \",\"resize\",\"扩容后的 newTab 的大小为老数组的两倍\",\"然后遍历老的table数组，散列方法重新计算位置\",\"开放地址解决冲突，然后放到新的newTab ，遍历完成之后， oldTab 中所有的 entry 数据都已经放入到 newTab 中了，然后table引用指向 newTab\",\" private void resize() { Entry[] oldTab = table; int oldLen = oldTab.length; int newLen = oldLen * 2; Entry[] newTab = new Entry[newLen]; int count = 0; for (Entry e : oldTab) { if (e != null) { ThreadLocal<?> k = e.get(); if (k == null) { e.value = null; // Help the GC } else { int h = k.threadLocalHashCode & (newLen - 1); while (newTab[h] != null) h = nextIndex(h, newLen); newTab[h] = e; count++; } } } setThreshold(newLen); size = count; table = newTab; } \"]},\"335\":{\"h\":\"父子线程怎么共享数据？\",\"t\":[\"InheritableThreadLocal\",\"在主线程的InheritableThreadLocal实例设置值，在子线程中就可以拿到了\",\"public class InheritableThreadLocalTest { public static void main(String[] args) { final ThreadLocal threadLocal = new InheritableThreadLocal(); // 主线程 threadLocal.set(\\\"不擅技术\\\"); //子线程 Thread t = new Thread() { @Override public void run() { super.run(); System.out.println(\\\"鄙人三某 ，\\\" + threadLocal.get()); } }; t.start(); } } \"]},\"336\":{\"h\":\"InheritableThreadLocal原理是什么呢？\",\"t\":[\"原理很简单，在Thread类里还有另外一个变量\",\"ThreadLocal.ThreadLocalMap inheritableThreadLocals = null; \",\"在Thread的构造函数中，如果父线程的 inheritableThreadLocals 不为空，就把它赋给当前线程（子线程）的 inheritableThreadLocals\",\" // thread locals if (!attached) { if ((characteristics & NO_INHERIT_THREAD_LOCALS) == 0) { ThreadLocal.ThreadLocalMap parentMap = parent.inheritableThreadLocals; if (parentMap != null && parentMap.size() > 0) { //从父线程中取出inheritableThreadLocals this.inheritableThreadLocals = ThreadLocal.createInheritedMap(parentMap); } if (VM.isBooted()) { this.contextClassLoader = contextClassLoader(parent); } } else if (VM.isBooted()) { // default CCL to the system class loader when not inheriting this.contextClassLoader = ClassLoader.getSystemClassLoader(); } } \"]},\"337\":{\"h\":\"还有什么其它办法？TTL？\",\"t\":[\"TransmittableThreadLocal（TTL） \",\"是阿里巴巴开源的基于 InheritableThreadLocal 的增强版\",\"解决了线程池等场景下InheritableThreadLocal 的值传递问题\",\"TTL通过重写 ThreadLocal 的方法和使用特定的数据结构，确保子线程能够正确获取父线程最新的值\",\"它还提供了自定义初始化方法和支持传递不可序列化对象的功能\"]},\"338\":{\"h\":\"基础\"},\"339\":{\"h\":\"并行跟并发有什么区别？\",\"t\":[\"并行就是同一时刻，两个线程都在执行。这就要求有两个CPU去分别执行两个线程\",\"并发就是同一时刻，只有一个执行，但是一个时间段内，两个线程都执行了 \",\"并发的实现依赖于CPU切换线程，因为切换的时间特别短，所以基本对于用户是无感知的\"]},\"340\":{\"h\":\"说说什么是进程和线程？\",\"t\":[\"进程 \",\"进程是代码在数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位\",\"一个进程中有多个线程，多个线程共用进程的堆和方法区资源\",\"线程 \",\"线程是进程的一个执行路径，一个进程中至少有一个线程，进程中的多个线程共享进程的资源\",\"每个线程有自己的程序计数器和栈\"]},\"341\":{\"h\":\"说说线程有几种创建方式？\",\"t\":[\"继承Thread类 \",\"继承Thread类，重写run()方法，调用start()方法启动线程\",\"实现Runnable接口 \",\"实现 Runnable 接口，重写run()方法\",\"实现Callable接口 \",\"实现Callable接口，重写call()方法，这种方式可以通过FutureTask获取任务执行的返回值\"]},\"342\":{\"h\":\"为什么调用start()方法时会执行run()方法，那怎么不直接调用run()方法？\",\"t\":[\"JVM执行start方法，会先创建一条线程，由创建出来的新线程去执行thread的run方法，这才起到多线程的效果\",\"为什么我们不能直接调用run()方法？ \",\"如果直接调用Thread的run()方法，那么run方法还是运行在主线程中，相当于顺序执行，就起不到多线程的效果\"]},\"343\":{\"h\":\"Thread和Runnable有什么区别？\",\"t\":[\"特点\",\"Thread\",\"Runnable\",\"继承关 系\",\"是一个类\",\"是一个接口\",\"代码复 用\",\"不方便，每个线程需要创建新实 例\",\"方便，多个线程可以共享同一实 例\",\"灵活性\",\"相对较低，只能继承Thread类\",\"相对较高，可以与其他接口组合\",\"可控性\",\"相对较低，需要手动管理线程\",\"相对较高，可以通过线程池管理\",\"Thread类适合直接创建新线程\",\"而Runnable接口适合定义线程要执行的任务，并可以与其他接口组合使用\"]},\"344\":{\"h\":\"线程有哪些常用的调度方法？\",\"t\":[\"线程等待与通知 \",\"Object类方法 \",\"wait() \",\"当一个线程A调用一个共享变量的 wait()方法时， 线程A会被阻塞挂起，发生下面几种情况才会返回\",\"其他线程调用了线程A共享对象 notify()或者 notifyAll()方法\",\"其他线程调用了线程A的 interrupt() 方法，线程A抛出InterruptedException异常返回\",\"wait(long timeout) \",\"这个方法相比 wait() 方法多了一个超时参数\",\"在等待时间内没有其他线程调用相同对象的 notify() 或 notifyAll() 方法唤醒它，或者等待时间到期，线程会被自动唤醒，并且重新尝试获取对象的锁\",\"如果等待时间到期而线程没有获取到锁，则线程会被唤醒，但是它不会重新尝试获取锁。相反，它会在等待队列中等待，直到其他线程通过 notify() 或 notifyAll() 方法唤醒它，并且在获取锁之前，线程是不会继续执行的\",\"wait(long timeout, int nanos)\",\"其内部调用的是 wait(long timout）函数\",\"notify() \",\"一个线程A调用共享对象的 notify() 方法后，会唤醒一个在这个共享变量上调用 wait 系列方法后被挂起的线程。 一个共享变量上可能会有多个线程在等待，具体唤醒哪个等待的线程是随机的\",\"notifyAll() \",\"不同于在共享变量上调用 notify() 函数会唤醒被阻塞到该共享变量上的一个线程，notifyAll()方法则会唤醒所有在该共享变量上由于调用 wait 系列方法而被挂起的线程\",\"Thread类的方法 \",\"join() \",\"如果一个线程A执行了thread.join()语句，其含义是：当前线程A等待thread线程终止之后从thread.join()返回\",\"线程休眠 \",\"sleep(long millis) \",\"Thread类中的静态方法\",\"当一个执行中的线程A调用了Thread的sleep方法后，线程A会暂时让出指定时间的执行权\",\"但是线程A所拥有的监视器资源，比如锁还是持有不让出的\",\"指定的睡眠时间到了后该函数会正常返回，接着参与 CPU 的调度，获取到 CPU 资源后就可以继续运行\",\"让出优先权 \",\"yield() \",\"Thread类中的静态方法\",\"当一个线程调用 yield 方法时，实际就是在暗示线程调度器当前线程请求让出自己的CPU ，但是线程调度器可以无条件忽略这个暗示\",\"线程中断 \",\"定义 \",\"Java 中的线程中断是一种线程间的协作模式\",\"通过设置线程的中断标志并不能直接终止该线程的执行，而是被中断的线程根据中断状态自行处理\",\"方法 \",\"void interrupt() \",\"中断线程\",\"例如，当线程A运行时，线程B可以调用线程interrupt() 方法来设置线程的中断标志为true 并立即返回\",\"线程A实际并没有被中断， 会继续往下执行\",\"boolean isInterrupted() \",\"检测当前线程是否被中断\",\"boolean interrupted() \",\"检测当前线程是否被中断，与 isInterrupted 不同的是，该方法如果发现当前线程被中断，则会清除中断标志\"]},\"345\":{\"h\":\"线程有几种状态？\",\"t\":[\"线程共有六种状态\",\"状态\",\"说明\",\"NEW\",\"初始状态：线程被创建，但还没有调用start()方法\",\"RUNNABLE\",\"运行状态：Java线程将操作系统中的就绪和运行两种状态笼 统的称作“运行”\",\"BLOCKED\",\"阻塞状态：表示线程阻塞于锁\",\"WAITING\",\"等待状态：表示线程进入等待状态，进入该状态表示当前线 程需要等待其他线程做出一些特定动作（通知或中断）\",\"TIME_WAITING\",\"超时等待状态：该状态不同于 WAITIND，它是可以在指定 的时间自行返回的\",\"TERMINATED\",\"终止状态：表示当前线程已经执行完毕\"]},\"346\":{\"h\":\"BLOCKED和WAITING有什么区别？\",\"t\":[\"BLOCKED状态表示线程被阻塞，无法继续执行，通常是因为等待获取锁\",\"WAITING状态表示线程正在等待其他线程的通知，通常是因为调用了wait()方法、join()方法或LockSupport.park()方法\",\"这两种状态的区别在于阻塞状态是等待获取锁，而等待状态是等待其他线程的通知或中断\"]},\"347\":{\"h\":\"WAITING和TERMINATED有什么区别？\",\"t\":[\"WAITING状态表示线程在等待其他线程的通知或中断\",\"而TERMINATED状态表示线程已经执行完毕，不再执行任何代码\",\"WAITING状态是暂时的，可以再次进入RUNNABLE状态，而TERMINATED状态是永久的，线程不会再进入任何状态\"]},\"348\":{\"h\":\"什么是线程上下文切换？\",\"t\":[\"线程上下文切换是指在多线程环境下，CPU 从一个线程转而执行另一个线程的过程。\",\"在这个过程中，操作系统会保存当前线程的上下文（包括寄存器状态、程序计数器、堆栈指针等信息），然后恢复下一个线程的上下文，以便该线程可以继续执行。\",\"线程上下文切换是一种非常耗时的操作，因为操作系统需要保存和恢复线程的上下文信息。因此，在编写多线程应用程序时，应尽量减少线程上下文切换的次数，以提高系统的性能和效率\"]},\"349\":{\"h\":\"线程上下文切换通常发生在以下几种情况下\",\"t\":[\"当一个线程的时间片用完时，操作系统会强制进行线程上下文切换，将 CPU 时间片分配给另一个处于就绪状态的线程。\",\"当一个线程因为等待某些事件（如I/O操作、锁的释放等）而被阻塞时，操作系统会将 CPU 时间片分配给另一个处于就绪状态的线程\",\"当一个线程调用了 yield() 方法主动放弃 CPU 时间片时，操作系统会将 CPU 时间片分配给另一个处于就绪状态的线程\"]},\"350\":{\"h\":\"守护线程了解吗？\",\"t\":[\"Java中的线程分为两类，分别为 daemon 线程（守护线程）和 user 线程（用户线程）\",\"在JVM 启动时会调用 main 函数，main函数所在的钱程就是一个用户线程\",\"其实在JVM 内部同时还启动了很多守护线程， 比如垃圾回收线程\",\"那么守护线程和用户线程有什么区别呢 ？ \",\"是当最后一个非守护线程束时，JVM会正常退出，而不管当前是否存在守护线程，也就是说守护线程是否结束并不影响 JVM退出\"]},\"351\":{\"h\":\"线程间有哪些通信方式？\",\"t\":[\"volatile和synchronized关键字 \",\"关键字volatile可以用来修饰字段（成员变量），就是告知程序任何对该变量的访问均需要从共享内存中获取，而对它的改变必须同步刷新回共享内存，它能保证所有线程对变量访问的可见性\",\"关键字synchronized可以修饰方法或者以同步块的形式来进行使用，它主要确保多个线程在同一个时刻，只能有一个线程处于方法或者同步块中，它保证了线程对变量访问的可见性和排他性\",\"等待/通知机制 \",\"可以通过Java内置的等待/通知机制（wait()/notify()）实现一个线程修改一个对象的值，而另一个线程感知到了变化，然后进行相应的操作\",\"管道输入/输出流 \",\"管道输入/输出流和普通的文件输入/输出流或者网络输入/输出流不同之处在于，它主要用于线程之间的数据传输，而传输的媒介为内存\",\"管道输入/输出流主要包括了如下4种具体实现 \",\"PipedOutputStream、PipedInputStream、 PipedReader和PipedWriter，前两种面向字节，而后两种面向字 符\",\"使用Thread.join() \",\"如果一个线程A执行了thread.join()语句，其含义是：当前线程A等待thread线程终止之后才从thread.join()返回\",\"线程Thread除了提供join()方法之外，还提供了join(long millis)和join(long millis,int nanos)两个具备超时特性的方法\",\"使用ThreadLocal（线程内 ） \",\"ThreadLocal，即线程变量，是一个以ThreadLocal对象为键、任意对象为值的存储结构\",\"这个结构被附带在线程上，也就是说一个线程可以根据一个ThreadLocal对象查询到绑定在这个线程上的一个值\"]},\"352\":{\"h\":\"并发工具类\"},\"353\":{\"h\":\"CountDownLatch（倒计数器）了解吗？\",\"t\":[\"CountDownLatch，倒计数器，有两个常见的应用场景\",\"场景1：协调子线程结束动作：等待所有子线程运行结束\",\"public static void main(String[] args) throws InterruptedException { CountDownLatch countDownLatch = new CountDownLatch(5); Thread 大乔 = new Thread(countDownLatch::countDown); Thread 兰陵王 = new Thread(countDownLatch::countDown); Thread 安其拉 = new Thread(countDownLatch::countDown); Thread 哪吒 = new Thread(countDownLatch::countDown); Thread 铠 = new Thread(() -> { try { // 稍等，上个卫生间，马上到... Thread.sleep(1500); countDownLatch.countDown(); } catch (InterruptedException ignored) { } }); 大乔.start(); 兰陵王.start(); 安其拉.start(); 哪吒.start(); 铠.start(); countDownLatch.await(); System.out.println(\\\"所有玩家已经就位！\\\"); } \",\"子线程使用countDownLatch.countDown()进行倒数计数\",\"主线程使用countDownLatch.await()进行阻塞，等待子线程完成\",\"场景2：协调子线程开始动作：统一各线程动作开始的时机\",\" public static void main(String[] args) throws InterruptedException { CountDownLatch countDownLatch = new CountDownLatch(1); Thread 大乔 = new Thread(() -> waitToFight(countDownLatch)); Thread 兰陵王 = new Thread(() -> waitToFight(countDownLatch)); Thread 安其拉 = new Thread(() -> waitToFight(countDownLatch)); Thread 哪吒 = new Thread(() -> waitToFight(countDownLatch)); Thread 铠 = new Thread(() -> waitToFight(countDownLatch)); 大乔.start(); 兰陵王.start(); 安其拉.start(); 哪吒.start(); 铠.start(); Thread.sleep(1000); countDownLatch.countDown(); System.out.println(\\\"敌方还有5秒达到战场，全军出击！\\\"); } private static void waitToFight(CountDownLatch countDownLatch) { try { countDownLatch.await(); // 在此等待信号再继续 System.out.println(\\\"收到，发起进攻！\\\"); } catch (InterruptedException e) { e.printStackTrace(); } } \",\"子线程使用countDownLatch.await()进行阻塞，等待主线程完成\",\"主线程使用countDownLatch.countDown()进行倒数计数\",\"CountDownLatch的核心方法\",\"await() ：等待latch降为0\",\"boolean await(long timeout, TimeUnit unit) ：等待latch降为0，但是可以设置超时时间。比如有玩家超时未确认，那就重新匹配，总不能为了某个玩家等到天荒地老\",\"countDown() ：latch数量减1\",\"getCount() ：获取当前的latch数量\"]},\"354\":{\"h\":\"CyclicBarrier（同步屏障）了解吗？\",\"t\":[\"CyclicBarrier的字面意思是可循环使用（Cyclic）的屏障（Barrier）\",\"它要做的事情是，让一 组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行\",\"它和CountDownLatch类似，都可以协调多线程的结束动作，在它们结束后都可以执行特定动作\"]},\"355\":{\"h\":\"重要注意事项\",\"t\":[\"线程中断：如果某个线程在等待时被中断，会抛出 InterruptedException，此时其他线程也会收到 BrokenBarrierException 并继续执行。\",\"重用性：CyclicBarrier 可以重复使用，当所有等待线程都被释放后，屏障会自动重置，可以再次使用。\",\"异常处理：需要处理可能的 BrokenBarrierException 和 TimeoutException（如果使用带超时参数的 await 方法）。\",\"核心方法await()：\",\"使线程在屏障点等待，直到所有线程都到达。如果当前线程是最后一个到达的线程，则会放行，往下执行\",\"如再次await()则阻塞，当前线程是最后一个到达的线程await时，再次放行，循环往复\",\"public class CyclicBarrierExample { public static void main(String[] args) { // 创建CyclicBarrier实例，并设置屏障点操作（所有线程到达屏障点时执行） CyclicBarrier barrier = new CyclicBarrier(3, new Runnable() { @Override public void run() { System.out.println(\\\"所有线程已到达屏障点，继续执行后续任务...\\\"); } }); // 创建并启动三个线程 for (int i = 1; i <= 3; i++) { new Thread(new Task(barrier), \\\"线程 \\\" + i).start(); } } static class Task implements Runnable { private CyclicBarrier barrier; public Task(CyclicBarrier barrier) { this.barrier = barrier; } @Override public void run() { try { while (true) { System.out.println(Thread.currentThread().getName() + \\\" 正在执行任务...\\\"); // 模拟任务执行时间 Thread.sleep((long) (Math.random() * 1000)); System.out.println(Thread.currentThread().getName() + \\\" 完成任务，等待其他线程...\\\"); // 调用await方法等待其他线程 barrier.await(); // 所有线程到达屏障点后执行的代码 System.out.println(Thread.currentThread().getName() + \\\" 继续执行后续任务...\\\"); } } catch (InterruptedException | BrokenBarrierException e) { e.printStackTrace(); } } } } \",\"线程 1 正在执行任务... 线程 2 正在执行任务... 线程 3 正在执行任务... 线程 3 完成任务，等待其他线程... 线程 2 完成任务，等待其他线程... 线程 1 完成任务，等待其他线程... 所有线程已到达屏障点，继续执行后续任务... 线程 1 继续执行后续任务... 线程 1 正在执行任务... 线程 2 继续执行后续任务... 线程 3 继续执行后续任务... 线程 2 正在执行任务... 线程 3 正在执行任务... 线程 3 完成任务，等待其他线程... 线程 2 完成任务，等待其他线程... 线程 1 完成任务，等待其他线程... 所有线程已到达屏障点，继续执行后续任务... 线程 1 继续执行后续任务... 线程 1 正在执行任务... 线程 3 继续执行后续任务... 线程 3 正在执行任务... 线程 2 继续执行后续任务... 线程 2 正在执行任务... 线程 1 完成任务，等待其他线程... 线程 2 完成任务，等待其他线程... 线程 3 完成任务，等待其他线程... 所有线程已到达屏障点，继续执行后续任务... 线程 3 继续执行后续任务... 线程 3 正在执行任务... 线程 1 继续执行后续任务... 线程 1 正在执行任务... 线程 2 继续执行后续任务... 线程 2 正在执行任务... 线程 3 完成任务，等待其他线程... 线程 1 完成任务，等待其他线程... 线程 2 完成任务，等待其他线程... 所有线程已到达屏障点，继续执行后续任务... ... \",\"线程达到公共屏障点（barrier）前阻塞，知道最后一个线程达到屏障点，然后又开始执行\",\"循环往复的做达到屏障点->放行->达到屏障点->放行...\"]},\"356\":{\"h\":\"CyclicBarrier和CountDownLatch有什么区别？\",\"t\":[\"CountDownLatch是一次性的，而CyclicBarrier则可以多次设置屏障，实现重复利用\",\"CountDownLatch中的各个子线程不可以等待其他线程，只能完成自己的任务；而CyclicBarrier中的各个线程可以等待其他线程\",\"CyclicBarrier\",\"CountDownLatch\",\"CyclicBarrier是可重用的，其中的线程会等待 所有的线程完成任务。届时，屏障将被拆 除，并可以选择性地做一些特定的动作。\",\"CountDownLatch是一次性的， 不同的线程在同一个计数器上 工作，直到计数器为0.\",\"CyclicBarrier面向的是线程数\",\"CountDownLatch面向的是任务 数\",\"在使用CyclicBarrier时，你必须在构造中指定 参与协作的线程数，这些线程必须调用await() 方法\",\"使用CountDownLatch时，则必 须要指定任务数，至于这些任 务由哪些线程完成无关紧要\",\"CyclicBarrier可以在所有的线程释放后重新使 用\",\"CountDownLatch在计数器为0 时不能再使用\",\"在CyclicBarrier中，如果某个线程遇到了中 断、超时等问题时，则处于await的线程都会 出现问题\",\"在CountDownLatch中，如果某 个线程出现问题，其他线程不 受影响\"]},\"357\":{\"h\":\"Semaphore（信号量）了解吗？\",\"t\":[\"定义\",\"Semaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源\",\"应用场景\",\"资源池管理：如数据库连接池，限制同时访问数据库的连接数\",\"限流控制：如限制同时处理的请求数量，防止过载\",\"多线程限量操作：如控制多个线程对某个资源的访问，确保不会出现资源争用\",\"示例代码\",\"public class SemaphoreExample { public static void main(String[] args) { // 创建一个Semaphore实例，设定可用许可数量为3（表示有3个停车位） Semaphore parkingLot = new Semaphore(3); // 创建并启动六个线程模拟汽车 for (int i = 1; i <= 6; i++) { new Thread(new Car(parkingLot), \\\"汽车 \\\" + i).start(); } } static class Car implements Runnable { private Semaphore parkingLot; public Car(Semaphore parkingLot) { this.parkingLot = parkingLot; } @Override public void run() { try { System.out.println(Thread.currentThread().getName() + \\\" 尝试进入停车场...\\\"); // 获取一个许可，阻塞直到有可用的许可 parkingLot.acquire(); System.out.println(Thread.currentThread().getName() + \\\" 成功进入停车场。\\\"); // 模拟停车时间 Thread.sleep((long) (Math.random() * 10000)); System.out.println(Thread.currentThread().getName() + \\\" 离开停车场。\\\"); // 释放许可 parkingLot.release(); } catch (InterruptedException e) { e.printStackTrace(); } } } } \"]},\"358\":{\"h\":\"解释\",\"t\":[\"Semaphore：构造函数中传入的参数表示可以同时访问的资源数量。在这个例子中，设定为3，表示有3个停车位。\",\"acquire() 方法：线程调用这个方法尝试获取一个许可，如果没有可用许可，线程会被阻塞，直到有可用许可为止。\",\"release() 方法：线程调用这个方法释放一个许可，使其他被阻塞的线程可以继续执行。\",\"模拟停车场：Car 类中的 run 方法模拟了汽车进入停车场、停车和离开的过程。线程首先尝试获取一个许可，成功后进入停车场， 停车一段时间后离开，并释放许可。\"]},\"359\":{\"h\":\"重要注意事项\",\"t\":[\"公平性：Semaphore可以设置为公平模式（FIFO），通过在构造函数中传入 true，确保线程按请求顺序获取许可：\",\"Semaphore parkingLot = new Semaphore(3, true); \",\"中断：acquire 方法响应中断，如果线程在等待许可时被中断，会抛出 InterruptedException。\",\"tryAcquire 方法：尝试获取许可但不阻塞，有多种重载形式：\",\"boolean acquired = parkingLot.tryAcquire(); boolean acquiredWithTimeout = parkingLot.tryAcquire(1, TimeUnit.SECONDS); \",\"使用 Semaphore 可以有效控制对资源的并发访问，确保系统资源的有效利用和安全性\"]},\"360\":{\"h\":\"Exchanger 了解吗？\",\"t\":[\"Exchanger 是 Java 中的一个同步辅助类，专门用于在两个线程之间交换数据。它的主要应用场景包括：\",\"双线程数据交换：两个线程需要在某个点交换数据，如生产者和消费者模式中的数据交换。\",\"任务分配与结果收集：一个线程生成任务，另一个线程处理任务并返回结果。\",\"资源双向传递：两个线程互相传递数据或资源，如双缓冲区交换。\"]},\"361\":{\"h\":\"代码示例\",\"t\":[\"以下是一个简单的 Exchanger 使用示例，模拟两个线程之间的数据交换：\",\"import java.util.concurrent.Exchanger; public class ExchangerExample { public static void main(String[] args) { // 创建一个Exchanger实例 Exchanger<String> exchanger = new Exchanger<>(); // 创建并启动两个线程 new Thread(new Producer(exchanger), \\\"生产者\\\").start(); new Thread(new Consumer(exchanger), \\\"消费者\\\").start(); } static class Producer implements Runnable { private Exchanger<String> exchanger; public Producer(Exchanger<String> exchanger) { this.exchanger = exchanger; } @Override public void run() { try { String data = \\\"生产的数据\\\"; System.out.println(Thread.currentThread().getName() + \\\" 生产了数据：\\\" + data); // 与消费者交换数据 String response = exchanger.exchange(data); System.out.println(Thread.currentThread().getName() + \\\" 收到消费者的数据：\\\" + response); } catch (InterruptedException e) { e.printStackTrace(); } } } static class Consumer implements Runnable { private Exchanger<String> exchanger; public Consumer(Exchanger<String> exchanger) { this.exchanger = exchanger; } @Override public void run() { try { String data = \\\"消费者处理的数据\\\"; // 接收生产者的数据并返回处理后的数据 String received = exchanger.exchange(data); System.out.println(Thread.currentThread().getName() + \\\" 接收到生产者的数据：\\\" + received); System.out.println(Thread.currentThread().getName() + \\\" 处理后数据：\\\" + data); } catch (InterruptedException e) { e.printStackTrace(); } } } } \"]},\"362\":{\"h\":\"解释\",\"t\":[\"Exchanger：一个用于在两个线程之间交换数据的同步点。通过 exchange 方法，两个线程可以交换数据，并且这两个线程在此方法处阻塞，直到对方也到达此同步点。\",\"Producer 类：模拟生产者线程，生成数据并与消费者交换。\",\"Consumer 类：模拟消费者线程，准备处理数据并与生产者交换。\",\"exchange() 方法：线程调用此方法进行数据交换，该方法会阻塞，直到另一个线程也调用 exchange 方法。\"]},\"363\":{\"h\":\"重要注意事项\",\"t\":[\"成对使用：Exchanger 是为成对线程设计的，如果有一个线程没有配对线程来交换数据，那么它会一直阻塞。\",\"超时机制：exchange 方法有带超时参数的重载形式，可以指定最大等待时间：\",\"String response = exchanger.exchange(data, 1, TimeUnit.SECONDS); \",\"中断处理：如果线程在等待交换数据时被中断，会抛出 InterruptedException。\",\"Exchanger 可以简化两个线程之间的数据交换逻辑，确保交换操作是同步和线程安全的，非常适合需要双向数据传递的场景。\",\"应用场景\",\"遗传算法 \",\"Exchanger可以用于遗传算法，遗传算法里需要选出两个人作为交配对象，这时候会交换两人的数据，并使用交叉规则得出2个交配结果\",\"校对工作 \",\"Exchanger也可以用于校对工作，比如我们需要将纸制银行流水通过人工的方式录入成电子银行流水，为了避免错误，采用AB岗两人进行录入，录入到Excel之后，系统需要加载这两个Excel，并对两个Excel数据进行校对，看看是否录入一致\"]},\"364\":{\"h\":\"说说你对CompletableFuture的理解？\"},\"365\":{\"h\":\"1. 引言\",\"t\":[\"CompletableFuture 是Java 8引入的一个异步编程工具类，用于处理异步任务的结果和执行流程。它提供了一种简洁而强大的方式来处理异步操作，包括任务的串行执行、并行执行、组合以及异常处理等\"]},\"366\":{\"h\":\"2. 基本概念\"},\"367\":{\"h\":\"2.1 创建 CompletableFuture\",\"t\":[\"你可以使用静态工厂方法来创建 CompletableFuture 对象：\",\"supplyAsync：用于执行有返回值的异步任务。\",\"runAsync：用于执行没有返回值的异步任务。\",\"CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> { // 任务逻辑 return \\\"结果\\\"; }); CompletableFuture<Void> future = CompletableFuture.runAsync(() -> { // 任务逻辑 }); \"]},\"368\":{\"h\":\"3. 任务完成后的回调\"},\"369\":{\"h\":\"3.1 thenApply\",\"t\":[\"用于在任务完成后，对结果进行处理并返回新的结果。\",\"CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> \\\"Hello\\\") .thenApply(result -> result + \\\" World\\\"); \"]},\"370\":{\"h\":\"3.2 thenAccept\",\"t\":[\"用于在任务完成后，消费结果但不返回新的结果。\",\"CompletableFuture.supplyAsync(() -> \\\"Hello\\\") .thenAccept(result -> System.out.println(result)); \"]},\"371\":{\"h\":\"3.3 thenRun\",\"t\":[\"用于在任务完成后执行一个没有返回值的操作。\",\"CompletableFuture.supplyAsync(() -> \\\"Hello\\\") .thenRun(() -> System.out.println(\\\"任务完成\\\")); \"]},\"372\":{\"h\":\"4. 组合多个 CompletableFuture\"},\"373\":{\"h\":\"4.1 thenCompose\",\"t\":[\"用于在一个 CompletableFuture 完成后，启动另一个 CompletableFuture。\",\"CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> \\\"Hello\\\") .thenCompose(result -> CompletableFuture.supplyAsync(() -> result + \\\" World\\\")); \"]},\"374\":{\"h\":\"4.2 thenCombine\",\"t\":[\"用于将两个独立的 CompletableFuture 的结果进行合并。\",\"CompletableFuture<String> future1 = CompletableFuture.supplyAsync(() -> \\\"Hello\\\"); CompletableFuture<String> future2 = CompletableFuture.supplyAsync(() -> \\\" World\\\"); CompletableFuture<String> resultFuture = future1.thenCombine(future2, (result1, result2) -> result1 + result2); \"]},\"375\":{\"h\":\"4.3 allOf\",\"t\":[\"用于等待所有给定的 CompletableFuture 完成。\",\"CompletableFuture<String> future1 = CompletableFuture.supplyAsync(() -> \\\"结果1\\\"); CompletableFuture<String> future2 = CompletableFuture.supplyAsync(() -> \\\"结果2\\\"); CompletableFuture<String> future3 = CompletableFuture.supplyAsync(() -> \\\"结果3\\\"); CompletableFuture<Void> allOf = CompletableFuture.allOf(future1, future2, future3); allOf.thenAccept(v -> { try { String result1 = future1.get(); String result2 = future2.get(); String result3 = future3.get(); System.out.println(result1 + \\\", \\\" + result2 + \\\", \\\" + result3); } catch (InterruptedException | ExecutionException e) { e.printStackTrace(); } }); \"]},\"376\":{\"h\":\"5. 处理异常\"},\"377\":{\"h\":\"5.1 exceptionally\",\"t\":[\"用于在异步任务发生异常时提供一个默认值。\",\"CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> { if (Math.random() > 0.5) { throw new RuntimeException(\\\"发生异常\\\"); } return \\\"成功\\\"; }).exceptionally(ex -> \\\"默认值\\\"); \"]},\"378\":{\"h\":\"5.2 handle\",\"t\":[\"用于在异步任务完成或发生异常时对结果进行处理。\",\"CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> { if (Math.random() > 0.5) { throw new RuntimeException(\\\"发生异常\\\"); } return \\\"成功\\\"; }).handle((result, ex) -> { if (ex != null) { return \\\"异常处理后的默认值\\\"; } return result; }); \"]},\"379\":{\"h\":\"6. 超时控制\"},\"380\":{\"h\":\"6.1 orTimeout\",\"t\":[\"用于为异步操作设定超时。\",\"CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> { try { Thread.sleep(3000); } catch (InterruptedException e) { throw new IllegalStateException(e); } return \\\"结果\\\"; }).orTimeout(2, TimeUnit.SECONDS); \"]},\"381\":{\"h\":\"6.2 completeOnTimeout\",\"t\":[\"用于在超时时返回默认值。\",\"CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> { try { Thread.sleep(3000); } catch (InterruptedException e) { throw new IllegalStateException(e); } return \\\"结果\\\"; }).completeOnTimeout(\\\"超时默认值\\\", 2, TimeUnit.SECONDS); \"]},\"382\":{\"h\":\"7. 并行执行多个任务\"},\"383\":{\"h\":\"示例\",\"t\":[\"import java.util.concurrent.CompletableFuture; import java.util.concurrent.ExecutionException; import java.util.List; import java.util.stream.Collectors; public class CompletableFutureParallelExample { public static void main(String[] args) { // 定义三个异步任务 CompletableFuture<String> future1 = CompletableFuture.supplyAsync(() -> { try { Thread.sleep(1000); // 模拟耗时操作 } catch (InterruptedException e) { throw new IllegalStateException(e); } return \\\"结果1\\\"; }); CompletableFuture<String> future2 = CompletableFuture.supplyAsync(() -> { try { Thread.sleep(2000); // 模拟耗时操作 } catch (InterruptedException e) { throw new IllegalStateException(e); } return \\\"结果2\\\"; }); CompletableFuture<String> future3 = CompletableFuture.supplyAsync(() -> { try { Thread.sleep(3000); // 模拟耗时操作 } catch (InterruptedException e) { throw new IllegalStateException(e); } return \\\"结果3\\\"; }); // 创建一个包含所有异步任务的CompletableFuture CompletableFuture<Void> allOf = CompletableFuture.allOf(future1, future2, future3); // 在所有任务完成后处理结果 allOf.thenAccept(v -> { List<String> results = List.of(future1, future2, future3).stream() .map(future -> { try { return future.get(); } catch (InterruptedException | ExecutionException e) { throw new IllegalStateException(e); } }) .collect(Collectors.toList()); // 处理所有结果 results.forEach(result -> System.out.println(\\\"任务完成，结果: \\\" + result)); }).join(); // 等待所有任务完成 System.out.println(\\\"主线程继续执行其他操作...\\\"); } } \"]},\"384\":{\"h\":\"8. 真实场景应用\"},\"385\":{\"h\":\"8.1 并行获取数据\",\"t\":[\"以下示例展示如何并行获取多个远程数据源的数据，并在所有数据获取完成后进行处理。\",\"import java.util.concurrent.CompletableFuture; import java.util.concurrent.ExecutionException; import java.util.List; import java.util.stream.Collectors; public class CompletableFutureRealWorldExample { public static void main(String[] args) { CompletableFuture<String> future1 = fetchDataFromService1(); CompletableFuture<String> future2 = fetchDataFromService2(); CompletableFuture<String> future3 = fetchDataFromService3(); CompletableFuture<Void> allOf = CompletableFuture.allOf(future1, future2, future3); allOf.thenAccept(v -> { try { String result1 = future1.get(); String result2 = future2.get(); String result3 = future3.get(); // 合并结果 String finalResult = result1 + \\\", \\\" + result2 + \\\", \\\" + result3; System.out.println(\\\"最终结果: \\\" + finalResult); } catch (InterruptedException | ExecutionException e) { e.printStackTrace(); } }).join(); // 等待所有任务完成 } private static CompletableFuture<String> fetchDataFromService1() { return CompletableFuture.supplyAsync(() -> { // 模拟远程调用 try { Thread.sleep(1000); } catch (InterruptedException e) { throw new IllegalStateException(e); } return \\\"Service1数据\\\"; }); } private static CompletableFuture<String> fetchDataFromService2() { return CompletableFuture.supplyAsync(() -> { // 模拟远程调用 try { Thread.sleep(2000); } catch (InterruptedException e) { throw new IllegalStateException(e); } return \\\"Service2数据\\\"; }); } private static CompletableFuture<String> fetchDataFromService3() { return CompletableFuture.supplyAsync(() -> { // 模拟远程调用 try { Thread.sleep(3000); } catch (InterruptedException e) { throw new IllegalStateException(e); } return \\\"Service3数据\\\"; }); } } \"]},\"386\":{\"h\":\"9. 总结\",\"t\":[\"CompletableFuture 提供了一种简洁而强大的方式来处理异\"]},\"387\":{\"h\":\"CompletableFuture的线程池设置？\",\"t\":[\"CompletableFuture 使用 ForkJoinPool.commonPool() 作为默认线程池来执行异步任务，但你可以指定自定义的线程池来满足特殊需求，如提高性能或控制资源使用。以下是如何设置和使用自定义线程池的详细指南。\"]},\"388\":{\"h\":\"1. 使用默认线程池\",\"t\":[\"默认情况下，CompletableFuture 使用 ForkJoinPool.commonPool()。这对于大多数情况已经足够，但在需要更多控制或资源隔离时，可以使用自定义线程池。\",\"CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> { // 异步任务逻辑 return \\\"结果\\\"; }); \"]},\"389\":{\"h\":\"2. 指定自定义线程池\",\"t\":[\"你可以使用 CompletableFuture.supplyAsync 或 CompletableFuture.runAsync 方法的重载版本来指定自定义的线程池。\"]},\"390\":{\"h\":\"2.1 创建自定义线程池\",\"t\":[\"首先，创建一个自定义线程池。你可以使用 Executors 工具类来创建不同类型的线程池：\",\"import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; ExecutorService customThreadPool = Executors.newFixedThreadPool(10); // 创建一个固定大小的线程池 \"]},\"391\":{\"h\":\"2.2 使用自定义线程池\",\"t\":[\"然后，将自定义线程池传递给 CompletableFuture：\",\"CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> { // 异步任务逻辑 return \\\"结果\\\"; }, customThreadPool); \"]},\"392\":{\"h\":\"3. 完整示例\",\"t\":[\"以下是一个完整的示例，展示如何使用自定义线程池执行异步任务：\",\"import java.util.concurrent.CompletableFuture; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.TimeUnit; public class CustomThreadPoolExample { public static void main(String[] args) { // 创建自定义线程池 ExecutorService customThreadPool = Executors.newFixedThreadPool(10); // 提交异步任务并使用自定义线程池 CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> { try { Thread.sleep(1000); // 模拟耗时操作 } catch (InterruptedException e) { throw new IllegalStateException(e); } return \\\"结果\\\"; }, customThreadPool); // 注册回调处理结果 future.thenAccept(result -> System.out.println(\\\"异步任务完成，结果: \\\" + result)); // 主线程继续执行其他操作 System.out.println(\\\"主线程继续执行其他操作...\\\"); // 关闭线程池 customThreadPool.shutdown(); try { if (!customThreadPool.awaitTermination(800, TimeUnit.MILLISECONDS)) { customThreadPool.shutdownNow(); } } catch (InterruptedException e) { customThreadPool.shutdownNow(); } } } \"]},\"393\":{\"h\":\"4. 线程池类型\"},\"394\":{\"h\":\"4.1 固定大小线程池\",\"t\":[\"适用于已知固定数量的并发任务：\",\"ExecutorService fixedThreadPool = Executors.newFixedThreadPool(10); \"]},\"395\":{\"h\":\"4.2 缓存线程池\",\"t\":[\"适用于大量短生命周期的并发任务，线程池大小根据需要动态调整：\",\"ExecutorService cachedThreadPool = Executors.newCachedThreadPool(); \"]},\"396\":{\"h\":\"4.3 单线程池\",\"t\":[\"适用于需要顺序执行任务的场景：\",\"ExecutorService singleThreadPool = Executors.newSingleThreadExecutor(); \"]},\"397\":{\"h\":\"4.4 调度线程池\",\"t\":[\"适用于需要定期执行任务的场景：\",\"ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(5); \"]},\"398\":{\"h\":\"5. 异步任务链中的线程池\",\"t\":[\"你还可以在异步任务链中的不同部分使用不同的线程池：\",\"ExecutorService pool1 = Executors.newFixedThreadPool(5); ExecutorService pool2 = Executors.newCachedThreadPool(); CompletableFuture.supplyAsync(() -> { // 使用 pool1 执行异步任务 return \\\"任务1结果\\\"; }, pool1).thenApplyAsync(result -> { // 使用 pool2 处理结果 return result + \\\" 经过处理\\\"; }, pool2).thenAcceptAsync(result -> { System.out.println(\\\"最终结果: \\\" + result); // 可以不指定线程池，则使用默认的 ForkJoinPool.commonPool() }); \",\"通过设置自定义线程池，你可以更好地控制 CompletableFuture 的并发行为，满足不同应用场景的需求。\"]},\"399\":{\"h\":\"并发队列\"},\"400\":{\"h\":\"说说阻塞队列是怎么实现的？\",\"t\":[\"阻塞队列是一种特殊的队列数据结构，在多线程编程中起着重要作用。它允许多个线程在队列为空或者队列已满时进行阻塞等待，从而实现线程之间的同步与通信。阻塞队列的实现通常基于经典的队列数据结构，如数组或者链表，并结合了锁和条件等待机制来实现线程的阻塞和唤醒。\",\"下面是阻塞队列的基本实现原理：\",\"队列数据结构： 阻塞队列基于数组或链表等数据结构实现，用于存储元素。常见的阻塞队列有 ArrayBlockingQueue、LinkedBlockingQueue 等。\",\"锁和条件等待： 阻塞队列内部通常使用锁和条件等待来实现线程的阻塞和唤醒。当队列为空时，试图从队列中取出元素的线程会被阻塞，直到队列非空；当队列已满时，试图向队列中添加元素的线程会被阻塞，直到队列有空闲位置。\",\"线程阻塞和唤醒机制： 在队列为空或已满时，等待队列状态改变的线程会进入等待状态，释放锁并进入等待队列。当有其他线程向队列中添加或取出元素时，会触发条件变量的通知操作，唤醒等待队列中的线程。\",\"线程安全性： 阻塞队列需要保证在多线程环境下的线程安全性。因此，在对队列进行添加或移除元素的操作时，需要使用锁来保护对队列数据结构的访问，从而确保操作的原子性和线程安全性。\",\"总的来说，阻塞队列通过结合队列数据结构、锁和条件等待机制，实现了多线程环境下的线程安全、阻塞和唤醒操作，从而为多线程编程提供了便利和高效的同步与通信机制。\"]},\"401\":{\"h\":\"线程池\"},\"402\":{\"h\":\"什么是线程池？\",\"t\":[\"线程池是一种管理和控制多个线程并发执行的机制，旨在提高性能并优化资源使用。线程池通过预先创建一组线程，避免了频繁创建和销毁线程的开销，从而提高了系统效率。\"]},\"403\":{\"h\":\"1. 线程池的基本概念\",\"t\":[\"线程复用：线程池在初始化时创建一定数量的线程，这些线程在处理完一个任务后不会被销毁，而是被重用来处理下一个任务。\",\"任务队列：当所有线程都在忙碌时，新的任务会被放入一个队列中等待执行。\",\"线程管理：线程池会自动管理线程的生命周期，如创建新线程、回收空闲线程等。\"]},\"404\":{\"h\":\"2. 线程池的优势\",\"t\":[\"提高性能：减少了频繁创建和销毁线程的开销。\",\"资源控制：可以限制并发线程的数量，防止系统资源耗尽。\",\"简化编程：提供了统一的接口来管理和调度线程，简化了并发编程的复杂性。\"]},\"405\":{\"h\":\"3. Java中的线程池实现\",\"t\":[\"Java通过java.util.concurrent包提供了多种线程池实现，主要通过Executors工具类来创建。\"]},\"406\":{\"h\":\"3.1 常见的线程池类型\",\"t\":[\"FixedThreadPool：固定大小的线程池，适用于已知线程数固定的场景。\",\"ExecutorService fixedThreadPool = Executors.newFixedThreadPool(10); \",\"CachedThreadPool：根据需要创建新线程的线程池，但在空闲时会重用先前创建的线程，适用于大量短生命周期任务。\",\"ExecutorService cachedThreadPool = Executors.newCachedThreadPool(); \",\"SingleThreadExecutor：单线程线程池，适用于需要顺序执行任务的场景。\",\"ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor(); \",\"ScheduledThreadPool：定时或周期性执行任务的线程池。\",\"ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(5); \"]},\"407\":{\"h\":\"4. 线程池的使用示例\",\"t\":[\"以下是一个使用固定大小线程池执行多个任务的示例：\",\"import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.TimeUnit; public class ThreadPoolExample { public static void main(String[] args) { // 创建一个固定大小的线程池 ExecutorService executor = Executors.newFixedThreadPool(5); // 提交多个任务 for (int i = 0; i < 10; i++) { final int index = i; executor.submit(() -> { try { System.out.println(\\\"任务 \\\" + index + \\\" 由线程 \\\" + Thread.currentThread().getName() + \\\" 执行\\\"); Thread.sleep(2000); // 模拟任务执行 } catch (InterruptedException e) { Thread.currentThread().interrupt(); } }); } // 关闭线程池 executor.shutdown(); try { if (!executor.awaitTermination(60, TimeUnit.SECONDS)) { executor.shutdownNow(); } } catch (InterruptedException e) { executor.shutdownNow(); } } } \"]},\"408\":{\"h\":\"5. 线程池的配置参数\",\"t\":[\"线程池的配置参数影响其行为和性能，常见参数包括：\",\"corePoolSize：核心线程数，线程池维护的最小线程数。\",\"maximumPoolSize：最大线程数，线程池能够创建的最大线程数。\",\"keepAliveTime：空闲线程的存活时间，当线程池中的线程数超过核心线程数时，多余的空闲线程在终止前等待新任务的最长时间。\",\"workQueue：任务队列，用于保存等待执行的任务。\"]},\"409\":{\"h\":\"6. 自定义线程池\",\"t\":[\"你可以使用ThreadPoolExecutor来创建自定义线程池，以更灵活地控制线程池的行为：\",\"import java.util.concurrent.ArrayBlockingQueue; import java.util.concurrent.ThreadPoolExecutor; import java.util.concurrent.TimeUnit; public class CustomThreadPoolExample { public static void main(String[] args) { // 创建自定义线程池 ThreadPoolExecutor executor = new ThreadPoolExecutor( 5, // corePoolSize 10, // maximumPoolSize 60, // keepAliveTime TimeUnit.SECONDS, // keepAliveTime单位 new ArrayBlockingQueue<>(100) // workQueue ); // 提交多个任务 for (int i = 0; i < 10; i++) { final int index = i; executor.submit(() -> { try { System.out.println(\\\"任务 \\\" + index + \\\" 由线程 \\\" + Thread.currentThread().getName() + \\\" 执行\\\"); Thread.sleep(2000); // 模拟任务执行 } catch (InterruptedException e) { Thread.currentThread().interrupt(); } }); } // 关闭线程池 executor.shutdown(); try { if (!executor.awaitTermination(60, TimeUnit.SECONDS)) { executor.shutdownNow(); } } catch (InterruptedException e) { executor.shutdownNow(); } } } \",\"通过自定义线程池，你可以精细控制线程池的各种参数，以满足不同应用场景的需求。\"]},\"410\":{\"h\":\"为什么说频繁创建和销毁线程的开销大？\",\"t\":[\"频繁创建和销毁线程的开销大，主要是因为线程的创建和销毁涉及操作系统和JVM层面的多种资源管理和调度。具体来说，有以下几个原因：\"]},\"411\":{\"h\":\"1. 系统资源消耗\"},\"412\":{\"h\":\"1.1 内存开销\",\"t\":[\"每个线程在创建时需要分配内存，用于其堆栈空间和线程本地存储（Thread Local Storage）。默认情况下，在典型的JVM中，每个线程的堆栈大小可能是1MB或者更大。频繁创建和销毁线程会导致内存分配和释放操作的频繁发生，从而增加内存管理的开销。\"]},\"413\":{\"h\":\"1.2 操作系统资源\",\"t\":[\"操作系统为每个线程分配了一些内核对象和数据结构，这些结构用于线程调度和管理。频繁创建和销毁线程会导致操作系统不断地创建和销毁这些内核对象，增加了系统调用的开销。\"]},\"414\":{\"h\":\"2. CPU消耗\"},\"415\":{\"h\":\"2.1 线程上下文切换\",\"t\":[\"操作系统通过线程调度器在多个线程之间切换执行。每次切换执行线程时，需要保存当前线程的状态（寄存器、程序计数器等），然后恢复即将执行线程的状态。频繁的线程创建和销毁会增加上下文切换的次数，从而增加CPU的负担。\"]},\"416\":{\"h\":\"2.2 同步开销\",\"t\":[\"线程的创建和销毁需要在操作系统和JVM内部进行同步，以确保线程状态的一致性。这些同步操作会导致锁的竞争和开销，降低系统性能。\"]},\"417\":{\"h\":\"3. JVM的开销\"},\"418\":{\"h\":\"3.1 垃圾回收\",\"t\":[\"频繁创建和销毁线程会导致大量短生命周期的对象被创建，例如线程对象、任务对象等。这些短生命周期的对象会加大垃圾回收的压力，频繁的垃圾回收会导致应用程序的性能下降。\"]},\"419\":{\"h\":\"3.2 JIT优化\",\"t\":[\"JVM中的即时编译器（JIT）会对热点代码进行优化，但频繁的线程创建和销毁会导致代码路径的变化，从而影响JIT的优化效果。\"]},\"420\":{\"h\":\"能说说工作中线程池的应用吗？\",\"t\":[\"线程池在实际工作中有着广泛的应用，特别是在高并发和需要处理大量任务的场景中。以下是线程池在各种工作场景中的一些典型应用：\"]},\"421\":{\"h\":\"1. Web服务器\"},\"422\":{\"h\":\"场景描述\",\"t\":[\"Web服务器需要处理大量的客户端请求。每个请求可能涉及复杂的处理逻辑，包括数据库访问、文件操作和计算等。频繁地为每个请求创建和销毁线程将导致性能瓶颈。\"]},\"423\":{\"h\":\"解决方案\",\"t\":[\"通过使用线程池，Web服务器可以预先创建一组线程来处理请求。线程池中的线程会在处理完一个请求后立即准备处理下一个请求，从而减少了线程创建和销毁的开销。\"]},\"424\":{\"h\":\"代码示例\",\"t\":[\"以下是一个使用线程池处理HTTP请求的简单示例：\",\"import java.io.IOException; import java.net.ServerSocket; import java.net.Socket; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; public class SimpleWebServer { private final ExecutorService threadPool; public SimpleWebServer(int port, int poolSize) throws IOException { ServerSocket serverSocket = new ServerSocket(port); threadPool = Executors.newFixedThreadPool(poolSize); while (true) { Socket clientSocket = serverSocket.accept(); threadPool.submit(() -> handleRequest(clientSocket)); } } private void handleRequest(Socket clientSocket) { // 处理请求逻辑 } public static void main(String[] args) throws IOException { new SimpleWebServer(8080, 10); // 端口8080，线程池大小为10 } } \"]},\"425\":{\"h\":\"2. 数据库连接池\"},\"426\":{\"h\":\"场景描述\",\"t\":[\"数据库操作通常是IO密集型的，需要消耗较多的时间。频繁地创建和销毁数据库连接会导致性能下降和资源浪费。\"]},\"427\":{\"h\":\"解决方案\",\"t\":[\"通过使用数据库连接池，应用程序可以复用一组数据库连接，减少连接创建和销毁的开销，并提高数据库操作的效率。\"]},\"428\":{\"h\":\"代码示例\",\"t\":[\"以Apache Commons DBCP为例，使用连接池管理数据库连接：\",\"import org.apache.commons.dbcp2.BasicDataSource; import java.sql.Connection; import java.sql.PreparedStatement; import java.sql.ResultSet; import java.sql.SQLException; public class DatabaseConnectionPoolExample { public static void main(String[] args) { BasicDataSource dataSource = new BasicDataSource(); dataSource.setUrl(\\\"jdbc:mysql://localhost:3306/mydatabase\\\"); dataSource.setUsername(\\\"username\\\"); dataSource.setPassword(\\\"password\\\"); dataSource.setMinIdle(5); dataSource.setMaxIdle(10); dataSource.setMaxOpenPreparedStatements(100); try (Connection conn = dataSource.getConnection(); PreparedStatement stmt = conn.prepareStatement(\\\"SELECT * FROM mytable\\\"); ResultSet rs = stmt.executeQuery()) { while (rs.next()) { System.out.println(\\\"Column 1: \\\" + rs.getString(1)); } } catch (SQLException e) { e.printStackTrace(); } } } \"]},\"429\":{\"h\":\"3. 并行数据处理\"},\"430\":{\"h\":\"场景描述\",\"t\":[\"在大数据处理和计算任务中，数据处理通常可以并行化以提高效率。例如，处理大型数据集时，可以将数据分割成多个块，并行处理每个块。\"]},\"431\":{\"h\":\"解决方案\",\"t\":[\"通过使用线程池，可以并行处理数据块，充分利用多核CPU的优势，提高数据处理的速度。\"]},\"432\":{\"h\":\"代码示例\",\"t\":[\"以下是一个使用线程池并行处理数据块的示例：\",\"import java.util.Arrays; import java.util.List; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.TimeUnit; public class ParallelDataProcessingExample { public static void main(String[] args) { List<Integer> data = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10); ExecutorService executor = Executors.newFixedThreadPool(4); for (Integer item : data) { executor.submit(() -> process(item)); } executor.shutdown(); try { if (!executor.awaitTermination(60, TimeUnit.SECONDS)) { executor.shutdownNow(); } } catch (InterruptedException e) { executor.shutdownNow(); } } private static void process(Integer item) { System.out.println(\\\"Processing item: \\\" + item + \\\" by \\\" + Thread.currentThread().getName()); try { Thread.sleep(1000); // 模拟处理时间 } catch (InterruptedException e) { Thread.currentThread().interrupt(); } } } \"]},\"433\":{\"h\":\"4. 异步任务执行\"},\"434\":{\"h\":\"场景描述\",\"t\":[\"在许多应用中，需要执行一些异步任务，例如发送邮件、日志记录、文件上传等。这些任务不需要立即完成，可以在后台执行。\"]},\"435\":{\"h\":\"解决方案\",\"t\":[\"通过使用线程池，可以将异步任务提交到线程池中执行，主线程可以继续处理其他工作。\"]},\"436\":{\"h\":\"代码示例\",\"t\":[\"以下是一个使用线程池执行异步任务的示例：\",\"import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; public class AsyncTaskExample { public static void main(String[] args) { ExecutorService executor = Executors.newFixedThreadPool(5); // 提交异步任务 executor.submit(() -> { sendEmail(\\\"user@example.com\\\"); }); // 主线程继续执行其他操作 System.out.println(\\\"主线程继续执行其他操作...\\\"); executor.shutdown(); } private static void sendEmail(String recipient) { System.out.println(\\\"发送邮件给: \\\" + recipient); try { Thread.sleep(2000); // 模拟发送邮件时间 } catch (InterruptedException e) { Thread.currentThread().interrupt(); } System.out.println(\\\"邮件发送完成\\\"); } } \"]},\"437\":{\"h\":\"5. 定时任务\"},\"438\":{\"h\":\"场景描述\",\"t\":[\"需要定期执行一些任务，例如清理临时文件、定时备份数据库等。\"]},\"439\":{\"h\":\"解决方案\",\"t\":[\"通过使用ScheduledThreadPoolExecutor，可以调度定时任务，在指定时间或周期性执行。\"]},\"440\":{\"h\":\"代码示例\",\"t\":[\"以下是一个使用调度线程池执行定时任务的示例：\",\"import java.util.concurrent.Executors; import java.util.concurrent.ScheduledExecutorService; import java.util.concurrent.TimeUnit; public class ScheduledTaskExample { public static void main(String[] args) { ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1); // 定期执行任务，每隔5秒执行一次 scheduler.scheduleAtFixedRate(() -> { System.out.println(\\\"执行定时任务: \\\" + System.currentTimeMillis()); }, 0, 5, TimeUnit.SECONDS); // 关闭调度器 Runtime.getRuntime().addShutdownHook(new Thread(() -> { scheduler.shutdown(); try { if (!scheduler.awaitTermination(60, TimeUnit.SECONDS)) { scheduler.shutdownNow(); } } catch (InterruptedException e) { scheduler.shutdownNow(); } })); } } \"]},\"441\":{\"h\":\"能简单说一下线程池的工作流程吗？\",\"t\":[\"线程池的工作流程可以分为以下几个步骤：初始化、任务提交、任务执行和资源回收。了解这些步骤有助于理解线程池如何管理线程和任务，提高并发编程的效率和资源利用率。\"]},\"442\":{\"h\":\"1. 线程池初始化\",\"t\":[\"线程池在初始化时，会根据配置参数创建一定数量的核心线程，并准备好任务队列。这些参数通常包括核心线程数（corePoolSize）、最大线程数（maximumPoolSize）、空闲线程存活时间（keepAliveTime）和任务队列（workQueue）等。\",\"ExecutorService executor = new ThreadPoolExecutor( 5, // corePoolSize 10, // maximumPoolSize 60L, // keepAliveTime TimeUnit.SECONDS, // 时间单位 new LinkedBlockingQueue<Runnable>() // 任务队列 ); \"]},\"443\":{\"h\":\"2. 任务提交\",\"t\":[\"任务可以通过execute()或submit()方法提交到线程池。execute()方法提交的任务没有返回值，而submit()方法可以返回一个Future对象，用于获取任务的执行结果。\",\"executor.execute(() -> { // 任务逻辑 }); Future<String> future = executor.submit(() -> { // 任务逻辑 return \\\"任务结果\\\"; }); \"]},\"444\":{\"h\":\"3. 任务执行\",\"t\":[\"当一个任务被提交到线程池后，线程池按照以下顺序处理任务：\",\"空闲核心线程执行任务：如果有空闲的核心线程，则直接由核心线程执行任务。\",\"任务加入队列：如果没有空闲的核心线程且任务队列未满，则将任务放入任务队列等待执行。\",\"创建新线程执行任务：如果任务队列已满且线程数未达到最大线程数，则创建新的非核心线程执行任务。\",\"拒绝策略：如果线程数已达到最大线程数且任务队列已满，则根据设置的拒绝策略处理新任务。常见的拒绝策略包括抛出异常、丢弃任务、丢弃队列最前的任务和由调用线程执行任务。\"]},\"445\":{\"h\":\"4. 任务执行完成\",\"t\":[\"线程执行任务时，如果任务执行完成且当前线程数超过核心线程数，且空闲时间超过keepAliveTime，该线程将被终止。否则，线程将继续处于空闲状态，准备执行下一个任务。\"]},\"446\":{\"h\":\"5. 线程池关闭\",\"t\":[\"线程池可以通过调用shutdown()或shutdownNow()方法关闭：\",\"shutdown()：停止接受新任务，并在所有已提交任务执行完成后关闭线程池。\",\"shutdownNow()：立即停止所有任务，尝试终止正在执行的任务，并返回未执行的任务列表。\",\"executor.shutdown(); // 优雅关闭 try { if (!executor.awaitTermination(60, TimeUnit.SECONDS)) { executor.shutdownNow(); // 强制关闭 } } catch (InterruptedException e) { executor.shutdownNow(); } \"]},\"447\":{\"h\":\"线程池的完整工作流程\",\"t\":[\"线程池的工作流程如下图所示：\",\"初始化线程池，创建核心线程和任务队列。\",\"任务提交到线程池。\",\"空闲核心线程执行任务；如无空闲核心线程则将任务加入队列；队列已满则创建新线程；达到最大线程数则执行拒绝策略。\",\"任务执行完成，线程空闲或终止。\",\"线程池关闭，停止接受新任务，等待已提交任务完成或立即终止。\",\"这个流程保证了线程资源的高效利用和任务的有效调度，使得线程池成为并发编程中重要的工具。\"]},\"448\":{\"h\":\"线程池主要参数有哪些？\",\"t\":[\"线程池的主要参数包括：\",\"corePoolSize（核心线程数）：线程池中保持活动状态的最小线程数。即使线程处于空闲状态，也不会被回收，除非设置了allowCoreThreadTimeOut。当有新任务提交时，线程池会优先使用核心线程来处理任务。\",\"maximumPoolSize（最大线程数）：线程池中允许存在的最大线程数。当核心线程都在忙碌，并且任务队列已满时，新任务会触发创建额外的线程，直到达到最大线程数。\",\"keepAliveTime（线程空闲时间）：当线程数超过核心线程数时，空闲线程在被终止前等待新任务的最长时间。如果线程空闲时间超过该值，则线程会被终止，直到线程数量等于核心线程数。\",\"TimeUnit（时间单位）：用于指定keepAliveTime的时间单位，通常为秒、分钟等。\",\"workQueue（任务队列）：用于存储等待执行的任务的队列。常见的任务队列包括有界队列（如ArrayBlockingQueue）和无界队列（如LinkedBlockingQueue、SynchronousQueue）。\",\"ThreadFactory（线程工厂）：用于创建新线程的工厂。可以通过自定义ThreadFactory来指定线程的名称、优先级等属性。\",\"RejectedExecutionHandler（拒绝策略）：当任务无法被接受执行时的处理策略。常见的拒绝策略包括抛出异常、丢弃任务、丢弃队列最前的任务和由调用线程执行任务。\",\"这些参数可以根据应用场景的需求进行调整和配置，以优化线程池的性能和资源利用率。\"]},\"449\":{\"h\":\"线程池的拒绝策略有哪些？\",\"t\":[\"线程池的拒绝策略用于定义当线程池无法接受新任务时应该采取的操作。以下是常见的线程池拒绝策略：\",\"AbortPolicy（默认策略）：默认的拒绝策略。当任务无法被执行时，会抛出RejectedExecutionException异常。\",\"CallerRunsPolicy：调用者运行策略。如果线程池无法接受新任务，会在调用线程中直接执行被拒绝的任务。这样做可能会导致调用线程的性能下降，因为调用线程需要承担执行任务的负责。\",\"DiscardPolicy：丢弃策略。当任务无法被执行时，会默默地丢弃被拒绝的任务，不会抛出异常也不会进行任何处理。\",\"DiscardOldestPolicy：丢弃最旧策略。当任务无法被执行时，会丢弃任务队列中最旧的任务，并尝试重新提交当前任务。\",\"可以根据具体的业务需求和系统特性选择合适的拒绝策略，以保证系统的稳定性和可靠性。\"]},\"450\":{\"h\":\"线程池有哪几种工作队列？\",\"t\":[\"线程池通常使用工作队列来存储等待执行的任务。常见的线程池工作队列包括：\",\"无界队列（Unbounded Queue）：无界队列可以存储无限数量的任务，即使线程池中的线程都在忙碌，新任务也可以被放入队列等待执行。常见的无界队列包括LinkedBlockingQueue，它基于链表实现，具有高吞吐量和无限容量的特点。\",\"有界队列（Bounded Queue）：有界队列有限制存储的任务数量，当队列已满时，新任务将被拒绝。有界队列可以有效地控制线程池中任务的数量，防止任务过载。常见的有界队列包括ArrayBlockingQueue，它基于数组实现，具有固定容量的特点。\",\"同步移交队列（Synchronous Transfer Queue）：同步移交队列是一种特殊的队列，它不存储任务，而是将任务直接移交给线程池中的线程进行执行。如果没有空闲线程可用，新任务会被拒绝。常见的同步移交队列包括SynchronousQueue，它实际上不存储任何元素，只是用于线程之间的任务传递。\",\"优先级队列（Priority Queue）：优先级队列根据元素的优先级来决定元素的顺序。在线程池中，可以使用优先级队列来根据任务的优先级高低来执行任务。Java中的PriorityBlockingQueue是一个线程安全的优先级队列实现。\",\"延迟队列（Delay Queue）：延迟队列用于存储延迟执行的任务，即在指定延迟时间之后才能被消费。延迟队列通常用于实现定时任务调度。Java中的Delayed接口和DelayedWorkQueue类用于实现延迟队列。\",\"工作窃取队列（Work Stealing Queue）：工作窃取队列是一种用于并行计算的特殊队列，每个线程都有自己的工作队列，并且可以从其他线程的队列中窃取任务来执行。工作窃取队列通常用于实现任务并行化的线程池。Java中的ForkJoinPool使用工作窃取队列来实现任务的并行执行。\",\"这些不同类型的工作队列具有不同的特性和适用场景，可以根据具体的需求选择合适的队列类型来优化线程池的性能和行为。\"]},\"451\":{\"h\":\"线程池提交execute和submit有什么区别？\",\"t\":[\"在Java的线程池中，execute()和submit()方法都用于向线程池提交任务，但它们之间存在一些区别：\",\"返回值类型：\",\"execute()方法没有返回值，因为它用于提交不需要返回结果的任务。\",\"submit()方法返回一个Future对象，可以用来获取任务的执行结果或者监控任务的执行状态。这使得submit()方法更加灵活，可以处理需要返回结果的任务。\",\"异常处理：\",\"execute()方法无法处理任务执行过程中抛出的异常。如果任务抛出了未捕获的异常，线程池会将其记录下来，但不会通知调用者。\",\"submit()方法可以通过Future对象来捕获任务执行过程中抛出的异常。调用Future对象的get()方法时，如果任务抛出了异常，会将异常包装在ExecutionException中重新抛出，从而让调用者能够捕获和处理异常。\",\"参数类型：\",\"execute()方法接受Runnable接口类型的任务作为参数，这种任务不返回结果。\",\"submit()方法除了接受Runnable接口类型的任务外，还可以接受Callable接口类型的任务作为参数，这种任务可以返回结果。\",\"综上所述，execute()方法用于提交不需要返回结果的任务，而submit()方法则更加灵活，既可以提交不需要返回结果的任务，也可以提交需要返回结果的任务，并且可以处理任务执行过程中抛出的异常。\"]},\"452\":{\"h\":\"线程池怎么关闭知道吗？\",\"t\":[\"线程池的关闭可以通过调用shutdown()方法或shutdownNow()方法来实现。这两种方法都是用来关闭线程池的，但它们之间有一些细微的差别：\",\"shutdown()方法： \",\"shutdown()方法用于平缓地关闭线程池。调用shutdown()方法后，线程池将不再接受新的任务，但会继续执行已提交的任务，直到所有任务执行完毕后才会关闭。\",\"shutdown()方法不会立即停止线程池，而是等待所有已提交的任务执行完成后再关闭线程池。\",\"executor.shutdown(); \",\"shutdownNow()方法： \",\"shutdownNow()方法用于立即关闭线程池。调用shutdownNow()方法后，线程池会尝试停止所有正在执行的任务，并返回未执行的任务列表。\",\"shutdownNow()方法会尝试中断正在执行的任务，以便更快地停止线程池，但并不保证所有任务都能被成功中断。 \",\"它的原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止\",\"executor.shutdownNow(); \",\"在调用了shutdown()或shutdownNow()方法后，可以通过调用awaitTermination()方法来等待线程池关闭，或者通过轮询isTerminated()方法来检查线程池是否已经关闭。\",\"try { if (!executor.awaitTermination(60, TimeUnit.SECONDS)) { executor.shutdownNow(); } } catch (InterruptedException e) { executor.shutdownNow(); } \",\"总之，通过调用shutdown()方法或shutdownNow()方法可以安全地关闭线程池，确保所有任务得到正确处理，并释放线程池所占用的资源。\"]},\"453\":{\"h\":\"线程池的线程数应该怎么配置？\",\"t\":[\"线程池的线程数配置应该根据你的应用场景和需求来决定，需要考虑以下几个因素：\",\"任务的性质：首先要考虑的是你的任务的性质。如果你的任务是CPU密集型的（计算密集型），那么你可能需要配置较少的线程数，因为每个线程都会占用较多的CPU资源。如果你的任务是I/O密集型的（如网络请求、文件操作等），那么你可能需要配置较多的线程数，因为线程在执行任务时会阻塞等待I/O操作的完成。\",\"系统资源：其次要考虑的是你的系统资源。你需要确保你的线程池的线程数不要超过系统资源的限制，包括CPU核心数、内存等。过多的线程可能会导致系统资源的竞争和浪费，从而降低系统的性能和稳定性。\",\"任务执行时间：还需要考虑任务的执行时间。如果你的任务执行时间较长，那么可能需要更多的线程来处理任务队列中的任务，以避免任务等待时间过长。但是，如果线程数过多，可能会导致线程间上下文切换的开销增加，从而降低系统的性能。\",\"任务队列容量：线程池的任务队列也是需要考虑的因素之一。如果任务队列容量较小，那么可能需要配置更多的线程来处理任务，以避免任务被拒绝。反之，如果任务队列容量较大，那么可能可以配置较少的线程来处理任务，减少线程间的竞争。\",\"综上所述，线程池的线程数配置需要根据任务性质、系统资源、任务执行时间和任务队列容量等因素综合考虑。通常情况下，可以通过监控系统资源的使用情况和线程池的运行状态来动态调整线程数配置，以保证线程池的性能和稳定性。\"]},\"454\":{\"h\":\"线程池是怎么实现线程复用的？\",\"t\":[\"核心应该是线程池+任务队列，使线程和队列解耦\",\"在线程池中，一开始会创建一定数量的线程，并将它们放入线程池中。\",\"当有任务需要执行时，可以通过向线程池提交任务的方式，将任务放入任务队列中。\",\"线程池中的线程作为消费者，会不断地从任务队列中取出任务来执行。当线程取出任务后，会执行任务的run()方法。执行完任务后，线程并不会立即销毁，而是回线程池中，继续等待新的任务\",\"这样，线程池中的线程就实现了复用\"]},\"455\":{\"h\":\"有哪几种常见的线程池？\",\"t\":[\"常见的线程池包括以下几种：\",\"FixedThreadPool（固定大小线程池）：\",\"固定大小线程池包含固定数量的线程，线程池中的线程数量不会发生变化。\",\"当有新任务提交时，如果线程池中有空闲的线程，则将任务分配给空闲线程执行；如果线程池中的线程都在执行任务，新任务将在任务队列中等待。\",\"适用于需要限制线程数量的场景，例如并发量稳定的服务器应用。\",\"CachedThreadPool（缓存线程池）：\",\"缓存线程池可以根据需要创建新线程，线程池中的线程数量会根据任务的数量自动调整。\",\"当有新任务提交时，如果线程池中有空闲的线程，则将任务分配给空闲线程执行；如果线程池中的线程都在执行任务，将创建新的线程来处理新任务。\",\"适用于短时任务较多、任务执行时间较短的场景，可以动态调整线程数量以适应任务量的变化。\",\"SingleThreadExecutor（单线程线程池）：\",\"单线程线程池只包含一个线程，所有任务按照顺序在这个线程中执行。\",\"当有新任务提交时，如果线程池中的线程空闲，则将任务分配给该线程执行；如果线程正在执行任务，新任务将在任务队列中等待。\",\"适用于需要保证任务按照顺序执行、不需要并发执行的场景，例如任务依赖性较强的场景。\",\"ScheduledThreadPool（定时任务线程池）：\",\"定时任务线程池用于执行定时任务和周期性任务，可以在指定的时间点执行任务，也可以按照固定的时间间隔执行任务。\",\"通过调用schedule()方法或scheduleAtFixedRate()方法提交定时任务或周期性任务。\",\"适用于需要执行定时任务和周期性任务的场景，例如定时任务调度、定时数据同步等。\"]},\"456\":{\"h\":\"能说一下四种常见线程池的原理吗？\"},\"457\":{\"h\":\"1.FixedThreadPool（固定大小线程池）\",\"t\":[\"// 创建固定大小线程池 public static ExecutorService newFixedThreadPool(int nThreads) { return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>()); } \",\"线程池特点 \",\"核心线程数和最大线程数大小一样\",\"没有所谓的非空闲时间，即keepAliveTime为0\",\"阻塞队列为无界队列LinkedBlockingQueue，可能会导致OOM\",\"工作流程 \",\"提交任务\",\"如果线程数少于核心线程，创建核心线程执行任务\",\"如果线程数等于核心线程，把任务添加到LinkedBlockingQueue阻塞队列\",\"如果线程执行完任务，去阻塞队列取任务，继续执行。\",\"适用场景 \",\"FixedThreadPool 适用于处理CPU密集型的任务，确保CPU在长期被工作线程使用的情况下，尽可能的少的分配线程，即适用执行长期的任务\"]},\"458\":{\"h\":\"2.CachedThreadPool（缓存线程池）\",\"t\":[\"// 创建缓存线程池 public static ExecutorService newCachedThreadPool() { return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue<Runnable>()); } \",\"线程池特点 \",\"核心线程数为0\",\"最大线程数为Integer.MAX_VALUE，即无限大，可能会因为无限创建线程，导致OOM\",\"队列是同步移交队列SynchronousQueue\",\"非核心线程空闲存活时间为60秒\",\"工作流程 \",\"提交任务\",\"因为没有核心线程，所以任务直接加到SynchronousQueue队列\",\"判断是否有空闲线程，如果有，就去取出任务执行\",\"如果没有空闲线程，就新建一个线程执行\",\"执行完任务的线程，还可以存活60秒，如果在这期间，接到任务，可以继续活下去；否则，被销毁\",\"适用场景 \",\"用于并发执行大量短期的小任务\"]},\"459\":{\"h\":\"3.SingleThreadExecutor（单线程线程池）\",\"t\":[\"// 创建单线程线程池 public static ExecutorService newSingleThreadExecutor() { return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>())); } \",\"线程池特点 \",\"核心线程数为1\",\"最大线程数也为1\",\"阻塞队列是无界队列LinkedBlockingQueue，可能会导致OOM\",\"keepAliveTime为0\",\"工作流程 \",\"提交任务\",\"线程池是否有一条线程在，如果没有，新建线程执行任务\",\"如果有，将任务加到阻塞队列\",\"当前的唯一线程，从队列取任务，执行完一个，再继续取，一个线程执行任务\",\"适用场景 \",\"适用于串行执行任务的场景，一个任务一个任务地执行\"]},\"460\":{\"h\":\"4.ScheduledThreadPool（定时任务线程池）\",\"t\":[\"// 创建定时任务线程池 public ScheduledThreadPoolExecutor(int corePoolSize) { super(corePoolSize, Integer.MAX_VALUE, DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS, new DelayedWorkQueue()); } \",\"线程池特点 \",\"最大线程数为Integer.MAX_VALUE，也有OOM的风险\",\"阻塞队列是DelayedWorkQueue\",\"keepAliveTime默认是10\",\"工作流程 \",\"线程从DelayQueue中获取已到期的ScheduledFutureTask（DelayQueue.take()）。\",\"到期任务是指ScheduledFutureTask的time大于等于当前时间\",\"适用场景 \",\"周期性执行任务的场景，需要限制线程数量的场景\"]},\"461\":{\"h\":\"线程池异常怎么处理知道吗？\",\"t\":[\"线程池异常处理是一个常见的问题，特别是在高并发或多线程应用程序中。处理线程池中的异常可以确保程序的稳定性和可靠性。以下是一些处理线程池异常的常见方法和技巧：\"]},\"462\":{\"h\":\"1. 捕获并处理异常\",\"t\":[\"在任务（Runnable 或 Callable）内部捕获并处理异常。这可以防止异常传播到线程池外部，从而避免线程池中的线程因未处理的异常而终止。\",\"ExecutorService executor = Executors.newFixedThreadPool(10); executor.submit(() -> { try { // 任务逻辑 } catch (Exception e) { // 处理异常 e.printStackTrace(); } }); \"]},\"463\":{\"h\":\"2. 自定义线程池\",\"t\":[\"创建一个自定义的线程池，通过覆盖 afterExecute 方法来处理线程执行完毕后的异常。\",\"public class CustomThreadPool extends ThreadPoolExecutor { public CustomThreadPool(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue) { super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue); } @Override protected void afterExecute(Runnable r, Throwable t) { super.afterExecute(r, t); if (t == null && r instanceof Future<?>) { try { Future<?> future = (Future<?>) r; if (future.isDone()) { future.get(); } } catch (CancellationException ce) { t = ce; } catch (ExecutionException ee) { t = ee.getCause(); } catch (InterruptedException ie) { Thread.currentThread().interrupt(); } } if (t != null) { // 处理异常 t.printStackTrace(); } } } \"]},\"464\":{\"h\":\"3. 使用 UncaughtExceptionHandler\",\"t\":[\"设置线程的 UncaughtExceptionHandler，处理未捕获的异常。\",\"ThreadFactory threadFactory = new ThreadFactory() { @Override public Thread newThread(Runnable r) { Thread thread = new Thread(r); thread.setUncaughtExceptionHandler((t, e) -> { // 处理未捕获的异常 e.printStackTrace(); }); return thread; } }; ExecutorService executor = Executors.newFixedThreadPool(10, threadFactory); \"]},\"465\":{\"h\":\"4. 使用自定义 RejectedExecutionHandler\",\"t\":[\"如果任务被拒绝执行，可以通过自定义 RejectedExecutionHandler 来处理异常情况。\",\"RejectedExecutionHandler handler = new RejectedExecutionHandler() { @Override public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) { // 处理被拒绝的任务 System.err.println(\\\"Task rejected: \\\" + r.toString()); } }; ExecutorService executor = new ThreadPoolExecutor(10, 10, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<>(100), handler); \"]},\"466\":{\"h\":\"5. 使用 CompletableFuture 处理异步任务\",\"t\":[\"对于需要处理异步任务的情况，可以使用 CompletableFuture，它提供了更加灵活的异常处理方式。\",\"CompletableFuture.runAsync(() -> { // 任务逻辑 }).exceptionally(e -> { // 处理异常 e.printStackTrace(); return null; }); \"]},\"467\":{\"h\":\"6. 使用 Callable 和 Future\",\"t\":[\"在任务内部使用 Callable，并通过 Future 来捕获和处理异常。\",\"import java.util.concurrent.*; public class FutureExceptionHandling { public static void main(String[] args) { ExecutorService executor = Executors.newFixedThreadPool(10); Callable<Integer> task = () -> { // 任务逻辑 if (true) { throw new Exception(\\\"Callable Exception\\\"); } return 42; }; Future<Integer> future = executor.submit(task); try { Integer result = future.get(); System.out.println(\\\"Task result: \\\" + result); } catch (InterruptedException e) { Thread.currentThread().interrupt(); // 恢复中断状态 e.printStackTrace(); } catch (ExecutionException e) { // 处理任务执行期间抛出的异常 e.getCause().printStackTrace(); } executor.shutdown(); } } \",\"通过这些方法，您可以有效地处理线程池中的异常，确保程序的稳定运行。选择合适的方法取决于您的具体需求和应用场景。\"]},\"468\":{\"h\":\"能说一下线程池有几种状态吗？\",\"t\":[\"线程池（Thread Pool）在执行过程中会经历多个状态，这些状态有助于管理线程池的生命周期和行为。Java 的 ThreadPoolExecutor 类定义了五种线程池状态，每种状态都表示线程池当前的不同运行阶段。以下是详细的线程池状态：\"]},\"469\":{\"h\":\"1. RUNNING\",\"t\":[\"这是线程池的初始状态。在该状态下，线程池可以接受新任务，并处理已经在队列中的任务。\",\"RUNNING \",\"特征：\",\"可以接受新任务。\",\"可以处理队列中的任务。\"]},\"470\":{\"h\":\"2. SHUTDOWN\",\"t\":[\"当调用 shutdown() 方法时，线程池进入 SHUTDOWN 状态。在该状态下，线程池不再接受新任务，但会继续执行已提交的任务和队列中等待的任务。\",\"SHUTDOWN \",\"特征：\",\"不接受新任务。\",\"继续处理已提交和队列中的任务。\"]},\"471\":{\"h\":\"3. STOP\",\"t\":[\"当调用 shutdownNow() 方法时，线程池进入 STOP 状态。在该状态下，线程池不再接受新任务，也不处理队列中的任务，并且会尝试中断正在进行的任务。\",\"STOP \",\"特征：\",\"不接受新任务。\",\"不处理队列中的任务。\",\"尝试中断正在执行的任务。\"]},\"472\":{\"h\":\"4. TIDYING\",\"t\":[\"当线程池在 SHUTDOWN 状态下完成了所有任务，或在 STOP 状态下中断了所有任务后，会进入 TIDYING 状态。在该状态下，线程池中没有活动的线程，且任务队列为空。\",\"TIDYING \",\"特征：\",\"所有任务都已完成。\",\"线程池中没有活动的线程。\"]},\"473\":{\"h\":\"5. TERMINATED\",\"t\":[\"当线程池在 TIDYING 状态下完成终止操作后，会进入 TERMINATED 状态。这是线程池的最终状态，表示线程池已经完全终止。\",\"TERMINATED \",\"特征：\",\"线程池完全终止。\",\"不再有任何活动线程。\"]},\"474\":{\"h\":\"状态转换图\",\"t\":[\"以下是线程池状态的转换图：\"]},\"475\":{\"h\":\"线程池如何实现参数的动态修改？\",\"t\":[\"下面是对答案的一些完善和补充：\",\"使用可调整的线程池（ThreadPoolExecutor）确实是一种常见的方式。通过调用 ThreadPoolExecutor 的构造函数或者提供的方法，可以动态地调整线程池的参数。例如，可以使用 setCorePoolSize()、setMaximumPoolSize()、setQueue() 方法来修改核心线程数、最大线程数以及任务队列等参数。\",\"使用动态代理也是一种有效的方式。通过在代理类中封装线程池，并在代理类中提供方法来动态修改线程池的参数，可以实现更灵活的控制。这种方式可以通过反射机制来实现，但需要一些额外的编码工作。\",\"使用配置文件是一种常见的方式，特别适用于需要频繁调整参数的情况。将线程池的参数配置在外部的配置文件或者配置中心中，可以实现在不修改代码的情况下动态修改线程池的参数。这种方式使得参数的修改更加便捷，并且可以配合其他配置管理工具来实现自动化管理。\",\"使用管理平台是一种更高级的方式，可以提供可视化界面让用户方便地修改线程池的参数，并实时查看线程池的状态和性能指标。管理平台可以根据实际需求提供各种功能，如监控、报警、日志记录等，帮助用户更好地管理线程池。\"]},\"476\":{\"h\":\"线程池调优了解吗？\",\"t\":[\"事前评估： 在上线之前，通过对系统负载、任务类型和处理速度等进行评估，确定合适的线程池配置。这包括确定核心线程数、最大线程数、任务队列类型和大小等参数。评估的目的是为了在上线之前就能够预估系统的负载情况，并针对性地配置线程池，以满足系统的性能需求和稳定性要求。\",\"测试： 在上线之前进行充分的测试，包括功能测试、性能测试、压力测试等。通过测试可以验证线程池的配置是否合理，是否能够满足系统的性能和稳定性要求。如果测试发现线程池存在性能瓶颈或者稳定性问题，需要及时调整配置并重新测试，直到达到预期的效果。\",\"监控机制： 在上线之后建立完善的线程池监控机制，包括监控线程池的运行状态、性能指标、任务执行情况等。监控机制可以帮助及时发现线程池的问题，如线程池过载、任务堆积、线程死锁等，并采取相应的措施进行处理。\",\"告警机制： 结合监控机制建立告警机制，及时发现线程池的异常情况，并发送告警通知给相关人员进行处理。告警机制可以帮助及时发现线程池的问题，避免问题进一步恶化。\",\"事中分析优化： 结合监控告警机制，分析线程池的问题或者可优化点，根据实际情况动态调整线程池的配置。这包括调整核心线程数、最大线程数、任务队列大小等参数，以适应系统的动态变化和优化性能。\",\"事后观察调整： 在线程池上线之后，需要仔细观察线程池的运行情况，随时调整线程池的配置，以确保线程池能够始终保持良好的性能和稳定性。\",\"通过以上评估方案，可以有效地管理和调优线程池的配置，保障系统的性能和稳定性，提高系统的可靠性和可维护性。\"]},\"477\":{\"h\":\"你能设计实现一个线程池吗？\",\"t\":[\"当然可以。以下是一个简单的线程池的设计和实现，包括线程池的初始化、任务提交、线程执行任务、线程池关闭等基本功能：\",\"import java.util.concurrent.BlockingQueue; import java.util.concurrent.LinkedBlockingQueue; public class CustomThreadPool { private final int poolSize; private final WorkerThread[] workers; private final BlockingQueue<Runnable> taskQueue; public CustomThreadPool(int poolSize) { this.poolSize = poolSize; taskQueue = new LinkedBlockingQueue<>(); workers = new WorkerThread[poolSize]; for (int i = 0; i < poolSize; i++) { workers[i] = new WorkerThread(); workers[i].start(); } } public void submit(Runnable task) { try { taskQueue.put(task); } catch (InterruptedException e) { Thread.currentThread().interrupt(); } } public void shutdown() { for (WorkerThread worker : workers) { worker.stopWorker(); } } private class WorkerThread extends Thread { private volatile boolean running = true; @Override public void run() { while (running) { try { Runnable task = taskQueue.take(); task.run(); } catch (InterruptedException e) { running = false; Thread.currentThread().interrupt(); } } } public void stopWorker() { running = false; interrupt(); } } // 测试 public static void main(String[] args) { CustomThreadPool threadPool = new CustomThreadPool(3); // 提交任务 for (int i = 0; i < 5; i++) { final int taskId = i; threadPool.submit(() -> { System.out.println(\\\"Task \\\" + taskId + \\\" is running on thread: \\\" + Thread.currentThread().getName()); try { Thread.sleep(1000); } catch (InterruptedException e) { Thread.currentThread().interrupt(); } System.out.println(\\\"Task \\\" + taskId + \\\" is completed.\\\"); }); } // 关闭线程池 threadPool.shutdown(); } } \",\"这个简单的线程池实现了基本的功能，包括线程池的初始化、任务提交、线程执行任务、线程池关闭等。你可以根据实际需求和场景进一步扩展和优化这个线程池的实现。\"]},\"478\":{\"h\":\"单机线程池执行断电了应该怎么处理？\",\"t\":[\"当单机线程池执行断电时，系统无法继续执行任务，因此需要一些机制来处理这种情况，以确保任务的一致性和可靠性。以下是处理单机线程池断电情况的一般策略：\",\"持久化任务队列： 将任务队列中的任务持久化到可靠的存储介质中，例如数据库、磁盘文件等。这样即使发生断电，任务队列中的任务数据也不会丢失。\",\"事务性执行任务： 在执行任务时，确保任务操作是原子性的，即要么任务执行成功，要么任务执行失败需要回滚。可以使用事务管理的机制来实现这一点。\",\"日志记录和回滚： 在执行任务之前和之后，记录任务的执行日志。当系统发生断电时，根据任务执行日志来回滚已经执行成功但未持久化的任务，以保证任务的一致性和可靠性。\",\"系统重启后的处理： 当系统重新启动时，可以重新加载持久化的任务队列，并根据任务执行日志来恢复任务的执行状态。然后继续执行任务队列中的任务。\",\"综上所述，通过持久化任务队列、事务性执行任务、日志记录和回滚等机制，可以确保单机线程池在断电情况下的任务一致性和可靠性。\"]},\"479\":{\"h\":\"线程池并发调用api，有个调用特别耗时，怎么优化？\",\"t\":[\"当线程池中存在一个调用特别耗时的 API 时，可能会影响到整个线程池的性能和响应速度。为了优化这种情况，可以考虑以下几种策略：\",\"异步调用： 将耗时的 API 调用改为异步调用，即将任务提交到线程池后立即返回，并在后台执行耗时的操作。这样可以避免阻塞线程池中的其他任务，提高线程池的并发能力。\",\"任务拆分： 将耗时的操作拆分为多个小任务，并将这些小任务分配给线程池中的多个线程并行执行。这样可以利用多个线程同时执行任务，提高任务的并发性和执行效率。\",\"限制并发数： 对耗时的 API 调用进行限流，限制同时执行的任务数量，避免线程池中的任务过多导致资源耗尽和性能下降。可以使用信号量或者线程池的控制参数来实现并发数的限制。\",\"超时机制： 对耗时的 API 调用设置超时时间，如果调用超过预设的时间仍未返回结果，则取消调用并释放资源。这样可以避免线程被长时间阻塞，提高线程池的响应速度。\",\"缓存结果： 对于频繁调用且结果稳定的耗时 API，可以将调用结果缓存起来，避免重复调用同一个耗时操作。这样可以减少对耗时 API 的调用次数，提高系统的性能和响应速度。\",\"优化算法： 对耗时的操作进行算法上的优化，减少其执行时间。可以使用更高效的算法、数据结构或者并行计算等技术来优化耗时操作的执行效率。\",\"综上所述，通过异步调用、任务拆分、限制并发数、超时机制、缓存结果和优化算法等策略，可以有效优化线程池中调用特别耗时的 API，提高线程池的性能和响应速度。\"]},\"480\":{\"h\":\"Fork/Join框架了解吗？\",\"t\":[\"Fork/Join框架是Java7提供的一个用于并行执行任务的框架，是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。\",\"要想掌握Fork/Join框架，首先需要理解两个点，分而治之和工作窃取算法。\",\"分而治之 \",\"Fork/Join框架的定义，其实就体现了分治思想：将一个规模为N的问题分解为K个规模较小的子问题，这些子问题相互独立且与原问题性质相同。求出子问题的解，就可得到原问题的解。\",\"工作窃取算法 \",\"大任务拆成了若干个小任务，把这些小任务放到不同的队列里，各自创建单独线程来执行队列里的任务。 那么问题来了，有的线程干活块，有的线程干活慢。干完活的线程不能让它空下来，得让它去帮没干完活的线程干活。它去其它线程的队列里窃取一个任务来执行，这就是所谓的工作窃取。\",\"工作窃取发生的时候，它们会访问同一个队列，为了减少窃取任务线程和被窃取任务线程之间的竞争，通常任务会使用双端队列，被窃取任务线程永远从双端队列的头部拿，而窃取任务的线程永远从双端队列的尾部拿任务执行\",\"Fork/Join框架的工作原理如下：\",\"任务分解（Fork）： 当一个大任务到来时，Fork/Join框架会将这个大任务拆分成若干个小任务，直到拆分的任务足够小而可以被快速处理为止。这个过程是递归的，直到达到拆分任务的终止条件。\",\"任务执行（Join）： 拆分出的小任务会被分配给线程池中的工作线程执行。每个工作线程会不断地从任务队列中获取任务并执行，直到任务队列为空为止。\",\"结果合并： 当一个线程执行完一个小任务后，会将其结果合并到大任务的结果中。这个过程也是递归的，直到所有小任务的结果都被合并到大任务的结果中为止。\",\"Fork/Join框架的关键组件包括：\",\"ForkJoinPool： ForkJoinPool是Fork/Join框架的线程池实现，管理着一组工作线程，用于执行Fork/Join任务。ForkJoinPool实现了工作窃取算法，使得任务能够动态地分配给空闲的线程，提高了线程的利用率和任务的并行性。\",\"ForkJoinTask： ForkJoinTask是Fork/Join框架中表示任务的抽象类，有两个主要的子类：RecursiveTask用于表示有返回值的任务，和RecursiveAction用于表示没有返回值的任务。开发者可以继承ForkJoinTask类来定义自己的任务。\",\"下面是一个简单的示例代码，演示了如何使用Fork/Join框架来计算斐波那契数列的值：\",\"import java.util.concurrent.RecursiveTask; public class FibonacciTask extends RecursiveTask<Integer> { private final int n; public FibonacciTask(int n) { this.n = n; } @Override protected Integer compute() { if (n <= 1) { return n; } else { FibonacciTask task1 = new FibonacciTask(n - 1); FibonacciTask task2 = new FibonacciTask(n - 2); task1.fork(); int result2 = task2.compute(); int result1 = task1.join(); return result1 + result2; } } public static void main(String[] args) { FibonacciTask task = new FibonacciTask(10); int result = task.compute(); System.out.println(\\\"Fibonacci(10) = \\\" + result); } } \",\"以上代码示例演示了如何使用Fork/Join框架来计算斐波那契数列的值。下面是对代码示例的解释：\",\"FibonacciTask 类继承了 RecursiveTask<Integer> 类，表示这是一个有返回值的递归任务，返回值类型为 Integer。\",\"在 FibonacciTask 类中，有一个私有的成员变量 n，表示要计算斐波那契数列的第 n 个数。\",\"compute() 方法是 RecursiveTask 类的抽象方法，需要子类来实现。在 FibonacciTask 类中，我们重写了 compute() 方法来定义具体的任务逻辑。\",\"在 compute() 方法中，首先判断当前要计算的斐波那契数列的位置 n 是否小于等于1。如果是，直接返回 n，因为斐波那契数列的第一个数和第二个数都是1。\",\"如果 n 大于1，则将问题拆分成两个子任务，分别计算第 n-1 和第 n-2 个斐波那契数。使用 FibonacciTask 类自身的构造函数创建两个新的任务对象。\",\"调用 fork() 方法提交第一个子任务给线程池执行，并直接在当前线程中执行第二个子任务的 compute() 方法。\",\"在执行第二个子任务的过程中，如果需要继续拆分任务，则会递归调用 compute() 方法，直到计算到基本情况。\",\"使用 join() 方法等待第一个子任务的执行结果，然后将第一个子任务和第二个子任务的结果相加，得到当前位置的斐波那契数。\",\"在 main() 方法中，创建一个 FibonacciTask 对象，表示要计算斐波那契数列的第10个数。\",\"调用 compute() 方法开始执行任务，得到斐波那契数列的第10个数的值，并输出结果。\",\"在这个示例中，我们定义了一个继承自RecursiveTask<Integer>的FibonacciTask类，用于计算斐波那契数列的值。在compute()方法中，如果n的值小于等于1，则直接返回n；否则，将问题拆分成两个子任务并使用fork()方法提交给线程池执行，并通过join()方法等待子任务的完成并合并结果。\"]},\"481\":{\"h\":\"锁\"},\"482\":{\"h\":\"synchronized用过吗？怎么使用？\",\"t\":[\"修饰实例方法\",\"作用于当前对象实例加锁，进入同步代码前要获得 当前对象实例的锁\",\"synchronized void method() { //业务代码 } \",\"修饰静态方法\",\"也就是给当前类加锁，会作⽤于类的所有对象实例 ，进⼊同步代码前要获得当前 class 的锁\",\"因为静态成员不属于任何⼀个实例对象，是类成员（ static 表明这是该类的⼀个静态资源，不管 new 了多少个对象，只有⼀份）\",\"synchronized void staic method() { //业务代码 } \",\"修饰代码块\",\"指定加锁对象，对给定对象/类加锁。\",\"synchronized(this|object) 表示进⼊同步代码库前要获得给定对象的锁。\",\"synchronized(类.class) 表示进⼊同步代码前要获得 当前 class 的锁\",\"synchronized(this) { //业务代码 } \"]},\"483\":{\"h\":\"synchronized的实现原理？\"},\"484\":{\"h\":\"synchronized是怎么加锁的呢？\",\"t\":[\"synchronized修饰代码块时 \",\"JVM采用 monitorenter 、 monitorexit 两个指令来实现同步\",\"monitorenter 指令指向同步代码块的开始位置\",\"monitorexit 指令则指向同步代码块的结束位置\",\"ynchronized修饰同步方法时 \",\"JVM采用 ACC_SYNCHRONIZED 标记符来实现同步，这个标识指明了该方法是一个同步方法\"]},\"485\":{\"h\":\"synchronized锁住的是什么呢？\",\"t\":[\"monitorenter、monitorexit或者ACC_SYNCHRONIZED，其实都是基于对象的内置锁（Intrinsic Lock）或称为监视器锁（Monitor Lock）\",\"每个对象都有一个内置锁\",\"当一个线程获取了对象的内置锁时，其他线程必须等待该线程释放锁后才能获取锁\",\"这样就保证了同一时间只有一个线程能够访问该对象的同步代码块或同步方法\",\"ObjectMonitor的工作原理\",\"ObjectMonitor有两个队列： _ WaitSet、 _ EntryList，用来保存ObjectWaiter 对象列表\",\"_owner，获取 Monitor 对象的线程进入 _owner 区时， _count + 1。如果线程调用了 wait() 方法，此时会释放 Monitor 对象， _owner 恢复为空， _count - 1。同时该等待线程进入 _WaitSet 中，等待被唤醒\",\"ObjectMonitor() { _header = NULL; _count = 0; // 记录线程获取锁的次数 _waiters = 0, _recursions = 0; //锁的重入次数 _object = NULL; _owner = NULL; // 指向持有ObjectMonitor对象的线程 _WaitSet = NULL; // 处于wait状态的线程，会被加入到 _WaitSet _WaitSetLock = 0 ; _Responsible = NULL ; _succ = NULL ; _cxq = NULL ; FreeNext = NULL ; _EntryList = NULL ; // 处于等待锁block状态的线程，会被加入 到该列表 _SpinFreq = 0 ; _SpinClock = 0 ; OwnerIsThread = 0 ; } \",\"所以我们就知道了，同步是锁住的什么东西\",\"monitorenter，在判断拥有同步标识 ACC_SYNCHRONIZED 抢先进入此方法的线程会优先拥有 Monitor 的 owner ，此时计数器 +1\",\"monitorexit，当执行完退出后，计数器 -1，归 0 后被其他进入的线程获得。\"]},\"486\":{\"h\":\"除了原子性，synchronized可见性，有序性，可重入性怎么实现？\"},\"487\":{\"h\":\"synchronized怎么保证可见性？\",\"t\":[\"线程加锁前，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新读取最新的值\",\"线程加锁后，其它线程无法获取主内存中的共享变量\",\"线程解锁前，必须把共享变量的最新值刷新到主内存中\"]},\"488\":{\"h\":\"synchronized怎么保证有序性？\",\"t\":[\"synchronized同步的代码块，具有排他性，一次只能被一个线程拥有，所以synchronized保证同一时刻，代码是单线程执行的 \",\"因为as-if-serial语义的存在，单线程的程序能保证最终结果是有序的，但是不保证不会指令重排\",\"所以synchronized保证的有序是执行结果的有序性，而不是防止指令重排的有序性\"]},\"489\":{\"h\":\"synchronized怎么实现可重入的呢？\",\"t\":[\"synchronized 是可重入锁，也就是说，允许一个线程二次请求自己持有对象锁的临界资源，这种情况称为可重入锁\",\"synchronized 锁对象的时候有个计数器，他会记录下线程获取锁的次数，在执行完对应的代码块之后，计数器就会-1，直到计数器清零，就释放锁了\"]},\"490\":{\"h\":\"锁升级？synchronized优化了解吗？\",\"t\":[\"锁的状态\",\"Mark Word 标记字段记录着锁的状态\",\"Java对象头里，有一块结构，叫 Mark Word 标记字段，记录着锁的状态，这块结构会随着锁的状态变化而变化\",\"64 位虚拟机 Mark Word 是 64bit，我们来看看它的状态变化\",\"Mark Word存储对象自身的运行数据，如哈希码、GC分代年龄、锁状态标志、偏向时间戳（Epoch） 等\"]},\"491\":{\"h\":\"synchronized做了哪些优化？\",\"t\":[\"在JDK1.6之前 \",\"在JDK1.6之前synchronized的实现直接调用ObjectMonitor的enter和exit，这种锁被称之为重量级锁\",\"从JDK6开始 \",\"从JDK6开始HotSpot虚拟机开发团队对Java中的锁进行优化，如增加了适应性自旋、锁消除、锁粗化、轻量级锁和偏向锁等优化策略，提升了synchronized的性能\",\"偏向锁 \",\"在无竞争的情况下，只是在Mark Word里存储当前线程指针，CAS操作都不做\",\"在没有多线程竞争时，相对重量级锁，减少操作系统互斥量带来的性能消耗。但是，如果存在锁竞争，除了互斥量本身开销，还额外有CAS操作的开销\",\"自旋锁 \",\"减少不必要的CPU上下文切换。在轻量级锁升级为重量级锁时，就使用了自旋加锁的方式\",\"锁粗化 \",\"将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁\",\"锁消除 \",\"虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除\"]},\"492\":{\"h\":\"锁升级的过程是什么样的？\",\"t\":[\"锁升级方向：无锁-->偏向锁---> 轻量级锁---->重量级锁，这个方向基本上是不可逆的\"]},\"493\":{\"h\":\"偏向锁\",\"t\":[\"偏向锁的获取 \",\"判断是否为可偏向状态--MarkWord中锁标志是否为‘01’，偏向锁标记是否为‘1‘\",\"如果是可偏向状态，则查看线程ID是否为当前线程，如果是，则进入步骤'5'，否则进入步骤‘3’\",\"通过CAS操作竞争锁，如果竞争成功，则将MarkWord中线程ID设置为当前线程ID，然后执行‘5’；竞争失败，则执行‘4’\",\"CAS获取偏向锁失败表示有竞争。当达到safepoint时获得偏向锁的线程被挂起，偏向锁升级为轻量级锁 ，然后被阻塞在安全点的线程继续往下执行同步代码块\",\"执行同步代码\",\"偏向锁的撤销 \",\"偏向锁不会主动释放(撤销)，只有遇到其他线程竞争时才会执行撤销，由于撤销需要知道当前持有该偏向锁的线程栈状态，因此要等到safepoint时执行，此时持有该偏向锁的线程（T）有‘2’，‘3’两种情况\",\"撤销 \",\"T线程已经退出同步代码块，或者已经不再存活，则直接撤销偏向锁，变成无锁状态----该状态达到阈值20则执行批量重偏向\",\"升级 \",\"T线程还在同步代码块中，则将T线程的偏向锁 升级为轻量级锁 ，当前线程执行轻量级锁状态下的锁获取步骤----该状态达到阈值40则执行批量撤销\"]},\"494\":{\"h\":\"轻量级锁\",\"t\":[\"轻量级锁的获取\",\"进行加锁操作时，jvm会判断是否已经是重量级锁，如果不是，则会在当前线程栈帧中划出一块空间，作为该锁的锁记录，并且将锁对象MarkWord复制到该锁记录中\",\"复制成功之后，jvm使用CAS操作将对象头MarkWord更新为指向锁记录的指针，并将锁记录里的owner指针指向对象头的MarkWord。如果成功，则执行‘3’，否则执行‘4’\",\"更新成功，则当前线程持有该对象锁，并且对象MarkWord锁标志设置为‘00’，即表示此对象处于轻量级锁状态\",\"更新失败，jvm先检查对象MarkWord是否指向当前线程栈帧中的锁记录，如果是则执行‘5’，否则执行6 ’\",\"表示锁重入；然后当前线程栈帧中增加一个锁记录第一部分（Displaced Mark Word）为null，并指向Mark Word的锁对象，起到一个重入计数器的作用。\",\"表示该锁对象已经被其他线程抢占，则进行 自旋等待 （默认10次），等待次数达到阈值仍未获取到锁，则 升级为重量级锁\",\"简略的锁升级过程\",\"完整的升级过程\"]},\"495\":{\"h\":\"说说synchronized和ReentrantLock的区别？\",\"t\":[\"锁的实现 \",\"synchronized是Java语言的关键字，基于JVM实现\",\"ReentrantLock是基于JDK的API层面实现的（一般是lock()和unlock()方法配合try/finally 语句块来完成。）\",\"性能 \",\"在JDK1.6锁优化以前，synchronized的性能比ReenTrantLock差很多\",\"但是JDK6开始，增加了适应性自旋、锁消除等，两者性能就差不多了\",\"功能特点 \",\"ReentrantLock 比 synchronized 增加了一些高级功能，如等待可中断、可实现公平锁、可实现选择性通知 \",\"ReentrantLock提供了一种能够中断等待锁的线程的机制，通过lock.lockInterruptibly()来实现这个机制\",\"ReentrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。\",\"synchronized与wait()和notify()/notifyAll()方法结合实现等待/通知机制，ReentrantLock类借助Condition接口与newCondition()方法实现\",\"ReentrantLock需要手工声明来加锁和释放锁，一般跟finally配合释放锁。而synchronized不用手动释放锁\"]},\"496\":{\"h\":\"AQS了解多少？\",\"t\":[\"AbstractQueuedSynchronizer 抽象同步队列，简称 AQS ，它是Java并发包的根基，并发包中的锁就是基于AQS实现的，是Java并发面试的高频题目\",\"AQS是一个一个FIFO的双向队列，Node节点中的thread变量用来存放进入AQS队列里的线程，SHARED表示是获取共享资源时被阻塞挂起后放入AQS队列的，EXCLUSIVE表示是获取独占资源时被挂起后放入AQS队列的\",\"AQS 使用一个 volatile 修饰的 int 类型的成员变量 state 来表示同步状态，修改同步状态成功即为获得锁 ，volatile 保证了变量在多线程之间的可见性，修改 state值时通过 CAS 机制来保证修改的原子性\",\"获取state的方式分为两种，\",\"独占方式 tryAcquire() \",\"一个线程使用独占方式获取了资源，其它线程就会在获取失败后被阻塞。\",\"抽象方法，需要子类自行实现\",\"共享方式tryAcquireShared() \",\"一个线程使用共享方式获取了资源，另外一个线程还可以通过CAS的方式进行获取\",\"抽象方法，需要子类自行实现\",\"如果共享资源被占用，需要一定的阻塞等待唤醒机制来保证锁的分配，AQS 中会将竞争共享资源失败的线程添加到队列中，线程进入队列后会进行自旋，自旋一定次数后，会使用LockSupport.park()进入阻塞状态\",\"获取到锁的线程可以重入，每重入一次，state+1，释放资源的时候，会使用CAS操作将state修改为0，重入多少次，释放多少次，并使用LockSupport.unpark()唤醒处于等待状态的线程\"]},\"497\":{\"h\":\"ReentrantLock实现原理？\",\"t\":[\"ReentrantLock通过Sync类，间接继承了AQS\",\"它是可重入的独占锁，只能有一个线程可以获取该锁，其它获取该锁的线程会被阻塞而被放入该锁的阻塞队列里面\",\"new ReentrantLock() 构造函数默认创建的是非公平锁 NonfairSync\"]},\"498\":{\"h\":\"公平锁 FairSync\",\"t\":[\"公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁\",\"公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU 唤醒阻塞线程的开销比非公平锁大\"]},\"499\":{\"h\":\"非公平锁 NonfairSync\",\"t\":[\"非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁\",\"非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU 不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁\"]},\"500\":{\"h\":\"Lock()的执行过程\",\"t\":[\"如果锁当前没有被其它线程占用，并且当前线程之前没有获取过该锁，则当前线程会获取到该锁，然后设置当前锁的拥有者为当前线程，并设置 AQS 的状态值为1 ，然后直接返回。\",\"如果当前线程之前己经获取过该锁，则这次只是简单地把AQS 的状态值加1后返回。\",\"如果该锁己经被其他线程持有，非公平锁会尝试去获取锁，获取失败的话，则调用该方法线程会被放入 AQS 队列阻塞挂起。\"]},\"501\":{\"h\":\"ReentrantLock怎么实现公平锁的？\",\"t\":[\"new ReentrantLock() 构造函数默认创建的是非公平锁 NonfairSync\",\"public ReentrantLock() { sync = new NonfairSync(); } \",\"同时也可以在创建锁构造函数中传入具体参数创建公平锁 FairSync\",\"ReentrantLock lock = new ReentrantLock(true); --- ReentrantLock // true 代表公平锁，false 代表非公平锁 public ReentrantLock(boolean fair) { sync = fair ? new FairSync() : new NonfairSync(); } \",\"FairSync、NonfairSync 代表公平锁和非公平锁，两者都是 ReentrantLock 静态内部类，只不过实现不同锁语义\",\"非公平锁和公平锁的两处不同\",\"非公平锁在调用 lock 后，首先就会调用 CAS 进行一次抢锁，如果这个时候恰巧锁没有被占用，那么直接就获取到锁返回了\",\"非公平锁在 CAS 失败后，和公平锁一样都会进入到 tryAcquire 方法，在tryAcquire 方法中，如果发现锁这个时候被释放了（state == 0），非公平锁会直接 CAS 抢锁，但是公平锁会判断等待队列是否有线程处于等待状态，如果有则不去抢锁，乖乖排到后面\",\"相对来说，非公平锁会有更好的性能，因为它的吞吐量比较大。当然，非公平锁让获取锁的时间变得更加不确定，可能会导致在阻塞队列中的线程长期处于饥饿状态\"]},\"502\":{\"h\":\"什么是CAS?\",\"t\":[\"CAS（Compare And Swap）是一种原子操作，用于实现多线程环境下的同步操作\",\"CAS 操作包含三个操作数：内存位置（V）、旧的预期值（A）和新值（B）\",\"当且仅当预期值 A 和内存位置 V 的值相同时，CAS 会将内存位置 V 的值更新为新值B\",\"CAS 的操作过程如下 \",\"比较：比较内存位置 V 的当前值是否等于预期值 A \",\"如果相等，说明内存位置 V 的值没有被其他线程改变，继续执行第2步\",\"如果不相等，说明内存位置 V 的值已经被其他线程改变，CAS 操作失败，返回 false\",\"交换：将内存位置 V 的值更新为新值 B，CAS 操作成功，返回 true\"]},\"503\":{\"h\":\"CAS 有什么问题？如何解决？\",\"t\":[\"ABA 问题\",\"循环性能开销\",\"只能保证一个变量的原子操作\"]},\"504\":{\"h\":\"ABA 问题\",\"t\":[\"A ->B ->A\",\"并发环境下，假设初始条件是A，去修改数据时，发现是A就会执行修改\",\"但是看到的虽然是A，中间可能发生了A变B，B又变回A的情况\",\"此时A已经非彼A，数据即使成功修改，也可能有问题\"]},\"505\":{\"h\":\"怎么解决ABA问题？\",\"t\":[\"加版本号\",\"使用AtomicStampReference类\",\"Java提供了AtomicStampReference类，它的compareAndSet方法首先检查当前的对象引用值是否等于预期引用，并且当前印戳（Stamp）标志是否等于预期标志，如果全部相等，则以原子方式将引用值和印戳标志的值更新为给定的更新值\",\"通过native方法实现以原子方式将引用值和印戳标志的值更新为给定的更新值\",\" private boolean casPair(Pair<V> cmp, Pair<V> val) { return PAIR.compareAndSet(this, cmp, val); } \",\" public final native @MethodHandle.PolymorphicSignature @IntrinsicCandidate boolean compareAndSet(Object... args); \"]},\"506\":{\"h\":\"循环性能开销\",\"t\":[\"自旋CAS，如果一直循环执行，一直不成功，会给CPU带来非常大的执行开销\"]},\"507\":{\"h\":\"怎么解决循环性能开销问题？\",\"t\":[\"在Java中，很多使用自旋CAS的地方，会有一个自旋次数的限制，超过一定次数，就停止自旋\"]},\"508\":{\"h\":\"只能保证一个变量的原子操作\",\"t\":[\"CAS 保证的是对一个变量执行操作的原子性，如果对多个变量操作时，CAS 目前无法直接保证操作的原子性的\",\"可以考虑合并多个变量，将多个变量封装成一个对象，通过AtomicReference来保证原子性。\"]},\"509\":{\"h\":\"Java有哪些保证原子性的方法？如何保证多线程下i++ 结果正确？\",\"t\":[\"使用循环原子类，例如AtomicInteger，实现i++原子操作\",\"使用juc包下的锁，如ReentrantLock ，对i++操作加锁lock.lock()来实现原子性\",\"使用synchronized，对i++操作加锁\"]},\"510\":{\"h\":\"原子操作类了解多少？\",\"t\":[\"原子操作类是Java提供的一组线程安全的工具类，用于在多线程环境下保证共享变量的操作是原子性的\",\"原子操作类一般都是通过底层的CAS（Compare and Swap）操作来实现的\",\"Java中提供了多种原子操作类，如AtomicBoolean、AtomicInteger、AtomicLong、AtomicReference等，这些类都提供了一些原子操作方法，如getAndIncrement()、compareAndSet()、getAndSet()等，这些方法都是原子性的，可以保证对变量的操作是线程安全的\",\"原子操作类的优点在于，它们提供了一种更高效的线程安全机制，不需要像synchronized关键字那样对整个代码块进行加锁，而是只对需要进行原子操作的代码进行了保护，从而提高了程序的并发性能\"]},\"511\":{\"h\":\"AtomicInteger 的原理？\",\"t\":[\"使用自旋+CAS实现\",\"以AtomicInteger的添加方法为例\",\" public final int getAndDecrement() { return U.getAndAddInt(this, VALUE, -1); } \",\" public final int getAndAddInt(Object o, long offset, int delta) { int v; do { v = getIntVolatile(o, offset); } while (!weakCompareAndSetInt(o, offset, v, v + delta)); return v; } \",\" public final boolean weakCompareAndSetInt(Object o, long offset, int expected, int x) { return compareAndSetInt(o, offset, expected, x); } \",\" public final native boolean compareAndSetInt(Object o, long offset, int expected, int x); \",\"compareAndSetInt是个native方法，\",\"基于CAS来操作int类型变量。其它的原子操作类基本都是大同小异\"]},\"512\":{\"h\":\"线程死锁了解吗？该如何避免？\",\"t\":[\"死锁 \",\"死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的互相等待的现象，在无外力作用的情况下，这些线程会一直相互等待而无法继续运行下去\",\"死锁产生的四个条件 \",\"互斥条件 \",\"指线程对己经获取到的资源进行排它性使用，即该资源同时只由一个线程占用\",\"如果此时还有其它线程请求获取获取该资源，则请求者只能等待，直至占有资源的线程释放该资源\",\"请求并持有 \",\"持有一个资源的同时请求一个新资源\",\"指一个 线程己经持有了至少一个资源，但又提出了新的资源请求，而新资源己被其它线程占有，所以当前线程会被阻塞，但阻塞 的同时并不释放自己已经获取的资源\",\"不可剥夺条件 \",\"指线程获取到的资源在自己使用完之前不能被其它线程抢占，只有在自己使用完毕后才由自己释放该资源\",\"环路等待条件 \",\"形成了一个等待环路，使得每个线程都在等待下一个线程占有的资源，从而形成循环等待\",\"该如何避免死锁呢？ 答案是至少破坏死锁发生的一个条件 \",\"其中，互斥这个条件我们没有办法破坏，因为用锁为的就是互斥。不过其他三个条件都是有办法破坏掉的，到底如何做呢？\",\"对于“请求并持有”这个条件，可以一次性请求所有的资源\",\"对于“不可剥夺”这个条件，占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源，然后重新尝试，这样不可抢占这个条件就破坏掉了。 \",\"如何做到的？ \",\"超时机制：在获取资源时设置超时，如果超过一定时间没有获取到资源，则释放已持有的资源，并重试或采取其他措施。\",\"对于“环路等待”这个条件，可以靠按序申请资源来预防。所谓按序申请，是指资源是有线性顺序的，申请的时候可以先申请资源序号小的，再申请资源序号大的，这样线性化后就不存在环路了\"]},\"513\":{\"h\":\"死锁问题怎么排查呢？\",\"t\":[\"可以使用JDK自带的命令行工具排查 \",\"使用jps查找运行的Java进程：jps -l\",\"使用jstack查看线程堆栈信息：jstack -l 进程id\",\"还可以利用图形化工具，比如JConsole \",\"出现线程死锁以后，点击JConsole线程面板的 检测到死锁 按钮，将会看到线程的死锁信息\",\"死锁检测算法 \",\"可以使用图算法如找环算法来检测死锁\",\"死锁恢复 \",\"终止死锁进程：强制终止一个或多个进程，释放它们持有的资源。\",\"资源剥夺：从一些死锁进程中剥夺资源，将这些资源分配给其他等待进程\"]},\"514\":{\"h\":\"List\"},\"515\":{\"h\":\"ArrayList和LinkedList有什么区别？\",\"t\":[\"数据结构不同 \",\"ArrayList基于数组实现\",\"LinkedList基于双向链表实现\",\"多数情况下，ArrayList更利于查找，LinkedList更利于增删 \",\"查找速率 \",\"ArrayList基于数组实现，get(int index)可以直接通过数组下标获取，时间复杂度是O(1)\",\"LinkedList基于链表实现，get(int index)需要遍历链表，时间复杂度是O(n)\",\"get(E element)这种查找，两种集合都需要遍历，时间复杂度都是O(n)\",\"增删速率 \",\"ArrayList增删如果是数组末尾的位置，直接插入或者删除就可以了，但是如果插入中间的位置，就需要把插入位置后的元素都向前或者向后移动，甚至还有可能触发扩容\",\"双向链表的插入和删除只需要改变前驱节点、后继节点和插入节点的指向就行了，不需要移动元素\",\"是否支持随机访问 \",\"ArrayList基于数组，所以它可以根据下标查找，支持随机访问 \",\"它也实现了RandmoAccess 接口，这个接口只是用来标识是否支持随机访问\",\"LinkedList基于链表，所以它没法根据序号直接获取元素，它没有实现RandmoAccess 接口，标记不支持随机访问\",\"内存占用 \",\"ArrayList基于数组，是一块连续的内存空间 \",\"ArrayList是预先定义好的数组，可能会有空的内存空间，存在一定空间浪费\",\"LinkedList基于链表，内存空间不连续，它们在空间占用上都有一些额外的消耗 \",\"LinkedList每个节点，需要存储前驱和后继，所以每个节点会占用更多的空间\"]},\"516\":{\"h\":\"ArrayList的扩容机制了解吗？\",\"t\":[\"数组满了，再插入时，触发扩容\",\"计算新数组容量，容量大小为原数组1.5倍\",\" private int newCapacity(int minCapacity) { // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity >> 1); if (newCapacity - minCapacity <= 0) { if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) return Math.max(DEFAULT_CAPACITY, minCapacity); if (minCapacity < 0) // overflow throw new OutOfMemoryError(); return minCapacity; } return (newCapacity - MAX_ARRAY_SIZE <= 0) ? newCapacity : hugeCapacity(minCapacity); } \",\"int newCapacity = oldCapacity + (oldCapacity >> 1);\",\"复制原数组元素到新数组\"]},\"517\":{\"h\":\"ArrayList怎么序列化的知道吗？ 为什么用transient修饰数组？\",\"t\":[\"ArrayList的序列化不太一样，它使用 transient 修饰存储元素的 elementData 的数组\",\"transient 关键字的作用是让被修饰的成员属性不被序列化\"]},\"518\":{\"h\":\"为什么最ArrayList不直接序列化元素数组呢？\",\"t\":[\"出于效率的考虑 \",\"数组可能长度100，但实际只用了50，剩下的50不用其实不用序列化，这样可以提高序列化和反序列化的效率，还可以节省内存空间\"]},\"519\":{\"h\":\"那ArrayList怎么序列化呢 ？\",\"t\":[\"ArrayList通过两个方法readObject、writeObject自定义序列化和反序列化策略，实际直接使用两个流 ObjectOutputStream 和 ObjectInputStream 来进行序列化和反序列化\"]},\"520\":{\"h\":\"快速失败(fail-fast)和安全失败(fail-safe)了解吗？\",\"t\":[\"快速失败（fail—fast）：快速失败是Java集合的一种错误检测机制 \",\"触发 \",\"在用迭代器遍历一个集合对象时，如果线程A遍历过程中，线程B对集合对象的内容进行了修改（增加、删除、修改），则会抛出Concurrent Modification Exception\",\"原理 \",\"迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个modCount 变量。集合在被遍历期间如果内容发生变化，就会改变 modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测 modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。\",\"注意 \",\"这里异常的抛出条件是检测到 modCount！=expectedmodCount 这个条件。如果集合发生变化时修改modCount值刚好又设置为了expectedmodCount值，则异常不会抛出。因此，不能依赖于这个异常是否抛出而进行并发操作的编程，这个异常只建议用于检测并发修改的bug\",\"场景 \",\"java.util包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改），比如ArrayList 类。\",\"安全失败（fail—safe） \",\"策略 \",\"采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历\",\"原理 \",\"由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception\",\"缺点 \",\"基于拷贝内容的优点是避免了Concurrent Modification Exception，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的\",\"场景 \",\"java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改，比如CopyOnWriteArrayList类\"]},\"521\":{\"h\":\"实现ArrayList线程安全有哪几种方法？\",\"t\":[\"用Vector代替ArrayList \",\"Vector是一个线程安全的动态数组类，可以直接使用它来替代ArrayList\",\"Vector的所有方法都是同步的，因此在并发环境下可以安全地进行读写操作。\",\"但它的性能很低，不推荐使用。\",\"使用Collections.synchronizedList包装ArrayList \",\"可以使用Collections工具类的synchronizedList方法将ArrayList转换为线程安全的List\",\"该方法返回一个包装后的线程安全List，对该List的所有操作都会进行同步处理，确保线程安全\",\"使用CopyOnWriteArrayList代替ArrayList \",\"CopyOnWriteArrayList是一种线程安全的并发List\",\"它通过在修改时创建副本来实现并发访问\",\"由于读操作不需要加锁，因此在读多写少的场景中，CopyOnWriteArrayList具有较高的性能\",\"使用同步机制控制ArrayList的读写 \",\"在使用ArrayList时，可以通过同步机制（如使用synchronized关键字或Lock）来控制对ArrayList的读写操作，以确保线程安全\"]},\"522\":{\"h\":\"CopyOnWriteArrayList了解多少？\",\"t\":[\"CopyOnWriteArrayList就是线程安全版本的ArrayList，它的名字叫 CopyOnWrite，写时复制，已经明示了它的原理\",\"特点 \",\"线程安全性 \",\"CopyOnWriteArrayList通过创建副本的方式实现线程安全，因此可以在多线程环境下安全地进行读操作，而不需要额外的同步措施\",\"读写分离 \",\"CopyOnWriteArrayList适合在读多写少的场景中使用，因为每次写操作都会创建一个新的副本，会带来一定的内存开销。但在读操作频繁、写操作较少的情况下，可以获得较高的读取性能\",\"迭代器的弱一致性 \",\"由于CopyOnWriteArrayList在写操作时会创建副本，因此在遍历集合时使用的迭代器可能不反映最新的修改。迭代器提供的是一个一致性视图，即迭代器创建时的集合状态\",\"工作流程 \",\"将原数组拷贝一份\",\"写操作在副本上，加锁\",\"读操作在原数组上，无锁\",\"写完将元素数组指向副本\",\"缺点 \",\"由于CopyOnWriteArrayList在每次写操作时都会创建副本，因此适用于写操作较少、读操作频繁且对实时性要求不高的场景。如果写操作频繁或对实时性要求较高，可能会带来较高的内存开销和延迟。\",\"volatile修饰原数组array，保证了可见性\"]},\"523\":{\"h\":\"数据拷贝的过程中，有其它线程写入数据怎么办？\",\"t\":[\"阻塞呗，数据拷贝在add方法中进行，add方法有锁\"]},\"524\":{\"h\":\"Map\"},\"525\":{\"h\":\"能说一下HashMap的数据结构吗？\",\"t\":[\"数组 + 链表（JDK1.7）\",\"数组 + 链表 + 红黑树 （JDK1.8）\",\"数据结构示意图\",\"存储结构 \",\"HashMap内部使用一个数组（Entry[]）来存储数据\",\"数组中的每个元素称为一个桶（Bucket），每个桶存储一个键值对（Entry）\",\"哈希函数 \",\"HashMap使用键的哈希码（hash code）来计算存储位置\",\"每个键值对根据哈希函数计算得到一个桶的索引，然后将键值对存储在该桶中\",\"冲突处理 \",\"由于哈希函数的计算结果可能会出现冲突，即不同的键计算得到相同的桶索引\",\"HashMap使用链表或红黑树来解决冲突\",\"当桶中的元素较少时，使用链表存储键值对\",\"当桶中的元素较多时，将链表转换为红黑树，以提高查找、插入和删除的效率\"]},\"526\":{\"h\":\"你对红黑树了解多少？为什么不用二叉树/平衡树呢？\"},\"527\":{\"h\":\"什么是红黑树？\",\"t\":[\"红黑树是一种自平衡的二叉搜索树\",\"二叉搜索树性质\",\"左子节点的值小于等于当前节点的值，右子节点的值大于等于当前节点的值\",\"节点颜色\",\"每个节点要么是红色，要么是黑色\",\"根节点和叶子节点\",\"根节点是黑色的，叶子节点（NIL节点）是黑色的\",\"红色节点限制\",\"红色节点的子节点必须是黑色的\",\"黑色节点计数\",\"从任一节点到其每个叶子节点的路径上，黑色节点的数量是相同的\"]},\"528\":{\"h\":\"为什么不用二叉树？\",\"t\":[\"红黑树相对于普通的二叉搜索树的优势在于它能够保持良好的平衡，性能更加优秀和稳定\",\"普通的二叉搜索树在最坏情况下可能会退化成链表 ,导致插入、删除和查找操作的时间复杂度变为O(n)\",\"而红黑树通过自平衡的特性，避免了这种退化情况，保证了操作的最坏时间复杂度为O(log n)，其中n是树中节点的数量\"]},\"529\":{\"h\":\"为什么不用平衡二叉树？\",\"t\":[\"相比于平衡二叉树，红黑树在保持平衡的过程中旋转的次数较少，提高了插入和删除操作的效率\",\"红黑树通过引入节点颜色和特定性质，保证了树的相对平衡\",\"而平衡二叉树要求更严格的平衡条件，需要更多的旋转操作来保持平衡，导致插入和删除操作的效率较低\"]},\"530\":{\"h\":\"红黑树怎么保持平衡的知道吗？\",\"t\":[\"红黑树有两种方式保持平衡： 旋转 和 染色\",\"旋转 \",\"旋转分为两种，左旋和右旋\",\"染色\"]},\"531\":{\"h\":\"HashMap的put流程知道吗？\",\"t\":[\"首先进行哈希值的扰动，获取一个新的哈希值\",\"(key == null) ? 0 : (h =key.hashCode()) ^ (h >>> 16) \",\"判断tab是否位空或者长度为0，如果是则进行扩容操作\",\"if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; \",\"根据哈希值计算下标，如果对应下标正好没有存放数据，则直接插入即可，否则需要覆盖\",\"if ((p = tab[i = (n - 1) & hash]) == null) tab[i] = newNode(hash, key, value, null); else { //覆盖 } \",\"判断tab[i]是否为树节点，否则向链表中插入数据，是则向树中插入节点\",\"// 覆盖逻辑 Node<K,V> e; K k; if (p.hash == hash && ((k = p.key) == key || (key != null && key.equals(k)))) e = p; else if (p instanceof TreeNode) e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value); else { for (int binCount = 0; ; ++binCount) { if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; } if (e.hash == hash && ((k = e.key) == key || (key != null && key.equals(k)))) break; p = e; } } \",\"如果链表中插入节点的时候，链表长度大于等于8，则需要把链表转换为红黑树\",\" if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); \",\"最后所有元素处理完成后，判断是否超过阈值； threshold ，超过则扩容\",\" if (++size > threshold) resize(); \"]},\"532\":{\"h\":\"HashMap怎么查找元素的呢？\",\"t\":[\" public V get(Object key) { Node<K,V> e; return (e = getNode(hash(key), key)) == null ? null : e.value; } \",\" final Node<K,V> getNode(int hash, Object key) { Node<K,V>[] tab; Node<K,V> first, e; int n; K k; if ((tab = table) != null && (n = tab.length) > 0 && (first = tab[(n - 1) & hash]) != null) { if (first.hash == hash && // always check first node ((k = first.key) == key || (key != null && key.equals(k)))) return first; if ((e = first.next) != null) { if (first instanceof TreeNode) return ((TreeNode<K,V>)first).getTreeNode(hash, key); do { if (e.hash == hash && ((k = e.key) == key || (key != null && key.equals(k)))) return e; } while ((e = e.next) != null); } } return null; } \",\"使用扰动函数，获取新的哈希值\",\"计算数组下标，获取节点\",\"当前节点和key匹配，直接返回\",\"否则，当前节点是否为树节点，查找红黑树\",\"否则，遍历链表查找\"]},\"533\":{\"h\":\"HashMap的哈希/扰动函数是怎么设计的?\",\"t\":[\"HashMap的哈希函数是先通过 hashCode() 获取到key的哈希值\",\"哈希值是一个32位的int类型的数值，然后再将哈希值右移16位（高位），然后与哈希值本身异或，达到高位与低位混合的效果\",\"这样的设计增加了哈希值的随机性，降低了哈希冲突的概率 。\",\"异或操作使得低位的特征影响到高位，减少了相同低位的哈希值导致相同索引位置的情况\"]},\"534\":{\"h\":\"为什么哈希/扰动函数能降hash碰撞？\",\"t\":[\"因为哈希值&(数组长度 - 1)保留的是hash值的地位特征，所以对扰动函数通过对哈希值进行变换，新hash值保留了高低位的特征，这样使得哈希值的分布更加均匀，从而降低哈希碰撞的概率\"]},\"535\":{\"h\":\"为什么HashMap的容量是2的倍数呢？\",\"t\":[\"方便哈希取余 \",\"取余是去除整数倍，保留整数倍以下的数据\",\"hash值&(数组大小-1) ，也达到了取余的效果 \",\"数组大小为2的倍数，(数组大小-1) 则为一个全是1的二进制数\",\"hash值&(数组大小-1) 结果为直接保留hash值对(数组大小-1) 的低位的余数部分 \",\"因为任意数&1得任意数\",\"任意数&0得0\",\"hash值&(数组大小-1) ，将(数组大小-1)高位补0，补全到和hash值一样多的位数，那么hash值高位是与0做&运算，低位是与1做位运算，即保留了低位hash值，也是取余的效果\",\"在扩容时，利用扩容后的大小也是2的倍数，将已经产生hash碰撞的元素完美的转移到新的table中去\"]},\"536\":{\"h\":\"如果初始化HashMap，传一个17的值 new HashMap<> ，它会怎么处理？\",\"t\":[\"初始化时，传的不是2的倍数时，HashMap会向上寻找 离得最近的2的倍数 ，所以传入17，但HashMap的实际容量是32\",\"HashMap的容量必须是2的倍数\"]},\"537\":{\"h\":\"你还知道哪些哈希函数的构造方法呢？\",\"t\":[\"除留取余法 \",\"HashMap里进行了优化改造，效率更高，散列也更均衡\",\"直接定址法 \",\"直接根据 key 来映射到对应的数组位置，例如1232放到下标1232的位置\",\"数字分析法 \",\"取 key 的某些数字（例如十位和百位）作为映射的位置\",\"平方取中法 \",\"取 key 平方的中间几位作为映射的位置\",\"折叠法 \",\"将 key 分割成位数相同的几段，然后把它们的叠加和作为映射的位置\"]},\"538\":{\"h\":\"解决哈希冲突有哪些方法呢？\",\"t\":[\"链地址法 \",\"在冲突的位置拉一个链表，把冲突的元素放进去\",\"开放定址法 \",\"开放定址法就是从冲突的位置再接着往下找，给冲突元素找个空位\",\"找到空闲位置的方法也有很多 \",\"线行探查法 \",\"从冲突的位置开始，依次判断下一个位置是否空闲，直至找到空闲位置\",\"平方探查法 \",\"从冲突的位置x开始，第一次增加 1^2 个位置，第二次增加2^2 …，直至找到空闲的位置\",\"再哈希法 \",\"换种哈希函数，重新计算冲突元素的地址\",\"建立公共溢出区 \",\"再建一个数组，把冲突的元素放进去\"]},\"539\":{\"h\":\"为什么HashMap链表转红黑树的阈值为8呢？\",\"t\":[\"红黑树节点的大小大概是普通节点大小的两倍，所以转红黑树，牺牲了空间换时间，更多的是一种兜底的策略，保证极端情况下的查找效率\",\"链表转红黑树的阈值为什么要选8呢？ \",\"和统计学有关。理想情况下，使用随机哈希码，链表里的节点符合泊松分布，出现节点个数的概率是递减的，节点个数为8的情况，发生概率仅为0.00000006\",\"红黑树转回链表的阈值为什么是6，而不是8？ \",\"是因为如果这个阈值也设置成8，假如发生碰撞，节点增减刚好在8附近，会发生链表和红黑树的不断转换，导致资源浪费\"]},\"540\":{\"h\":\"扩容在什么时候呢？为什么扩容因子是0.75？\",\"t\":[\"为了减少哈希冲突发生的概率,当前HashMap的元素个数达到一个临界值的时候，就会触发扩容\",\"这个 临界值threshold 就是由加载因子和当前容器的容量大小来确定的\"]},\"541\":{\"h\":\"那么为什么选择了0.75作为HashMap的默认加载因子呢？\",\"t\":[\"这是对 空间 成本和 时间 成本平衡的考虑 \",\"假如我们设的比较大，元素比较多，空位比较少的时候才扩容，那么发生哈希冲突的概率就增加了，查找的时间成本就增加了\",\"我们设的比较小的话，元素比较少，空位比较多的时候就扩容了，发生哈希碰撞的概率就降低了，查找时间成本降低，但是就需要更多的空间去存储元素，空间成本就增加了\"]},\"542\":{\"h\":\"HashMap扩容机制了解吗？\",\"t\":[\"为了减少哈希冲突发生的概率,当前HashMap的元素个数达到一个临界值的时候，就会触发扩容\",\"链表结构扩容后 \",\"hash&老容量==0 \",\"现在位置=原先位置\",\"hash&老容量==1 \",\"现在位置=原先位置+oldCap\"]},\"543\":{\"h\":\"JDK1.8对HashMap主要做了哪些优化呢？为什么？\",\"t\":[\"数据结构 \",\"在JDK 1.8中，当哈希冲突较多时，HashMap会将链表转换为红黑树，以提高查找、插入和删除操作的效率\",\"种优化是为了解决在极端情况下链表过长导致的性能问题。\",\"红黑树的平均时间复杂度为O(log n)，相比于链表的O(n)更高效\",\"哈希碰撞优化 \",\"JDK 1.8对哈希碰撞的处理进行了优化\",\"当发生哈希碰撞时，HashMap会使用更加均匀的哈希函数来计算索引位置，减少碰撞的概率\",\"JDK 1.8还引入了\\\"树化阈值\\\"和\\\"链表转树阈值\\\"的概念，动态调整链表和红黑树的阈值，以平衡性能和空间的消耗\",\"链表插入方式 \",\"在JDK 1.8中，当插入新的键值对时，HashMap采用了尾插法（将新键值对插入链表或红黑树末尾），而不是头插法\",\"这样做可以减少链表或红黑树的重新排序次数，提高插入操作的效率\",\"扩容优化 \",\"JDK 1.8对HashMap的扩容操作进行了优化\",\"在扩容时，HashMap采用了\\\"渐进式扩容\\\"的策略，将扩容操作分散到多次进行，避免了一次性重新计算所有键的哈希值和索引位置，减少了扩容操作的时间和资源消耗\"]},\"544\":{\"h\":\"你能自己设计实现一个HashMap吗？\",\"t\":[\"散列函数 \",\"hashCode()+除留余数法\",\"冲突解决 \",\"链地址法\",\"扩容 \",\"节点重新hash获取位置\"]},\"545\":{\"h\":\"HashMap 是线程安全的吗？多线程下会有什么问题？\",\"t\":[\"不是线程安全的\",\"多线程下扩容死循环 \",\"在JDK1.7中，HashMap使用头插法插入元素，当多个线程同时进行扩容操作时，可能会导致环形链表的出现，从而形成死循环\",\"JDK1.8中的HashMap改为使用尾插法插入元素，在扩容时保持链表元素原本的顺序，避免了环形链表的问题\",\"多线程的put可能导致元素的丢失 \",\"当多个线程同时执行put操作时，如果计算出来的索引位置相同，就会导致后一个key覆盖前一个key，从而导致元素的丢失\",\"这个问题在JDK1.7和JDK1.8中都存在\",\"put和get并发时，可能导致get为null \",\"当一个线程执行put操作导致扩容时，另一个线程同时执行get操作\",\"由于扩容过程中元素迁移的不可见性，可能导致get操作返回null\",\"这个问题在JDK1.7和JDK1.8中都存在\"]},\"546\":{\"h\":\"有什么办法能解决HashMap线程不安全的问题呢？\",\"t\":[\"使用线程安全的包装类 \",\"使用 Collections.synchronizedMap() 方法将HashMap包装成线程安全的Map\",\"这个方法返回一个线程安全的Map对象，对该对象的操作会自动进行同步，从而保证线程安全\",\"使用同步机制 \",\"可以使用 synchronized 关键字或其他同步机制（如ReentrantLock ）对HashMap进行加锁\",\"使用线程安全的并发容器 \",\"可以使用 ConcurrentHashMap 代替HashMap\",\"ConcurrentHashMap 是Java提供的线程安全的哈希表实现，通过使用锁分段技术和CAS操作来实现高效的并发性能\"]},\"547\":{\"h\":\"能说一下ConcurrentHashmap的具体实现吗？\",\"t\":[\"ConcurrentHashmap线程安全在jdk1.7版本是基于 分段锁 实现\",\"在jdk1.8是基于CAS+synchronized 实现\"]},\"548\":{\"h\":\"JDK1.7：分段锁\",\"t\":[\"JDK1.7版本的ConcurrentHashMap采用分段锁机制 \",\"里面包含一个Segment数组，Segment继承于ReentrantLock，Segment则包含HashEntry的数组\",\"HashEntry本身就是一个链表的结构，具有保存key、value的能力能指向下一个节点的指针\",\"实际上就是相当于每个Segment都是一个HashMap\",\"默认的Segment长度是16，也就是支持16个线程的并发写，Segment之间相互不会受到影响\",\"put流程 \",\"计算hash，定位到segment，segment如果是空就先初始化\",\"使用ReentrantLock加锁，如果获取锁失败则尝试自旋，自旋超过次数就阻塞获取，保证一定获取锁成功\",\"遍历HashEntry，就是和HashMap一样，数组中key和hash一样就直接替换，不存在就再插入链表，链表同样操作\",\"get流程 \",\"key通过hash定位到segment，再遍历链表定位到具体的元素上\",\"需要注意的是value是volatile的，所以get是不需要加锁的\"]},\"549\":{\"h\":\"JDK1.8：CAS+synchronized\",\"t\":[\"数据结构\",\"数据结构和HashMap是一样的，数组+链表+红黑树\",\"它实现线程安全的关键点在于put流程\",\"put流程\",\"首先计算hash，遍历node数组，如果数组是空的话，就通过CAS+自旋的方式初始化数组\",\" if (tab == null || (n = tab.length) == 0) tab = initTable(); \",\"初始化数组\",\"private final Node<K,V>[] initTable() { Node<K,V>[] tab; int sc; while ((tab = table) == null || tab.length == 0) { //如果正在初始化或者扩容 if ((sc = sizeCtl) < 0) //等待(让出线程) Thread.yield(); // lost initialization race; just spin else if (U.compareAndSetInt(this, SIZECTL, sc, -1)) {//CAS操作 try { if ((tab = table) == null || tab.length == 0) { int n = (sc > 0) ? sc : DEFAULT_CAPACITY; @SuppressWarnings(\\\"unchecked\\\") Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n]; table = tab = nt; sc = n - (n >>> 2); } } finally { sizeCtl = sc; } break; } } return tab; } \",\"如果当前数组位置是空则直接通过CAS自旋写入数据\",\"else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) { if (casTabAt(tab, i, null, new Node<K,V>(hash, key, value))) break; // no lock when adding to empty bin } \",\"如果hash==MOVED，说明需要扩容，执行扩容\",\" final Node<K,V>[] helpTransfer(Node<K,V>[] tab, Node<K,V> f) { Node<K,V>[] nextTab; int sc; if (tab != null && (f instanceof ForwardingNode) && (nextTab = ((ForwardingNode<K,V>)f).nextTable) != null) { int rs = resizeStamp(tab.length) << RESIZE_STAMP_SHIFT; while (nextTab == nextTable && table == tab && (sc = sizeCtl) < 0) { if (sc == rs + MAX_RESIZERS || sc == rs + 1 || transferIndex <= 0) break; if (U.compareAndSetInt(this, SIZECTL, sc, sc + 1)) { transfer(tab, nextTab); break; } } return nextTab; } return table; } \",\"如果都不满足，就使用synchronized写入数据\",\"写入数据同样判断链表、红黑树，链表写入和HashMap的方式一样，key hash一样就覆盖，反之就尾插法，链表长度超过8就转换成红黑树\",\"get查询\",\"无锁化读取，和HashMap的get流程基本相同 \",\"头节点通过Unsafe获取\"]},\"550\":{\"h\":\"HashMap 内部节点是有序的吗？\",\"t\":[\"HashMap 内部节点的顺序是无序的\",\"因为 HashMap 使用的是哈希表的数据结构，它通过哈希函数将键映射到桶（bucket）中，而不是按照插入顺序进行存储\",\"如果需要有序的存储和遍历元素，可以考虑使用 LinkedHashMap 或者 TreeMap\"]},\"551\":{\"h\":\"讲讲 LinkedHashMap 怎么实现有序的？\",\"t\":[\"LinkedHashMap在 HashMap 的基础上维护了一个双向链表，用于记录元素的插入顺序或访问顺序\",\"通过这个链表， LinkedHashMap 可以按照插入顺序或访问顺序进行遍历。\"]},\"552\":{\"h\":\"讲讲 TreeMap 怎么实现有序的？\",\"t\":[\"TreeMap 是基于红黑树实现的，是一种有序的的集合\",\"在 TreeMap 中，元素是按照是按照 Key 的自然顺序或者 Comprator 的顺序进行排序，因此可以通过键值来遍历 集合中的元素 \",\"不是通过插入顺序遍历\"]},\"553\":{\"h\":\"Set\"},\"554\":{\"h\":\"讲讲HashSet的底层实现？\",\"t\":[\"HashSet 底层就是基于 HashMap 实现的\",\"HashSet 的源码⾮常⾮常少，因为除了clone() 、 writeObject() 、 readObject() 是 HashSet⾃⼰不得不实现之外，其他⽅法都是直接调⽤ HashMap 中的⽅法。\",\"HashSet的add方法\",\" public boolean add(E e) { return map.put(e, PRESENT)==null; } \",\"直接调用HashMap的put方法，将添加的元素作为key，new一个Object作为value\",\"会根据返回值是否为空来判断是否插入元素成功\",\"HashMap的putVal\",\"进行了一系列判断，最后的结果是，只有在key在table数组中不存在的时候，才会返回插入的值\",\"if (e != null) { // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; } \"]},\"555\":{\"h\":\"引言\"},\"556\":{\"h\":\"说说有哪些常见集合？\",\"t\":[\"List\",\"Map\",\"Set\"]},\"557\":{\"h\":\"Docker实用篇\"},\"558\":{\"h\":\"1.1.什么是Docker\",\"t\":[\"微服务虽然具备各种各样的优势，但服务的拆分通用给部署带来了很大的麻烦。\",\"分布式系统中，依赖的组件非常多，不同组件之间部署时往往会产生一些冲突。\",\"在数百上千台服务中重复部署，环境不一定一致，会遇到各种问题\"]},\"559\":{\"h\":\"1.1.1.应用部署的环境问题\",\"t\":[\"大型项目组件较多，运行环境也较为复杂，部署时会碰到一些问题：\",\"依赖关系复杂，容易出现兼容性问题\",\"开发、测试、生产环境有差异\",\"image-20210731141907366\",\"例如一个项目中，部署时需要依赖于node.js、Redis、RabbitMQ、MySQL等，这些服务部署时所需要的函数库、依赖项各不相同，甚至会有冲突。给部署带来了极大的困难。\"]},\"560\":{\"h\":\"1.1.2.Docker解决依赖兼容问题\",\"t\":[\"而Docker确巧妙的解决了这些问题，Docker是如何实现的呢？\",\"Docker为了解决依赖的兼容问题的，采用了两个手段：\",\"将应用的Libs（函数库）、Deps（依赖）、配置与应用一起打包\",\"将每个应用放到一个隔离容器去运行，避免互相干扰\",\"image-20210731142219735\",\"这样打包好的应用包中，既包含应用本身，也保护应用所需要的Libs、Deps，无需再操作系统上安装这些，自然就不存在不同应用之间的兼容问题了。\",\"虽然解决了不同应用的兼容问题，但是开发、测试等环境会存在差异，操作系统版本也会有差异，怎么解决这些问题呢？\"]},\"561\":{\"h\":\"1.1.3.Docker解决操作系统环境差异\",\"t\":[\"要解决不同操作系统环境差异问题，必须先了解操作系统结构。以一个Ubuntu操作系统为例，结构如下：\",\"image-20210731143401460\",\"结构包括：\",\"计算机硬件：例如CPU、内存、磁盘等\",\"系统内核：所有Linux发行版的内核都是Linux，例如CentOS、Ubuntu、Fedora等。内核可以与计算机硬件交互，对外提供内核指令，用于操作计算机硬件。\",\"系统应用：操作系统本身提供的应用、函数库。这些函数库是对内核指令的封装，使用更加方便。\",\"应用于计算机交互的流程如下：\",\"1）应用调用操作系统应用（函数库），实现各种功能\",\"2）系统函数库是对内核指令集的封装，会调用内核指令\",\"3）内核指令操作计算机硬件\",\"Ubuntu和CentOSpringBoot都是基于Linux内核，无非是系统应用不同，提供的函数库有差异：\",\"image-20210731144304990\",\"此时，如果将一个Ubuntu版本的MySQL应用安装到CentOS系统，MySQL在调用Ubuntu函数库时，会发现找不到或者不匹配，就会报错了：\",\"image-20210731144458680\",\"Docker如何解决不同系统环境的问题？\",\"Docker将用户程序与所需要调用的系统(比如Ubuntu)函数库一起打包\",\"Docker运行到不同操作系统时，直接基于打包的函数库，借助于操作系统的Linux内核来运行\",\"如图：\",\"image-20210731144820638\"]},\"562\":{\"h\":\"1.1.4.小结\",\"t\":[\"Docker如何解决大型项目依赖关系复杂，不同组件依赖的兼容性问题？\",\"Docker允许开发中将应用、依赖、函数库、配置一起打包，形成可移植镜像\",\"Docker应用运行在容器中，使用沙箱机制，相互隔离\",\"Docker如何解决开发、测试、生产环境有差异的问题？\",\"Docker镜像中包含完整运行环境，包括系统函数库，仅依赖系统的Linux内核，因此可以在任意Linux操作系统上运行\",\"Docker是一个快速交付应用、运行应用的技术，具备下列优势：\",\"可以将程序及其依赖、运行环境一起打包为一个镜像，可以迁移到任意Linux操作系统\",\"运行时利用沙箱机制形成隔离容器，各个应用互不干扰\",\"启动、移除都可以通过一行命令完成，方便快捷\"]},\"563\":{\"h\":\"1.2.Docker和虚拟机的区别\",\"t\":[\"Docker可以让一个应用在任何操作系统中非常方便的运行。而以前我们接触的虚拟机，也能在一个操作系统中，运行另外一个操作系统，保护系统中的任何应用。\",\"两者有什么差异呢？\",\"虚拟机（virtual machine）是在操作系统中模拟硬件设备，然后运行另一个操作系统，比如在 Windows 系统里面运行 Ubuntu 系统，这样就可以运行任意的Ubuntu应用了。\",\"Docker仅仅是封装函数库，并没有模拟完整的操作系统，如图：\",\"image-20210731145914960\",\"对比来看：\",\"image-20210731152243765\",\"小结：\",\"Docker和虚拟机的差异：\",\"docker是一个系统进程；虚拟机是在操作系统中的操作系统\",\"docker体积小、启动速度快、性能好；虚拟机体积大、启动速度慢、性能一般\"]},\"564\":{\"h\":\"1.3.Docker架构\"},\"565\":{\"h\":\"1.3.1.镜像和容器\",\"t\":[\"Docker中有几个重要的概念：\",\"镜像（Image）：Docker将应用程序及其所需的依赖、函数库、环境、配置等文件打包在一起，称为镜像。\",\"容器（Container）：镜像中的应用程序运行后形成的进程就是容器，只是Docker会给容器进程做隔离，对外不可见。\",\"一切应用最终都是代码组成，都是硬盘中的一个个的字节形成的文件。只有运行时，才会加载到内存，形成进程。\",\"而镜像，就是把一个应用在硬盘上的文件、及其运行环境、部分系统函数库文件一起打包形成的文件包。这个文件包是只读的。\",\"容器呢，就是将这些文件中编写的程序、函数加载到内存中允许，形成进程，只不过要隔离起来。因此一个镜像可以启动多次，形成多个容器进程。\",\"image-20210731153059464\",\"例如你下载了一个QQ，如果我们将QQ在磁盘上的运行文件及其运行的操作系统依赖打包，形成QQ镜像。然后你可以启动多次，双开、甚至三开QQ，跟多个妹子聊天。\"]},\"566\":{\"h\":\"1.3.2.DockerHub\",\"t\":[\"开源应用程序非常多，打包这些应用往往是重复的劳动。为了避免这些重复劳动，人们就会将自己打包的应用镜像，例如Redis、MySQL镜像放到网络上，共享使用，就像GitHub的代码共享一样。\",\"DockerHub：DockerHub是一个官方的Docker镜像的托管平台。这样的平台称为Docker Registry。\",\"国内也有类似于DockerHub 的公开服务，比如 网易云镜像服务、阿里云镜像库等。\",\"我们一方面可以将自己的镜像共享到DockerHub，另一方面也可以从DockerHub拉取镜像：\",\"image-20210731153743354\"]},\"567\":{\"h\":\"1.3.3.Docker架构\",\"t\":[\"我们要使用Docker来操作镜像、容器，就必须要安装Docker。\",\"Docker是一个CS架构的程序，由两部分组成：\",\"服务端(server)：Docker守护进程，负责处理Docker指令，管理镜像、容器等\",\"客户端(client)：通过命令或RestAPI向Docker服务端发送指令。可以在本地或远程向服务端发送指令。\",\"如图：\",\"image-20210731154257653\"]},\"568\":{\"h\":\"1.3.4.小结\",\"t\":[\"镜像：\",\"将应用程序及其依赖、环境、配置打包在一起\",\"容器：\",\"镜像运行起来就是容器，一个镜像可以运行多个容器\",\"Docker结构：\",\"服务端：接收命令或远程请求，操作镜像或容器\",\"客户端：发送命令或者请求到Docker服务端\",\"DockerHub：\",\"一个镜像托管的服务器，类似的还有阿里云镜像服务，统称为DockerRegistry\"]},\"569\":{\"h\":\"1.4.安装Docker\",\"t\":[\"企业部署一般都是采用Linux操作系统，而其中又数CentOS发行版占比最多，因此我们在CentOS下安装Docker。参考课前资料中的文档：\",\"image-20210731155002425\"]},\"570\":{\"h\":\"2.1.镜像操作\"},\"571\":{\"h\":\"2.1.1.镜像名称\",\"t\":[\"首先来看下镜像的名称组成：\",\"镜名称一般分两部分组成：[repository]:[tag]。\",\"在没有指定tag时，默认是latest，代表最新版本的镜像\",\"如图：\",\"image-20210731155141362\",\"这里的mysql就是repository，5.7就是tag，合一起就是镜像名称，代表5.7版本的MySQL镜像。\"]},\"572\":{\"h\":\"2.1.2.镜像命令\",\"t\":[\"常见的镜像操作命令如图：\",\"image-20210731155649535\"]},\"573\":{\"h\":\"2.1.3.案例1-拉取、查看镜像\",\"t\":[\"需求：从DockerHub中拉取一个nginx镜像并查看\",\"1）首先去镜像仓库搜索nginx镜像，比如DockerHub:\",\"image-20210731155844368\",\"2）根据查看到的镜像名称，拉取自己需要的镜像，通过命令：docker pull nginx\",\"image-20210731155856199\",\"3）通过命令：docker images 查看拉取到的镜像\",\"image-20210731155903037\"]},\"574\":{\"h\":\"2.1.4.案例2-保存、导入镜像\",\"t\":[\"需求：利用docker save将nginx镜像导出磁盘，然后再通过load加载回来\",\"1）利用docker xx --help命令查看docker save和docker load的语法\",\"例如，查看save命令用法，可以输入命令：\",\"docker save --help \",\"结果：\",\"image-20210731161104732\",\"命令格式：\",\"docker save -o [保存的目标文件名称] [镜像名称] \",\"2）使用docker save导出镜像到磁盘\",\"运行命令：\",\"docker save -o nginx.tar nginx:latest \",\"结果如图：\",\"image-20210731161354344\",\"3）使用docker load加载镜像\",\"先删除本地的nginx镜像：\",\"docker rmi nginx:latest \",\"然后运行命令，加载本地文件：\",\"docker load -i nginx.tar \",\"结果：\",\"image-20210731161746245\"]},\"575\":{\"h\":\"2.1.5.练习\",\"t\":[\"需求：去DockerHub搜索并拉取一个Redis镜像\",\"目标：\",\"1）去DockerHub搜索Redis镜像\",\"2）查看Redis镜像的名称和版本\",\"3）利用docker pull命令拉取镜像\",\"4）利用docker save命令将 redis:latest打包为一个redis.tar包\",\"5）利用docker rmi 删除本地的redis:latest\",\"6）利用docker load 重新加载 redis.tar文件\"]},\"576\":{\"h\":\"2.2.容器操作\"},\"577\":{\"h\":\"2.2.1.容器相关命令\",\"t\":[\"容器操作的命令如图：\",\"image-20210731161950495\",\"容器保护三个状态：\",\"运行：进程正常运行\",\"暂停：进程暂停，CPU不再运行，并不释放内存\",\"停止：进程终止，回收进程占用的内存、CPU等资源\",\"其中：\",\"docker run：创建并运行一个容器，处于运行状态\",\"docker pause：让一个运行的容器暂停\",\"docker unpause：让一个容器从暂停状态恢复运行\",\"docker stop：停止一个运行的容器\",\"docker start：让一个停止的容器再次运行\",\"docker rm：删除一个容器\"]},\"578\":{\"h\":\"2.2.2.案例-创建并运行一个容器\",\"t\":[\"创建并运行nginx容器的命令：\",\"docker run --name containerName -p 80:80 -d nginx \",\"命令解读：\",\"docker run ：创建并运行一个容器\",\"--name : 给容器起一个名字，比如叫做mn\",\"-p ：将宿主机端口与容器端口映射，冒号左侧是宿主机端口，右侧是容器端口\",\"-d：后台运行容器\",\"nginx：镜像名称，例如nginx\",\"这里的-p参数，是将容器端口映射到宿主机端口。\",\"默认情况下，容器是隔离环境，我们直接访问宿主机的80端口，肯定访问不到容器中的nginx。\",\"现在，将容器的80与宿主机的80关联起来，当我们访问宿主机的80端口时，就会被映射到容器的80，这样就能访问到nginx了：\",\"image-20210731163255863\"]},\"579\":{\"h\":\"2.2.3.案例-进入容器，修改文件\",\"t\":[\"需求：进入Nginx容器，修改HTML文件内容，添加“传智教育欢迎您”\",\"提示：进入容器要用到docker exec命令。\",\"步骤：\",\"1）进入容器。进入我们刚刚创建的nginx容器的命令为：\",\"docker exec -it mn bash \",\"命令解读：\",\"docker exec ：进入容器内部，执行一个命令\",\"-it : 给当前进入的容器创建一个标准输入、输出终端，允许我们与容器交互\",\"mn ：要进入的容器的名称\",\"bash：进入容器后执行的命令，bash是一个linux终端交互命令\",\"2）进入nginx的HTML所在目录 /usr/share/nginx/html\",\"容器内部会模拟一个独立的Linux文件系统，看起来如同一个linux服务器一样：\",\"image-20210731164159811\",\"nginx的环境、配置、运行文件全部都在这个文件系统中，包括我们要修改的html文件。\",\"查看DockerHub网站中的nginx页面，可以知道nginx的html目录位置在/usr/share/nginx/html\",\"我们执行命令，进入该目录：\",\"cd /usr/share/nginx/html \",\"查看目录下文件：\",\"image-20210731164455818\",\"3）修改index.html的内容\",\"容器内没有vi命令，无法直接修改，我们用下面的命令来修改：\",\"sed -i -e 's#Welcome to nginx#传智教育欢迎您#g' -e 's#<head>#<head><meta charset=\\\"utf-8\\\">#g' index.html \",\"在浏览器访问自己的虚拟机地址，例如我的是：http://192.168.150.101，即可看到结果：\",\"image-20210731164717604\"]},\"580\":{\"h\":\"2.2.4.小结\",\"t\":[\"docker run命令的常见参数有哪些？\",\"--name：指定容器名称\",\"-p：指定端口映射\",\"-d：让容器后台运行\",\"查看容器日志的命令：\",\"docker logs\",\"添加 -f 参数可以持续查看日志\",\"查看容器状态：\",\"docker ps\",\"docker ps -a 查看所有容器，包括已经停止的\"]},\"581\":{\"h\":\"2.3.数据卷（容器数据管理）\",\"t\":[\"在之前的nginx案例中，修改nginx的html页面时，需要进入nginx内部。并且因为没有编辑器，修改文件也很麻烦。\",\"这就是因为容器与数据（容器内文件）耦合带来的后果。\",\"image-20210731172440275\",\"要解决这个问题，必须将数据与容器解耦，这就要用到数据卷了。\"]},\"582\":{\"h\":\"2.3.1.什么是数据卷\",\"t\":[\"**数据卷（volume）**是一个虚拟目录，指向宿主机文件系统中的某个目录。\",\"image-20210731173541846\",\"一旦完成数据卷挂载，对容器的一切操作都会作用在数据卷对应的宿主机目录了。\",\"这样，我们操作宿主机的/var/lib/docker/volumes/html目录，就等于操作容器内的/usr/share/nginx/html目录了\"]},\"583\":{\"h\":\"2.3.2.数据集操作命令\",\"t\":[\"数据卷操作的基本语法如下：\",\"docker volume [COMMAND] \",\"docker volume命令是数据卷操作，根据命令后跟随的command来确定下一步的操作：\",\"create 创建一个volume\",\"inspect 显示一个或多个volume的信息\",\"ls 列出所有的volume\",\"prune 删除未使用的volume\",\"rm 删除一个或多个指定的volume\"]},\"584\":{\"h\":\"2.3.3.创建和查看数据卷\",\"t\":[\"需求：创建一个数据卷，并查看数据卷在宿主机的目录位置\",\"① 创建数据卷\",\"docker volume create html \",\"② 查看所有数据\",\"docker volume ls \",\"结果：\",\"image-20210731173746910\",\"③ 查看数据卷详细信息卷\",\"docker volume inspect html \",\"结果：\",\"image-20210731173809877\",\"可以看到，我们创建的html这个数据卷关联的宿主机目录为/var/lib/docker/volumes/html/_data目录。\",\"小结：\",\"数据卷的作用：\",\"将容器与数据分离，解耦合，方便操作容器内数据，保证数据安全\",\"数据卷操作：\",\"docker volume create：创建数据卷\",\"docker volume ls：查看所有数据卷\",\"docker volume inspect：查看数据卷详细信息，包括关联的宿主机目录位置\",\"docker volume rm：删除指定数据卷\",\"docker volume prune：删除所有未使用的数据卷\"]},\"585\":{\"h\":\"2.3.4.挂载数据卷\",\"t\":[\"我们在创建容器时，可以通过 -v 参数来挂载一个数据卷到某个容器内目录，命令格式如下：\",\"docker run \\\\ --name mn \\\\ -v html:/root/html \\\\ -p 8080:80 nginx \\\\ \",\"这里的-v就是挂载数据卷的命令：\",\"-v html:/root/htm ：把html数据卷挂载到容器内的/root/html这个目录中\"]},\"586\":{\"h\":\"2.3.5.案例-给nginx挂载数据卷\",\"t\":[\"需求：创建一个nginx容器，修改容器内的html目录内的index.html内容\",\"分析：上个案例中，我们进入nginx容器内部，已经知道nginx的html目录所在位置/usr/share/nginx/html ，我们需要把这个目录挂载到html这个数据卷上，方便操作其中的内容。\",\"提示：运行容器时使用 -v 参数挂载数据卷\",\"步骤：\",\"① 创建容器并挂载数据卷到容器内的HTML目录\",\"docker run --name mn -v html:/usr/share/nginx/html -p 80:80 -d nginx \",\"② 进入html数据卷所在位置，并修改HTML内容\",\"# 查看html数据卷的位置 docker volume inspect html # 进入该目录 cd /var/lib/docker/volumes/html/_data # 修改文件 vi index.html \"]},\"587\":{\"h\":\"2.3.6.案例-给MySQL挂载本地目录\",\"t\":[\"容器不仅仅可以挂载数据卷，也可以直接挂载到宿主机目录上。关联关系如下：\",\"带数据卷模式：宿主机目录 --> 数据卷 ---> 容器内目录\",\"直接挂载模式：宿主机目录 ---> 容器内目录\",\"如图：\",\"image-20210731175155453\",\"语法：\",\"目录挂载与数据卷挂载的语法是类似的：\",\"-v [宿主机目录]:[容器内目录]\",\"-v [宿主机文件]:[容器内文件]\",\"需求：创建并运行一个MySQL容器，将宿主机目录直接挂载到容器\",\"实现思路如下：\",\"1）在将课前资料中的mysql.tar文件上传到虚拟机，通过load命令加载为镜像\",\"2）创建目录/tmp/mysql/data\",\"3）创建目录/tmp/mysql/conf，将课前资料提供的hmy.cnf文件上传到/tmp/mysql/conf\",\"4）去DockerHub查阅资料，创建并运行MySQL容器，要求：\",\"① 挂载/tmp/mysql/data到mysql容器内数据存储目录\",\"② 挂载/tmp/mysql/conf/hmy.cnf到mysql容器的配置文件\",\"③ 设置MySQL密码\"]},\"588\":{\"h\":\"2.3.7.小结\",\"t\":[\"docker run的命令中通过 -v 参数挂载文件或目录到容器中：\",\"-v volume名称:容器内目录\",\"-v 宿主机文件:容器内文\",\"-v 宿主机目录:容器内目录\",\"数据卷挂载与目录直接挂载的\",\"数据卷挂载耦合度低，由docker来管理目录，但是目录较深，不好找\",\"目录挂载耦合度高，需要我们自己管理目录，不过目录容易寻找查看\",\"常见的镜像在DockerHub就能找到，但是我们自己写的项目就必须自己构建镜像了。\",\"而要自定义镜像，就必须先了解镜像的结构才行。\"]},\"589\":{\"h\":\"3.1.镜像结构\",\"t\":[\"镜像是将应用程序及其需要的系统函数库、环境、配置、依赖打包而成。\",\"我们以MySQL为例，来看看镜像的组成结构：\",\"image-20210731175806273\",\"简单来说，镜像就是在系统函数库、运行环境基础上，添加应用程序文件、配置文件、依赖文件等组合，然后编写好启动脚本打包在一起形成的文件。\",\"我们要构建镜像，其实就是实现上述打包的过程。\"]},\"590\":{\"h\":\"3.2.Dockerfile语法\",\"t\":[\"构建自定义的镜像时，并不需要一个个文件去拷贝，打包。\",\"我们只需要告诉Docker，我们的镜像的组成，需要哪些BaseImage、需要拷贝什么文件、需要安装什么依赖、启动脚本是什么，将来Docker会帮助我们构建镜像。\",\"而描述上述信息的文件就是Dockerfile文件。\",\"Dockerfile就是一个文本文件，其中包含一个个的指令(Instruction)，用指令来说明要执行什么操作来构建镜像。每一个指令都会形成一层Layer。\",\"image-20210731180321133\",\"更新详细语法说明，请参考官网文档： https://docs.docker.com/engine/reference/builder\"]},\"591\":{\"h\":\"3.3.构建Java项目\"},\"592\":{\"h\":\"3.3.1.基于Ubuntu构建Java项目\",\"t\":[\"需求：基于Ubuntu镜像构建一个新镜像，运行一个java项目\",\"步骤1：新建一个空文件夹docker-demo\",\"image-20210801101207444\",\"步骤2：拷贝课前资料中的docker-demo.jar文件到docker-demo这个目录\",\"image-20210801101314816\",\"步骤3：拷贝课前资料中的jdk8.tar.gz文件到docker-demo这个目录\",\"image-20210801101410200\",\"步骤4：拷贝课前资料提供的Dockerfile到docker-demo这个目录\",\"image-20210801101455590\",\"其中的内容如下：\",\"# 指定基础镜像 FROM ubuntu:16.04 # 配置环境变量，JDK的安装目录 ENV JAVA_DIR=/usr/local # 拷贝jdk和java项目的包 COPY ./jdk8.tar.gz $JAVA_DIR/ COPY ./docker-demo.jar /tmp/app.jar # 安装JDK RUN cd $JAVA_DIR \\\\ && tar -xf ./jdk8.tar.gz \\\\ && mv ./jdk1.8.0_144 ./java8 # 配置环境变量 ENV JAVA_HOME=$JAVA_DIR/java8 ENV PATH=$PATH:$JAVA_HOME/bin # 暴露端口 EXPOSE 8090 # 入口，java项目的启动命令 ENTRYPOINT java -jar /tmp/app.jar \",\"步骤5：进入docker-demo\",\"将准备好的docker-demo上传到虚拟机任意目录，然后进入docker-demo目录下\",\"步骤6：运行命令：\",\"docker build -t javaweb:1.0 . \",\"最后访问 http://192.168.150.101:8090/hello/count，其中的ip改成你的虚拟机ip\"]},\"593\":{\"h\":\"3.3.2.基于java8构建Java项目\",\"t\":[\"虽然我们可以基于Ubuntu基础镜像，添加任意自己需要的安装包，构建镜像，但是却比较麻烦。所以大多数情况下，我们都可以在一些安装了部分软件的基础镜像上做改造。\",\"例如，构建java项目的镜像，可以在已经准备了JDK的基础镜像基础上构建。\",\"需求：基于java:8-alpine镜像，将一个Java项目构建为镜像\",\"实现思路如下：\",\"① 新建一个空的目录，然后在目录中新建一个文件，命名为Dockerfile\",\"② 拷贝课前资料提供的docker-demo.jar到这个目录中\",\"③ 编写Dockerfile文件：\",\"a ）基于java:8-alpine作为基础镜像\",\"b ）将app.jar拷贝到镜像中\",\"c ）暴露端口\",\"d ）编写入口ENTRYPOINT\",\"内容如下：\",\"FROM java:8-alpine COPY ./app.jar /tmp/app.jar EXPOSE 8090 ENTRYPOINT java -jar /tmp/app.jar \",\"④ 使用docker build命令构建镜像\",\"⑤ 使用docker run创建容器并运行\"]},\"594\":{\"h\":\"3.4.小结\",\"t\":[\"小结：\",\"Dockerfile的本质是一个文件，通过指令描述镜像的构建过程\",\"Dockerfile的第一行必须是FROM，从一个基础镜像来构建\",\"基础镜像可以是基本操作系统，如Ubuntu。也可以是其他人制作好的镜像，例如：java:8-alpine\",\"Docker Compose可以基于Compose文件帮我们快速的部署分布式应用，而无需手动一个个创建和运行容器！\",\"image-20210731180921742\"]},\"595\":{\"h\":\"4.1.初识DockerCompose\",\"t\":[\"Compose文件是一个文本文件，通过指令定义集群中的每个容器如何运行。格式如下：\",\"version: \\\"3.8\\\" services: mysql: image: mysql:5.7.25 environment: MYSQL_ROOT_PASSWORD: 123 volumes: - \\\"/tmp/mysql/data:/var/lib/mysql\\\" - \\\"/tmp/mysql/conf/hmy.cnf:/etc/mysql/conf.d/hmy.cnf\\\" web: build: . ports: - \\\"8090:8090\\\" \",\"上面的Compose文件就描述一个项目，其中包含两个容器：\",\"mysql：一个基于mysql:5.7.25镜像构建的容器，并且挂载了两个目录\",\"web：一个基于docker build临时构建的镜像容器，映射端口时8090\",\"DockerCompose的详细语法参考官网：https://docs.docker.com/compose/compose-file/\",\"其实DockerCompose文件可以看做是将多个docker run命令写到一个文件，只是语法稍有差异。\"]},\"596\":{\"h\":\"4.2.安装DockerCompose\",\"t\":[\"参考课前资料\"]},\"597\":{\"h\":\"4.3.部署微服务集群\",\"t\":[\"需求：将之前学习的cloud-demo微服务集群利用DockerCompose部署\",\"实现思路：\",\"① 查看课前资料提供的cloud-demo文件夹，里面已经编写好了docker-compose文件\",\"② 修改自己的cloud-demo项目，将数据库、nacos地址都命名为docker-compose中的服务名\",\"③ 使用maven打包工具，将项目中的每个微服务都打包为app.jar\",\"④ 将打包好的app.jar拷贝到cloud-demo中的每一个对应的子目录中\",\"⑤ 将cloud-demo上传至虚拟机，利用 docker-compose up -d 来部署\"]},\"598\":{\"h\":\"4.3.1.compose文件\",\"t\":[\"查看课前资料提供的cloud-demo文件夹，里面已经编写好了docker-compose文件，而且每个微服务都准备了一个独立的目录：\",\"image-20210731181341330\",\"内容如下：\",\"version: \\\"3.2\\\" services: nacos: image: nacos/nacos-server environment: MODE: standalone ports: - \\\"8848:8848\\\" mysql: image: mysql:5.7.25 environment: MYSQL_ROOT_PASSWORD: 123 volumes: - \\\"$PWD/mysql/data:/var/lib/mysql\\\" - \\\"$PWD/mysql/conf:/etc/mysql/conf.d/\\\" userservice: build: ./user-service orderservice: build: ./order-service gateway: build: ./gateway ports: - \\\"10010:10010\\\" \",\"可以看到，其中包含5个service服务：\",\"nacos：作为注册中心和配置中心 \",\"image: nacos/nacos-server： 基于nacos/nacos-server镜像构建\",\"environment：环境变量 \",\"MODE: standalone：单点模式启动\",\"ports：端口映射，这里暴露了8848端口\",\"mysql：数据库 \",\"image: mysql:5.7.25：镜像版本是mysql:5.7.25\",\"environment：环境变量 \",\"MYSQL_ROOT_PASSWORD: 123：设置数据库root账户的密码为123\",\"volumes：数据卷挂载，这里挂载了mysql的data、conf目录，其中有我提前准备好的数据\",\"userservice、orderservice、gateway：都是基于Dockerfile临时构建的\",\"查看mysql目录，可以看到其中已经准备好了cloud_order、cloud_user表：\",\"image-20210801095205034\",\"查看微服务目录，可以看到都包含Dockerfile文件：\",\"image-20210801095320586\",\"内容如下：\",\"FROM java:8-alpine COPY ./app.jar /tmp/app.jar ENTRYPOINT java -jar /tmp/app.jar \"]},\"599\":{\"h\":\"4.3.2.修改微服务配置\",\"t\":[\"因为微服务将来要部署为docker容器，而容器之间互联不是通过IP地址，而是通过容器名。这里我们将order-service、user-service、gateway服务的mysql、nacos地址都修改为基于容器名的访问。\",\"如下所示：\",\"spring: datasource: url: jdbc:mysql://mysql:3306/cloud_order?useSSL=false username: root password: 123 driver-class-name: com.mysql.jdbc.Driver application: name: orderservice cloud: nacos: server-addr: nacos:8848 # nacos服务地址 \"]},\"600\":{\"h\":\"4.3.3.打包\",\"t\":[\"接下来需要将我们的每个微服务都打包。因为之前查看到Dockerfile中的jar包名称都是app.jar，因此我们的每个微服务都需要用这个名称。\",\"可以通过修改pom.xml中的打包名称来实现，每个微服务都需要修改：\",\"<build> <!-- 服务打包的最终名称 --> <finalName>app</finalName> <plugins> <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> </plugin> </plugins> </build> \",\"打包后：\",\"image-20210801095951030\"]},\"601\":{\"h\":\"4.3.4.拷贝jar包到部署目录\",\"t\":[\"编译打包好的app.jar文件，需要放到Dockerfile的同级目录中。注意：每个微服务的app.jar放到与服务名称对应的目录，别搞错了。\",\"user-service：\",\"image-20210801100201253\",\"order-service：\",\"image-20210801100231495\",\"gateway：\",\"image-20210801100308102\"]},\"602\":{\"h\":\"4.3.5.部署\",\"t\":[\"最后，我们需要将文件整个cloud-demo文件夹上传到虚拟机中，理由DockerCompose部署。\",\"上传到任意目录：\",\"image-20210801100955653\",\"部署：\",\"进入cloud-demo目录，然后运行下面的命令：\",\"docker-compose up -d \"]},\"603\":{\"h\":\"5.1.搭建私有镜像仓库\",\"t\":[\"参考课前资料《CentOS7安装Docker.md》\"]},\"604\":{\"h\":\"5.2.推送、拉取镜像\",\"t\":[\"推送镜像到私有镜像服务必须先tag，步骤如下：\",\"① 重新tag本地镜像，名称前缀为私有仓库的地址：192.168.150.101:8080/\",\"docker tag nginx:latest 192.168.150.101:8080/nginx:1.0 \",\"② 推送镜像\",\"docker push 192.168.150.101:8080/nginx:1.0 \",\"③ 拉取镜像\",\"docker pull 192.168.150.101:8080/nginx:1.0 \"]},\"605\":{\"h\":\"基础\"},\"606\":{\"h\":\"讲一下distinct的语法\",\"t\":[\"DISTINCT 关键字在 SQL 中用于从结果集中去除重复的行。它可以用于单个字段，也可以用于多个字段。当用于多个字段时，只有当所有指定的字段的组合都相同时，才会被视为重复并去除。\"]},\"607\":{\"h\":\"基本语法\"},\"608\":{\"h\":\"单字段去重\",\"t\":[\"SELECT DISTINCT column1 FROM table_name; \",\"这个查询将返回表 table_name 中 column1 字段的唯一值。\"]},\"609\":{\"h\":\"多字段去重\",\"t\":[\"SELECT DISTINCT column1, column2 FROM table_name; \",\"这个查询将返回表 table_name 中 column1 和 column2 组合后的唯一值。\"]},\"610\":{\"h\":\"示例\",\"t\":[\"假设有一个名为 employees 的表，包含以下数据：\",\"id\",\"first_name\",\"last_name\",\"department\",\"1\",\"John\",\"Doe\",\"HR\",\"2\",\"Jane\",\"Doe\",\"IT\",\"3\",\"John\",\"Smith\",\"IT\",\"4\",\"John\",\"Doe\",\"HR\"]},\"611\":{\"h\":\"单字段去重示例\",\"t\":[\"SELECT DISTINCT first_name FROM employees; \",\"这个查询将返回所有唯一的 first_name：\",\"first_name\",\"John\",\"Jane\"]},\"612\":{\"h\":\"多字段去重示例\",\"t\":[\"SELECT DISTINCT first_name, last_name FROM employees; \",\"这个查询将返回所有唯一的 first_name 和 last_name 的组合：\",\"first_name\",\"last_name\",\"John\",\"Doe\",\"Jane\",\"Doe\",\"John\",\"Smith\"]},\"613\":{\"h\":\"注意事项\",\"t\":[\"DISTINCT 关键字适用于所有字段的组合。如果两个或多个行的所有字段都相同，则这些行被视为重复行。\",\"当在多个字段上使用 DISTINCT 时，SQL 引擎会根据指定的字段组合来检查重复。\",\"在大数据集上使用 DISTINCT 可能会影响性能，因为需要对结果进行去重操作。\"]},\"614\":{\"h\":\"在查询中使用 DISTINCT\",\"t\":[\"假设我们有一个查询，需要对多个字段进行去重，并且需要对结果进行排序和限制返回的行数。可以使用如下方式：\",\"SELECT DISTINCT column1, column2 FROM table_name WHERE some_condition ORDER BY column1, column2 LIMIT 10; \",\"这个查询将对 column1 和 column2 进行去重，然后按照指定的字段排序，最后限制返回的行数为 10。\"]},\"615\":{\"h\":\"limit 语句和distinct哪个先执行\",\"t\":[\"在 SQL 查询的执行过程中，DISTINCT 会先于 LIMIT 执行。这意味着在应用 LIMIT 之前，查询会首先通过 DISTINCT 去除重复的行。\"]},\"616\":{\"h\":\"执行顺序\",\"t\":[\"FROM 子句 - 确定从哪个表或视图中选择数据。\",\"WHERE 子句 - 应用过滤条件，筛选出满足条件的行。\",\"JOIN 子句 - 执行表的连接操作。\",\"GROUP BY 子句 - 对数据进行分组。\",\"HAVING 子句 - 筛选分组后的数据。\",\"SELECT 子句 - 选择要返回的列，同时可以包含 DISTINCT 去重操作。\",\"DISTINCT 操作 - 去除重复的行。\",\"ORDER BY 子句 - 对结果集进行排序。\",\"LIMIT 子句 - 限制返回的行数。\"]},\"617\":{\"h\":\"示例说明\",\"t\":[\"假设有一个名为 employees 的表，包含以下数据：\",\"id\",\"first_name\",\"last_name\",\"department\",\"1\",\"John\",\"Doe\",\"HR\",\"2\",\"Jane\",\"Doe\",\"IT\",\"3\",\"John\",\"Smith\",\"IT\",\"4\",\"John\",\"Doe\",\"HR\"]},\"618\":{\"h\":\"查询示例\",\"t\":[\"SELECT DISTINCT first_name, last_name FROM employees ORDER BY last_name LIMIT 2; \",\"执行顺序如下：\",\"FROM 子句 - 读取 employees 表中的所有数据。\",\"SELECT 子句 - 选择 first_name 和 last_name 列。\",\"DISTINCT 操作 - 去除重复的 first_name 和 last_name 组合。结果为：\",\"first_name\",\"last_name\",\"John\",\"Doe\",\"Jane\",\"Doe\",\"John\",\"Smith\",\"ORDER BY 子句 - 按 last_name 排序。结果为：\",\"first_name\",\"last_name\",\"John\",\"Doe\",\"Jane\",\"Doe\",\"John\",\"Smith\",\"LIMIT 子句 - 限制返回的行数为 2。最终结果为：\",\"first_name\",\"last_name\",\"John\",\"Doe\",\"Jane\",\"Doe\"]},\"619\":{\"h\":\"总结\",\"t\":[\"在 SQL 查询中，DISTINCT 操作在 LIMIT 之前执行。这意味着查询首先会去除重复的行，然后对去重后的结果集应用 LIMIT 限制返回的行数。\"]},\"620\":{\"h\":\"智能变电站实用知识问答\",\"t\":[\"进度： 小于1/3\"]},\"621\":{\"h\":\"什么是智能电网？\",\"t\":[\"智能电网（Smart Power Grids），就是电网的智能化，也被称为“电网2．0”。它是建立在集成的高速双向通信网络基础上，通过先进的传感和测量技术、先进的设备技术、先进的控制方法及先进的决策支持系统技术的应用，实现电网的可靠、安全、经济、高效、环境友好和使用安全的目标。与现代电网相比，智能电网体现出电力流、信息流和业务流高度融合的显著特点。\"]},\"622\":{\"h\":\"智能电网有哪些特征？\",\"t\":[\"智能电网的特征如下所述。 （1）坚强：在电网发生大扰动和故障时，仍能保持对用户的供电能力，而不发生大面积停电事故；在自然灾害、极端气候条件下或外力破坏下仍能保证电网的安全运行；具有确保电力信息安全的能力。 （2）自愈：具有实时、在线和连续的安全评估和分析能力，强大的预警和预防控制能力，以及自动故障诊断、故障隔离和系统自我恢复的能力。 （3）兼容：支持可再生能源的有序、合理接入，适应分布式电源和微电网的接入，能够实现与用户的交互和高效互动，满足用户多样化的电力需求，并提供对用户的增值服务。 （4）经济：支持电力市场运营和电力交易的有效开展，实现资源的优化配置，降低电网损耗，提高能源利用效率。 （5）集成：实现电网信息的高度集成和共享，采用统一的平台和模型，实现标准化、规范化和精益化管理。 （6）优化：优化资产的利用，降低投资成本和运行维护成本。\"]},\"623\":{\"h\":\"什么是智能变电站？\",\"t\":[\"智能变电站采用先进、可靠、集成、低碳、环保的智能设备，以全站信息数字化、通信平台网络化、信息共享标准化为基本要求，自动完成信息采集、测量、控制、保护、计量和监测等基本功能，并可根据需要支持电网实时自动控制、智能调节、在线分析决策、协同互动等高级功能，实现与相邻变电站、电网调度等互动的变电站。\"]},\"624\":{\"h\":\"智能变电站与数字化变电站有什么区别？\",\"t\":[\"智能变电站与数字化变电站有密不可分的联系。数字化变电站是智能变电站的前提和基础，是智能变电站的初级阶段，智能变电站是数字化变电站的发展和升级。智能变电站拥有数字化变电站的所有自动化功能和技术特征。智能变电站与数字化变电站的差别主要体现在以下两个方面。\",\"（1）数字化变电站主要从满足变电站自身的需求出发，实现站内一次、二次设备的数字化通信和控制，建立全站统一的数据通信平台，侧重于在统一通信平台的基础上提高变电站内设备与系统间的互操作性。而智能变电站则从满足智能电网运行要求出发，比数字化变电站更加注重变电站之间、变电站与调度中心之间的信息的统一与功能的层次化。智能变电站需要建立全网统一的标准化信息平台，作为该平台的重要节点，提高其硬件与软件的标准化程度，以在全网范围内提高系统的整体运行水平为目标。\",\"（2）数字化变电站已经具有一定程度的设备集成和功能优化的概念，要求站内应用的所有智能电子装置（IED）满足统一的标准，拥有统一的接口，以实现互操作性。IED分布安装于站内，其功能的整合以统一标准为纽带，利用网络通信来实现。数字化变电站在以太网通信的基础上，模糊了一次、二次设备的界限，实现了一次、二次设备的初步融合。而智能变电站设备集成化程度更高，可以实现一次、二次设备的一体化、智能化整合和集成。\"]},\"625\":{\"h\":\"智能变电站与常规变电站有什么区别？\",\"t\":[\"简单地说，智能变电站与普通变电站的区别是，智能变电站是以数字化为代表的，现有的智能变电站一般是以采用IEC 61850标准和数字化互感器为主要特征。智能变电站与常规变电站的区别主要体现以下5点。\",\"● 采用光纤作为继电保护自动装置测量电流、电压的主通道，传输容量更大，解决了常规变电站中电流、电压精度受电流、电压互感器二次负载影响的问题，同时也使采用功能强大的一次设备在线监测成为可能。由于采用光纤，也彻底解决了常规变电站连接二次设备的二次电缆在强电场中穿越的干扰问题\",\"● 采用电子式或光学互感器。由于这些数字化互感器彻底摒弃了传统互感器电磁感应的原理，不仅精度更高，而且不存在磁饱和问题，不论是正常运行还是事故状态，都能为继电保护自动装置提供能够真实反映一次设备运行状态的测量数据。同时，由于采用光纤进行数字化传输，即使电流通道开路也就不会出现危及人身安全的高电压，当然也不会出现电压回路二次短路的问题，运行更安全、更可靠。\",\"● 功能强大的一体化平台。智能变电站采用一体化平台技术，将五防系统、智能报警、后台监控、在线监测等全面集成，不仅节省了设备投资，而且便于各个子系统之间、各个变电站之间及变电站与调度之间的数据交换，便于实现站域及区域控制和自我调节。\",\"● 设备集成化。智能变电站将断路器的操作回路、智能终端、在线监测等一次、二次设备集成化，不仅节省了设备的占地面积，而且使一次、二次设备的信息交换通道长度大为缩短，一定程度上也避免了电场干扰对二次控制设备影响。\",\"● 采用了数字化继电保护装置，简化了继电保护装置结构，大量省去保护装置内部的继电器，不仅减少了保护装置硬件故障的概率，提高了保护装置自身的运行可靠性，而且也减少了设备振动对保护装置的影响。\"]},\"626\":{\"h\":\"智能变电站中的IED是什么？\",\"t\":[\"IED是英文Intelligent Electronic Device（智能电子设备）的缩写，是指包含一个或多个处理器，可接收来自外部源的数据，或者向外部发送数据，或者进行控制的装置，如电子多功能仪表、数字保护、控制器等。IED是具有一个或多个特定环境中特定逻辑节点且受制于其接口的装置。\"]},\"627\":{\"h\":\"现有的智能变电站（数字化变电站）网络结构模式有几种？有什么优缺点？\",\"t\":[\"根据继电保护采样跳闸方式的不同，现有的智能变电站（数字化变电站）网络结构模式有两种，即“三网合一”网络采样跳闸模式和“直采直跳”采样跳闸模式。“三网合一”就是指把继电保护的交流采样SV网、开关量采集及跳闸GOOSE网、站控层网合为同一个网络，利用这个光纤网络实现测控装置信号采集、继电保护采样跳闸、计量采样等所有功能，其网络结构示意图如图1-1所示。\",\"图1-1 “三网合一”网络结构示意图\",\"“直采直跳”采样跳闸模式是指测控装置信号采集、继电保护采样跳闸、计量采样等通过专用的网络实现独立于站控层网络，其网络结构示意图如图1-2和图1-3所示。\",\"图1-2 “直采直跳”过程层网络结构示意图\",\"图1-3 “直采直跳”站控层网络结构示意图\",\"由于采用不同的网络结构模式，其各自的优缺点见表1-1。\",\"\\\"三网合一\\\"方式\",\"“直采直跳”方式\",\"光缆用量\",\"较少\",\"较大\",\"对GPS对时依赖\",\"完全依赖\",\"依赖性低\",\"对网络交换机的依赖性\",\"完全依赖\",\"依赖性低\",\"保护及自动装置的独立性\",\"弱\",\"强\"]},\"628\":{\"h\":\"智能变电站中“三层三网”指的是什么？\",\"t\":[\"智能变电站中“三层三网”是对智能变电站设备及网络架构的综合描述。\",\"三层”主要侧重于设备构成，即站控层、间隔层、过程层。\",\"间隔层设备包括继电保护装置、故障录波、测控装置、计量装置等；\",\"过程层设备包括变压器、断路器、隔离开关、电流互感器、电压互感器、电流/电压采集器、智能终端、合并单元及网络交换机等；\",\"站控层设备包括自动化站级监视控制系统、站域控制、通信系统、对时系统等，实现面向全站设备的监视、控制、报警及信息交互功能，完成数据采集和监视控制（SCADA）、操作闭锁，以及同步相量采集、电能量采集、保护信息管理等相关功能。\",\"“三网”主要侧重于网络结构，即站控层网络、间隔层网络、过程层网络。\",\"间隔层网络和过程层网络一样可以分为两类，即GOOSE网和SV网，其中GOOSE网主要传送一些开关量信息，而SV网主要传输电流/电压等测量信息。\",\"站控层网络主要传输站域及区域信息，如遥控、遥信、遥测、站域备自投及保护测控的报警信息；\",\"间隔层网络主要传输间隔内部的一些信息，如遥信、遥测及保护跳闸开出等；\",\"过程层网络是各个间隔保护装置之间的信息传输通道。\"]},\"629\":{\"h\":\"智能变电站中“直采直跳”指的是什么？\",\"t\":[\"“直采直跳”是智能变电站（数字化变电站）的一种网络结构模式，有别于网络采集网络跳闸。“直采直跳”模式中，保护装置的电流、电压采集是从本间隔的电流互感器和电压互感器直接采集，保护跳闸也是通过本间隔的GOOSE跳闸网络即直跳网络直接出口不再通过网络交换机，因此“直采直跳”方式的变电站较网络采集网络跳闸方式有更强的独立性，完全不依赖于网络交换机，可靠性更高。\"]},\"630\":{\"h\":\"现有智能变电站中高级应用功能一般有哪些？有什么特点？\",\"t\":[\"智能变电站的高级应用功能是智能变电站区别与数字化变电站的重要特征，是智能变电站满足智能电网坚强、自愈、兼容、经济、集成、优化六大要求的主要措施。根据智能电网的六大要求，智能变电站的高级应用功能受负荷性质、电源情况、电网情况等因素的影响，各个变电站配置并不完全相同，一般情况下由顺控操作、智能报警、五防系统、站域控制（包括站域备自投、站域无功控制、小电流接地选线）、区域控制、网络监测、设备状态可视化等自由组合而成，可能有其中几种也可能全部都有。它的优点主要体现在以下4个方面。\",\"● 集成化：智能变电站的所有高级应用功能全部集成在智能变电站的一体化平台中，降低了设备投资，减少了各个高级应用模块之间的通信环节，提高了运行效率和可靠性。\",\"● 软件化：大部分高级应用功能只是一个运行于一体化平台服务器的系统软件，并不增加屏、柜等硬件设施，体现了经济性。● 智能化：高级应用功能有自我监测、自动实施的功能，减少了人为参与的因素，从而减少了人员误操作的可能性。同时，也改进了常规变电站中运行操作受运行人员素质影响的缺陷。\",\"● 效率化：由于高级应用功能是在线运行的软件程序，实时监测电网的运行参数并进行调节，因此较此前的人为监测和调节更全面、更迅速，效率更高。\"]},\"631\":{\"h\":\"数字化微机型继电保护与常规微机型继电保护有什么不同？\",\"t\":[\"数字化微机型继电保护与常规微机型继电保护的区别主要体现在以下两个方面。\",\"● 软件方面：数字化微机型继电保护是为了满足智能变电站一次、二次设备情况设计而成的新型微机保护装置。由于智能变电站广泛采用光纤网络实现保护采样和跳闸功能，因此数字化继电保护装置除了具有常规微机型继电保护装置的保护逻辑软件和人机接口软件外，还必须增加功能强大的光纤网络通信软件，即支持IEC 61850通信规约的相关软件。\",\"● 硬件方面：由于智能变电站采用光纤网络作为保护采样和跳闸的通道，以及采用电子式互感器等数字化互感器，因此数字化继电保护装置在硬件方面与常规微机型继电保护装置差异很大。图1-4和图1-5所示分别为WXH—803A微机型继电保护装置和WXH—803B数字化微机型继电保护装置的背板图。\",\"图1-4 WXH—803A微机型继电保护装置背板图\",\"图1-4中，1#、2#为交流输入；3#为采样保持；4#、6#为DSP主板；5#（通道B）、7#（通道A）为光纤接口插件；8#为开入插件；9#为信号插件；A#、B#为出口插件；C#、D#、E#为备用插件；F#为通信插件；G#为稳压电源。\",\"图1-5 WXH—803B数字化微机型继电保护装置背板图\",\"图1-5中，7#为过程层接口插件、9#为CPU插件、B#为光纤插件、C#为稳压电源，其余为备用插件。通过对比可知，数字化微机型继电保护装置减少了交流输入插件两块、出口插件两块和采样保持插件、开入插件、信号插件各一块，增加了过程层接口插件一块，可见数字化微机型继电保护装置的硬件明显少于常规的微机型继电保护装置，也就减少了硬件故障率，提高了保护装置的可靠性。\"]},\"632\":{\"h\":\"电阻分压式电压互感器与常规电容式电压互感器有什么不同？有什么优点？\",\"t\":[\"虽然电阻分压式电压互感器与常规电容式电压互感器都是采用分压原理的电压互感器，但其实是两种不同类型的电压互感器。图1-6和图1-7所示分别为电阻分压式电压互感器和电容式电压互感器的原理示意图。\",\"图1-6电阻分压式电压互感器原理示意图\",\"电阻分压式电压互感器是利用电阻分压原理，直接将一次高电压转换成为与其成正比的0～5V的交流小信号，再经信号处理及光电转换单元转换成光数字信号供给保护、测量、计量等负载装置使用。显然电阻分压式电压互感器不存在电磁感应元件，没有因为电磁感应所造成的各种问题。\",\"图1-7电容式电压互感器原理示意图\",\"虽然电容式电压互感器同样采用分压原理将一次设备的高电压U1降低到一定程度，但其采样回路与电磁式电压互感器一样是YH通过电磁感应变压实现的，因此其精度和性能必然受电磁铁心特性的影响。与电容式电压互感器相比，电阻分压式电压互感器的优点主要体现在以下6个方面。\",\"● 采用0～5V的小信号输出，与数字化装置接口连接时不需要二次转换装置，便于与数字电路进行连接。\",\"● 由于其二次电压只有0～5V，因此在二次传输回路上产生的电压降明显降低，也就降低了传输误差。如果用于智能变电站（或数字化变电站）经光电转换装置转换成光数字信号进行传输，就不存在二次传输的电压损耗问题，精度更高。\",\"● 不存在电磁感应回路，因此其电压变换的线性度更好，精度更高，频响范围更宽，不存在铁磁畸变和饱和问题。\",\"● 由于采用特殊的采样原理，不存在二次短路烧坏电压互感器的问题，运行可靠性更高。\",\"● 采用纯电阻分压结构，不存在谐振问题。\",\"● 优化了结构设计，减少了绝缘油及YH等电压转换装置，减轻了设备重量，便于集成化安装，同时也减少了由于绝缘油绝缘性能下降对设备安全的影响。\"]},\"633\":{\"h\":\"磁光玻璃光学电流互感器与电磁式电流互感器有什么不同？有什么优缺点？\",\"t\":[\"磁光玻璃光学电流互感器（以下简称光学电流互感器）与电磁式电流互感器是完全不同的两种电气设备，尽管都是继电和保护测控装置测量一次设备电流的主要设备，但其工作原理完全不同。\",\"首先，它们的工作基本原理不同。常见的电磁式电流互感器是根据与变压器完全相同的电磁感应原理制造而成的。图1-8所示为电磁式电流互感器的工作原理示意图。\",\"当电流互感器的一次侧N1通过电流时，就会在铁心中产生磁通Φ，由电磁感应原理可知Φ=İ1×N1，由于铁心二次侧缠绕有二次绕组N2，如果忽略漏磁，由电磁原理可知Φ=İ1×N1=İ2×N2，如果N2=K×N1，那么İ2=1/K×İ1，显然也就起到了降低一次电流值、便于保护及测控装置采样的作用。\",\"图1-8电磁电流互感器工作原理图\",\"光学电流互感器是按照“磁旋光效应原理”（法拉第磁旋光效应原理如图1-9所示，当一束光通过一个磁场后，其偏振面就会发生偏转，其偏转角φ是对被测电流i 周围磁场强度的线积分成正比）制造而成的，光学电流互感器就是基于测量光通过载流导体附近的磁场后偏转角度的变化来测量电流的大小的。\",\"图1-9 法拉第磁旋光效应原理示意图\",\"如图1-10所示，当光学电流互感器一次载流导体上通过电流时，在其光学电流传感器内部就会产生与其大小及相位有关联的磁场。光学电流互感器二次采集装置通过其ST1、ST2两个光口分别向互感器的光学电流传感元件1及光学电流传感元件2发送两束标准光，此标准光经过光学传感器内的磁场后，其偏振角发生变化，经采集装置的ST7～ST10接收。采集装置经过比较标准光经磁场前、后的变化，并经过逻辑计算及转换后，由ST4（或ST5、ST6）输出至合并单元。\",\"图1-10 光学互感器原理示意图\",\"与电磁电流互感器相比，光学互感器有以下4个优点。\",\"● 不存在电磁感应回路，因此其电流变换的线性度更好，精度更高，频响范围更宽，不存在铁磁畸变和饱和问题。\",\"● 由于采用法拉第磁旋光效应原理，不会在二次开路时产生危及人身安全的高电压，运行安全性更高。\",\"● 互感器直接输出光数字信号，直接进入保护及测控装置的采样运算，减少了采样回路的中间环节，提高了保护及测控等装置的采样精度。\",\"● 优化了结构设计，不再采用绝缘油作为绝缘介质，而是采用硅橡胶或瓷质绝缘，减轻了设备重量，便于集成化安装，同时也减少了由于绝缘油绝缘性能下降对设备安全的影响。\",\"由于受光学互感器自身工作原理的局限，相比电磁电流互感器也存在以下两个缺点。\",\"● 光学互感器自身是一个有源采样系统，不可避免地要受电源可靠性的影响。\",\"● 光学互感器工作时需要一个标准光源，因此其可靠性必然受光源发生元件自身寿命的影响。\"]},\"634\":{\"h\":\"罗氏线圈电流互感器是什么样的工作原理？\",\"t\":[\"采用罗氏线圈（也叫空心线圈）原理的互感器，由罗氏线圈、积分器、A/D转换器组成。由罗氏线圈组成的电子式电流互感器原理图如图1-11所示。\",\"图1-11 由罗氏线圈组成的电子式电流互感器原理图\",\"电子式电流互感器一次传感部分采用了罗哥夫斯基线圈的原理，它由罗哥夫斯基线圈、积分器、A/D转换等单元组成，将一次侧大电流转换成二次的低电压模拟量输出或数字量输出。 电子式电流传感器不使用铁心，使用了原理上没有饱和的罗哥夫斯基线圈，由这个罗哥夫斯基线圈得到了与一次电流I1的时间微分成比例的二次电压E2，将该二次电压E2进行积分处理，获得与一次电流成比例的电压信号。 电子式互感器在二次回路中采用模拟积分和数字积分技术，通过数字运算，并利用去除直流偏置回路和不完全积分器的技术，有效地抑制了因直流偏置使积分值飞快增大的问题，并确保了作为叠加值DC分量的电流信号的真实反映，电流互感器将不完全积分器控制在一个适当的数值内。 在二次回路中，也利用抑制雷电过电压和操作过电压的措施，提高了互感器的耐冲击特性。电源供给方式和主信号的变换及传递，采用独特的电磁兼容设计技术，使新型互感器抗干扰能力得到增强，能有效可靠地工作。\"]},\"635\":{\"h\":\"目前用于智能变电站（数字化变电站）的电子式电流互感器有哪几种类型？\",\"t\":[\"目前用于智能变电站（数字化变电站）的电子式电流互感器主要有以下3种。\",\"（1）光学电流互感器：是指采用光学器件作为被测电流传感器，光学器件由光学玻璃、全光纤等构成。传输系统用光纤，输出电压大小正比于被测电流大小。由被测电流调制的光波物理特征，可将光波调制分为强度调制、波长调制、相位调制和偏振调制等。\",\"（2）空心线圈电流互感器：又称罗氏线圈式电流互感器。空心线圈往往由漆包线均匀绕制在环形骨架上制成，骨架采用塑料、陶瓷等非铁磁材料，其相对磁导率与空气的相对磁导率相同，这是空心线圈有别于带铁心的电流互感器的一个显著特征。\",\"（3）铁心线圈式低功率电流互感器（LPCT）：它是传统电磁式电流互感器的一种发展。它按照高阻抗电阻设计，在非常高的一次电流下，饱和特性得到改善，扩大了测量范围，降低了功率消耗，可以无饱和、高准确度测量高达短路电流的过电流、全偏移短路电流，测量和保护可共用一个铁心线圈式低功率电流互感器，其输出为电压信号。\"]},\"636\":{\"h\":\"IEC 61850通信规约是什么？有什么特点？\",\"t\":[\"IEC 61850标准是由国际电工委员会（International Electro technicalCommission）第57技术委员会于2004年颁布的、应用于变电站通信网络和系统的国际标准。作为基于网信通信平台的变电站唯一的国际标准，IEC 61850标准吸收了IEC 60870系列标准和UCA的经验，同时吸收了很多先进的技术，对保护和控制等自动化产品和变电站自动化系统（SAS）的设计产生深刻的影响。它将不仅应用在变电站内，而且将应用于变电站与调度中心之间以及各级调度中心之间。IEC 61850的特点如下所述。\",\"（1）定义了变电站的信息分层结构：变电站通信网络和系统协议IEC61850标准草案提出了变电站内信息分层的概念，将变电站的通信体系分为3个层次，即变电站层、间隔层和过程层，并且定义了层和层之间的通信接口。\",\"（2）采用了面向对象的数据建模技术：IEC 61850标准采用面向对象的建模技术，定义了基于客户机/服务器结构数据模型。每个IED包含一个或多个服务器，每个服务器本身又包含一个或多个逻辑设备。逻辑设备包含逻辑节点，逻辑节点包含数据对象。数据对象则是由数据属性构成的公用数据类的命名实例。从通信而言，IED同时也扮演客户的角色。任何一个客户可通过抽象通信服务接口（ACSI）和服务器通信可访问数据对象。\",\"（3）数据自描述：该标准定义了采用设备名、逻辑节点名、实例编号和数据类名建立对象名的命名规则；采用面向对象的方法，定义了对象之间的通信服务，如获取和设定对象值的通信服务，取得对象名列表的通信服务，获得数据对象值列表的服务等。面向对象的数据自描述在数据源就对数据本身进行自我描述，传输到接收方的数据都带有自我说明，不需要再对数据进行工程物理量对应、标度转换等工作。由于数据本身带有说明，所以传输时可以不受预先定义限制，简化了对数据的管理和维护工作。\",\"（4）网络独立性：IEC 61850标准总结了变电站内信息传输所必需的通信服务，设计了独立于所采用网络和应用层协议的抽象通信服务接口（ASCI）。在IEC 61850—7—2中，建立了标准兼容服务器所必须提供的通信服务的模型，包括服务器模型、逻辑设备模型、逻辑节点模型、数据模型和数据集模型。客户通过ACSI，由专用通信服务映射（SCSM）映射到所采用的具体协议栈，如制造报文规范（MMS）等。IEC 61850标准使用ACSI和SCSM技术，解决了标准的稳定性与未来网络技术发展之间的矛盾，即当网络技术发展时只要改动SCSM，而不需要修改ACSI。\"]},\"637\":{\"h\":\"什么是通信规约？现有智能变电站（数字化变电站）有几种通信规约？分别运行于哪些地方？\",\"t\":[\"通信规约又名通信协议，是为保证数据通信系统中通信双方能有效和可靠地通信而规定的双方应共同遵守的一系列约定，包括数据的格式、顺序和速率、链路管理、流量调节和差错控制等。现有智能变电站的通信规约主要有FT3规约、IEC 61850规约、101规约、104规约、DISA规约、CDT规约及DNP规约等，它们分别使用在不同的网络中，如图1-12所示。现有采用“直采直跳”网络方式的智能变电站网络中，站控层和过程层主要采用IEC 61850规约。间隔层网络主要采用IEC 61850规约和FT3规约，其中保护装置、测控装置与合并单元及智能终端的通信规约为IEC 61850规约，而合并单元与电流采集器、电压采集器之间采用FT3规约。站控层与调度主站及集控站之间根据通道模式采用101规约、104规约、DISA规约、CDT规约及DNP规约等。\",\"图1-12 “直采直跳”网络方式的智能变电站网络示意图\"]},\"638\":{\"h\":\"智能变电站的网络配置过程中ICD、CID、SCD文件指的是什么？有什么用处？\",\"t\":[\"ICD文件是由装置厂商提供给智能变电站系统集成厂商，该文件描述IED提供的基本数据模型及服务，但不包含IED实例名称和通信参数。 SCD文件由系统集成厂商根据变电站设计图纸，完成的描述所有IED的实例配置和通信参数、IED之间的通信配置及变电站一次系统结构配置文件。 SCD文件应包含版本修改信息，明确描述修改时间、修改版本号等内容。 CID文件：智能变电站中的每个装置都有有一个CID文件，由各装置厂商根据SCD文件中与各自设备（IED）相关配置内容重新配置生成的配置文件。 ICD文件是设计人员进行变电站设计时必需的，它显示了各个智能设备的功能输出、SV采样需求及GOOSE开入/开出需求等信息。一般情况下，同一厂家同一型号和版本的设备的ICD文件是相同的。在系统配置完成后，ICD文件没有实际用处。 SCD文件是设计人员经过综合变电站的各种功能需求进行完善的设计后，由智能变电站的系统集成商进行配置生成的配置文件，该文件包含了全站智能组件的全部信息及各智能组件之间的通信信息，是施工调试人员及运行检修人员进行传动调试必备的配置文件。 CID文件对于特定的某个智能组件来说与SCD文件完全相同，只是它只包含了单个智能组件的系统信息，是SCD文件一部分。\"]},\"639\":{\"h\":\"智能变电站中的智能终端装置有什么作用？\",\"t\":[\"智能终端装置是智能变电站二次系统的核心设备之一，它的作用十分重要，其主要作用有以下4个方面。\",\"● 智能终端是智能变电站中一次设备状态开关量（遥信量）的采集及转换设备。智能终端装置通过强/弱电转换方式将隔离开关、断路器等一次设备运行位置及断路器本体的报警及状态信号转换为弱电信号，并通过光电转换元件转换为光数字信号上送给继电保护、测控装置及合并单元等设备。\",\"● 智能终端装置是断路器的操作箱。终端箱内除了配置断路器控制回路监视、断路器SF6压力监视、防跳回路、断路器操作回路的同时还具有自我状态检测功能，能够检测自身所有光通道及开入/开出元件的完好性。\",\"● 智能终端是继电保护装置的跳/合闸出口装置。由于数字化继电保护装置没有出口插件，当继电保护装置动作出口时，继电保护装置将跳闸命令数字信号传送给智能终端装置，由智能终端装置驱动有关元件实现断路器的跳/合闸。\",\"● 智能终端装置是监控遥控执行装置。运行人员（或调度人员）进行远方遥控操作时，遥控命令通过站控层网络传送给测控装置后，测控装置经过逻辑五防校验后发出遥控操作指令，遥控操作指令由间隔层光通道传送至智能终端由智能终端实现断路器分/合、隔离开关拉/合及挡位调节等操作功能。\"]},\"640\":{\"h\":\"智能变电站中的合并单元（MU）装置有什么作用？\",\"t\":[\"合并单元（MU）装置是智能变电站二次系统的核心设备之一，它的作用十分重要。\",\"● 由图1-13可见，合并单元（MU）装置能够对电子式电流、电压互感器通过采集器输出的数字量进行合并和处理，供继电保护、计量装置、故障录波及测控装置使用。\",\"图1-13 “直采直跳”方式合并单元网络图\",\"● 合并单元（MU）装置具有规约转换功能。能够将电流采集器和电压采集器上送的FT3通信规约数据转换成标准的IEC 61850—9—2规约，便于不同厂家的二次设备与其通信。\",\"● 合并单元（MU）装置具有电压切换及并列功能。能够根据一次设备的运行方式，灵活切换或并列二次电压供继电保护、计量装置、故障录波及测控装置使用。\",\"● 合并单元（MU）装置具有数据扩展作用。能够将一组电流或一组电压数据扩展成多组输出，以供给不同的二次设备使用。\",\"图1-14和图1-15所示为DMU—813电压合并单元正视图和背视图。\",\"图1-14 DMU—813电压合并单元正视图\",\"图1-15 DMU—813电压合并单元背视图\"]},\"641\":{\"h\":\"双母接线方式 DMU—813电压合并单元的电压并列是如何实现的？它与常规的电压并列有什么不同点？\",\"t\":[\"DMU—813电压合并单元是许继电气生产的一款适用于智能变电站（或数字化变电站）的电压合并器。图1-16所示为DMU—813电压合并单元开入原理图，当母联间隔的所有刀闸及断路器在合闸位置时即两条母线并列运行时，如果Ⅰ母电压互感器停运，则将并列把手QK至于“Ⅰ母停运并列”位置，DMU—813电压合并单元就自动屏蔽Ⅰ母电压互感器的输入，同时其所有输出端口全部输出Ⅱ母电压信号。同理，如果Ⅱ母电压互感器停运，则将并列把手QK至于“Ⅱ母停运并列”位置，DMU—813电压合并单元就自动屏蔽Ⅱ母电压互感器的输入，同时其所有输出端口全部输出Ⅰ母电压信号，这样就实现了电压并列功能。\",\"图1-16 DMU—813电压合并单元开入原理图\",\"DMU—813电压合并单元工作原理与常规变电站的电压并列原理完全不同。如图1-17所示，在常规变电站中，当满足并列条件（母联间隔运行）操作人员将并列把手合上后，Ⅰ母电压互感器电压和Ⅱ母电压互感\"]},\"642\":{\"h\":\"智能变电站配置技术及典型报文分析\",\"t\":[\"进度：\"]},\"643\":{\"h\":\"1.1 概述\"},\"644\":{\"h\":\"1.1.1 掌握智能变电站调试主动权\",\"t\":[\"掌握智能变电站调试主动权理应从四个方面考虑，其内容应该包括如下四个方面。\",\"掌握智能变电站基础理论及概念\",\"熟读IEC61850标准以及在其标准基础下形成的智能变电站“三层两网”的组网方式\",\"智能变电站核心配置文本，即变电站能力描述文本（Substation Configuration Description，SCD）\",\"智能变电站常用光纤连接器涵盖的种类\",\"智能变电站电子式互感器原理、采样标准、极性校验方法\",\"合并单元、智能终端的校验方法以及交换机虚拟局域网（Virtual LocalArea Network，VLAN）的划分\",\"对于综自变电站保护逻辑回路概念的认知度\",\"110kV等级智能变电站 \",\"清楚主变压器相关二次回路、各分支电流回路、电压回路、各个间隔所涉及的位置开入回路、失灵保护回路以及断路器机构控制原理回路等\",\"220kV及以上等级智能变电站 \",\"除上述涉及内容外，还应对电压切换回路，包括保护电压切换及计量电压切换等、失灵联跳回路，包括主变压器失灵联跳、母差保护失灵联跳、间隔失灵启动开入及跳闸方式等、母差保护回路，包括母差保护启动开入及跳闸方式等有深入了解\",\"掌握智能变电站报文分析能力\",\"MMS报文\",\"GOOSE报文\",\"采样值（Sampling Value，SV）报文\",\"从而做到独立分析或解决智能变电站典型故障问题。\",\"掌握智能变电站配置技术\"]},\"645\":{\"h\":\"1.1.2 学习配置技术的意义\",\"t\":[\"学习和掌握配置技术有利于IED出厂系统联调及变电站现场调试\",\"学习和掌握配置技术有利于了解IEC61850标准模型文件的模型构成\",\"在工程建设前期便于审核和验证智能变电站虚端子回路，在工程建设期间便于调试和传动智能电子设备，即保护装置\",\"学习配置技术有利于维护设备调试成果，约束厂家擅动装置的行为\"]},\"646\":{\"h\":\"1.2 配置技术基础\"},\"647\":{\"h\":\"1.2.1 变电站通信网络和系统标准IEC61850\",\"t\":[\"IEC61850系列标准的全称为变电站通信网络和系统标准（Communication Networks and Systems in Substations），以下简称IEC61850或IEC61850标准。它规范了变电站内智能电子设备，即IED之间的通信行为和相关的系统要求。\"]},\"648\":{\"h\":\"IEC61850标准规约的产生背景及新标准的优点\",\"t\":[\"通信规约的多样化并不利于智能变电站的发展，因此需要一个更加完善的通信平台\"]},\"649\":{\"h\":\"IEC61850模型中配置技术相关缩略语\",\"t\":[\"1）IED：Intelligent Electronic Device智能电子设备； 2）MMS：Manufacturing Message Specification制造报文规范； 3）GOOSE：Generic Object Oriented Substation Events面向通用对象的变电站事件； 4）SV：Sampled Value采样值； 5）LD：Logical Device逻辑设备； 6）LN：Logical Node逻辑节点； 7）PD：Physical Device物理设备； 8）FC：Functional Constraint功能约束； 9）FCDA：Functionally Constrained Data Attribute功能约束数据属性； 10）CDC：Common Data Cass公共数据类； 11）DO：Data Object数据对象； 12）DA：Data Attribute数据属性； 13）ACC：Accelerate加速； 14）BF：Breaker failure断路器失灵； 15）BRCB：Buffered Report Control Block有缓存报告控制块； 16）CID：Configured IED Description IED实例配置文件； 17）CT：Current transformer电流互感器； 18）Dev：Device设备； 19）Err：Error错误； 20）Fst：First第一个； 21）ICD：IED Capability Description IED能力描述文件； 22）Long：Long长期的； 23）Pers Persist，Persistent：持续性的； 24）Pmt：Permit，Permitted许可； 25）SCD：Substation Configuration Description全站系统配置文件； 26）Sig：Signal信号； 27）SSD：System Specification Description系统规格文件； 28）Strp Strap压板； 29）URCB：Unbuffered Report Control Block无缓存报告控制块； 30）UV：Under Voltage欠电压。\"]},\"650\":{\"h\":\"IEC61850装置数据模型的层次结构\",\"t\":[\"IEC61850装置数据模型的层次结构如图1-1所示\",\"图1-1 IEC61850装置数据模型的层次结构\",\"图1-1表明，物理设备映射成为IED，然后将各个功能分解到逻辑节点，组织成一个或者多个逻辑设备。每个功能的保护数据映射到数据对象，并且根据功能约束进行拆分并映射到若干个数据属性\"]},\"651\":{\"h\":\"IEC61850标准规约的三大服务\",\"t\":[\"了解IEC61850规约，即是建立配置基础\",\"站在用户的角度，IEC61850提供给用户三大服务：制造报文规范服务MMS、面向通用对象的变电站事件服务GOOSE以及采样服务SV\"]},\"652\":{\"h\":\"制造报文规范服务MMS功能\",\"t\":[\"MMS具备信号上送功能、测量上送功能、控制功能以及故障报告功能。\",\"信号上送功能，包括开入、事件、报警等信号类数据的上送功能通过有缓冲报告控制块，即BRCB来实现，映射到MMS的读写和报告服务。\",\"测量上送功能：遥测、保护测量类数据的上送功能通过无缓冲报告控制块，即URCB来实现，映射到MMS的读写和报告服务。\",\"控制功能，控制功能又分定值控制功能和遥控、遥调等控制功能。\",\"定值控制功能，通过定值控制块，即SGCB来实现选择定值区进行召唤、修改、定值区切换。映射到MMS的读写服务。\",\"遥控、遥调等控制功能，通过IEC61850的控制相关数据结构实现，映射到MMS的读写和报告服务。\",\"故障报告功能，包括通过RDRE逻辑节点实现，映射到MMS的报告和文件操作服务。\",\"总之，IEC61850中的MMS服务，包括了整个智能变电站遥信、遥测、遥控以及故障分析等领域，是站控层信息交换的基础体现方式和平台，这些信息也是调度掌握智能变电站运行情况的重要依据和手段。\"]},\"653\":{\"h\":\"面向通用对象的变电站事件服务GOOSE功能\"},\"654\":{\"h\":\"MyBatis大全\"},\"655\":{\"h\":\"什么是 MyBatis？它与其他 ORM 框架有何不同？\",\"t\":[\"MyBatis是一个Java持久层框架，它通过使用XML或注解配置文件来映射Java对象和关系型数据库中的记录，从而实现对象-关系映射（ORM）。\",\"与其他ORM框架相比，MyBatis有几个不同之处：\",\"SQL控制： MyBatis允许开发人员直接编写和控制SQL查询，因此可以更细粒度地优化和控制数据库访问，而不像其他ORM框架那样完全隐藏了SQL。\",\"灵活性： MyBatis相对于其他ORM框架更加灵活，可以直接使用SQL语句来执行复杂查询，处理特殊情况和优化性能。\",\"XML配置： MyBatis通常使用XML文件进行配置，这使得配置和映射关系更清晰可见，尤其对于复杂的映射和查询。\",\"易于集成： MyBatis可以很容易地集成到已有的项目中，不需要大规模重构或修改代码。\",\"与SQL的亲和性： 对于开发人员更熟悉SQL的项目团队来说，MyBatis提供了更接近SQL的编程模型，这样可以更轻松地理解和调优查询。\",\"轻量级： MyBatis相对于其他ORM框架来说比较轻量级，它的学习曲线相对较低，对于新手来说更容易上手。\"]},\"656\":{\"h\":\"MyBatis 的核心组件是什么？它们各自的作用是什么？\",\"t\":[\"MyBatis的核心组件包括：\",\"SqlSessionFactoryBuilder：\",\"作用：用于创建SqlSessionFactory实例。\",\"解释：SqlSessionFactoryBuilder负责读取MyBatis的配置信息，并根据配置信息构建SqlSessionFactory实例。它通常在应用程序启动时使用一次，用于创建SqlSessionFactory。\",\"SqlSessionFactory：\",\"作用：用于创建SqlSession实例。\",\"解释：SqlSessionFactory是一个工厂类，负责创建SqlSession实例。它使用了构建器模式，一旦创建，就应该在应用程序的整个生命周期中保持不变。SqlSessionFactory的主要功能是加载映射文件以及配置信息，并为数据库连接提供会话级别的操作。\",\"SqlSession：\",\"作用：用于执行SQL语句和管理事务。\",\"解释：SqlSession是与数据库交互的主要接口。它提供了执行SQL语句、获取Mapper接口实例、管理事务等方法。每个SqlSession都会关联一个数据库连接，通常情况下，它是非线程安全的，因此应该在方法内部使用，并在执行完毕后关闭。\",\"Mapper接口：\",\"作用：用于定义SQL映射。\",\"解释：Mapper接口是用于定义数据库操作的接口，其中定义的方法与SQL语句相对应。MyBatis通过Mapper接口的动态代理方式将方法与对应的SQL语句绑定在一起，从而实现了面向接口编程的思想。Mapper接口的实现类由MyBatis框架在运行时自动生成。\",\"映射文件（Mapper XML）：\",\"作用：定义SQL语句和结果映射。\",\"解释：映射文件是XML格式的文件，用于定义SQL语句、参数映射、结果映射等。它提供了一种将Java对象与数据库表之间的映射关系描述出来的方式，可以实现对象关系映射（ORM）。映射文件通常包含SQL语句、参数映射、结果映射等信息。\",\"Executor：\",\"作用：执行SQL语句并管理缓存。\",\"解释：Executor负责执行SQL语句，并且管理一级缓存和二级缓存。它根据SQL的类型和配置信息选择合适的执行方式，可以是直接执行SQL、查询缓存、批处理等。Executor还负责缓存的管理，包括命中缓存、更新缓存等操作。\",\"StatementHandler：\",\"作用：处理SQL语句的创建和执行。\",\"解释：StatementHandler负责处理SQL语句的创建和执行过程。它通过底层的JDBC接口与数据库交互，可以创建PreparedStatement或Statement对象，并执行SQL语句。StatementHandler通常与ParameterHandler和ResultSetHandler一起工作，完成SQL语句的参数绑定和结果集处理。\",\"ParameterHandler：\",\"作用：处理SQL语句中的参数。\",\"解释：ParameterHandler负责处理SQL语句中的参数，将Java对象中的属性值绑定到SQL语句中的参数位置。它根据SQL语句中的参数信息，将Java对象的属性值设置到PreparedStatement对象中，以便执行SQL语句。\",\"ResultSetHandler：\",\"作用：处理SQL语句执行的结果集。\",\"解释：ResultSetHandler负责处理SQL语句执行后返回的结果集。它将结果集转换为Java对象或基本数据类型，并返回给调用者。ResultSetHandler根据映射文件中定义的结果映射，将结果集中的数据映射到Java对象的属性上，从而实现对象关系映射（ORM）。\",\"TypeHandler：\",\"作用：处理Java对象与数据库类型之间的转换。\",\"解释：TypeHandler负责处理Java对象与数据库类型之间的转换。在MyBatis中，当查询结果从数据库返回时，TypeHandler将数据库字段的值转换为Java对象的属性值；当向数据库插入、更新数据时，TypeHandler将Java对象的属性值转换为数据库字段的值。MyBatis提供了一系列内置的TypeHandler，同时也支持自定义TypeHandler来处理特定类型的转换。\",\"Interceptor：\",\"作用：拦截SQL执行过程，提供额外功能。\",\"解释：Interceptor是MyBatis提供的拦截器接口，可以拦截SQL执行过程中的多个环节，例如SQL语句的预处理、结果集的处理等。开发者可以编写自定义的拦截器来实现一些额外的功能，比如日志记录、权限控制、性能监控等。\",\"Plugin：\",\"作用：用于对MyBatis核心功能进行增强。\",\"解释：Plugin是MyBatis提供的插件接口，用于对MyBatis核心功能进行增强。Plugin可以在MyBatis的各个执行阶段插入自定义的逻辑，以实现对MyBatis的功能扩展或定制。Plugin通常与Interceptor结合使用，Interceptor负责实际的拦截功能，而Plugin则负责管理和调度Interceptor的执行。\",\"TransactionManager：\",\"作用：管理数据库事务。\",\"解释：TransactionManager负责管理数据库事务的生命周期，包括事务的开启、提交、回滚和关闭。MyBatis提供了多种事务管理器实现，可以与不同的持久化框架或数据库连接池集成，例如JDBC事务、Spring事务等。\",\"Cache：\",\"作用：缓存查询结果，提高查询性能。\",\"解释：Cache用于缓存查询结果，以减少对数据库的访问次数，提高查询性能。MyBatis中的缓存分为一级缓存和二级缓存两种，一级缓存是SqlSession级别的缓存，二级缓存是Mapper级别的缓存。开发者可以通过配置来启用或禁用缓存，以及设置缓存的策略和失效机制。\",\"Environment：\",\"作用：定义MyBatis的运行环境。\",\"解释：Environment用于定义MyBatis的运行环境，包括数据库连接信息、事务管理器、数据源等。一个MyBatis应用通常会有多个不同的运行环境，比如开发环境、测试环境、生产环境等，每个环境都可以有自己独立的配置信息。\",\"DataSource：\",\"作用：提供数据库连接。\",\"解释：DataSource用于提供数据库连接，是MyBatis与数据库之间的桥梁。MyBatis支持多种DataSource实现，包括内置的PooledDataSource、UnpooledDataSource等，也可以使用第三方的连接池实现。DataSource负责管理数据库连接的创建、销毁和连接池的管理，确保数据库连接的可用性和性能。\",\"MappedStatement：\",\"作用：代表一个映射的语句。\",\"解释：MappedStatement是MyBatis中的一个关键组件，它代表了一个映射文件中的一个SQL语句，包括了SQL语句的ID、参数类型、返回类型等信息。MappedStatement与Mapper接口中的方法一一对应，通过MappedStatement可以获取SQL语句的执行信息，以及进行参数绑定和结果映射。\",\"BoundSql：\",\"作用：封装了SQL语句及其参数。\",\"解释：BoundSql封装了一个完整的SQL语句以及与之对应的参数信息。它是在SQL语句执行前由SqlSource生成的，包含了动态解析后的完整SQL语句以及参数值。BoundSql可以方便地被Executor和StatementHandler使用，用于执行SQL语句并进行参数绑定。\",\"ResultMap：\",\"作用：定义了结果集到Java对象的映射规则。\",\"解释：ResultMap是MyBatis中用于定义查询结果集与Java对象之间映射关系的组件。它描述了查询结果集中每一列与Java对象属性之间的对应关系，包括了属性名、数据库列名、数据类型转换等信息。通过ResultMap，开发者可以实现复杂的结果集映射，将查询结果转换为Java对象的集合或嵌套对象。\",\"ParameterMap：\",\"作用：定义了SQL语句的参数映射规则。\",\"解释：ParameterMap用于定义SQL语句中参数与Java对象属性之间的映射关系。它描述了SQL语句中的参数位置、参数类型以及与Java对象属性之间的对应关系。ParameterMap可以方便地被ParameterHandler使用，用于将Java对象的属性值绑定到SQL语句的参数位置。\",\"SQL Scripting：\",\"作用：提供了一种动态生成 SQL 语句的方式。\",\"解释：SQL Scripting 是 MyBatis 中的一个功能，允许在 XML 映射文件中编写动态的 SQL 语句。通过使用动态 SQL 特性，可以根据条件动态地生成不同的 SQL 语句，以满足不同的查询需求。SQL Scripting 提供了一系列的标签和函数，如if、choose、foreach 等，用于构建动态 SQL 语句。\",\"SQL Builder：\",\"作用：用于编程式地构建 SQL 语句。\",\"解释：SQL Builder 是 MyBatis 提供的一种编程式地构建 SQL 语句的方式。它可以通过 Java 代码的方式来动态地拼接 SQL 片段，以实现复杂的查询需求。SQL Builder 提供了一系列的 API 方法，如 SELECT、INSERT、UPDATE、DELETE 等，用于构建不同类型的 SQL 语句，同时还支持动态条件拼接和参数绑定等功能。\"]},\"657\":{\"h\":\"MyBatis 的工作原理是什么？简要描述一下它的执行流程。\"},\"658\":{\"h\":\"什么是 Mapper 接口？它在 MyBatis 中的作用是什么？\"},\"659\":{\"h\":\"MyBatis 中的动态 SQL 是什么？你能举例说明如何使用动态 SQL 吗？\"},\"660\":{\"h\":\"如何在 MyBatis 中执行批量插入操作？\"},\"661\":{\"h\":\"MyBatis 中的缓存是如何工作的？它有哪些级别？\"},\"662\":{\"h\":\"介绍一下 MyBatis 的一级缓存和二级缓 存的区别。\"},\"663\":{\"h\":\"如何在 MyBatis 中进行参数绑定？有哪些方式可以传递参数？\"},\"664\":{\"h\":\"MyBatis 支持哪些类型的参数映射？\"},\"665\":{\"h\":\"什么是 MyBatis 的插件（Plugin）？你能否自定义一个插件？\"},\"666\":{\"h\":\"MyBatis 如何处理懒加载（Lazy Loading）？它的原理是什么？\"},\"667\":{\"h\":\"你在项目中是如何处理 MyBatis 的异常的？\"},\"668\":{\"h\":\"如何在 MyBatis 中实现分页查询？\"},\"669\":{\"h\":\"MyBatis 中的 resultMap 是什么？它有什么作用？\"},\"670\":{\"h\":\"什么是 MyBatis 的 SQL 注入？你如何在 MyBatis 中防止 SQL 注入攻击？\"},\"671\":{\"h\":\"MyBatis 如何处理数据库事务？它支持哪些事务管理方式？\"},\"672\":{\"h\":\"MyBatis 中的 ResultMap 和 ResultType 有什么区别？它们应该如何选择使用？\"},\"673\":{\"h\":\"介绍一下 MyBatis 中的 resultMap 的高级特性，比如关联映射和复杂属性映射。\"},\"674\":{\"h\":\"MyBatis 中的 SQL 日志是如何启用的？为什么在开发和调试过程中启用 SQL 日志很重要？\"},\"675\":{\"h\":\"你有在项目中使用 MyBatis Generator 吗？它的作用是什么？有哪些配置选项？\"},\"676\":{\"h\":\"MyBatis 中的 TypeHandler 是什么？你能否自定义一个 TypeHandler？\"},\"677\":{\"h\":\"MyBatis 如何处理结果集的映射？它支持哪些基本类型和复杂类型的映射？\"},\"678\":{\"h\":\"MyBatis 中的动态 SQL 如何处理 NULL 值？\"},\"679\":{\"h\":\"如何在 MyBatis 中执行存储过程？有哪些方式可以调用存储过程？\"},\"680\":{\"h\":\"MyBatis 中的连接池是如何配置的？你有什么经验可以分享吗？\"},\"681\":{\"h\":\"什么是 MyBatis 的拦截器（Interceptor）？你能否自定义一个拦截器？\"},\"682\":{\"h\":\"MyBatis 如何处理乐观锁和悲观锁？你在项目中是如何应用的？\"},\"683\":{\"h\":\"你有使用 MyBatis 的批量更新功能吗？它是如何工作的？\"},\"684\":{\"h\":\"MyBatis 和 Spring 框架如何集成？你有集成经验吗？\"},\"685\":{\"h\":\"在 MyBatis 中，你如何执行批量删除操作？\"},\"686\":{\"h\":\"MyBatis 中的延迟加载（Lazy Loading）和立即加载（Eager Loading）有何区别？你何时选择使用延迟加载？\"},\"687\":{\"h\":\"你有使用 MyBatis 的二级缓存吗？在什么情况下你会选择启用二级缓存？\"},\"688\":{\"h\":\"介绍一下 MyBatis 中的 SQL 脚本处理器（Scripting）以及它的应用场景。\"},\"689\":{\"h\":\"在 MyBatis 中，如何处理数据库连接的异常和超时？\"},\"690\":{\"h\":\"MyBatis 如何支持数据库的分页查询？有哪些常见的分页插件？\"},\"691\":{\"h\":\"MyBatis 中的动态 SQL 如何处理动态条件？举例说明如何构建动态条件查询。\"},\"692\":{\"h\":\"什么是 MyBatis 的乐观锁和悲观锁？你有在项目中应用过吗？请分享一下经验。\"},\"693\":{\"h\":\"MyBatis 如何进行批量更新和批量\"},\"694\":{\"h\":\"MyBatis 如何处理数据库字段和 Java 对象之间的类型转换？你有遇到过类型转换问题吗？\"},\"695\":{\"h\":\"MyBatis 中的 SQL 解析器（SQL Parser）是如何工作的？它的作用是什么？你有自定义过 SQL 解析器吗？\"},\"696\":{\"h\":\"MyBatis 中的 SQL 构建器（SQL Builder）是什么？你有使用过 MyBatis 的 SQL 构建器吗？能分享一些使用经验吗？\"},\"697\":{\"h\":\"你对 MyBatis 的性能调优有什么经验？你在项目中是如何优化 MyBatis 的性能的？\"},\"698\":{\"h\":\"MyBatis 中的连接池和数据库连接管理是如何工作的？你有进行过连接池的配置和优化吗？\"},\"699\":{\"h\":\"在 MyBatis 中，如何处理数据库分页？你有使用过 MyBatis 分页插件吗？它是如何工作的？\"},\"700\":{\"h\":\"MyBatis 中的 SQL 注解是什么？它的作用是什么？你有使用过 SQL 注解吗？它们与 XML 映射文件相比有什么优缺点？\"},\"701\":{\"h\":\"什么是 MyBatis 的多表查询？你有进行过复杂的多表查询吗？如何处理多表查询结果的映射？\"},\"702\":{\"h\":\"MyBatis 中的缓存机制是如何工作的？你有遇到过缓存失效的情况吗？如何处理缓存失效？\"},\"703\":{\"h\":\"MyBatis 中的动态 SQL 是如何实现的？你有在项目中使用过动态 SQL 吗？它的性能如何？\"},\"704\":{\"h\":\"在你看来，MyBatis 的优势是什么？它在项目中的应用场景是什么？\"},\"705\":{\"h\":\"MyBatis 如何处理数据库连接的管理和释放？它对连接池有何要求？\"},\"706\":{\"h\":\"你对 MyBatis 中的事务管理有何了解？它如何处理事务的提交和回滚？\"},\"707\":{\"h\":\"在 MyBatis 中，如何处理数据库的乐观锁和悲观锁？你有在项目中使用过这些机制吗？能分享一些应用经验吗？\"},\"708\":{\"h\":\"MyBatis 中的 ResultMap 是如何定义和使用的？你有使用过复杂的 ResultMap 吗？如何定义一个复杂的 ResultMap？\"},\"709\":{\"h\":\"你对 MyBatis 中的延迟加载机制有何理解？它如何提高系统性能？\"},\"710\":{\"h\":\"在 MyBatis 中，如何使用动态 SQL 构建动态查询语句？你有使用过动态 SQL 吗？如何避免动态 SQL 带来的潜在安全风险？\"},\"711\":{\"h\":\"你有使用过 MyBatis 的注解方式进行 SQL 映射吗？与 XML 映射方式相比，你更倾向于使用哪一种？为什么？\"},\"712\":{\"h\":\"MyBatis 如何处理结果集的映射？你有使用过复杂的映射关系吗？如何处理复杂的结果集映射？\"},\"713\":{\"h\":\"在 MyBatis 中，如何进行性能分析和调优？你有使用过 MyBatis 提供的性能分析工具吗？如何解读性能分析报告？\"},\"714\":{\"h\":\"在你的开发经验中，MyBatis 的哪些特性给你留下了深刻的印象？你认为 MyBatis 在未来的发展方向是什么？\"},\"715\":{\"h\":\"MyBatis 的动态 SQL 是如何实现的？你有使用过动态 SQL 来构建动态查询语句吗？能分享一些实际应用的经验吗？\"},\"716\":{\"h\":\"MyBatis 中的缓存机制包括一级缓存和二级缓存，请详细说明它们的区别和工作原理。\"},\"717\":{\"h\":\"你有使用过 MyBatis 的批量操作功能吗？它是如何实现的？在什么场景下你会选择使用批量操作？\"},\"718\":{\"h\":\"在 MyBatis 中，如何处理数据库的分页查询？你有使用过 MyBatis 分页插件吗？如果不使用插件，你会采取什么样的方法来实现分页？\"},\"719\":{\"h\":\"MyBatis 中的 TypeHandler 是什么？它的作用是什么？你有自定义过 TypeHandler 吗？在什么场景下会需要自定义 TypeHandler？\"},\"720\":{\"h\":\"MyBatis 与 Spring 框架的集成是如何实现的？你有在项目中使用过这种集成方式吗？有什么需要注意的地方？\"},\"721\":{\"h\":\"在你的开发经验中，MyBatis 的哪些功能给你带来了便利？相反，有没有遇到过 MyBatis 的局限性？\"},\"722\":{\"h\":\"你在使用 MyBatis 过程中遇到过的最大挑战是什么？你是如何克服的？\"},\"723\":{\"h\":\"MyBatis 如何处理数据库的连接异常？在面对连接异常时，你有哪些应对策略？\"},\"724\":{\"h\":\"你对 MyBatis 的未来发展有什么预期？你认为 MyBatis 在未来的发展中有哪些可以改进的地方？\"},\"725\":{\"h\":\"MyBatis 如何处理数据库连接的超时和重试机制？你有在项目中实践过连接超时和重试策略吗？\"},\"726\":{\"h\":\"在你的项目中，你是如何组织和管理 MyBatis 的 SQL 映射文件的？有没有遇到过文件过多或难以维护的情况？\"},\"727\":{\"h\":\"MyBatis 中的 Mapper 接口是如何定义和使用的？你有使用过注解方式定义 Mapper 接口吗？与 XML 方式相比，你更倾向于使用哪一种？\"},\"728\":{\"h\":\"在你的开发经验中，MyBatis 的异常处理是如何应用的？你有使用过 MyBatis 的异常处理机制来处理业务异常吗？\"},\"729\":{\"h\":\"MyBatis 中的批量更新操作是如何实现的？在什么场景下你会选择使用批量更新操作？\"},\"730\":{\"h\":\"在你的项目中，你是如何进行 MyBatis 的单元测试的？你认为单元测试对于 MyBatis 开发的重要性是什么？\"},\"731\":{\"h\":\"MyBatis 的 SQL 映射文件中，有哪些常用的标签和元素？你觉得其中哪些是最常用的？为什么？\"},\"732\":{\"h\":\"你有在项目中使用过 MyBatis 的乐观锁功能吗？它是如何工作的？在什么情况下你会选择使用乐观锁？\"},\"733\":{\"h\":\"在 MyBatis 中，如何进行 SQL 的拼接和参数传递？你有遇到过 SQL 注入的情况吗？如何防范 SQL 注入攻击？\"},\"734\":{\"h\":\"你认为 MyBatis 框架的优势和劣势分别是什么？在选择 ORM 框架时，你会优先考虑哪些因素？\"},\"735\":{\"h\":\"在你的项目中，你是如何进行 MyBatis 的性能监控和调优的？有哪些工具和技术是你常用的？\"},\"736\":{\"h\":\"MyBatis 中的动态 SQL 是如何实现的？你有使用过动态 SQL 来构建动态查询语句吗？能分享一些实际应用的经验吗？\"},\"737\":{\"h\":\"MyBatis 如何处理数据库连接的管理和释放？它对连接池有何要求？\"},\"738\":{\"h\":\"你对 MyBatis 中的事务管理有何了解？它如何处理事务的提交和回滚？\"},\"739\":{\"h\":\"在 MyBatis 中，如何使用注解方式定义 SQL 映射？与 XML 映射方式相比，你更倾向于使用哪一种？为什么？\"},\"740\":{\"h\":\"MyBatis 的缓存机制是如何工作的？你有在项目中使用过缓存吗？在什么情况下你会选择禁用缓存？\"},\"741\":{\"h\":\"在你的项目中，你是如何处理 MyBatis 中的懒加载问题的？有没有遇到过懒加载导致的性能问题？\"},\"742\":{\"h\":\"MyBatis 的 SQL 解析器是如何工作的？它的作用是什么？你有自定义过 SQL 解析器吗？\"},\"743\":{\"h\":\"你有在项目中使用过 MyBatis 的连接池配置吗？你是如何进行连接池优化的？\"},\"744\":{\"h\":\"在你的开发经验中，MyBatis 与其他 ORM 框架相比，有哪些优势和劣势？在选择使用 ORM 框架时，你会考虑哪些因素？\"},\"745\":{\"h\":\"MyBatis 如何处理数据库连接的超时和重试机制？你有在项目中实践过连接超时和重试策略吗？\"},\"746\":{\"h\":\"在你的项目中，你是如何组织和管理 MyBatis 的 SQL 映射文件的？有没有遇到过文件过多或难以维护的情况？\"},\"747\":{\"h\":\"MyBatis 中的 Mapper 接口是如何定义和使用的？你有使用过注解方式定义 Mapper 接口吗？与 XML 方式相比，你更倾向于使用哪一种？\"},\"748\":{\"h\":\"在你的开发经验中，MyBatis 的异常处理是如何应用的？你有使用过 MyBatis 的异常处理机制来处理业务异常吗？\"},\"749\":{\"h\":\"MyBatis 中的批量更新操作是如何实现的？在什么场景下你会选择使用批量更新操作？\"},\"750\":{\"h\":\"在你的项目中，你是如何进行 MyBatis 的单元测试的？你认为单元测试对于 MyBatis 开发的重要性是什么？\"},\"751\":{\"h\":\"MyBatis 的 SQL 映射文件中，有哪些常用的标签和元素？你觉得其中哪些是最常用的？为什么？\"},\"752\":{\"h\":\"你有在项目中使用过 MyBatis 的乐观锁功能吗？它是如何工作的？在什么情况下你会选择使用乐观锁？\"},\"753\":{\"h\":\"在 MyBatis 中，如何进行 SQL 的拼接和参数传递？你有遇到过 SQL 注入的情况吗？如何防范 SQL 注入攻击？\"},\"754\":{\"h\":\"你认为 MyBatis 框架的优势和劣势分别是什么？在选择 ORM 框架时，你会优先考虑哪些因素？\"},\"755\":{\"h\":\"基础\"},\"756\":{\"h\":\"说说什么是MyBatis?\"},\"757\":{\"h\":\"为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？\"},\"758\":{\"h\":\"JDBC编程有哪些不足之处，MyBatis是如何解决的？\"},\"759\":{\"h\":\"Hibernate 和 MyBatis 有什么区别？\"},\"760\":{\"h\":\"MyBatis和Hibernate的适用场景?\"},\"761\":{\"h\":\"MyBatis使用过程？生命周期？\"},\"762\":{\"h\":\"MyBatis生命周期？\"},\"763\":{\"h\":\"在mapper中如何传递多个参数？\"},\"764\":{\"h\":\"实体类属性名和表中字段名不一样 ，怎么办?\"},\"765\":{\"h\":\"Mybatis是否可以映射Enum枚举类？\"},\"766\":{\"h\":\"#{}和${}的区别?\"},\"767\":{\"h\":\"模糊查询like语句该怎么写?\"},\"768\":{\"h\":\"Mybatis能执行一对一、一对多的关联查询吗？\"},\"769\":{\"h\":\"Mybatis是否支持延迟加载？原理？\"},\"770\":{\"h\":\"如何获取生成的主键?\"},\"771\":{\"h\":\"MyBatis支持动态SQL吗？\"},\"772\":{\"h\":\"MyBatis如何执行批量操作？\"},\"773\":{\"h\":\"说说Mybatis的一级、二级缓存？\"},\"774\":{\"h\":\"Book\"},\"775\":{\"h\":\"Posts\"},\"776\":{\"h\":\"J V M\"},\"777\":{\"h\":\"Java\"},\"778\":{\"h\":\"Basic\"},\"779\":{\"h\":\"Concurrent\"},\"780\":{\"h\":\"Congregation\"},\"781\":{\"h\":\"Docker\"},\"782\":{\"h\":\"Microservices\"},\"783\":{\"h\":\"My Sql\"},\"784\":{\"h\":\"Database\"},\"785\":{\"h\":\"Redis\"},\"786\":{\"h\":\"Basic\"},\"787\":{\"h\":\"Electric\"},\"788\":{\"h\":\"Books\"},\"789\":{\"h\":\"Mybatis\"},\"790\":{\"h\":\"Frame\"},\"791\":{\"h\":\"Spring\"}},\"dirtCount\":0,\"index\":[[\"举例说明如何构建动态条件查询\",{\"0\":{\"691\":1}}],[\"脚本处理器\",{\"0\":{\"688\":1}}],[\"值\",{\"0\":{\"678\":1}}],[\"介绍一下\",{\"0\":{\"662\":1,\"673\":1,\"688\":1}}],[\"吗\",{\"0\":{\"659\":1,\"675\":1,\"703\":1,\"708\":1,\"710\":1,\"719\":1}}],[\"片段\",{\"1\":{\"656\":1}}],[\"销毁和连接池的管理\",{\"1\":{\"656\":1}}],[\"权限控制\",{\"1\":{\"656\":1}}],[\"拦截sql执行过程\",{\"1\":{\"656\":1}}],[\"批处理等\",{\"1\":{\"656\":1}}],[\"框架相比\",{\"0\":{\"744\":1}}],[\"框架时\",{\"0\":{\"734\":1,\"744\":1,\"754\":1}}],[\"框架的优势和劣势分别是什么\",{\"0\":{\"734\":1,\"754\":1}}],[\"框架的集成是如何实现的\",{\"0\":{\"720\":1}}],[\"框架如何集成\",{\"0\":{\"684\":1}}],[\"框架有何不同\",{\"0\":{\"655\":1}}],[\"框图文档\",{\"0\":{\"50\":1}}],[\"物理设备映射成为ied\",{\"1\":{\"650\":1}}],[\"物理上存放在堆中\",{\"1\":{\"99\":1,\"100\":1}}],[\"约束厂家擅动装置的行为\",{\"1\":{\"645\":1}}],[\"学习配置技术有利于维护设备调试成果\",{\"1\":{\"645\":1}}],[\"学习配置技术的意义\",{\"0\":{\"645\":1}}],[\"学习和掌握配置技术有利于了解iec61850标准模型文件的模型构成\",{\"1\":{\"645\":1}}],[\"学习和掌握配置技术有利于ied出厂系统联调及变电站现场调试\",{\"1\":{\"645\":1}}],[\"报文\",{\"1\":{\"644\":1}}],[\"报警等信号类数据的上送功能通过有缓冲报告控制块\",{\"1\":{\"652\":1}}],[\"报警及信息交互功能\",{\"1\":{\"628\":1}}],[\"报警\",{\"1\":{\"475\":1}}],[\"母差保护回路\",{\"1\":{\"644\":1}}],[\"母差保护失灵联跳\",{\"1\":{\"644\":1}}],[\"母联间隔运行\",{\"1\":{\"641\":1}}],[\"失灵联跳回路\",{\"1\":{\"644\":1}}],[\"失灵保护回路以及断路器机构控制原理回路等\",{\"1\":{\"644\":1}}],[\"失败后\",{\"1\":{\"501\":1}}],[\"熟读iec61850标准以及在其标准基础下形成的智能变电站\",{\"1\":{\"644\":1}}],[\"掌握智能变电站配置技术\",{\"1\":{\"644\":1}}],[\"掌握智能变电站报文分析能力\",{\"1\":{\"644\":1}}],[\"掌握智能变电站基础理论及概念\",{\"1\":{\"644\":1}}],[\"掌握智能变电站调试主动权理应从四个方面考虑\",{\"1\":{\"644\":1}}],[\"掌握智能变电站调试主动权\",{\"0\":{\"644\":1}}],[\"概述\",{\"0\":{\"643\":1}}],[\"ⅰ母电压互感器电压和ⅱ母电压互感\",{\"1\":{\"641\":1}}],[\"ⅰ母停运并列\",{\"1\":{\"641\":1}}],[\"ⅱ母停运并列\",{\"1\":{\"641\":1}}],[\"供继电保护\",{\"1\":{\"640\":1}}],[\"防跳回路\",{\"1\":{\"639\":1}}],[\"防止任务过载\",{\"1\":{\"450\":1}}],[\"防止系统资源耗尽\",{\"1\":{\"404\":1}}],[\"防止过载\",{\"1\":{\"357\":1}}],[\"防止核心类库\",{\"1\":{\"207\":1}}],[\"防止内存泄漏\",{\"1\":{\"178\":1}}],[\"明确描述修改时间\",{\"1\":{\"638\":1}}],[\"明确目标性能指标\",{\"1\":{\"79\":1}}],[\"顺序和速率\",{\"1\":{\"637\":1}}],[\"饱和特性得到改善\",{\"1\":{\"635\":1}}],[\"铁心线圈式低功率电流互感器\",{\"1\":{\"635\":1}}],[\"陶瓷等非铁磁材料\",{\"1\":{\"635\":1}}],[\"骨架采用塑料\",{\"1\":{\"635\":1}}],[\"波长调制\",{\"1\":{\"635\":1}}],[\"积分器\",{\"1\":{\"634\":2}}],[\"罗氏线圈电流互感器是什么样的工作原理\",{\"0\":{\"634\":1}}],[\"互感器直接输出光数字信号\",{\"1\":{\"633\":1}}],[\"互斥这个条件我们没有办法破坏\",{\"1\":{\"512\":1}}],[\"互斥条件\",{\"1\":{\"512\":1}}],[\"此标准光经过光学传感器内的磁场后\",{\"1\":{\"633\":1}}],[\"此时\",{\"1\":{\"561\":1}}],[\"此时a已经非彼a\",{\"1\":{\"504\":1}}],[\"此时持有该偏向锁的线程\",{\"1\":{\"493\":1}}],[\"此时计数器\",{\"1\":{\"485\":1}}],[\"此时会释放\",{\"1\":{\"485\":1}}],[\"此时其他线程也会收到\",{\"1\":{\"355\":1}}],[\"此时就会线性向后查找\",{\"1\":{\"333\":1}}],[\"此时finally块中的代码不会执行\",{\"1\":{\"281\":1}}],[\"此时pages页会显示访问域名\",{\"1\":{\"21\":1}}],[\"法拉第磁旋光效应原理示意图\",{\"1\":{\"633\":1}}],[\"法拉第磁旋光效应原理如图1\",{\"1\":{\"633\":1}}],[\"制造报文规范服务mms功能\",{\"0\":{\"652\":1}}],[\"制造报文规范服务mms\",{\"1\":{\"651\":1}}],[\"制造而成的\",{\"1\":{\"633\":1}}],[\"制定调优策略\",{\"0\":{\"81\":1}}],[\"制定性能指标\",{\"1\":{\"79\":1}}],[\"周围磁场强度的线积分成正比\",{\"1\":{\"633\":1}}],[\"周期性执行任务的场景\",{\"1\":{\"460\":1}}],[\"光学器件由光学玻璃\",{\"1\":{\"635\":1}}],[\"光学互感器工作时需要一个标准光源\",{\"1\":{\"633\":1}}],[\"光学互感器自身是一个有源采样系统\",{\"1\":{\"633\":1}}],[\"光学互感器有以下4个优点\",{\"1\":{\"633\":1}}],[\"光学互感器原理示意图\",{\"1\":{\"633\":1}}],[\"光学电流互感器\",{\"1\":{\"635\":1}}],[\"光学电流互感器二次采集装置通过其st1\",{\"1\":{\"633\":1}}],[\"光学电流互感器就是基于测量光通过载流导体附近的磁场后偏转角度的变化来测量电流的大小的\",{\"1\":{\"633\":1}}],[\"光学电流互感器是按照\",{\"1\":{\"633\":1}}],[\"光缆用量\",{\"1\":{\"627\":1}}],[\"磁旋光效应原理\",{\"1\":{\"633\":1}}],[\"磁光玻璃光学电流互感器\",{\"1\":{\"633\":1}}],[\"磁光玻璃光学电流互感器与电磁式电流互感器有什么不同\",{\"0\":{\"633\":1}}],[\"磁盘等\",{\"1\":{\"561\":1}}],[\"磁盘文件等\",{\"1\":{\"478\":1}}],[\"磁盘\",{\"1\":{\"54\":1}}],[\"频响范围更宽\",{\"1\":{\"632\":1,\"633\":1}}],[\"频繁地创建和销毁数据库连接会导致性能下降和资源浪费\",{\"1\":{\"426\":1}}],[\"频繁地为每个请求创建和销毁线程将导致性能瓶颈\",{\"1\":{\"422\":1}}],[\"频繁创建和销毁线程会导致大量短生命周期的对象被创建\",{\"1\":{\"418\":1}}],[\"频繁创建和销毁线程会导致操作系统不断地创建和销毁这些内核对象\",{\"1\":{\"413\":1}}],[\"频繁创建和销毁线程会导致内存分配和释放操作的频繁发生\",{\"1\":{\"412\":1}}],[\"频繁创建和销毁线程的开销大\",{\"1\":{\"410\":1}}],[\"频繁创建了大量对象\",{\"1\":{\"88\":1}}],[\"频繁full\",{\"0\":{\"88\":1}}],[\"频繁的线程创建和销毁会增加上下文切换的次数\",{\"1\":{\"415\":1}}],[\"频繁的minor\",{\"1\":{\"87\":1}}],[\"频繁的垃圾回收会导致应用程序的性能下降\",{\"1\":{\"418\":1}}],[\"频繁的垃圾回收\",{\"1\":{\"80\":1}}],[\"频繁\",{\"0\":{\"87\":1},\"1\":{\"89\":1}}],[\"精度更高\",{\"1\":{\"632\":2,\"633\":1}}],[\"便于不同厂家的二次设备与其通信\",{\"1\":{\"640\":1}}],[\"便于保护及测控装置采样的作用\",{\"1\":{\"633\":1}}],[\"便于集成化安装\",{\"1\":{\"632\":1,\"633\":1}}],[\"便于与数字电路进行连接\",{\"1\":{\"632\":1}}],[\"便于实现站域及区域控制和自我调节\",{\"1\":{\"625\":1}}],[\"硬件方面\",{\"1\":{\"631\":1}}],[\"硬件资源和gc特性的过程\",{\"1\":{\"161\":1}}],[\"体现了经济性\",{\"1\":{\"630\":1}}],[\"柜等硬件设施\",{\"1\":{\"630\":1}}],[\"软件方面\",{\"1\":{\"631\":1}}],[\"软件化\",{\"1\":{\"630\":1}}],[\"软引用是一种比强引用弱一些的引用\",{\"1\":{\"128\":1}}],[\"软引用\",{\"1\":{\"128\":1}}],[\"五防系统\",{\"1\":{\"630\":1}}],[\"五个子阶段\",{\"1\":{\"141\":1}}],[\"遥调等控制功能\",{\"1\":{\"652\":2}}],[\"遥控以及故障分析等领域\",{\"1\":{\"652\":1}}],[\"遥控\",{\"1\":{\"652\":1}}],[\"遥控操作指令由间隔层光通道传送至智能终端由智能终端实现断路器分\",{\"1\":{\"639\":1}}],[\"遥控命令通过站控层网络传送给测控装置后\",{\"1\":{\"639\":1}}],[\"遥测及保护跳闸开出等\",{\"1\":{\"628\":1}}],[\"遥测\",{\"1\":{\"628\":1,\"652\":2}}],[\"遥信量\",{\"1\":{\"639\":1}}],[\"遥信\",{\"1\":{\"628\":1}}],[\"站在用户的角度\",{\"1\":{\"651\":1}}],[\"站域无功控制\",{\"1\":{\"630\":1}}],[\"站域备自投及保护测控的报警信息\",{\"1\":{\"628\":1}}],[\"站域控制\",{\"1\":{\"628\":1,\"630\":1}}],[\"站控层与调度主站及集控站之间根据通道模式采用101规约\",{\"1\":{\"637\":1}}],[\"站控层和过程层主要采用iec\",{\"1\":{\"637\":1}}],[\"站控层设备包括自动化站级监视控制系统\",{\"1\":{\"628\":1}}],[\"站控层网络主要传输站域及区域信息\",{\"1\":{\"628\":1}}],[\"站控层网络结构示意图\",{\"1\":{\"627\":1}}],[\"站控层网合为同一个网络\",{\"1\":{\"627\":1}}],[\"隔离开关拉\",{\"1\":{\"639\":1}}],[\"隔离开关\",{\"1\":{\"628\":1}}],[\"故障报告功能\",{\"1\":{\"652\":1}}],[\"故障录波及测控装置使用\",{\"1\":{\"640\":2}}],[\"故障录波\",{\"1\":{\"628\":1}}],[\"故障隔离和系统自我恢复的能力\",{\"1\":{\"622\":1}}],[\"间隔失灵启动开入及跳闸方式等\",{\"1\":{\"644\":1}}],[\"间隔层和过程层\",{\"1\":{\"636\":1}}],[\"间隔层网络主要采用iec\",{\"1\":{\"637\":1}}],[\"间隔层网络主要传输间隔内部的一些信息\",{\"1\":{\"628\":1}}],[\"间隔层网络和过程层网络一样可以分为两类\",{\"1\":{\"628\":1}}],[\"间隔层网络\",{\"1\":{\"628\":1}}],[\"间隔层设备包括继电保护装置\",{\"1\":{\"628\":1}}],[\"间隔层\",{\"1\":{\"628\":1}}],[\"间接继承了aqs\",{\"1\":{\"497\":1}}],[\"较大\",{\"1\":{\"627\":1}}],[\"较少\",{\"1\":{\"627\":1}}],[\"采样值\",{\"1\":{\"644\":1}}],[\"采样标准\",{\"1\":{\"644\":1}}],[\"采样跳闸模式是指测控装置信号采集\",{\"1\":{\"627\":1}}],[\"采样跳闸模式\",{\"1\":{\"627\":1}}],[\"采集装置经过比较标准光经磁场前\",{\"1\":{\"633\":1}}],[\"采用面向对象的方法\",{\"1\":{\"636\":1}}],[\"采用独特的电磁兼容设计技术\",{\"1\":{\"634\":1}}],[\"采用罗氏线圈\",{\"1\":{\"634\":1}}],[\"采用纯电阻分压结构\",{\"1\":{\"632\":1}}],[\"采用0～5v的小信号输出\",{\"1\":{\"632\":1}}],[\"采用电子式或光学互感器\",{\"1\":{\"625\":1}}],[\"采用光纤作为继电保护自动装置测量电流\",{\"1\":{\"625\":1}}],[\"采用统一的平台和模型\",{\"1\":{\"622\":1}}],[\"采用了面向对象的数据建模技术\",{\"1\":{\"636\":1}}],[\"采用了数字化继电保护装置\",{\"1\":{\"625\":1}}],[\"采用了两个手段\",{\"1\":{\"560\":1}}],[\"采用了并发标记的策略\",{\"1\":{\"141\":1}}],[\"采用安全失败机制的集合容器\",{\"1\":{\"520\":1}}],[\"采用ab岗两人进行录入\",{\"1\":{\"363\":1}}],[\"采用clone机制\",{\"1\":{\"308\":1}}],[\"采用字节码的好处是什么\",{\"0\":{\"249\":1}}],[\"采用复制算法进行垃圾回收\",{\"1\":{\"132\":1}}],[\"●\",{\"1\":{\"625\":5,\"630\":4,\"631\":2,\"632\":6,\"633\":6,\"639\":4,\"640\":4}}],[\"拥有统一的接口\",{\"1\":{\"624\":1}}],[\"侧重于在统一通信平台的基础上提高变电站内设备与系统间的互操作性\",{\"1\":{\"624\":1}}],[\"侧重于高吞吐量\",{\"1\":{\"159\":1}}],[\"二级缓存\",{\"0\":{\"773\":1}}],[\"二级缓存是mapper级别的缓存\",{\"1\":{\"656\":1}}],[\"二次设备情况设计而成的新型微机保护装置\",{\"1\":{\"631\":1}}],[\"二次设备集成化\",{\"1\":{\"625\":1}}],[\"二次设备的信息交换通道长度大为缩短\",{\"1\":{\"625\":1}}],[\"二次设备的一体化\",{\"1\":{\"624\":1}}],[\"二次设备的初步融合\",{\"1\":{\"624\":1}}],[\"二次设备的界限\",{\"1\":{\"624\":1}}],[\"二次设备的数字化通信和控制\",{\"1\":{\"624\":1}}],[\"二叉搜索树性质\",{\"1\":{\"527\":1}}],[\"协同互动等高级功能\",{\"1\":{\"623\":1}}],[\"协调子线程开始动作\",{\"1\":{\"353\":1}}],[\"协调子线程结束动作\",{\"1\":{\"353\":1}}],[\"控制功能又分定值控制功能和遥控\",{\"1\":{\"652\":1}}],[\"控制功能\",{\"1\":{\"652\":1}}],[\"控制功能以及故障报告功能\",{\"1\":{\"652\":1}}],[\"控制器等\",{\"1\":{\"626\":1}}],[\"控制\",{\"1\":{\"623\":1,\"628\":1}}],[\"控制日志输出\",{\"1\":{\"56\":1}}],[\"集成化\",{\"1\":{\"630\":1}}],[\"集成\",{\"1\":{\"622\":1,\"623\":1,\"630\":1}}],[\"集合中的元素\",{\"1\":{\"552\":1}}],[\"集合在被遍历期间如果内容发生变化\",{\"1\":{\"520\":1}}],[\"集合基础\",{\"0\":{\"290\":1}}],[\"兼容\",{\"1\":{\"622\":1,\"630\":1}}],[\"兼容性\",{\"1\":{\"276\":1}}],[\"极性校验方法\",{\"1\":{\"644\":1}}],[\"极端气候条件下或外力破坏下仍能保证电网的安全运行\",{\"1\":{\"622\":1}}],[\"极低停顿时间\",{\"1\":{\"151\":1,\"159\":1}}],[\"仍能保持对用户的供电能力\",{\"1\":{\"622\":1}}],[\"仍然可以成功反序列化之前的序列化数据\",{\"1\":{\"276\":1}}],[\"仍然委派给父类加载器\",{\"1\":{\"215\":1}}],[\"仍然存活的对象会被移动到survivor区\",{\"1\":{\"130\":1}}],[\"坚强\",{\"1\":{\"622\":1}}],[\"电源供给方式和主信号的变换及传递\",{\"1\":{\"634\":1}}],[\"电源情况\",{\"1\":{\"630\":1}}],[\"电子式互感器在二次回路中采用模拟积分和数字积分技术\",{\"1\":{\"634\":1}}],[\"电子式电流传感器不使用铁心\",{\"1\":{\"634\":1}}],[\"电子式电流互感器一次传感部分采用了罗哥夫斯基线圈的原理\",{\"1\":{\"634\":1}}],[\"电阻分压式电压互感器的优点主要体现在以下6个方面\",{\"1\":{\"632\":1}}],[\"电阻分压式电压互感器是利用电阻分压原理\",{\"1\":{\"632\":1}}],[\"电阻分压式电压互感器与常规电容式电压互感器有什么不同\",{\"0\":{\"632\":1}}],[\"电能量采集\",{\"1\":{\"628\":1}}],[\"电流\",{\"1\":{\"628\":1}}],[\"电流互感器将不完全积分器控制在一个适当的数值内\",{\"1\":{\"634\":1}}],[\"电流互感器\",{\"1\":{\"628\":1}}],[\"电压回路\",{\"1\":{\"644\":1}}],[\"电压采集是从本间隔的电流互感器和电压互感器直接采集\",{\"1\":{\"629\":1}}],[\"电压采集器之间采用ft3规约\",{\"1\":{\"637\":1}}],[\"电压采集器\",{\"1\":{\"628\":1}}],[\"电压等测量信息\",{\"1\":{\"628\":1}}],[\"电压互感器通过采集器输出的数字量进行合并和处理\",{\"1\":{\"640\":1}}],[\"电压互感器\",{\"1\":{\"628\":1}}],[\"电压互感器二次负载影响的问题\",{\"1\":{\"625\":1}}],[\"电压精度受电流\",{\"1\":{\"625\":1}}],[\"电压的主通道\",{\"1\":{\"625\":1}}],[\"电网情况等因素的影响\",{\"1\":{\"630\":1}}],[\"电网调度等互动的变电站\",{\"1\":{\"623\":1}}],[\"电网2\",{\"1\":{\"621\":1}}],[\"电商公司的运营后台系统\",{\"1\":{\"84\":1}}],[\"智能化\",{\"1\":{\"630\":1}}],[\"智能化整合和集成\",{\"1\":{\"624\":1}}],[\"智能电子设备\",{\"1\":{\"626\":1}}],[\"智能电网的特征如下所述\",{\"1\":{\"622\":1}}],[\"智能电网有哪些特征\",{\"0\":{\"622\":1}}],[\"智能电网体现出电力流\",{\"1\":{\"621\":1}}],[\"智能电网\",{\"1\":{\"621\":1}}],[\"智能终端的校验方法以及交换机虚拟局域网\",{\"1\":{\"644\":1}}],[\"智能终端是继电保护装置的跳\",{\"1\":{\"639\":1}}],[\"智能终端是智能变电站中一次设备状态开关量\",{\"1\":{\"639\":1}}],[\"智能终端装置是监控遥控执行装置\",{\"1\":{\"639\":1}}],[\"智能终端装置是断路器的操作箱\",{\"1\":{\"639\":1}}],[\"智能终端装置是智能变电站二次系统的核心设备之一\",{\"1\":{\"639\":1}}],[\"智能终端装置通过强\",{\"1\":{\"639\":1}}],[\"智能终端\",{\"1\":{\"625\":1,\"628\":1}}],[\"智能报警\",{\"1\":{\"625\":1,\"630\":1}}],[\"智能调节\",{\"1\":{\"623\":1}}],[\"智能变电站电子式互感器原理\",{\"1\":{\"644\":1}}],[\"智能变电站常用光纤连接器涵盖的种类\",{\"1\":{\"644\":1}}],[\"智能变电站核心配置文本\",{\"1\":{\"644\":1}}],[\"智能变电站配置技术及典型报文分析\",{\"0\":{\"642\":1}}],[\"智能变电站的网络配置过程中icd\",{\"0\":{\"638\":1}}],[\"智能变电站的所有高级应用功能全部集成在智能变电站的一体化平台中\",{\"1\":{\"630\":1}}],[\"智能变电站的高级应用功能受负荷性质\",{\"1\":{\"630\":1}}],[\"智能变电站的高级应用功能是智能变电站区别与数字化变电站的重要特征\",{\"1\":{\"630\":1}}],[\"智能变电站中的合并单元\",{\"0\":{\"640\":1}}],[\"智能变电站中的智能终端装置有什么作用\",{\"0\":{\"639\":1}}],[\"智能变电站中的每个装置都有有一个cid文件\",{\"1\":{\"638\":1}}],[\"智能变电站中的ied是什么\",{\"0\":{\"626\":1}}],[\"智能变电站中\",{\"0\":{\"628\":1,\"629\":1},\"1\":{\"628\":1}}],[\"智能变电站将断路器的操作回路\",{\"1\":{\"625\":1}}],[\"智能变电站采用一体化平台技术\",{\"1\":{\"625\":1}}],[\"智能变电站采用先进\",{\"1\":{\"623\":1}}],[\"智能变电站是以数字化为代表的\",{\"1\":{\"625\":1}}],[\"智能变电站是数字化变电站的发展和升级\",{\"1\":{\"624\":1}}],[\"智能变电站与常规变电站的区别主要体现以下5点\",{\"1\":{\"625\":1}}],[\"智能变电站与常规变电站有什么区别\",{\"0\":{\"625\":1}}],[\"智能变电站与普通变电站的区别是\",{\"1\":{\"625\":1}}],[\"智能变电站与数字化变电站的差别主要体现在以下两个方面\",{\"1\":{\"624\":1}}],[\"智能变电站与数字化变电站有密不可分的联系\",{\"1\":{\"624\":1}}],[\"智能变电站与数字化变电站有什么区别\",{\"0\":{\"624\":1}}],[\"智能变电站需要建立全网统一的标准化信息平台\",{\"1\":{\"624\":1}}],[\"智能变电站拥有数字化变电站的所有自动化功能和技术特征\",{\"1\":{\"624\":1}}],[\"智能变电站实用知识问答\",{\"0\":{\"620\":1}}],[\"智能问题检测和根因分析\",{\"1\":{\"67\":1,\"70\":1}}],[\"列\",{\"1\":{\"618\":1}}],[\"列出所有的volume\",{\"1\":{\"583\":1}}],[\"列出指定进程的线程占用资源情况\",{\"1\":{\"85\":1}}],[\"列出系统中打开的文件和网络连接\",{\"1\":{\"54\":1}}],[\"筛选分组后的数据\",{\"1\":{\"616\":1}}],[\"筛选出满足条件的行\",{\"1\":{\"616\":1}}],[\"讲一下distinct的语法\",{\"0\":{\"606\":1}}],[\"讲讲hashset的底层实现\",{\"0\":{\"554\":1}}],[\"讲讲\",{\"0\":{\"551\":1,\"552\":1}}],[\"名称前缀为私有仓库的地址\",{\"1\":{\"604\":1}}],[\"搭建私有镜像仓库\",{\"0\":{\"603\":1}}],[\"理由dockercompose部署\",{\"1\":{\"602\":1}}],[\"理想情况下\",{\"1\":{\"539\":1}}],[\"别搞错了\",{\"1\":{\"601\":1}}],[\"$pwd\",{\"1\":{\"598\":2}}],[\"$java\",{\"1\":{\"592\":3}}],[\"格式如下\",{\"1\":{\"595\":1}}],[\"⑤\",{\"1\":{\"593\":1,\"597\":1}}],[\"④\",{\"1\":{\"593\":1,\"597\":1}}],[\"命名为dockerfile\",{\"1\":{\"593\":1}}],[\"命令解读\",{\"1\":{\"578\":1,\"579\":1}}],[\"命令格式如下\",{\"1\":{\"585\":1}}],[\"命令格式\",{\"1\":{\"574\":1}}],[\"命令和其他的⼀些基础构件\",{\"1\":{\"247\":1}}],[\"命令分析\",{\"1\":{\"89\":1}}],[\"命令并结合dump堆内存文件作进一步分析\",{\"1\":{\"88\":1}}],[\"入口\",{\"1\":{\"592\":1}}],[\"入手\",{\"1\":{\"89\":1}}],[\"暴露端口\",{\"1\":{\"592\":1,\"593\":1}}],[\"拷贝jar包到部署目录\",{\"0\":{\"601\":1}}],[\"拷贝jdk和java项目的包\",{\"1\":{\"592\":1}}],[\"拷贝课前资料提供的docker\",{\"1\":{\"593\":1}}],[\"拷贝课前资料提供的dockerfile到docker\",{\"1\":{\"592\":1}}],[\"拷贝课前资料中的jdk8\",{\"1\":{\"592\":1}}],[\"拷贝课前资料中的docker\",{\"1\":{\"592\":1}}],[\"拷贝被拷贝对象的成员变量的值\",{\"1\":{\"307\":1}}],[\"构建动态查询语句\",{\"0\":{\"710\":1}}],[\"构建器吗\",{\"0\":{\"696\":1}}],[\"构建器\",{\"0\":{\"696\":1}}],[\"构建镜像\",{\"1\":{\"593\":1}}],[\"构建java项目的镜像\",{\"1\":{\"593\":1}}],[\"构建java项目\",{\"0\":{\"591\":1}}],[\"构建自定义的镜像时\",{\"1\":{\"590\":1}}],[\"构造函数默认创建的是非公平锁\",{\"1\":{\"497\":1,\"501\":1}}],[\"构造函数中传入的参数表示可以同时访问的资源数量\",{\"1\":{\"358\":1}}],[\"构造函数执行等步骤\",{\"1\":{\"117\":1}}],[\"构造函数会对对象的实例变量进行初始化\",{\"1\":{\"117\":1}}],[\"构造函数可以是类的直接构造函数\",{\"1\":{\"117\":1}}],[\"挂载\",{\"1\":{\"587\":2}}],[\"挂载数据卷\",{\"0\":{\"585\":1}}],[\"宿主机文件\",{\"1\":{\"587\":1,\"588\":1}}],[\"宿主机目录\",{\"1\":{\"587\":3,\"588\":1}}],[\"带来的潜在安全风险\",{\"0\":{\"710\":1}}],[\"带来的好处就是\",{\"1\":{\"332\":1}}],[\"带数据卷模式\",{\"1\":{\"587\":1}}],[\"③\",{\"1\":{\"584\":1,\"587\":1,\"593\":1,\"597\":1,\"604\":1}}],[\"②\",{\"1\":{\"584\":1,\"586\":1,\"587\":1,\"593\":1,\"597\":1,\"604\":1}}],[\"①\",{\"1\":{\"584\":1,\"586\":1,\"587\":1,\"593\":1,\"597\":1,\"604\":1}}],[\"耦合带来的后果\",{\"1\":{\"581\":1}}],[\"步骤如下\",{\"1\":{\"604\":1}}],[\"步骤6\",{\"1\":{\"592\":1}}],[\"步骤5\",{\"1\":{\"592\":1}}],[\"步骤4\",{\"1\":{\"592\":1}}],[\"步骤3\",{\"1\":{\"592\":1}}],[\"步骤2\",{\"1\":{\"592\":1}}],[\"步骤1\",{\"1\":{\"592\":1}}],[\"步骤\",{\"1\":{\"579\":1,\"586\":1}}],[\"添加任意自己需要的安装包\",{\"1\":{\"593\":1}}],[\"添加应用程序文件\",{\"1\":{\"589\":1}}],[\"添加\",{\"1\":{\"579\":1,\"580\":1}}],[\"添加了\",{\"1\":{\"242\":1}}],[\"肯定访问不到容器中的nginx\",{\"1\":{\"578\":1}}],[\"右侧是容器端口\",{\"1\":{\"578\":1}}],[\"右子节点的值大于等于当前节点的值\",{\"1\":{\"527\":1}}],[\"冒号左侧是宿主机端口\",{\"1\":{\"578\":1}}],[\"暂停\",{\"1\":{\"577\":1}}],[\"暂停时间可控\",{\"1\":{\"141\":1}}],[\"练习\",{\"0\":{\"575\":1}}],[\"利用这个光纤网络实现测控装置信号采集\",{\"1\":{\"627\":1}}],[\"利用网络通信来实现\",{\"1\":{\"624\":1}}],[\"利用\",{\"1\":{\"597\":1}}],[\"利用docker\",{\"1\":{\"574\":2,\"575\":4}}],[\"利用扩容后的大小也是2的倍数\",{\"1\":{\"535\":1}}],[\"案例\",{\"0\":{\"578\":1,\"579\":1,\"586\":1,\"587\":1}}],[\"案例2\",{\"0\":{\"574\":1}}],[\"案例1\",{\"0\":{\"573\":1}}],[\"拉取镜像\",{\"0\":{\"604\":1},\"1\":{\"604\":1}}],[\"拉取自己需要的镜像\",{\"1\":{\"573\":1}}],[\"拉取\",{\"0\":{\"573\":1}}],[\"镜名称一般分两部分组成\",{\"1\":{\"571\":1}}],[\"镜像版本是mysql\",{\"1\":{\"598\":1}}],[\"镜像就是在系统函数库\",{\"1\":{\"589\":1}}],[\"镜像是将应用程序及其需要的系统函数库\",{\"1\":{\"589\":1}}],[\"镜像结构\",{\"0\":{\"589\":1}}],[\"镜像命令\",{\"0\":{\"572\":1}}],[\"镜像名称\",{\"0\":{\"571\":1},\"1\":{\"574\":1,\"578\":1}}],[\"镜像操作\",{\"0\":{\"570\":1}}],[\"镜像运行起来就是容器\",{\"1\":{\"568\":1}}],[\"镜像中的应用程序运行后形成的进程就是容器\",{\"1\":{\"565\":1}}],[\"镜像\",{\"1\":{\"565\":1,\"568\":1}}],[\"镜像和容器\",{\"0\":{\"565\":1}}],[\"企业部署一般都是采用linux操作系统\",{\"1\":{\"569\":1}}],[\"阿里云镜像库等\",{\"1\":{\"566\":1}}],[\"国内也有类似于dockerhub\",{\"1\":{\"566\":1}}],[\"人们就会将自己打包的应用镜像\",{\"1\":{\"566\":1}}],[\"跟多个妹子聊天\",{\"1\":{\"565\":1}}],[\"跟踪进去的时候总是卡死\",{\"1\":{\"84\":1}}],[\"跟踪方法的调用情况\",{\"1\":{\"56\":1}}],[\"移除都可以通过一行命令完成\",{\"1\":{\"562\":1}}],[\"移植工作面临诸多困难\",{\"1\":{\"114\":1}}],[\"移植到hotspot虚拟机中\",{\"1\":{\"114\":1}}],[\"借助于操作系统的linux内核来运行\",{\"1\":{\"561\":1}}],[\"借助工具分析哪\",{\"1\":{\"89\":1}}],[\"环保的智能设备\",{\"1\":{\"623\":1}}],[\"环境友好和使用安全的目标\",{\"1\":{\"621\":1}}],[\"环境变量\",{\"1\":{\"598\":2}}],[\"环境\",{\"1\":{\"565\":1,\"568\":1,\"589\":1}}],[\"环境不一定一致\",{\"1\":{\"558\":1}}],[\"环路等待\",{\"1\":{\"512\":1}}],[\"环路等待条件\",{\"1\":{\"512\":1}}],[\"微服务虽然具备各种各样的优势\",{\"1\":{\"558\":1}}],[\"底层就是基于\",{\"1\":{\"554\":1}}],[\"底部设置change\",{\"1\":{\"20\":1}}],[\"头节点通过unsafe获取\",{\"1\":{\"549\":1}}],[\"冲突解决\",{\"1\":{\"544\":1}}],[\"冲突处理\",{\"1\":{\"525\":1}}],[\"渐进式扩容\",{\"1\":{\"543\":1}}],[\"树化阈值\",{\"1\":{\"543\":1}}],[\"种优化是为了解决在极端情况下链表过长导致的性能问题\",{\"1\":{\"543\":1}}],[\"老容量==1\",{\"1\":{\"542\":1}}],[\"老容量==0\",{\"1\":{\"542\":1}}],[\"老年代占用的堆内存百分比阈值\",{\"1\":{\"144\":1}}],[\"老年代空间不足\",{\"1\":{\"135\":1}}],[\"老年代通常使用标记\",{\"1\":{\"131\":1}}],[\"老年代用于存放长期存活的对象\",{\"1\":{\"130\":1}}],[\"老年代\",{\"1\":{\"130\":1}}],[\"临界值threshold\",{\"1\":{\"540\":1}}],[\"假如我们设的比较大\",{\"1\":{\"541\":1}}],[\"假如发生碰撞\",{\"1\":{\"539\":1}}],[\"假设我们有一个查询\",{\"1\":{\"614\":1}}],[\"假设有一个名为\",{\"1\":{\"610\":1,\"617\":1}}],[\"假设有以下简单的java方法\",{\"1\":{\"165\":1}}],[\"假设初始条件是a\",{\"1\":{\"504\":1}}],[\"牺牲了空间换时间\",{\"1\":{\"539\":1}}],[\"建立了标准兼容服务器所必须提供的通信服务的模型\",{\"1\":{\"636\":1}}],[\"建立全站统一的数据通信平台\",{\"1\":{\"624\":1}}],[\"建立公共溢出区\",{\"1\":{\"538\":1}}],[\"建议使用\",{\"1\":{\"240\":1}}],[\"换种哈希函数\",{\"1\":{\"538\":1}}],[\"换行输出\",{\"1\":{\"89\":1}}],[\"依赖性低\",{\"1\":{\"627\":2}}],[\"依赖文件等组合\",{\"1\":{\"589\":1}}],[\"依赖打包而成\",{\"1\":{\"589\":1}}],[\"依赖\",{\"1\":{\"560\":1,\"562\":1}}],[\"依赖项各不相同\",{\"1\":{\"559\":1}}],[\"依赖关系复杂\",{\"1\":{\"559\":1}}],[\"依赖的组件非常多\",{\"1\":{\"558\":1}}],[\"依次判断下一个位置是否空闲\",{\"1\":{\"538\":1}}],[\"依存于类的实例\",{\"1\":{\"301\":1}}],[\"给mysql挂载本地目录\",{\"0\":{\"587\":1}}],[\"给nginx挂载数据卷\",{\"0\":{\"586\":1}}],[\"给当前进入的容器创建一个标准输入\",{\"1\":{\"579\":1}}],[\"给容器起一个名字\",{\"1\":{\"578\":1}}],[\"给部署带来了极大的困难\",{\"1\":{\"559\":1}}],[\"给冲突元素找个空位\",{\"1\":{\"538\":1}}],[\"给编译器用的\",{\"1\":{\"289\":1}}],[\"折叠法\",{\"1\":{\"537\":1}}],[\"散列函数\",{\"1\":{\"544\":1}}],[\"散列也更均衡\",{\"1\":{\"537\":1}}],[\"散列方法重新计算位置\",{\"1\":{\"334\":1}}],[\"散列方法就是怎么把对应的key映射到table数组的相应下标\",{\"1\":{\"332\":1}}],[\"散列方法\",{\"1\":{\"332\":1}}],[\"效率化\",{\"1\":{\"630\":1}}],[\"效率更高\",{\"1\":{\"537\":1,\"630\":1}}],[\"效果\",{\"0\":{\"13\":1}}],[\"离得最近的2的倍数\",{\"1\":{\"536\":1}}],[\"离开停车场\",{\"1\":{\"357\":1}}],[\"补全到和hash值一样多的位数\",{\"1\":{\"535\":1}}],[\"取得对象名列表的通信服务\",{\"1\":{\"636\":1}}],[\"取\",{\"1\":{\"537\":2}}],[\"取余是去除整数倍\",{\"1\":{\"535\":1}}],[\"取出key的threadlocalhashcode\",{\"1\":{\"332\":1}}],[\"扰动函数能降hash碰撞\",{\"0\":{\"534\":1}}],[\"扰动函数是怎么设计的\",{\"0\":{\"533\":1}}],[\"达到高位与低位混合的效果\",{\"1\":{\"533\":1}}],[\"达到最大线程数则执行拒绝策略\",{\"1\":{\"447\":1}}],[\"覆盖逻辑\",{\"1\":{\"531\":1}}],[\"覆盖\",{\"1\":{\"531\":1}}],[\"覆盖基础设施\",{\"1\":{\"67\":1}}],[\"^\",{\"1\":{\"531\":1}}],[\"左旋和右旋\",{\"1\":{\"530\":1}}],[\"左子节点的值小于等于当前节点的值\",{\"1\":{\"527\":1}}],[\"染色\",{\"1\":{\"530\":2}}],[\"旋转分为两种\",{\"1\":{\"530\":1}}],[\"旋转\",{\"1\":{\"530\":2}}],[\"黑色节点的数量是相同的\",{\"1\":{\"527\":1}}],[\"黑色节点计数\",{\"1\":{\"527\":1}}],[\"红色节点的子节点必须是黑色的\",{\"1\":{\"527\":1}}],[\"红色节点限制\",{\"1\":{\"527\":1}}],[\"红黑树的平均时间复杂度为o\",{\"1\":{\"543\":1}}],[\"红黑树转回链表的阈值为什么是6\",{\"1\":{\"539\":1}}],[\"红黑树节点的大小大概是普通节点大小的两倍\",{\"1\":{\"539\":1}}],[\"红黑树有两种方式保持平衡\",{\"1\":{\"530\":1}}],[\"红黑树怎么保持平衡的知道吗\",{\"0\":{\"530\":1}}],[\"红黑树通过引入节点颜色和特定性质\",{\"1\":{\"529\":1}}],[\"红黑树在保持平衡的过程中旋转的次数较少\",{\"1\":{\"529\":1}}],[\"红黑树相对于普通的二叉搜索树的优势在于它能够保持良好的平衡\",{\"1\":{\"528\":1}}],[\"红黑树是一种自平衡的二叉搜索树\",{\"1\":{\"527\":1}}],[\"红黑树\",{\"1\":{\"525\":1,\"549\":1}}],[\"叶子节点\",{\"1\":{\"527\":1}}],[\"平方探查法\",{\"1\":{\"538\":1}}],[\"平方的中间几位作为映射的位置\",{\"1\":{\"537\":1}}],[\"平方取中法\",{\"1\":{\"537\":1}}],[\"平衡树呢\",{\"0\":{\"526\":1}}],[\"平台无关性\",{\"1\":{\"246\":1}}],[\"插入和删除操作的效率\",{\"1\":{\"543\":1}}],[\"插入和删除的效率\",{\"1\":{\"525\":1}}],[\"插件系统等\",{\"1\":{\"252\":1}}],[\"插件\",{\"1\":{\"89\":1}}],[\"插件扩展丰富\",{\"1\":{\"70\":1}}],[\"插件扩展功能丰富\",{\"1\":{\"58\":1}}],[\"哈希碰撞优化\",{\"1\":{\"543\":1}}],[\"哈希值是一个32位的int类型的数值\",{\"1\":{\"533\":1}}],[\"哈希函数\",{\"1\":{\"525\":1}}],[\"哈希码常用于哈希表等数据结构的实现中\",{\"1\":{\"305\":1}}],[\"哈希码是一个整数\",{\"1\":{\"305\":1}}],[\"链路管理\",{\"1\":{\"637\":1}}],[\"链地址法\",{\"1\":{\"538\":1,\"544\":1}}],[\"链表长度超过8就转换成红黑树\",{\"1\":{\"549\":1}}],[\"链表长度大于等于8\",{\"1\":{\"531\":1}}],[\"链表写入和hashmap的方式一样\",{\"1\":{\"549\":1}}],[\"链表同样操作\",{\"1\":{\"548\":1}}],[\"链表插入方式\",{\"1\":{\"543\":1}}],[\"链表转树阈值\",{\"1\":{\"543\":1}}],[\"链表转红黑树的阈值为什么要选8呢\",{\"1\":{\"539\":1}}],[\"链表结构扩容后\",{\"1\":{\"542\":1}}],[\"链表里的节点符合泊松分布\",{\"1\":{\"539\":1}}],[\"链表\",{\"1\":{\"525\":2}}],[\"链接\",{\"1\":{\"180\":1}}],[\"策略\",{\"1\":{\"520\":1}}],[\"迭代器提供的是一个一致性视图\",{\"1\":{\"522\":1}}],[\"迭代器的弱一致性\",{\"1\":{\"522\":1}}],[\"迭代器遍历的是开始遍历那一刻拿到的集合拷贝\",{\"1\":{\"520\":1}}],[\"迭代器并不能访问到修改后的内容\",{\"1\":{\"520\":1}}],[\"迭代器在遍历时直接访问集合中的内容\",{\"1\":{\"520\":1}}],[\"迭代过程中被修改\",{\"1\":{\"520\":1}}],[\"迭代优化\",{\"1\":{\"83\":1}}],[\"删除所有未使用的数据卷\",{\"1\":{\"584\":1}}],[\"删除指定数据卷\",{\"1\":{\"584\":1}}],[\"删除一个或多个指定的volume\",{\"1\":{\"583\":1}}],[\"删除一个容器\",{\"1\":{\"577\":1}}],[\"删除未使用的volume\",{\"1\":{\"583\":1}}],[\"删除本地的redis\",{\"1\":{\"575\":1}}],[\"删除和查找操作的时间复杂度变为o\",{\"1\":{\"528\":1}}],[\"删除\",{\"1\":{\"520\":1}}],[\"删除或修改了类的属性\",{\"1\":{\"276\":1}}],[\"快速失败是java集合的一种错误检测机制\",{\"1\":{\"520\":1}}],[\"快速失败\",{\"0\":{\"520\":1},\"1\":{\"520\":1}}],[\"剩下的50不用其实不用序列化\",{\"1\":{\"518\":1}}],[\"出口插件两块和采样保持插件\",{\"1\":{\"631\":1}}],[\"出于效率的考虑\",{\"1\":{\"518\":1}}],[\"出现节点个数的概率是递减的\",{\"1\":{\"539\":1}}],[\"出现线程死锁以后\",{\"1\":{\"513\":1}}],[\"出现问题\",{\"1\":{\"356\":1}}],[\"触发\",{\"1\":{\"520\":1}}],[\"触发扩容\",{\"1\":{\"516\":1}}],[\"触发major\",{\"1\":{\"133\":1}}],[\"触发minor\",{\"1\":{\"132\":1,\"133\":1,\"134\":1}}],[\"申请的时候可以先申请资源序号小的\",{\"1\":{\"512\":1}}],[\"答案是至少破坏死锁发生的一个条件\",{\"1\":{\"512\":1}}],[\"死锁恢复\",{\"1\":{\"513\":1}}],[\"死锁检测算法\",{\"1\":{\"513\":1}}],[\"死锁问题怎么排查呢\",{\"0\":{\"513\":1}}],[\"死锁产生的四个条件\",{\"1\":{\"512\":1}}],[\"死锁是指两个或两个以上的线程在执行过程中\",{\"1\":{\"512\":1}}],[\"死锁\",{\"1\":{\"512\":1}}],[\"很多使用自旋cas的地方\",{\"1\":{\"507\":1}}],[\"去除重复的\",{\"1\":{\"618\":1}}],[\"去除重复的行\",{\"1\":{\"615\":1,\"616\":1}}],[\"去重操作\",{\"1\":{\"616\":1}}],[\"去dockerhub查阅资料\",{\"1\":{\"587\":1}}],[\"去dockerhub搜索redis镜像\",{\"1\":{\"575\":1}}],[\"去dockerhub搜索并拉取一个redis镜像\",{\"1\":{\"575\":1}}],[\"去修改数据时\",{\"1\":{\"504\":1}}],[\"去阻塞队列取任务\",{\"1\":{\"457\":1}}],[\"循环性能开销\",{\"0\":{\"506\":1},\"1\":{\"503\":1}}],[\"循环往复的做达到屏障点\",{\"1\":{\"355\":1}}],[\"循环往复\",{\"1\":{\"355\":1}}],[\"问题\",{\"0\":{\"504\":1},\"1\":{\"503\":1}}],[\"问题解决\",{\"1\":{\"84\":1}}],[\"交换\",{\"1\":{\"502\":1}}],[\"交易系统\",{\"1\":{\"158\":1}}],[\"旧的预期值\",{\"1\":{\"502\":1}}],[\"旧版本的\",{\"1\":{\"222\":1}}],[\"乖乖排到后面\",{\"1\":{\"501\":1}}],[\"抢锁\",{\"1\":{\"501\":1}}],[\"抢先进入此方法的线程会优先拥有\",{\"1\":{\"485\":1}}],[\"唤醒阻塞线程的开销比非公平锁大\",{\"1\":{\"498\":1}}],[\"唤醒处于等待状态的线程\",{\"1\":{\"496\":1}}],[\"唤醒等待队列中的线程\",{\"1\":{\"400\":1}}],[\"共享使用\",{\"1\":{\"566\":1}}],[\"共享方式tryacquireshared\",{\"1\":{\"496\":1}}],[\"共享项目到github\",{\"0\":{\"18\":1}}],[\"独占方式\",{\"1\":{\"496\":1}}],[\"独立性强\",{\"1\":{\"309\":1}}],[\"起到一个重入计数器的作用\",{\"1\":{\"494\":1}}],[\"升级为重量级锁\",{\"1\":{\"494\":1}}],[\"升级为轻量级锁\",{\"1\":{\"493\":1}}],[\"升级\",{\"1\":{\"493\":1}}],[\"撤销\",{\"1\":{\"493\":2}}],[\"竞争失败\",{\"1\":{\"493\":1}}],[\"偏向锁不会主动释放\",{\"1\":{\"493\":1}}],[\"偏向锁的撤销\",{\"1\":{\"493\":1}}],[\"偏向锁的获取\",{\"1\":{\"493\":1}}],[\"偏向锁升级为轻量级锁\",{\"1\":{\"493\":1}}],[\"偏向锁标记是否为\",{\"1\":{\"493\":1}}],[\"偏向锁\",{\"0\":{\"493\":1},\"1\":{\"491\":1}}],[\"偏向时间戳\",{\"1\":{\"490\":1}}],[\"叫\",{\"1\":{\"490\":1}}],[\"他会记录下线程获取锁的次数\",{\"1\":{\"489\":1}}],[\"归\",{\"1\":{\"485\":1}}],[\"处于运行状态\",{\"1\":{\"577\":1}}],[\"处于等待锁block状态的线程\",{\"1\":{\"485\":1}}],[\"处于wait状态的线程\",{\"1\":{\"485\":1}}],[\"处理java对象与数据库类型之间的转换\",{\"1\":{\"656\":1}}],[\"处理sql语句执行的结果集\",{\"1\":{\"656\":1}}],[\"处理sql语句中的参数\",{\"1\":{\"656\":1}}],[\"处理sql语句的创建和执行\",{\"1\":{\"656\":1}}],[\"处理特殊情况和优化性能\",{\"1\":{\"655\":1}}],[\"处理任务执行期间抛出的异常\",{\"1\":{\"467\":1}}],[\"处理异步任务\",{\"0\":{\"466\":1}}],[\"处理异常\",{\"0\":{\"376\":1},\"1\":{\"462\":1,\"463\":1,\"466\":1}}],[\"处理被拒绝的任务\",{\"1\":{\"465\":1}}],[\"处理未捕获的异常\",{\"1\":{\"464\":2}}],[\"处理线程池中的异常可以确保程序的稳定性和可靠性\",{\"1\":{\"461\":1}}],[\"处理大型数据集时\",{\"1\":{\"430\":1}}],[\"处理请求逻辑\",{\"1\":{\"424\":1}}],[\"处理结果\",{\"1\":{\"398\":1}}],[\"处理所有结果\",{\"1\":{\"383\":1}}],[\"处理后数据\",{\"1\":{\"361\":1}}],[\"处理器可以改变语句对应\",{\"1\":{\"319\":1}}],[\"处理流\",{\"1\":{\"236\":1}}],[\"恢复为空\",{\"1\":{\"485\":1}}],[\"恢复中断状态\",{\"1\":{\"467\":1}}],[\"业务代码\",{\"1\":{\"482\":3}}],[\"业务影响分析\",{\"1\":{\"70\":1}}],[\"得到斐波那契数列的第10个数的值\",{\"1\":{\"480\":1}}],[\"得到当前位置的斐波那契数\",{\"1\":{\"480\":1}}],[\"得让它去帮没干完活的线程干活\",{\"1\":{\"480\":1}}],[\"拆分出的小任务会被分配给线程池中的工作线程执行\",{\"1\":{\"480\":1}}],[\"拆箱\",{\"1\":{\"260\":1}}],[\"干完活的线程不能让它空下来\",{\"1\":{\"480\":1}}],[\"各分支电流回路\",{\"1\":{\"644\":1}}],[\"各个间隔所涉及的位置开入回路\",{\"1\":{\"644\":1}}],[\"各个变电站配置并不完全相同\",{\"1\":{\"630\":1}}],[\"各个变电站之间及变电站与调度之间的数据交换\",{\"1\":{\"625\":1}}],[\"各个应用互不干扰\",{\"1\":{\"562\":1}}],[\"各自创建单独线程来执行队列里的任务\",{\"1\":{\"480\":1}}],[\"各种报警\",{\"1\":{\"89\":1}}],[\"求出子问题的解\",{\"1\":{\"480\":1}}],[\"要求站内应用的所有智能电子装置\",{\"1\":{\"624\":1}}],[\"要求\",{\"1\":{\"587\":1}}],[\"要解决这个问题\",{\"1\":{\"581\":1}}],[\"要解决不同操作系统环境差异问题\",{\"1\":{\"561\":1}}],[\"要进入的容器的名称\",{\"1\":{\"579\":1}}],[\"要想掌握fork\",{\"1\":{\"480\":1}}],[\"要么是黑色\",{\"1\":{\"527\":1}}],[\"要么任务执行失败需要回滚\",{\"1\":{\"478\":1}}],[\"要么不执行\",{\"1\":{\"316\":1}}],[\"要么完全执行\",{\"1\":{\"316\":1}}],[\"怎么实现有序的\",{\"0\":{\"551\":1,\"552\":1}}],[\"怎么解决这些问题呢\",{\"1\":{\"560\":1}}],[\"怎么解决循环性能开销问题\",{\"0\":{\"507\":1}}],[\"怎么解决aba问题\",{\"0\":{\"505\":1}}],[\"怎么使用\",{\"0\":{\"482\":1}}],[\"怎么优化\",{\"0\":{\"479\":1}}],[\"怎么办\",{\"0\":{\"87\":1,\"764\":1},\"1\":{\"276\":1}}],[\"记录着锁的状态\",{\"1\":{\"490\":1}}],[\"记录线程获取锁的次数\",{\"1\":{\"485\":1}}],[\"记录任务的执行日志\",{\"1\":{\"478\":1}}],[\"记录哪些内存块是可用的\",{\"1\":{\"118\":1}}],[\"持有一个资源的同时请求一个新资源\",{\"1\":{\"512\":1}}],[\"持久化任务队列\",{\"1\":{\"478\":1}}],[\"持续性的\",{\"1\":{\"649\":1}}],[\"持续优化应用程序和jvm的配置\",{\"1\":{\"83\":1}}],[\"持续监控应用程序的性能和运行状态\",{\"1\":{\"83\":1}}],[\"持续监控\",{\"1\":{\"83\":1}}],[\"事务管理器\",{\"1\":{\"656\":1}}],[\"事务性执行任务\",{\"1\":{\"478\":2}}],[\"事件\",{\"1\":{\"652\":1}}],[\"事后观察调整\",{\"1\":{\"476\":1}}],[\"事中分析优化\",{\"1\":{\"476\":1}}],[\"事前评估\",{\"1\":{\"476\":1}}],[\"告警机制可以帮助及时发现线程池的问题\",{\"1\":{\"476\":1}}],[\"告警机制\",{\"1\":{\"476\":1}}],[\"压力测试等\",{\"1\":{\"476\":1}}],[\"压缩回收\",{\"1\":{\"149\":1}}],[\"评估的目的是为了在上线之前就能够预估系统的负载情况\",{\"1\":{\"476\":1}}],[\"评估应用需求\",{\"1\":{\"160\":1}}],[\"帮助用户更好地管理线程池\",{\"1\":{\"475\":1}}],[\"帮助识别性能问题和优化应用\",{\"1\":{\"66\":1}}],[\"您可以有效地处理线程池中的异常\",{\"1\":{\"467\":1}}],[\"捕获并处理异常\",{\"0\":{\"462\":1}}],[\"捕获异常\",{\"1\":{\"280\":1}}],[\"既包含应用本身\",{\"1\":{\"560\":1}}],[\"既可以提交不需要返回结果的任务\",{\"1\":{\"451\":1}}],[\"既然有了字节流\",{\"0\":{\"237\":1}}],[\"延迟队列通常用于实现定时任务调度\",{\"1\":{\"450\":1}}],[\"延迟队列用于存储延迟执行的任务\",{\"1\":{\"450\":1}}],[\"延迟队列\",{\"1\":{\"450\":1}}],[\"queue\",{\"1\":{\"450\":6}}],[\"quals\",{\"1\":{\"305\":1}}],[\"队列阻塞挂起\",{\"1\":{\"500\":1}}],[\"队列中的第一个线程才能获得锁\",{\"1\":{\"498\":1}}],[\"队列是同步移交队列synchronousqueue\",{\"1\":{\"458\":1}}],[\"队列已满则创建新线程\",{\"1\":{\"447\":1}}],[\"队列数据结构\",{\"1\":{\"400\":1}}],[\"立即停止所有任务\",{\"1\":{\"446\":1}}],[\"丢弃最旧策略\",{\"1\":{\"449\":1}}],[\"丢弃策略\",{\"1\":{\"449\":1}}],[\"丢弃队列最前的任务和由调用线程执行任务\",{\"1\":{\"444\":1,\"448\":1}}],[\"丢弃任务\",{\"1\":{\"444\":1,\"448\":1}}],[\"拒绝策略\",{\"1\":{\"444\":1,\"448\":1}}],[\"邮件发送完成\",{\"1\":{\"436\":1}}],[\"充分利用多核cpu的优势\",{\"1\":{\"431\":1}}],[\"充分利用多处理器的优势\",{\"1\":{\"148\":1}}],[\"寄存器\",{\"1\":{\"415\":1}}],[\"核心应该是线程池+任务队列\",{\"1\":{\"454\":1}}],[\"核心线程数为1\",{\"1\":{\"459\":1}}],[\"核心线程数为0\",{\"1\":{\"458\":1}}],[\"核心线程数和最大线程数大小一样\",{\"1\":{\"457\":1}}],[\"核心线程数\",{\"1\":{\"408\":1,\"448\":1}}],[\"核心方法await\",{\"1\":{\"355\":1}}],[\"固定大小的线程池\",{\"1\":{\"406\":1}}],[\"固定大小线程池包含固定数量的线程\",{\"1\":{\"455\":1}}],[\"固定大小线程池\",{\"0\":{\"394\":1,\"457\":1},\"1\":{\"455\":1}}],[\"试图向队列中添加元素的线程会被阻塞\",{\"1\":{\"400\":1}}],[\"试图从队列中取出元素的线程会被阻塞\",{\"1\":{\"400\":1}}],[\"试验和测量\",{\"1\":{\"160\":1}}],[\"满足统一的标准\",{\"1\":{\"624\":1}}],[\"满足用户多样化的电力需求\",{\"1\":{\"622\":1}}],[\"满足不同应用场景的需求\",{\"1\":{\"398\":1}}],[\"满足特定需求\",{\"1\":{\"204\":1}}],[\"展示如何使用自定义线程池执行异步任务\",{\"1\":{\"392\":1}}],[\"展示了双亲委派机制的工作流程\",{\"1\":{\"207\":1}}],[\"展示了标量替换的概念\",{\"1\":{\"171\":1}}],[\"合及挡位调节等操作功能\",{\"1\":{\"639\":1}}],[\"合\",{\"1\":{\"639\":1}}],[\"合闸\",{\"1\":{\"639\":1}}],[\"合闸出口装置\",{\"1\":{\"639\":1}}],[\"合并单元\",{\"1\":{\"640\":5,\"644\":1}}],[\"合并单元及网络交换机等\",{\"1\":{\"628\":1}}],[\"合并结果\",{\"1\":{\"385\":1}}],[\"合理接入\",{\"1\":{\"622\":1}}],[\"合理地管理这些内存区域对于jvm高效运行和垃圾回收有着至关重要的作用\",{\"1\":{\"92\":1}}],[\"合一起就是镜像名称\",{\"1\":{\"571\":1}}],[\"真实场景应用\",{\"0\":{\"384\":1}}],[\"消费结果但不返回新的结果\",{\"1\":{\"370\":1}}],[\"消费者处理的数据\",{\"1\":{\"361\":1}}],[\"消费者\",{\"1\":{\"361\":1}}],[\"看起来如同一个linux服务器一样\",{\"1\":{\"579\":1}}],[\"看看是否录入一致\",{\"1\":{\"363\":1}}],[\"看做是包装对象\",{\"1\":{\"243\":1}}],[\"录入到excel之后\",{\"1\":{\"363\":1}}],[\"校对工作\",{\"1\":{\"363\":1}}],[\"遗传算法里需要选出两个人作为交配对象\",{\"1\":{\"363\":1}}],[\"遗传算法\",{\"1\":{\"363\":1}}],[\"另一方面也可以从dockerhub拉取镜像\",{\"1\":{\"566\":1}}],[\"另一个线程同时执行get操作\",{\"1\":{\"545\":1}}],[\"另一个线程处理任务并返回结果\",{\"1\":{\"360\":1}}],[\"另外一个线程还可以通过cas的方式进行获取\",{\"1\":{\"496\":1}}],[\"另外\",{\"1\":{\"139\":1}}],[\"尝试中断正在执行的任务\",{\"1\":{\"471\":1}}],[\"尝试终止正在执行的任务\",{\"1\":{\"446\":1}}],[\"尝试获取许可但不阻塞\",{\"1\":{\"359\":1}}],[\"尝试进入停车场\",{\"1\":{\"357\":1}}],[\"公平锁的优点是等待锁的线程不会饿死\",{\"1\":{\"498\":1}}],[\"公平锁是指多个线程按照申请锁的顺序来获取锁\",{\"1\":{\"498\":1}}],[\"公平锁\",{\"0\":{\"498\":1}}],[\"公平性\",{\"1\":{\"359\":1}}],[\"公司的监控系统\",{\"1\":{\"88\":1}}],[\"停止一个运行的容器\",{\"1\":{\"577\":1}}],[\"停止\",{\"1\":{\"577\":1}}],[\"停止接受新任务\",{\"1\":{\"446\":1,\"447\":1}}],[\"停车一段时间后离开\",{\"1\":{\"358\":1}}],[\"停车和离开的过程\",{\"1\":{\"358\":1}}],[\"停顿时间较长\",{\"1\":{\"159\":1}}],[\"停顿时间要求\",{\"1\":{\"158\":1}}],[\"停顿时间不可预测\",{\"1\":{\"139\":1}}],[\"停顿时间和内存使用情况\",{\"1\":{\"87\":1}}],[\"汽车\",{\"1\":{\"357\":1}}],[\"限制返回的行数为\",{\"1\":{\"618\":1}}],[\"限制返回的行数\",{\"1\":{\"616\":1,\"619\":1}}],[\"限制同时执行的任务数量\",{\"1\":{\"479\":1}}],[\"限制同时访问数据库的连接数\",{\"1\":{\"357\":1}}],[\"限制并发数\",{\"1\":{\"479\":2}}],[\"限流控制\",{\"1\":{\"357\":1}}],[\"信号上送功能\",{\"1\":{\"652\":1}}],[\"信号插件各一块\",{\"1\":{\"631\":1}}],[\"信号量\",{\"0\":{\"357\":1},\"1\":{\"357\":1}}],[\"信息共享标准化为基本要求\",{\"1\":{\"623\":1}}],[\"信息流和业务流高度融合的显著特点\",{\"1\":{\"621\":1}}],[\"信息\",{\"1\":{\"89\":1}}],[\"受影响\",{\"1\":{\"356\":1}}],[\"受检异常\",{\"1\":{\"279\":1}}],[\"断路器操作回路的同时还具有自我状态检测功能\",{\"1\":{\"639\":1}}],[\"断路器sf6压力监视\",{\"1\":{\"639\":1}}],[\"断路器等一次设备运行位置及断路器本体的报警及状态信号转换为弱电信号\",{\"1\":{\"639\":1}}],[\"断路器\",{\"1\":{\"628\":1}}],[\"断\",{\"1\":{\"356\":1}}],[\"务由哪些线程完成无关紧要\",{\"1\":{\"356\":1}}],[\"至于这些任\",{\"1\":{\"356\":1}}],[\"须要指定任务数\",{\"1\":{\"356\":1}}],[\"届时\",{\"1\":{\"356\":1}}],[\"模糊查询like语句该怎么写\",{\"0\":{\"767\":1}}],[\"模糊了一次\",{\"1\":{\"624\":1}}],[\"模式中\",{\"1\":{\"629\":1}}],[\"模拟发送邮件时间\",{\"1\":{\"436\":1}}],[\"模拟处理时间\",{\"1\":{\"432\":1}}],[\"模拟任务执行\",{\"1\":{\"407\":1,\"409\":1}}],[\"模拟任务执行时间\",{\"1\":{\"355\":1}}],[\"模拟远程调用\",{\"1\":{\"385\":3}}],[\"模拟耗时操作\",{\"1\":{\"383\":3,\"392\":1}}],[\"模拟消费者线程\",{\"1\":{\"362\":1}}],[\"模拟生产者线程\",{\"1\":{\"362\":1}}],[\"模拟两个线程之间的数据交换\",{\"1\":{\"361\":1}}],[\"模拟停车场\",{\"1\":{\"358\":1}}],[\"模拟停车时间\",{\"1\":{\"357\":1}}],[\"模板已成功生成\",{\"1\":{\"11\":1}}],[\"正在执行任务\",{\"1\":{\"355\":13}}],[\"组织成一个或者多个逻辑设备\",{\"1\":{\"650\":1}}],[\"组合\",{\"1\":{\"618\":1}}],[\"组合后的唯一值\",{\"1\":{\"609\":1}}],[\"组合多个\",{\"0\":{\"372\":1}}],[\"组合以及异常处理等\",{\"1\":{\"365\":1}}],[\"组线程到达一个屏障\",{\"1\":{\"354\":1}}],[\"组件图\",{\"0\":{\"42\":1}}],[\"收到消费者的数据\",{\"1\":{\"361\":1}}],[\"收到\",{\"1\":{\"353\":1}}],[\"收集器是java虚拟机\",{\"1\":{\"139\":1}}],[\"收集器\",{\"1\":{\"137\":2,\"140\":1}}],[\"收集基准数据\",{\"1\":{\"79\":1}}],[\"收集jvm的配置信息\",{\"1\":{\"78\":1}}],[\"收集jvm信息\",{\"1\":{\"78\":1}}],[\"收集应用程序信息\",{\"1\":{\"78\":1}}],[\"收集信息和分析\",{\"0\":{\"78\":1}}],[\"收集系统的性能数据\",{\"1\":{\"54\":1}}],[\"敌方还有5秒达到战场\",{\"1\":{\"353\":1}}],[\"场景\",{\"1\":{\"520\":2}}],[\"场景描述\",{\"0\":{\"422\":1,\"426\":1,\"430\":1,\"434\":1,\"438\":1}}],[\"场景2\",{\"1\":{\"353\":1}}],[\"场景1\",{\"1\":{\"353\":1}}],[\"马上到\",{\"1\":{\"353\":1}}],[\"稍等\",{\"1\":{\"353\":1}}],[\"铠\",{\"1\":{\"353\":4}}],[\"哪吒\",{\"1\":{\"353\":4}}],[\"哪些是不可达的\",{\"1\":{\"127\":1}}],[\"兰陵王\",{\"1\":{\"353\":4}}],[\"倒计数器\",{\"0\":{\"353\":1},\"1\":{\"353\":1}}],[\"任意数\",{\"1\":{\"535\":1}}],[\"任意对象为值的存储结构\",{\"1\":{\"351\":1}}],[\"任务分解\",{\"1\":{\"480\":1}}],[\"任务分配与结果收集\",{\"1\":{\"360\":1}}],[\"任务拆分\",{\"1\":{\"479\":2}}],[\"任务堆积\",{\"1\":{\"476\":1}}],[\"任务类型和处理速度等进行评估\",{\"1\":{\"476\":1}}],[\"任务的性质\",{\"1\":{\"453\":1}}],[\"任务加入队列\",{\"1\":{\"444\":1}}],[\"任务执行情况等\",{\"1\":{\"476\":1}}],[\"任务执行时间较短的场景\",{\"1\":{\"455\":1}}],[\"任务执行时间和任务队列容量等因素综合考虑\",{\"1\":{\"453\":1}}],[\"任务执行时间\",{\"1\":{\"453\":1}}],[\"任务执行完成\",{\"0\":{\"445\":1},\"1\":{\"447\":1}}],[\"任务执行\",{\"0\":{\"444\":1},\"1\":{\"480\":1}}],[\"任务执行和资源回收\",{\"1\":{\"441\":1}}],[\"任务结果\",{\"1\":{\"443\":1}}],[\"任务可以通过execute\",{\"1\":{\"443\":1}}],[\"任务提交到线程池\",{\"1\":{\"447\":1}}],[\"任务提交\",{\"0\":{\"443\":1},\"1\":{\"441\":1,\"477\":2}}],[\"任务对象等\",{\"1\":{\"418\":1}}],[\"任务\",{\"1\":{\"407\":1,\"409\":1}}],[\"任务队列中的任务数据也不会丢失\",{\"1\":{\"478\":1}}],[\"任务队列大小等参数\",{\"1\":{\"476\":1}}],[\"任务队列类型和大小等参数\",{\"1\":{\"476\":1}}],[\"任务队列容量\",{\"1\":{\"453\":1}}],[\"任务队列\",{\"1\":{\"403\":1,\"408\":1,\"442\":1,\"448\":1}}],[\"任务1结果\",{\"1\":{\"398\":1}}],[\"任务完成\",{\"1\":{\"371\":1,\"383\":1}}],[\"任务完成后的回调\",{\"0\":{\"368\":1}}],[\"任务逻辑\",{\"1\":{\"367\":2,\"443\":2,\"462\":1,\"466\":1,\"467\":1}}],[\"任何一个客户可通过抽象通信服务接口\",{\"1\":{\"636\":1}}],[\"任何一个线程都能并发访问localvariable\",{\"1\":{\"326\":1}}],[\"任何对string的修改都会创建一个新的string对象\",{\"1\":{\"268\":1}}],[\"任何对\",{\"1\":{\"267\":1}}],[\"管道输入\",{\"1\":{\"351\":3}}],[\"管理数据库事务\",{\"1\":{\"656\":1}}],[\"管理事务等方法\",{\"1\":{\"656\":1}}],[\"管理镜像\",{\"1\":{\"567\":1}}],[\"管理着一组工作线程\",{\"1\":{\"480\":1}}],[\"管理平台可以根据实际需求提供各种功能\",{\"1\":{\"475\":1}}],[\"管理\",{\"1\":{\"178\":1}}],[\"管理机制\",{\"1\":{\"105\":1}}],[\"守护线程\",{\"1\":{\"350\":1}}],[\"守护线程了解吗\",{\"0\":{\"350\":1}}],[\"锁粗化\",{\"1\":{\"491\":2}}],[\"锁消除等\",{\"1\":{\"495\":1}}],[\"锁消除\",{\"1\":{\"491\":2}}],[\"锁升级方向\",{\"1\":{\"492\":1}}],[\"锁升级的过程是什么样的\",{\"0\":{\"492\":1}}],[\"锁升级\",{\"0\":{\"490\":1}}],[\"锁对象的时候有个计数器\",{\"1\":{\"489\":1}}],[\"锁的实现\",{\"1\":{\"495\":1}}],[\"锁的状态\",{\"1\":{\"490\":1}}],[\"锁的重入次数\",{\"1\":{\"485\":1}}],[\"锁的释放等\",{\"1\":{\"349\":1}}],[\"锁\",{\"0\":{\"481\":1}}],[\"锁和条件等待机制\",{\"1\":{\"400\":1}}],[\"锁和条件等待\",{\"1\":{\"400\":1}}],[\"锁状态标志\",{\"1\":{\"490\":1}}],[\"锁状态标志等\",{\"1\":{\"117\":1}}],[\"锁状态\",{\"1\":{\"121\":1}}],[\"终端箱内除了配置断路器控制回路监视\",{\"1\":{\"639\":1}}],[\"终端操作会返回一个结果\",{\"1\":{\"244\":1}}],[\"终端操作\",{\"1\":{\"244\":1}}],[\"终止遍历\",{\"1\":{\"520\":1}}],[\"终止死锁进程\",{\"1\":{\"513\":1}}],[\"终止状态\",{\"1\":{\"345\":1}}],[\"程需要等待其他线程做出一些特定动作\",{\"1\":{\"345\":1}}],[\"程序顺序规则\",{\"1\":{\"320\":1}}],[\"程序将无法继续执行\",{\"1\":{\"281\":2}}],[\"程序还没有进入try语句块就因为异常导致程序终止\",{\"1\":{\"281\":1}}],[\"程序运行中出现异常\",{\"1\":{\"279\":1}}],[\"程序运行速度变慢\",{\"1\":{\"123\":1}}],[\"程序返回\",{\"1\":{\"263\":1}}],[\"程序要经过先编译\",{\"1\":{\"250\":1}}],[\"程序从源代码到运行主要有三步\",{\"1\":{\"249\":1}}],[\"程序所需的所有内容的集合\",{\"1\":{\"247\":1}}],[\"程序员无法直接控制\",{\"1\":{\"190\":1}}],[\"程序可以访问和操作对象的属性和方法\",{\"1\":{\"117\":1}}],[\"程序计数器等\",{\"1\":{\"415\":1}}],[\"程序计数器和本地方法栈\",{\"1\":{\"92\":1}}],[\"程序计数器\",{\"1\":{\"92\":1,\"94\":1,\"96\":1,\"179\":1,\"348\":1}}],[\"程序bug\",{\"1\":{\"88\":1}}],[\"程序频繁生成一些\",{\"1\":{\"88\":1}}],[\"阻塞呗\",{\"1\":{\"523\":1}}],[\"阻塞和唤醒操作\",{\"1\":{\"400\":1}}],[\"阻塞队列是delayedworkqueue\",{\"1\":{\"460\":1}}],[\"阻塞队列是无界队列linkedblockingqueue\",{\"1\":{\"459\":1}}],[\"阻塞队列是一种特殊的队列数据结构\",{\"1\":{\"400\":1}}],[\"阻塞队列为无界队列linkedblockingqueue\",{\"1\":{\"457\":1}}],[\"阻塞队列通过结合队列数据结构\",{\"1\":{\"400\":1}}],[\"阻塞队列需要保证在多线程环境下的线程安全性\",{\"1\":{\"400\":1}}],[\"阻塞队列内部通常使用锁和条件等待来实现线程的阻塞和唤醒\",{\"1\":{\"400\":1}}],[\"阻塞队列基于数组或链表等数据结构实现\",{\"1\":{\"400\":1}}],[\"阻塞队列的实现通常基于经典的队列数据结构\",{\"1\":{\"400\":1}}],[\"阻塞直到有可用的许可\",{\"1\":{\"357\":1}}],[\"阻塞状态\",{\"1\":{\"345\":1}}],[\"阻止实例中那些用此关键字修饰的的变量序列化\",{\"1\":{\"276\":1}}],[\"统称为dockerregistry\",{\"1\":{\"568\":1}}],[\"统的称作\",{\"1\":{\"345\":1}}],[\"统一各线程动作开始的时机\",{\"1\":{\"353\":1}}],[\"统一类加载规则以及支持模块化开发和扩展性等方面\",{\"1\":{\"213\":1}}],[\"统一类加载规则\",{\"0\":{\"212\":1}}],[\"统一的内存管理\",{\"1\":{\"115\":1}}],[\"检测到死锁\",{\"1\":{\"513\":1}}],[\"检测当前线程是否被中断\",{\"1\":{\"344\":2}}],[\"检查当前类加载器是否已经加载过该类\",{\"1\":{\"206\":1}}],[\"检查是否已加载\",{\"1\":{\"206\":1}}],[\"检查类的结构\",{\"1\":{\"185\":1}}],[\"检查这些代码段是否存在内存泄漏或不合理的内存使用\",{\"1\":{\"90\":1}}],[\"检查代码\",{\"1\":{\"90\":1}}],[\"检查对象的引用\",{\"1\":{\"87\":1}}],[\"检查应用程序的代码逻辑\",{\"1\":{\"87\":1}}],[\"让容器后台运行\",{\"1\":{\"580\":1}}],[\"让出线程\",{\"1\":{\"549\":1}}],[\"让出优先权\",{\"1\":{\"344\":1}}],[\"让一个停止的容器再次运行\",{\"1\":{\"577\":1}}],[\"让一个容器从暂停状态恢复运行\",{\"1\":{\"577\":1}}],[\"让一个运行的容器暂停\",{\"1\":{\"577\":1}}],[\"让一\",{\"1\":{\"354\":1}}],[\"让后统计数量\",{\"1\":{\"244\":1}}],[\"资源剥夺\",{\"1\":{\"513\":1}}],[\"资源控制\",{\"1\":{\"404\":1}}],[\"资源双向传递\",{\"1\":{\"360\":1}}],[\"资源池管理\",{\"1\":{\"357\":1}}],[\"资源后就可以继续运行\",{\"1\":{\"344\":1}}],[\"资源密集型的程序中\",{\"1\":{\"123\":1}}],[\"函数加载到内存中允许\",{\"1\":{\"565\":1}}],[\"函数库一起打包\",{\"1\":{\"561\":1}}],[\"函数库\",{\"1\":{\"560\":1,\"561\":2,\"562\":1,\"565\":1}}],[\"函数会唤醒被阻塞到该共享变量上的一个线程\",{\"1\":{\"344\":1}}],[\"函数\",{\"1\":{\"344\":1,\"350\":1}}],[\"函数作为参数传递到方法中\",{\"1\":{\"240\":1}}],[\"灵活切换或并列二次电压供继电保护\",{\"1\":{\"640\":1}}],[\"灵活性\",{\"1\":{\"343\":1,\"655\":1}}],[\"灵活的仪表板\",{\"1\":{\"62\":1,\"70\":1}}],[\"例\",{\"1\":{\"343\":2}}],[\"例如sql语句的预处理\",{\"1\":{\"656\":1}}],[\"例如string\",{\"1\":{\"113\":1}}],[\"例如我的是\",{\"1\":{\"579\":1}}],[\"例如nginx\",{\"1\":{\"578\":1}}],[\"例如redis\",{\"1\":{\"566\":1}}],[\"例如你下载了一个qq\",{\"1\":{\"565\":1}}],[\"例如centos\",{\"1\":{\"561\":1}}],[\"例如cpu\",{\"1\":{\"561\":1}}],[\"例如catalina\",{\"1\":{\"234\":1}}],[\"例如一个项目中\",{\"1\":{\"559\":1}}],[\"例如十位和百位\",{\"1\":{\"537\":1}}],[\"例如1232放到下标1232的位置\",{\"1\":{\"537\":1}}],[\"例如atomicinteger\",{\"1\":{\"509\":1}}],[\"例如数据库\",{\"1\":{\"478\":1}}],[\"例如定时任务调度\",{\"1\":{\"455\":1}}],[\"例如任务依赖性较强的场景\",{\"1\":{\"455\":1}}],[\"例如并发量稳定的服务器应用\",{\"1\":{\"455\":1}}],[\"例如清理临时文件\",{\"1\":{\"438\":1}}],[\"例如发送邮件\",{\"1\":{\"434\":1}}],[\"例如线程对象\",{\"1\":{\"418\":1}}],[\"例如读取\",{\"1\":{\"315\":1}}],[\"例如整型默认为0\",{\"1\":{\"300\":1}}],[\"例如整数\",{\"1\":{\"104\":1}}],[\"例如添加\",{\"1\":{\"276\":1}}],[\"例如图像\",{\"1\":{\"237\":1}}],[\"例如图片缓存\",{\"1\":{\"128\":1}}],[\"例如tomcat的jdbc驱动等\",{\"1\":{\"234\":1}}],[\"例如threadlocal和weakhashmap\",{\"1\":{\"128\":1}}],[\"例如加载动态生成的类或者非标准位置的类\",{\"1\":{\"233\":1}}],[\"例如代码热替换和模块热部署\",{\"1\":{\"224\":1}}],[\"例如jdbc事务\",{\"1\":{\"656\":1}}],[\"例如java\",{\"1\":{\"234\":1}}],[\"例如java中的outofmemoryerror\",{\"1\":{\"123\":1}}],[\"例如jit编译器生成的机器代码\",{\"1\":{\"130\":1}}],[\"例如关闭文件\",{\"1\":{\"129\":1}}],[\"例如打开文件\",{\"1\":{\"125\":1}}],[\"例如对象的哈希码\",{\"1\":{\"121\":1}}],[\"例如运行时常量池\",{\"1\":{\"94\":1}}],[\"例如接口超时报警等\",{\"1\":{\"89\":1}}],[\"例如调整触发垃圾回收的阈值\",{\"1\":{\"81\":1}}],[\"例如内存泄漏\",{\"1\":{\"80\":1}}],[\"例如响应时间\",{\"1\":{\"79\":1}}],[\"例如\",{\"1\":{\"72\":7,\"73\":2,\"75\":2,\"76\":1,\"89\":1,\"90\":1,\"128\":2,\"160\":1,\"164\":1,\"166\":1,\"174\":1,\"185\":1,\"186\":1,\"195\":1,\"267\":1,\"305\":1,\"344\":1,\"430\":1,\"475\":1,\"574\":1,\"593\":1,\"594\":1}}],[\"系列方法而被挂起的线程\",{\"1\":{\"344\":1}}],[\"系列方法后被挂起的线程\",{\"1\":{\"344\":1}}],[\"系\",{\"1\":{\"343\":1}}],[\"系统\",{\"1\":{\"563\":1}}],[\"系统里面运行\",{\"1\":{\"563\":1}}],[\"系统函数库是对内核指令集的封装\",{\"1\":{\"561\":1}}],[\"系统应用\",{\"1\":{\"561\":1}}],[\"系统内核\",{\"1\":{\"561\":1}}],[\"系统重启后的处理\",{\"1\":{\"478\":1}}],[\"系统无法继续执行任务\",{\"1\":{\"478\":1}}],[\"系统资源\",{\"1\":{\"453\":2}}],[\"系统资源消耗\",{\"0\":{\"411\":1}}],[\"系统需要加载这两个excel\",{\"1\":{\"363\":1}}],[\"系统自动抛异常\",{\"1\":{\"280\":1}}],[\"系统的实现\",{\"1\":{\"247\":1}}],[\"系统一次性加载了过多数据到内存中\",{\"1\":{\"88\":1}}],[\"系统和服务的监控\",{\"1\":{\"70\":1}}],[\"系统上下文图\",{\"0\":{\"40\":1}}],[\"鄙人三某\",{\"1\":{\"335\":1}}],[\"鄙人张三\",{\"1\":{\"326\":1}}],[\"扩大了测量范围\",{\"1\":{\"635\":1}}],[\"扩容\",{\"1\":{\"544\":1}}],[\"扩容优化\",{\"1\":{\"543\":1}}],[\"扩容在什么时候呢\",{\"0\":{\"540\":1}}],[\"扩容后的\",{\"1\":{\"334\":1}}],[\"扩展成一个范围更大的锁\",{\"1\":{\"491\":1}}],[\"扩展或定制某个功能或组件的实现\",{\"1\":{\"252\":1}}],[\"扩展类加载器\",{\"0\":{\"200\":1}}],[\"个位置\",{\"1\":{\"538\":1}}],[\"个斐波那契数\",{\"1\":{\"480\":1}}],[\"个数\",{\"1\":{\"480\":1}}],[\"个线程出现问题\",{\"1\":{\"356\":1}}],[\"个槽位中\",{\"1\":{\"333\":1}}],[\"个对象非常多\",{\"1\":{\"89\":1}}],[\"往下执行\",{\"1\":{\"355\":1}}],[\"往后找一圈没找到就会从头开始找\",{\"1\":{\"333\":1}}],[\"往往选择zgc来确保系统的实时性和低延迟\",{\"1\":{\"155\":1}}],[\"黄金分割数\",{\"1\":{\"332\":1}}],[\"元素是按照是按照\",{\"1\":{\"552\":1}}],[\"元素比较少\",{\"1\":{\"541\":1}}],[\"元素比较多\",{\"1\":{\"541\":1}}],[\"元素数组\",{\"1\":{\"332\":1}}],[\"元空间进行垃圾回收\",{\"1\":{\"133\":1}}],[\"元空间不再位于java堆中\",{\"1\":{\"130\":1}}],[\"元空间提供更好的类加载和卸载支持\",{\"1\":{\"115\":1}}],[\"元空间设计使其更好地与分代垃圾回收器协同工作\",{\"1\":{\"115\":1}}],[\"元空间利用新的垃圾回收算法\",{\"1\":{\"115\":1}}],[\"元空间的优势\",{\"0\":{\"115\":1}}],[\"元空间在本地内存中动态扩展\",{\"1\":{\"98\":1}}],[\"元空间在本地内存中分配\",{\"1\":{\"96\":1,\"115\":1}}],[\"元空间用于存储类元数据\",{\"1\":{\"98\":1}}],[\"元空间\",{\"1\":{\"96\":1,\"130\":1,\"300\":1}}],[\"元空间使用的是本地内存而不是堆内存\",{\"1\":{\"92\":1}}],[\"元空间大小\",{\"1\":{\"88\":1}}],[\"读操作频繁且对实时性要求不高的场景\",{\"1\":{\"522\":1}}],[\"读操作在原数组上\",{\"1\":{\"522\":1}}],[\"读写分离\",{\"1\":{\"522\":1}}],[\"读也是以某个threadlocal作为引用\",{\"1\":{\"328\":1}}],[\"读取\",{\"1\":{\"326\":1,\"618\":1}}],[\"读取或写入操作使用缓冲区\",{\"1\":{\"238\":1}}],[\"读取字节码文件\",{\"1\":{\"184\":1}}],[\"存的区别\",{\"0\":{\"662\":1}}],[\"存在一定空间浪费\",{\"1\":{\"515\":1}}],[\"存放token\",{\"1\":{\"327\":1}}],[\"存储结构\",{\"1\":{\"525\":1}}],[\"存储entry类型的元素\",{\"1\":{\"332\":1}}],[\"存储操作\",{\"1\":{\"324\":1}}],[\"存储方式\",{\"1\":{\"300\":1}}],[\"存储方法调用的局部变量和部分方法执行时的中间结果\",{\"1\":{\"107\":1}}],[\"存储方法调用的局部变量\",{\"1\":{\"92\":1,\"110\":1}}],[\"存储字符串\",{\"1\":{\"268\":2}}],[\"存储在栈中\",{\"1\":{\"108\":1}}],[\"存储在字符串常量池中\",{\"1\":{\"104\":1,\"109\":1}}],[\"存储过程\",{\"1\":{\"108\":1}}],[\"存储类加载时从类文件中提取的常量\",{\"1\":{\"110\":1}}],[\"存储类文件中的各种常量\",{\"1\":{\"107\":1}}],[\"存储类的元数据\",{\"1\":{\"96\":1}}],[\"存储本地方法的调用信息\",{\"1\":{\"92\":1}}],[\"存储对象实例和数组\",{\"1\":{\"92\":1}}],[\"存储已加载的类信息\",{\"1\":{\"92\":1}}],[\"​\",{\"1\":{\"324\":1}}],[\"屏障将被拆\",{\"1\":{\"356\":1}}],[\"屏障会自动重置\",{\"1\":{\"355\":1}}],[\"屏障才会开门\",{\"1\":{\"354\":1}}],[\"屏障\",{\"1\":{\"324\":4}}],[\"屏蔽差异性\",{\"1\":{\"294\":1}}],[\"规范化和精益化管理\",{\"1\":{\"622\":1}}],[\"规则\",{\"1\":{\"320\":2}}],[\"规定了需要提供的功能或扩展点\",{\"1\":{\"252\":1}}],[\"双母接线方式\",{\"0\":{\"641\":1}}],[\"双开\",{\"1\":{\"565\":1}}],[\"双向链表的插入和删除只需要改变前驱节点\",{\"1\":{\"515\":1}}],[\"双线程数据交换\",{\"1\":{\"360\":1}}],[\"双重校验单例模式就是一个经典的指令重排的例子\",{\"1\":{\"319\":1}}],[\"双亲委派机制还不存在\",{\"1\":{\"222\":1}}],[\"双亲委派机制支持模块化开发\",{\"1\":{\"213\":1}}],[\"双亲委派机制定义了类加载器的委派规则\",{\"1\":{\"212\":1}}],[\"双亲委派机制保证了核心类库由java虚拟机的引导类加载器加载\",{\"1\":{\"211\":1}}],[\"双亲委派机制可以避免同一个类被多个类加载器重复加载\",{\"1\":{\"210\":1}}],[\"双亲委派机制确保了在整个java虚拟机中\",{\"1\":{\"209\":1}}],[\"双亲委派机制是java类加载机制的重要设计\",{\"1\":{\"213\":1}}],[\"双亲委派机制是java类加载机制的核心设计之一\",{\"1\":{\"208\":1}}],[\"双亲委派机制是java类加载器的核心机制\",{\"1\":{\"207\":1}}],[\"双亲委派机制的优点\",{\"0\":{\"207\":1}}],[\"双亲委派机制\",{\"1\":{\"205\":1}}],[\"那arraylist怎么序列化呢\",{\"0\":{\"519\":1}}],[\"那就重新匹配\",{\"1\":{\"353\":1}}],[\"那就接着去找空着的坑\",{\"1\":{\"333\":1}}],[\"那怎么不直接调用run\",{\"0\":{\"342\":1}}],[\"那怎么解决内存泄漏问题呢\",{\"0\":{\"330\":1}}],[\"那说说什么是指令重排\",{\"0\":{\"319\":1}}],[\"那么i̇2=1\",{\"1\":{\"633\":1}}],[\"那么发生哈希冲突的概率就增加了\",{\"1\":{\"541\":1}}],[\"那么为什么选择了0\",{\"0\":{\"541\":1}}],[\"那么hash值高位是与0做\",{\"1\":{\"535\":1}}],[\"那么直接就获取到锁返回了\",{\"1\":{\"501\":1}}],[\"那么这个线程可以无需阻塞直接获取到锁\",{\"1\":{\"499\":1}}],[\"那么这种重排序并不非法\",{\"1\":{\"320\":1}}],[\"那么问题来了\",{\"1\":{\"480\":1}}],[\"那么可能可以配置较少的线程来处理任务\",{\"1\":{\"453\":1}}],[\"那么可能需要配置更多的线程来处理任务\",{\"1\":{\"453\":1}}],[\"那么可能需要更多的线程来处理任务队列中的任务\",{\"1\":{\"453\":1}}],[\"那么可以通过显式地指定serialversionuid来保持兼容性\",{\"1\":{\"276\":1}}],[\"那么你可能需要配置较多的线程数\",{\"1\":{\"453\":1}}],[\"那么你可能需要配置较少的线程数\",{\"1\":{\"453\":1}}],[\"那么它会一直阻塞\",{\"1\":{\"363\":1}}],[\"那么守护线程和用户线程有什么区别呢\",{\"1\":{\"350\":1}}],[\"那么run方法还是运行在主线程中\",{\"1\":{\"342\":1}}],[\"那么访问这个变量的每个线程都会有这个变量的一个本地拷贝\",{\"1\":{\"326\":1}}],[\"那么线程b中的任意操作\",{\"1\":{\"320\":1}}],[\"那么a线程的threadb\",{\"1\":{\"320\":1}}],[\"那么a\",{\"1\":{\"320\":1}}],[\"那么第一个操作的执行结果将对第二个操作可见\",{\"1\":{\"320\":1}}],[\"那么拷贝后对象\",{\"1\":{\"307\":1}}],[\"那么即使线程不再使用某个threadlocal实例\",{\"1\":{\"331\":1}}],[\"那么即使类的结构发生了变化\",{\"1\":{\"276\":1}}],[\"那么即使外部类不再需要\",{\"1\":{\"125\":1}}],[\"那么序列化和反序列化时可能会出现版本不一致的问题\",{\"1\":{\"276\":1}}],[\"那么自动装箱时不会new新的integer对象\",{\"1\":{\"272\":1}}],[\"那么会生成多个中间对象\",{\"1\":{\"270\":2}}],[\"那么只能加载其中一个版本的类库\",{\"1\":{\"234\":1}}],[\"那么编译器可以将对象的分配优化掉\",{\"1\":{\"170\":1}}],[\"序性保证了程序的执行顺序与代码的顺序一致\",{\"1\":{\"316\":1}}],[\"序列化不包含静态变量\",{\"1\":{\"276\":1}}],[\"序列化\",{\"0\":{\"275\":1},\"1\":{\"276\":1,\"307\":1}}],[\"序列图\",{\"0\":{\"29\":1}}],[\"写完将元素数组指向副本\",{\"1\":{\"522\":1}}],[\"写操作在副本上\",{\"1\":{\"522\":1}}],[\"写操作较少的情况下\",{\"1\":{\"522\":1}}],[\"写时复制\",{\"1\":{\"522\":1}}],[\"写入数据同样判断链表\",{\"1\":{\"549\":1}}],[\"写入变量\",{\"1\":{\"326\":1}}],[\"写入\",{\"1\":{\"326\":1}}],[\"写入和同步操作\",{\"1\":{\"315\":1}}],[\"写缓冲区\",{\"1\":{\"319\":1}}],[\"写共享变量的副本\",{\"1\":{\"315\":1}}],[\"除上述涉及内容外\",{\"1\":{\"644\":1}}],[\"除留取余法\",{\"1\":{\"537\":1}}],[\"除了互斥量本身开销\",{\"1\":{\"491\":1}}],[\"除了原子性\",{\"0\":{\"486\":1}}],[\"除了命令行工具之外\",{\"1\":{\"57\":1}}],[\"除非设置了allowcorethreadtimeout\",{\"1\":{\"448\":1}}],[\"除非必须使用非静态内部类\",{\"1\":{\"313\":1}}],[\"除\",{\"1\":{\"356\":1}}],[\"且任务队列为空\",{\"1\":{\"472\":1}}],[\"且空闲时间超过keepalivetime\",{\"1\":{\"445\":1}}],[\"且当前散列数组中\",{\"1\":{\"334\":1}}],[\"且b\",{\"1\":{\"320\":1}}],[\"且可以直接访问外部类的静态成员\",{\"1\":{\"312\":1}}],[\"且没有任何活动的实例时\",{\"1\":{\"190\":1}}],[\"完全不依赖于网络交换机\",{\"1\":{\"629\":1}}],[\"完全依赖\",{\"1\":{\"627\":2}}],[\"完全拷贝一个对象\",{\"1\":{\"307\":1}}],[\"完整的升级过程\",{\"1\":{\"494\":1}}],[\"完整示例\",{\"0\":{\"392\":1}}],[\"完成sql语句的参数绑定和结果集处理\",{\"1\":{\"656\":1}}],[\"完成的描述所有ied的实例配置和通信参数\",{\"1\":{\"638\":1}}],[\"完成数据采集和监视控制\",{\"1\":{\"628\":1}}],[\"完成\",{\"1\":{\"375\":1}}],[\"完成后\",{\"1\":{\"373\":1}}],[\"完成后才通知\",{\"1\":{\"238\":1}}],[\"完成任务\",{\"1\":{\"355\":13}}],[\"完成对并发标记阶段遗漏对象的标记\",{\"1\":{\"142\":1}}],[\"深拷贝如何实现呢\",{\"1\":{\"307\":1}}],[\"深拷贝是安全的\",{\"1\":{\"307\":1}}],[\"深拷贝\",{\"1\":{\"307\":1}}],[\"深度诊断\",{\"1\":{\"70\":1}}],[\"深度诊断和业务影响分析\",{\"1\":{\"66\":1}}],[\"仅依赖系统的linux内核\",{\"1\":{\"562\":1}}],[\"仅拷贝被拷贝对象的成员变量的值\",{\"1\":{\"307\":1}}],[\"仅包含字符串字面值\",{\"1\":{\"105\":1}}],[\"浅拷贝如何实现呢\",{\"1\":{\"307\":1}}],[\"浅拷贝的话如果有引用类型\",{\"1\":{\"307\":1}}],[\"浅拷贝\",{\"1\":{\"307\":1}}],[\"比数字化变电站更加注重变电站之间\",{\"1\":{\"624\":1}}],[\"比较内存位置\",{\"1\":{\"502\":1}}],[\"比较\",{\"1\":{\"502\":1}}],[\"比较这两个对象\",{\"1\":{\"304\":1}}],[\"比\",{\"1\":{\"495\":1}}],[\"比如关联映射和复杂属性映射\",{\"0\":{\"673\":1}}],[\"比如开发环境\",{\"1\":{\"656\":1}}],[\"比如日志记录\",{\"1\":{\"656\":1}}],[\"比如叫做mn\",{\"1\":{\"578\":1}}],[\"比如dockerhub\",{\"1\":{\"573\":1}}],[\"比如\",{\"1\":{\"566\":1}}],[\"比如在\",{\"1\":{\"563\":1}}],[\"比如ubuntu\",{\"1\":{\"561\":1}}],[\"比如copyonwritearraylist类\",{\"1\":{\"520\":1}}],[\"比如arraylist\",{\"1\":{\"520\":1}}],[\"比如jconsole\",{\"1\":{\"513\":1}}],[\"比如我们需要将纸制银行流水通过人工的方式录入成电子银行流水\",{\"1\":{\"363\":1}}],[\"比如我们熟悉的空指针\",{\"1\":{\"279\":1}}],[\"比如有玩家超时未确认\",{\"1\":{\"353\":1}}],[\"比如垃圾回收线程\",{\"1\":{\"350\":1}}],[\"比如锁还是持有不让出的\",{\"1\":{\"344\":1}}],[\"比如虚拟机异常\",{\"1\":{\"279\":1}}],[\"比如serlvet\",{\"1\":{\"234\":1}}],[\"比如sql查询未做分页\",{\"1\":{\"88\":1}}],[\"比如从网络\",{\"1\":{\"202\":1}}],[\"比如io对象使用完后未调用close方法释放资源\",{\"1\":{\"88\":1}}],[\"⽅法\",{\"1\":{\"304\":1,\"305\":1}}],[\"⽅法名\",{\"1\":{\"301\":3}}],[\"判断tab\",{\"1\":{\"531\":1}}],[\"判断tab是否位空或者长度为0\",{\"1\":{\"531\":1}}],[\"判断是否超过阈值\",{\"1\":{\"531\":1}}],[\"判断是否为可偏向状态\",{\"1\":{\"493\":1}}],[\"判断是否有空闲线程\",{\"1\":{\"458\":1}}],[\"判断两个对象是否相等\",{\"1\":{\"304\":1}}],[\"判断两个对象是不是同⼀个对象\",{\"1\":{\"304\":1}}],[\"判断哪些对象是可达的\",{\"1\":{\"127\":1}}],[\"经采集装置的st7～st10接收\",{\"1\":{\"633\":1}}],[\"经光电转换装置转换成光数字信号进行传输\",{\"1\":{\"632\":1}}],[\"经济\",{\"1\":{\"621\":1,\"622\":1,\"630\":1}}],[\"经常被用在需要释放资源的情况下\",{\"1\":{\"303\":1}}],[\"经过处理\",{\"1\":{\"398\":1}}],[\"经过了编译器的指令重排序\",{\"1\":{\"319\":1}}],[\"经过拼接新生成了string对象\",{\"1\":{\"270\":1}}],[\"经过多次minor\",{\"1\":{\"130\":1}}],[\"必须将数据与容器解耦\",{\"1\":{\"581\":1}}],[\"必须先了解操作系统结构\",{\"1\":{\"561\":1}}],[\"必须把共享变量的最新值刷新到主内存中\",{\"1\":{\"487\":1}}],[\"必须依存于某一实例\",{\"1\":{\"301\":1}}],[\"必须在由程序运⾏期间才能决定\",{\"1\":{\"295\":1}}],[\"随时调整线程池的配置\",{\"1\":{\"476\":1}}],[\"随对象的销毁而销毁\",{\"1\":{\"300\":1}}],[\"随对象的创建而生\",{\"1\":{\"300\":1}}],[\"随着方法或代码块的执行而创建和销毁\",{\"1\":{\"300\":1}}],[\"随着对程序动态性的追求\",{\"1\":{\"224\":1}}],[\"设计了独立于所采用网络和应用层协议的抽象通信服务接口\",{\"1\":{\"636\":1}}],[\"设计层面\",{\"1\":{\"299\":1}}],[\"设备状态可视化等自由组合而成\",{\"1\":{\"630\":1}}],[\"设备集成化\",{\"1\":{\"625\":1}}],[\"设定为3\",{\"1\":{\"358\":1}}],[\"设定可用许可数量为3\",{\"1\":{\"357\":1}}],[\"设置数据库root账户的密码为123\",{\"1\":{\"598\":1}}],[\"设置mysql密码\",{\"1\":{\"587\":1}}],[\"设置线程的\",{\"1\":{\"464\":1}}],[\"设置当前线程的上下文类加载器为自定义类加载器\",{\"1\":{\"220\":1}}],[\"设置每个region的大小\",{\"1\":{\"144\":1}}],[\"设置在进行混合回收之前\",{\"1\":{\"144\":1}}],[\"设置目标最大gc停顿时间\",{\"1\":{\"144\":1,\"159\":1}}],[\"设置对象头\",{\"1\":{\"117\":1}}],[\"设置基准线\",{\"0\":{\"79\":1}}],[\"设置系统属性\",{\"1\":{\"76\":1}}],[\"设置内联方法的最大字节码大小\",{\"1\":{\"74\":1}}],[\"设置触发垃圾回收的堆内存占用阈值\",{\"1\":{\"73\":1}}],[\"设置用于并发标记\",{\"1\":{\"73\":1}}],[\"设置用于并行垃圾回收的线程数\",{\"1\":{\"73\":1}}],[\"设置最大元空间大小\",{\"1\":{\"72\":1}}],[\"设置最大永久代大小\",{\"1\":{\"72\":1}}],[\"设置初始元空间大小\",{\"1\":{\"72\":1}}],[\"设置初始永久代大小\",{\"1\":{\"72\":1}}],[\"设置年轻代大小\",{\"1\":{\"72\":1}}],[\"设置jvm最大内存堆大小\",{\"1\":{\"72\":1}}],[\"设置jvm初始化内存堆大小\",{\"1\":{\"72\":1}}],[\"设置协议\",{\"1\":{\"11\":1}}],[\"设置应用描述\",{\"1\":{\"11\":1}}],[\"设置应用版本号\",{\"1\":{\"11\":1}}],[\"设置应用名称\",{\"1\":{\"11\":1}}],[\"抽象同步队列\",{\"1\":{\"496\":1}}],[\"抽象方法\",{\"1\":{\"496\":2}}],[\"抽象方法是为了被重写\",{\"1\":{\"299\":1}}],[\"抽象方法可以有public\",{\"1\":{\"299\":1}}],[\"抽象类是对类的抽象\",{\"1\":{\"299\":1}}],[\"抽象类\",{\"0\":{\"299\":1}}],[\"普通的二叉搜索树在最坏情况下可能会退化成链表\",{\"1\":{\"528\":1}}],[\"普通的直接引用\",{\"1\":{\"298\":1}}],[\"普通的对象引用赋值\",{\"1\":{\"128\":1}}],[\"指的是什么\",{\"0\":{\"628\":1,\"629\":1}}],[\"指线程获取到的资源在自己使用完之前不能被其它线程抢占\",{\"1\":{\"512\":1}}],[\"指线程对己经获取到的资源进行排它性使用\",{\"1\":{\"512\":1}}],[\"指一个\",{\"1\":{\"512\":1}}],[\"指向宿主机文件系统中的某个目录\",{\"1\":{\"582\":1}}],[\"指向持有objectmonitor对象的线程\",{\"1\":{\"485\":1}}],[\"指向对象本身的一个指针\",{\"1\":{\"298\":1}}],[\"指定基础镜像\",{\"1\":{\"592\":1}}],[\"指定端口映射\",{\"1\":{\"580\":1}}],[\"指定容器名称\",{\"1\":{\"580\":1}}],[\"指定加锁对象\",{\"1\":{\"482\":1}}],[\"指定自定义线程池\",{\"0\":{\"389\":1}}],[\"指定的睡眠时间到了后该函数会正常返回\",{\"1\":{\"344\":1}}],[\"指令则指向同步代码块的结束位置\",{\"1\":{\"484\":1}}],[\"指令指向同步代码块的开始位置\",{\"1\":{\"484\":1}}],[\"指令重排也是有一些限制的\",{\"1\":{\"320\":1}}],[\"指令重排有限制吗\",{\"0\":{\"320\":1}}],[\"指令级并行的重排序\",{\"1\":{\"319\":1}}],[\"指针碰撞适用于内存连续的情况\",{\"1\":{\"118\":1}}],[\"指针碰撞适用于\",{\"1\":{\"118\":1}}],[\"指针碰撞\",{\"1\":{\"118\":2}}],[\"变电站通信网络和系统标准iec61850\",{\"0\":{\"647\":1}}],[\"变电站通信网络和系统协议iec61850标准草案提出了变电站内信息分层的概念\",{\"1\":{\"636\":1}}],[\"变电站与调度中心之间的信息的统一与功能的层次化\",{\"1\":{\"624\":1}}],[\"变成无锁状态\",{\"1\":{\"493\":1}}],[\"变量\",{\"1\":{\"297\":2,\"299\":2,\"520\":1}}],[\"变为堆的一部分\",{\"1\":{\"95\":1}}],[\"若为引用数据类型则返回值为被重写方法的返回值或是其子类\",{\"1\":{\"296\":1}}],[\"若达到阀值就会执行\",{\"1\":{\"89\":1}}],[\"参考课前资料\",{\"1\":{\"596\":1,\"603\":1}}],[\"参考课前资料中的文档\",{\"1\":{\"569\":1}}],[\"参考资料\",{\"1\":{\"9\":1}}],[\"参与协作的线程数\",{\"1\":{\"356\":1}}],[\"参数映射\",{\"1\":{\"656\":2}}],[\"参数挂载文件或目录到容器中\",{\"1\":{\"588\":1}}],[\"参数挂载数据卷\",{\"1\":{\"586\":1}}],[\"参数来挂载一个数据卷到某个容器内目录\",{\"1\":{\"585\":1}}],[\"参数可以持续查看日志\",{\"1\":{\"580\":1}}],[\"参数顺序满足任一\",{\"1\":{\"296\":1}}],[\"参数类型以及与java对象属性之间的对应关系\",{\"1\":{\"656\":1}}],[\"参数类型\",{\"1\":{\"296\":1,\"451\":1,\"656\":1}}],[\"参数个数\",{\"1\":{\"296\":1}}],[\"⽽是在程序运⾏期间才确定\",{\"1\":{\"295\":1}}],[\"面向通用对象的变电站事件服务goose功能\",{\"0\":{\"653\":1}}],[\"面向通用对象的变电站事件服务goose以及采样服务sv\",{\"1\":{\"651\":1}}],[\"面向过程就是分析出解决问题所需要的步骤\",{\"1\":{\"294\":1}}],[\"面向对象的数据自描述在数据源就对数据本身进行自我描述\",{\"1\":{\"636\":1}}],[\"面向对象有哪些特性\",{\"0\":{\"295\":1}}],[\"面向对象\",{\"0\":{\"293\":1},\"1\":{\"246\":1,\"294\":1}}],[\"⾯向对象\",{\"1\":{\"294\":1}}],[\"⾯向对象和⾯向过程的区别\",{\"0\":{\"294\":1}}],[\"⾯向过程\",{\"1\":{\"294\":1}}],[\"保护测量类数据的上送功能通过无缓冲报告控制块\",{\"1\":{\"652\":1}}],[\"保护跳闸也是通过本间隔的goose跳闸网络即直跳网络直接出口不再通过网络交换机\",{\"1\":{\"629\":1}}],[\"保护装置的电流\",{\"1\":{\"629\":1}}],[\"保护信息管理等相关功能\",{\"1\":{\"628\":1}}],[\"保护及自动装置的独立性\",{\"1\":{\"627\":1}}],[\"保护\",{\"1\":{\"623\":1}}],[\"保护系统中的任何应用\",{\"1\":{\"563\":1}}],[\"保存的目标文件名称\",{\"1\":{\"574\":1}}],[\"保存\",{\"0\":{\"574\":1}}],[\"保留整数倍以下的数据\",{\"1\":{\"535\":1}}],[\"保留的是hash值的地位特征\",{\"1\":{\"534\":1}}],[\"保障系统的性能和稳定性\",{\"1\":{\"476\":1}}],[\"保持插入顺序或访问顺序\",{\"1\":{\"291\":1}}],[\"保证数据安全\",{\"1\":{\"584\":1}}],[\"保证一定获取锁成功\",{\"1\":{\"548\":1}}],[\"保证极端情况下的查找效率\",{\"1\":{\"539\":1}}],[\"保证的是对一个变量执行操作的原子性\",{\"1\":{\"508\":1}}],[\"保证可见性和有序性\",{\"1\":{\"322\":1}}],[\"保证了树的相对平衡\",{\"1\":{\"529\":1}}],[\"保证了操作的最坏时间复杂度为o\",{\"1\":{\"528\":1}}],[\"保证了可见性\",{\"1\":{\"522\":1}}],[\"保证了变量在多线程之间的可见性\",{\"1\":{\"496\":1}}],[\"保证了java平台的安全性\",{\"1\":{\"213\":1}}],[\"保证了类的唯一性和一致性\",{\"1\":{\"209\":1}}],[\"保证了类的类型一致性\",{\"1\":{\"207\":1}}],[\"保证某个类只会被加载一次\",{\"1\":{\"207\":1}}],[\"保证导出的请求不会一直打到服务端\",{\"1\":{\"84\":1}}],[\"永久保存\",{\"1\":{\"289\":1}}],[\"永久代是java\",{\"1\":{\"130\":1}}],[\"永久代可能会填满\",{\"1\":{\"113\":1}}],[\"永久代的设计可能导致某些方法在不同jvm下表现不同\",{\"1\":{\"113\":1}}],[\"永久代的大小在jvm启动时设定\",{\"1\":{\"113\":1}}],[\"永久代的限制\",{\"1\":{\"113\":1}}],[\"永久代完全移除\",{\"1\":{\"101\":1}}],[\"永久代被元空间\",{\"1\":{\"130\":1}}],[\"永久代被完全废弃\",{\"1\":{\"114\":1}}],[\"永久代被完全移除\",{\"1\":{\"96\":1}}],[\"永久代被移除\",{\"1\":{\"98\":1}}],[\"永久代用于存储类元数据\",{\"1\":{\"98\":1}}],[\"永久代逐步移除\",{\"1\":{\"95\":1}}],[\"永久代\",{\"0\":{\"98\":1},\"1\":{\"81\":1,\"130\":1}}],[\"没找到\",{\"1\":{\"289\":1}}],[\"没有因为电磁感应所造成的各种问题\",{\"1\":{\"632\":1}}],[\"没有所谓的非空闲时间\",{\"1\":{\"457\":1}}],[\"没有取到才会创建新的对象\",{\"1\":{\"272\":1}}],[\"没有规定方法区的数据存储格式\",{\"1\":{\"195\":1}}],[\"没有逃逸出方法的作用域\",{\"1\":{\"165\":1}}],[\"没有在使用完毕后及时关闭\",{\"1\":{\"125\":1}}],[\"没有的话随便修改下master分支代码\",{\"1\":{\"21\":1}}],[\"属性上等\",{\"1\":{\"289\":1}}],[\"代替hashmap\",{\"1\":{\"546\":1}}],[\"代表一个映射的语句\",{\"1\":{\"656\":1}}],[\"代表5\",{\"1\":{\"571\":1}}],[\"代表最新版本的镜像\",{\"1\":{\"571\":1}}],[\"代表非公平锁\",{\"1\":{\"501\":1}}],[\"代表公平锁和非公平锁\",{\"1\":{\"501\":1}}],[\"代表公平锁\",{\"1\":{\"501\":1}}],[\"代表\",{\"1\":{\"286\":1}}],[\"代码的方式来动态地拼接\",{\"1\":{\"656\":1}}],[\"代码的执行顺序可能与代码的编写顺序不一致\",{\"1\":{\"316\":1}}],[\"代码是单线程执行的\",{\"1\":{\"488\":1}}],[\"代码示例\",{\"0\":{\"361\":1,\"424\":1,\"428\":1,\"432\":1,\"436\":1,\"440\":1}}],[\"代码复\",{\"1\":{\"343\":1}}],[\"代码缓存区用于存放编译后的本地代码\",{\"1\":{\"130\":1}}],[\"代码缓存区\",{\"1\":{\"130\":1}}],[\"代码显式调用gc方法比较容易排查\",{\"1\":{\"88\":1}}],[\"代码中\",{\"1\":{\"88\":1}}],[\"键值中的\",{\"1\":{\"286\":1}}],[\"k×i̇1\",{\"1\":{\"633\":1}}],[\"keepalive\",{\"1\":{\"460\":1}}],[\"keepalivetime默认是10\",{\"1\":{\"460\":1}}],[\"keepalivetime为0\",{\"1\":{\"459\":1}}],[\"keepalivetime单位\",{\"1\":{\"409\":1}}],[\"keepalivetime\",{\"1\":{\"408\":1,\"409\":1,\"442\":2,\"448\":1,\"463\":2}}],[\"key通过hash定位到segment\",{\"1\":{\"548\":1}}],[\"key设计成弱引用同样是为了防止内存泄漏问题\",{\"1\":{\"331\":1}}],[\"key是threadlocal的弱引用\",{\"1\":{\"328\":1}}],[\"key\",{\"1\":{\"286\":2,\"329\":1,\"332\":1,\"531\":12,\"532\":13,\"537\":4,\"549\":2,\"552\":1,\"554\":1}}],[\"k\",{\"1\":{\"286\":1,\"334\":3,\"531\":6,\"532\":6}}],[\"kit\",{\"1\":{\"247\":1}}],[\"kibana提供丰富的可视化支持\",{\"1\":{\"64\":1,\"70\":1}}],[\"泛型信息会被擦除\",{\"1\":{\"287\":1}}],[\"泛型主要是为了提供编译时类型检查\",{\"1\":{\"287\":1}}],[\"泛型常用的通配符有哪些\",{\"0\":{\"286\":1}}],[\"泛型方法\",{\"1\":{\"285\":1}}],[\"泛型接口\",{\"1\":{\"285\":1}}],[\"泛型类\",{\"1\":{\"285\":1}}],[\"泛型的使用方法\",{\"0\":{\"285\":1}}],[\"泛型\",{\"0\":{\"283\":1}}],[\"了多少个对象\",{\"1\":{\"482\":1}}],[\"了\",{\"1\":{\"282\":2,\"303\":1}}],[\"了解iec61850规约\",{\"1\":{\"651\":1}}],[\"了解这些步骤有助于理解线程池如何管理线程和任务\",{\"1\":{\"441\":1}}],[\"了解这些情况可以帮助开发者更好地调优java应用程序的内存配置和性能\",{\"1\":{\"135\":1}}],[\"了解吗\",{\"0\":{\"353\":1,\"354\":1,\"357\":1,\"360\":1,\"520\":1}}],[\"了解jvm的参数设置\",{\"1\":{\"88\":1}}],[\"了解该时间点之前有没有程序上线\",{\"1\":{\"88\":1}}],[\"了解应用程序的特性\",{\"1\":{\"78\":1}}],[\"了解哪些可视化的性能监控和故障处理工具\",{\"0\":{\"57\":1}}],[\"按\",{\"1\":{\"618\":1}}],[\"按钮\",{\"1\":{\"513\":1}}],[\"按finally中return的为准\",{\"1\":{\"282\":1}}],[\"按照键的自然顺序或自定义顺序进行排序\",{\"1\":{\"291\":1}}],[\"按照流的角色划分为\",{\"1\":{\"236\":1}}],[\"按照流的流向分\",{\"1\":{\"236\":1}}],[\"按照操作单元划分\",{\"1\":{\"236\":1}}],[\"按照以下步骤处理\",{\"1\":{\"206\":1}}],[\"题目3\",{\"1\":{\"282\":1}}],[\"题目2\",{\"1\":{\"282\":1}}],[\"题目1\",{\"1\":{\"282\":1}}],[\"语法\",{\"1\":{\"587\":1}}],[\"语法形式\",{\"1\":{\"300\":1}}],[\"语句的方式\",{\"1\":{\"656\":2}}],[\"语句和distinct哪个先执行\",{\"0\":{\"615\":1}}],[\"语句\",{\"1\":{\"344\":1,\"351\":1,\"656\":5}}],[\"语句中\",{\"1\":{\"303\":1}}],[\"语句块来完成\",{\"1\":{\"495\":1}}],[\"语句块\",{\"1\":{\"282\":1}}],[\"语言\",{\"0\":{\"250\":1}}],[\"三网\",{\"1\":{\"628\":1}}],[\"三网合一\",{\"1\":{\"627\":4}}],[\"三层两网\",{\"1\":{\"644\":1}}],[\"三层\",{\"1\":{\"628\":1}}],[\"三层三网\",{\"0\":{\"628\":1},\"1\":{\"628\":1}}],[\"三步操作了\",{\"1\":{\"317\":1}}],[\"三道经典异常处理代码题\",{\"0\":{\"282\":1}}],[\"三分钟搭建一个博客网站\",{\"0\":{\"7\":1,\"8\":1}}],[\"抛出异常\",{\"1\":{\"280\":1}}],[\"抛出classnotfoundexception\",{\"1\":{\"206\":1}}],[\"异或操作使得低位的特征影响到高位\",{\"1\":{\"533\":1}}],[\"异步调用\",{\"1\":{\"479\":1}}],[\"异步任务执行\",{\"0\":{\"433\":1}}],[\"异步任务链中的线程池\",{\"0\":{\"398\":1}}],[\"异步任务完成\",{\"1\":{\"392\":1}}],[\"异步任务逻辑\",{\"1\":{\"388\":1,\"391\":1}}],[\"异步非阻塞io\",{\"1\":{\"238\":1}}],[\"异常的处理机制\",{\"0\":{\"280\":1}}],[\"异常处理后的默认值\",{\"1\":{\"378\":1}}],[\"异常处理\",{\"0\":{\"278\":1},\"1\":{\"355\":1,\"451\":1}}],[\"版本控制\",{\"1\":{\"276\":1}}],[\"又称罗氏线圈式电流互感器\",{\"1\":{\"635\":1}}],[\"又有什么用\",{\"1\":{\"276\":1}}],[\"又一次破坏了双亲委派模型\",{\"1\":{\"224\":1}}],[\"方式相比\",{\"0\":{\"727\":1,\"747\":1}}],[\"方式合并单元网络图\",{\"1\":{\"640\":1}}],[\"方式的变电站较网络采集网络跳闸方式有更强的独立性\",{\"1\":{\"629\":1}}],[\"方式\",{\"1\":{\"627\":2}}],[\"方便操作其中的内容\",{\"1\":{\"586\":1}}],[\"方便操作容器内数据\",{\"1\":{\"584\":1}}],[\"方便快捷\",{\"1\":{\"562\":1}}],[\"方便哈希取余\",{\"1\":{\"535\":1}}],[\"方便\",{\"1\":{\"343\":1}}],[\"方便存储和传输\",{\"1\":{\"276\":1}}],[\"方法结合实现等待\",{\"1\":{\"495\":1}}],[\"方法配合try\",{\"1\":{\"495\":1}}],[\"方法开始执行任务\",{\"1\":{\"480\":1}}],[\"方法中\",{\"1\":{\"480\":3,\"501\":1}}],[\"方法中调用父类加载器的\",{\"1\":{\"233\":1}}],[\"方法不会立即停止线程池\",{\"1\":{\"452\":1}}],[\"方法用于立即关闭线程池\",{\"1\":{\"452\":1}}],[\"方法用于平缓地关闭线程池\",{\"1\":{\"452\":1}}],[\"方法用于提交不需要返回结果的任务\",{\"1\":{\"451\":1}}],[\"方法或scheduleatfixedrate\",{\"1\":{\"455\":1}}],[\"方法或shutdownnow\",{\"1\":{\"452\":2}}],[\"方法或locksupport\",{\"1\":{\"346\":1}}],[\"方法则更加灵活\",{\"1\":{\"451\":1}}],[\"方法则会唤醒所有在该共享变量上由于调用\",{\"1\":{\"344\":1}}],[\"方法除了接受runnable接口类型的任务外\",{\"1\":{\"451\":1}}],[\"方法接受runnable接口类型的任务作为参数\",{\"1\":{\"451\":1}}],[\"方法无法处理任务执行过程中抛出的异常\",{\"1\":{\"451\":1}}],[\"方法更加灵活\",{\"1\":{\"451\":1}}],[\"方法返回一个future对象\",{\"1\":{\"451\":1}}],[\"方法返回值等\",{\"1\":{\"94\":1}}],[\"方法没有返回值\",{\"1\":{\"451\":1}}],[\"方法都用于向线程池提交任务\",{\"1\":{\"451\":1}}],[\"方法关闭\",{\"1\":{\"446\":1}}],[\"方法提交给线程池执行\",{\"1\":{\"480\":1}}],[\"方法提交第一个子任务给线程池执行\",{\"1\":{\"480\":1}}],[\"方法提交定时任务或周期性任务\",{\"1\":{\"455\":1}}],[\"方法提交的任务没有返回值\",{\"1\":{\"443\":1}}],[\"方法提交到线程池\",{\"1\":{\"443\":1}}],[\"方法提供了一个在对象被垃圾回收之前进行一些清理操作的机会\",{\"1\":{\"129\":1}}],[\"方法有带超时参数的重载形式\",{\"1\":{\"363\":1}}],[\"方法响应中断\",{\"1\":{\"359\":1}}],[\"方法模拟了汽车进入停车场\",{\"1\":{\"358\":1}}],[\"方法之外\",{\"1\":{\"351\":1}}],[\"方法主动放弃\",{\"1\":{\"349\":1}}],[\"方法后\",{\"1\":{\"344\":1,\"452\":3}}],[\"方法唤醒它\",{\"1\":{\"344\":2}}],[\"方法多了一个超时参数\",{\"1\":{\"344\":1}}],[\"方法时\",{\"1\":{\"344\":2,\"451\":1,\"470\":1,\"471\":1}}],[\"方法时会执行run\",{\"0\":{\"342\":1}}],[\"方法启动线程\",{\"1\":{\"341\":1}}],[\"方法释放内存空间\",{\"1\":{\"330\":1}}],[\"方法判断相等\",{\"1\":{\"305\":1}}],[\"方法只会被调用一次\",{\"1\":{\"303\":1}}],[\"方法和类\",{\"1\":{\"303\":1}}],[\"方法修饰符\",{\"1\":{\"299\":1}}],[\"方法实现\",{\"1\":{\"299\":1,\"495\":1}}],[\"方法重写\",{\"1\":{\"296\":1}}],[\"方法重载\",{\"1\":{\"296\":1}}],[\"方法重载和方法重写都是实现多态性的方式\",{\"1\":{\"296\":1}}],[\"方法上\",{\"1\":{\"289\":1}}],[\"方法会尝试中断正在执行的任务\",{\"1\":{\"452\":1}}],[\"方法会终止java虚拟机的运行\",{\"1\":{\"281\":1}}],[\"方法会无限递归调用自身\",{\"1\":{\"124\":1}}],[\"方法为true\",{\"1\":{\"271\":1}}],[\"方法通常用于直接加载类的字节码\",{\"1\":{\"233\":1}}],[\"方法通常用于完全掌控类的加载过程\",{\"1\":{\"233\":1}}],[\"方法通常用于继承父类加载器的双亲委派行为\",{\"1\":{\"233\":1}}],[\"方法可以安全地关闭线程池\",{\"1\":{\"452\":1}}],[\"方法可以通过future对象来捕获任务执行过程中抛出的异常\",{\"1\":{\"451\":1}}],[\"方法可以返回一个future对象\",{\"1\":{\"443\":1}}],[\"方法可以非常简单地实现对象的浅拷贝\",{\"1\":{\"307\":1}}],[\"方法可以直接加载类的字节码\",{\"1\":{\"233\":1}}],[\"方法可以绕过双亲委派模型\",{\"1\":{\"233\":1}}],[\"方法可手动将字符串添加到池中\",{\"1\":{\"105\":1}}],[\"方法加载类\",{\"1\":{\"228\":1}}],[\"方法将hashmap包装成线程安全的map\",{\"1\":{\"546\":1}}],[\"方法将类的字节码加载到内存中\",{\"1\":{\"228\":1}}],[\"方法将字符串添加到字符串常量池中\",{\"1\":{\"103\":1}}],[\"方法信息\",{\"1\":{\"195\":1}}],[\"方法信息等\",{\"1\":{\"98\":1}}],[\"方法调用\",{\"1\":{\"189\":1}}],[\"方法调用之后\",{\"1\":{\"138\":1}}],[\"方法是\",{\"1\":{\"480\":1}}],[\"方法是由编译器自动生成的类构造器\",{\"1\":{\"188\":1}}],[\"方法是java中的一个特殊方法\",{\"1\":{\"129\":1}}],[\"方法名相同\",{\"1\":{\"296\":2}}],[\"方法名\",{\"1\":{\"187\":1}}],[\"方法来定义具体的任务逻辑\",{\"1\":{\"480\":1}}],[\"方法来修改核心线程数\",{\"1\":{\"475\":1}}],[\"方法来处理线程执行完毕后的异常\",{\"1\":{\"463\":1}}],[\"方法来检查线程池是否已经关闭\",{\"1\":{\"452\":1}}],[\"方法来等待线程池关闭\",{\"1\":{\"452\":1}}],[\"方法来实现\",{\"1\":{\"452\":1}}],[\"方法来设置线程的中断标志为true\",{\"1\":{\"344\":1}}],[\"方法来加载类\",{\"1\":{\"233\":1}}],[\"方法来委派加载类\",{\"1\":{\"233\":1}}],[\"方法来进行资源释放和清理操作\",{\"1\":{\"129\":1}}],[\"方法来执行重要的清理工作\",{\"1\":{\"129\":1}}],[\"方法存在一些缺点\",{\"1\":{\"129\":1}}],[\"方法的重载版本来指定自定义的线程池\",{\"1\":{\"389\":1}}],[\"方法的最后\",{\"1\":{\"334\":1}}],[\"方法的返回值必须相等\",{\"1\":{\"305\":1}}],[\"方法的过程\",{\"1\":{\"188\":1}}],[\"方法的时间是不确定的\",{\"1\":{\"129\":1}}],[\"方法的符号引用\",{\"1\":{\"107\":1}}],[\"方法被用来实现对象在被垃圾回收之前\",{\"1\":{\"129\":1}}],[\"方法签名\",{\"1\":{\"129\":1}}],[\"方法了解吗\",{\"0\":{\"129\":1}}],[\"方法在处理字符串常量池时可能表现出不同的性能和行为\",{\"1\":{\"113\":1}}],[\"方法行为不一致\",{\"1\":{\"113\":1}}],[\"方法引用等\",{\"1\":{\"104\":1,\"105\":1}}],[\"方法代码等\",{\"1\":{\"193\":1}}],[\"方法代码\",{\"1\":{\"94\":1}}],[\"方法出口等信息\",{\"1\":{\"92\":1}}],[\"方法区是jvm中用于存储类结构信息的内存区域\",{\"1\":{\"193\":1}}],[\"方法区内存空间不足\",{\"1\":{\"135\":1}}],[\"方法区中的数据存储格式完全由虚拟机实现自行定义\",{\"1\":{\"196\":1}}],[\"方法区中的常量引用的对象\",{\"1\":{\"127\":1}}],[\"方法区中的常量引用\",{\"1\":{\"127\":1}}],[\"方法区中的静态变量引用的对象\",{\"1\":{\"127\":1}}],[\"方法区中的静态引用\",{\"1\":{\"127\":1}}],[\"方法区\",{\"1\":{\"92\":1,\"94\":1}}],[\"方法\",{\"0\":{\"342\":2},\"1\":{\"88\":1,\"129\":1,\"215\":1,\"222\":2,\"233\":9,\"273\":2,\"281\":1,\"297\":4,\"303\":1,\"341\":3,\"342\":2,\"344\":3,\"345\":1,\"346\":2,\"355\":1,\"356\":1,\"358\":2,\"359\":1,\"362\":3,\"452\":2,\"454\":1,\"480\":2,\"485\":1,\"501\":1,\"656\":1}}],[\"方法等待子任务的完成并合并结果\",{\"1\":{\"480\":1}}],[\"方法等待第一个子任务的执行结果\",{\"1\":{\"480\":1}}],[\"方法等信息\",{\"1\":{\"256\":1}}],[\"方法等\",{\"1\":{\"56\":1,\"276\":1}}],[\"把html数据卷挂载到容器内的\",{\"1\":{\"585\":1}}],[\"把冲突的元素放进去\",{\"1\":{\"538\":2}}],[\"把这些小任务放到不同的队列里\",{\"1\":{\"480\":1}}],[\"把任务添加到linkedblockingqueue阻塞队列\",{\"1\":{\"457\":1}}],[\"把元素放到空的槽中\",{\"1\":{\"333\":1}}],[\"把构成问题的事务分解成各个对象\",{\"1\":{\"294\":1}}],[\"把二进制流恢复成对象\",{\"1\":{\"276\":1}}],[\"把java对象转为二进制流\",{\"1\":{\"276\":1}}],[\"把一个表数范围小的数值或变量直接赋给另一个数范围大的变量时\",{\"1\":{\"259\":1}}],[\"到底如何做呢\",{\"1\":{\"512\":1}}],[\"到该列表\",{\"1\":{\"485\":1}}],[\"到期任务是指scheduledfuturetask的time大于等于当前时间\",{\"1\":{\"460\":1}}],[\"到\",{\"1\":{\"272\":1}}],[\"搞了个缓存池\",{\"1\":{\"272\":1}}],[\"超过则扩容\",{\"1\":{\"531\":1}}],[\"超过一定次数\",{\"1\":{\"507\":1}}],[\"超过范围\",{\"1\":{\"272\":1}}],[\"超时默认值\",{\"1\":{\"381\":1}}],[\"超时控制\",{\"0\":{\"379\":1}}],[\"超时机制\",{\"1\":{\"363\":1,\"479\":2,\"512\":1}}],[\"超时等问题时\",{\"1\":{\"356\":1}}],[\"超时等待状态\",{\"1\":{\"345\":1}}],[\"超低停顿时间\",{\"1\":{\"154\":1}}],[\"号拼接会编译成stringbuilder的append方法\",{\"1\":{\"270\":1}}],[\"两者有什么差异呢\",{\"1\":{\"563\":1}}],[\"两者都是\",{\"1\":{\"501\":1}}],[\"两者性能就差不多了\",{\"1\":{\"495\":1}}],[\"两种集合都需要遍历\",{\"1\":{\"515\":1}}],[\"两种情况\",{\"1\":{\"493\":1}}],[\"两种方法来确定对象是否可以被回收\",{\"1\":{\"126\":1}}],[\"两种方式的选择由java堆是否规整决定\",{\"1\":{\"118\":1}}],[\"两步操作\",{\"1\":{\"317\":1}}],[\"两个指令来实现同步\",{\"1\":{\"484\":1}}],[\"两个线程可以交换数据\",{\"1\":{\"362\":1}}],[\"两个线程互相传递数据或资源\",{\"1\":{\"360\":1}}],[\"两个线程需要在某个点交换数据\",{\"1\":{\"360\":1}}],[\"两个线程都执行了\",{\"1\":{\"339\":1}}],[\"两个线程都在执行\",{\"1\":{\"339\":1}}],[\"两个具备超时特性的方法\",{\"1\":{\"351\":1}}],[\"两个操作之间存在happens\",{\"1\":{\"320\":1}}],[\"两个\",{\"1\":{\"269\":1}}],[\"两个语句都会去字符串常量池中检查是否已经存在\",{\"1\":{\"269\":1}}],[\"影响性能\",{\"1\":{\"268\":1}}],[\"影响系统的响应性能\",{\"1\":{\"87\":1}}],[\"高准确度测量高达短路电流的过电流\",{\"1\":{\"635\":1}}],[\"高级应用功能有自我监测\",{\"1\":{\"630\":1}}],[\"高效\",{\"1\":{\"621\":1}}],[\"高位补0\",{\"1\":{\"535\":1}}],[\"高位\",{\"1\":{\"533\":1}}],[\"高\",{\"1\":{\"268\":1}}],[\"高吞吐量应用\",{\"1\":{\"158\":1,\"159\":1}}],[\"高吞吐量\",{\"1\":{\"158\":1}}],[\"减轻了设备重量\",{\"1\":{\"632\":1,\"633\":1}}],[\"减\",{\"1\":{\"265\":2}}],[\"减少碰撞的概率\",{\"1\":{\"543\":1}}],[\"减少不必要的cpu上下文切换\",{\"1\":{\"491\":1}}],[\"减少操作系统互斥量带来的性能消耗\",{\"1\":{\"491\":1}}],[\"减少其执行时间\",{\"1\":{\"479\":1}}],[\"减少线程间的竞争\",{\"1\":{\"453\":1}}],[\"减少连接创建和销毁的开销\",{\"1\":{\"427\":1}}],[\"减少\",{\"1\":{\"244\":1}}],[\"减少锁开销\",{\"1\":{\"167\":1}}],[\"减少停顿时间\",{\"1\":{\"159\":1}}],[\"减少手动调优的复杂性\",{\"1\":{\"153\":1}}],[\"减少内存碎片\",{\"1\":{\"153\":1}}],[\"减少内存碎片化\",{\"1\":{\"151\":1}}],[\"减少垃圾收集的停顿时间\",{\"1\":{\"148\":1}}],[\"减少碎片化\",{\"1\":{\"148\":1}}],[\"减少full\",{\"1\":{\"116\":1}}],[\"减少了采样回路的中间环节\",{\"1\":{\"633\":1}}],[\"减少了绝缘油及yh等电压转换装置\",{\"1\":{\"632\":1}}],[\"减少了人为参与的因素\",{\"1\":{\"630\":1}}],[\"减少了各个高级应用模块之间的通信环节\",{\"1\":{\"630\":1}}],[\"减少了扩容操作的时间和资源消耗\",{\"1\":{\"543\":1}}],[\"减少了相同低位的哈希值导致相同索引位置的情况\",{\"1\":{\"533\":1}}],[\"减少了频繁创建和销毁线程的开销\",{\"1\":{\"404\":1}}],[\"减少了不必要的内存开销\",{\"1\":{\"309\":1}}],[\"减少了gc的负担\",{\"1\":{\"167\":1}}],[\"减少了堆内存的分配和垃圾收集\",{\"1\":{\"167\":1}}],[\"减少了对垃圾收集器的复杂调优需求\",{\"1\":{\"154\":1}}],[\"减少了手动调优的复杂性\",{\"1\":{\"148\":1}}],[\"减少了full\",{\"1\":{\"115\":1}}],[\"减少了因类加载过多而导致的内存不足问题\",{\"1\":{\"115\":1}}],[\"减少配置复杂性\",{\"1\":{\"115\":1}}],[\"减少outofmemoryerror的发生\",{\"1\":{\"101\":1,\"116\":1}}],[\"减少对象的内存占用\",{\"1\":{\"87\":1}}],[\"继电保护装置将跳闸命令数字信号传送给智能终端装置\",{\"1\":{\"639\":1}}],[\"继电保护采样跳闸\",{\"1\":{\"627\":2}}],[\"继续处理已提交和队列中的任务\",{\"1\":{\"470\":1}}],[\"继续等待新的任务\",{\"1\":{\"454\":1}}],[\"继续执行第2步\",{\"1\":{\"502\":1}}],[\"继续执行\",{\"1\":{\"457\":1}}],[\"继续执行后续任务\",{\"1\":{\"355\":15}}],[\"继续执行下次循环\",{\"1\":{\"263\":1}}],[\"继承关\",{\"1\":{\"343\":1}}],[\"继承thread类\",{\"1\":{\"341\":2}}],[\"继承是使⽤已存在的类的定义作为基础创建新的类\",{\"1\":{\"295\":1}}],[\"继承\",{\"1\":{\"246\":1,\"295\":2}}],[\"跳出本次循环\",{\"1\":{\"263\":1}}],[\"跳出整个循环\",{\"1\":{\"263\":1}}],[\"逻辑设备模型\",{\"1\":{\"636\":1}}],[\"逻辑设备包含逻辑节点\",{\"1\":{\"636\":1}}],[\"逻辑节点模型\",{\"1\":{\"636\":1}}],[\"逻辑节点名\",{\"1\":{\"636\":1}}],[\"逻辑节点包含数据对象\",{\"1\":{\"636\":1}}],[\"逻辑\",{\"1\":{\"334\":1}}],[\"逻辑与\",{\"1\":{\"261\":1}}],[\"逻辑上属于方法区\",{\"1\":{\"99\":1,\"100\":1}}],[\"短路与\",{\"1\":{\"261\":1}}],[\"装置具有数据扩展作用\",{\"1\":{\"640\":1}}],[\"装置具有电压切换及并列功能\",{\"1\":{\"640\":1}}],[\"装置具有规约转换功能\",{\"1\":{\"640\":1}}],[\"装置能够对电子式电流\",{\"1\":{\"640\":1}}],[\"装置是智能变电站二次系统的核心设备之一\",{\"1\":{\"640\":1}}],[\"装置有什么作用\",{\"0\":{\"640\":1}}],[\"装箱\",{\"1\":{\"260\":1}}],[\"装入dump\",{\"1\":{\"89\":1}}],[\"封箱\",{\"0\":{\"260\":1}}],[\"封装了sql语句及其参数\",{\"1\":{\"656\":1}}],[\"封装把⼀个对象的属性私有化\",{\"1\":{\"295\":1}}],[\"封装\",{\"1\":{\"246\":1,\"295\":1}}],[\"位虚拟机\",{\"1\":{\"490\":1}}],[\"位运算\",{\"1\":{\"264\":1}}],[\"位数\",{\"1\":{\"258\":1}}],[\"位置\",{\"1\":{\"103\":1,\"104\":1,\"105\":1,\"641\":2}}],[\"布尔型默认为false\",{\"1\":{\"300\":1}}],[\"布尔型\",{\"1\":{\"258\":1}}],[\"浮点类型\",{\"1\":{\"258\":1}}],[\"浮点数\",{\"1\":{\"104\":1,\"107\":1}}],[\"接下来需要将我们的每个微服务都打包\",{\"1\":{\"600\":1}}],[\"接到任务\",{\"1\":{\"458\":1}}],[\"接收命令或远程请求\",{\"1\":{\"568\":1}}],[\"接收到生产者的数据\",{\"1\":{\"361\":1}}],[\"接收生产者的数据并返回处理后的数据\",{\"1\":{\"361\":1}}],[\"接着参与\",{\"1\":{\"344\":1}}],[\"接着\",{\"1\":{\"252\":1}}],[\"接口吗\",{\"0\":{\"727\":1,\"747\":1}}],[\"接口是如何定义和使用的\",{\"0\":{\"727\":1,\"747\":1}}],[\"接口自身可以通过extends关键字扩展多个接口\",{\"1\":{\"299\":1}}],[\"接口中只能包含静态\",{\"1\":{\"299\":1}}],[\"接口中的方法默认修饰符是public\",{\"1\":{\"299\":1}}],[\"接口中的方法默认是公开的\",{\"1\":{\"299\":1}}],[\"接口中的方法可以有默认实现\",{\"1\":{\"299\":1}}],[\"接口也可以定义静态方法\",{\"1\":{\"299\":1}}],[\"接口或方法的参数和返回值的类型\",{\"1\":{\"284\":1}}],[\"接口\",{\"0\":{\"658\":1},\"1\":{\"258\":1,\"297\":2,\"341\":1,\"515\":2}}],[\"接口可以包含默认方法和静态方法\",{\"1\":{\"240\":1}}],[\"接口的默认方法和静态方法\",{\"1\":{\"240\":1}}],[\"接口列表\",{\"1\":{\"195\":1}}],[\"向应用程序注入实现了特定接口的服务提供者\",{\"1\":{\"252\":1}}],[\"机器指令的执行顺序\",{\"1\":{\"319\":1}}],[\"机器码\",{\"1\":{\"249\":1}}],[\"机制来保证修改的原子性\",{\"1\":{\"496\":1}}],[\"机制是java标准库提供的一种服务发现机制\",{\"1\":{\"252\":1}}],[\"机制\",{\"1\":{\"148\":1}}],[\"跨平台的数据交换\",{\"1\":{\"276\":1}}],[\"跨平台\",{\"1\":{\"248\":1}}],[\"切\",{\"1\":{\"247\":1}}],[\"运算\",{\"1\":{\"332\":1,\"535\":1}}],[\"运算符放在变量之前时\",{\"1\":{\"265\":1}}],[\"运算符可以放在变量之前\",{\"1\":{\"265\":1}}],[\"运⾏时环境\",{\"1\":{\"247\":1}}],[\"运行人员\",{\"1\":{\"639\":1}}],[\"运行安全性更高\",{\"1\":{\"633\":1}}],[\"运行可靠性更高\",{\"1\":{\"632\":1}}],[\"运行更安全\",{\"1\":{\"625\":1}}],[\"运行一个java项目\",{\"1\":{\"592\":1}}],[\"运行容器时使用\",{\"1\":{\"586\":1}}],[\"运行文件全部都在这个文件系统中\",{\"1\":{\"579\":1}}],[\"运行命令\",{\"1\":{\"574\":1,\"592\":1}}],[\"运行另外一个操作系统\",{\"1\":{\"563\":1}}],[\"运行应用的技术\",{\"1\":{\"562\":1}}],[\"运行环境基础上\",{\"1\":{\"589\":1}}],[\"运行环境一起打包为一个镜像\",{\"1\":{\"562\":1}}],[\"运行环境也较为复杂\",{\"1\":{\"559\":1}}],[\"运行环境和性能目标\",{\"1\":{\"150\":1}}],[\"运行环境和性能需求\",{\"1\":{\"78\":1}}],[\"运行\",{\"1\":{\"345\":1,\"577\":1}}],[\"运行状态\",{\"1\":{\"345\":1}}],[\"运行时利用沙箱机制形成隔离容器\",{\"1\":{\"562\":1}}],[\"运行时异常\",{\"1\":{\"279\":1}}],[\"运行时数据区\",{\"1\":{\"179\":1}}],[\"运行时常量池中的字面值\",{\"1\":{\"108\":1}}],[\"运行时常量池和栈中的局部变量\",{\"0\":{\"107\":1}}],[\"运行时常量池和字符串常量池迁移到java堆中\",{\"1\":{\"101\":1}}],[\"运行时常量池和字符串常量池等\",{\"1\":{\"101\":1}}],[\"运行时常量池在类加载时从类文件的常量池\",{\"1\":{\"104\":1}}],[\"运行时常量池在永久代中\",{\"1\":{\"100\":1}}],[\"运行时常量池包含类加载后所需的各种常量\",{\"1\":{\"104\":1}}],[\"运行时常量池被移到java堆\",{\"1\":{\"104\":1}}],[\"运行时常量池也位于永久代\",{\"1\":{\"104\":1}}],[\"运行时常量池移到java堆中\",{\"1\":{\"100\":1}}],[\"运行时常量池\",{\"0\":{\"100\":1,\"104\":1},\"1\":{\"95\":1,\"104\":1,\"105\":4,\"106\":1,\"107\":1,\"110\":1}}],[\"运行在任何地方\",{\"1\":{\"177\":1}}],[\"运行java程序时可以使用以下命令\",{\"1\":{\"174\":1}}],[\"台\",{\"1\":{\"247\":1}}],[\"针对不同\",{\"1\":{\"247\":1}}],[\"针对大对象或者长生命周期对象导致的fgc\",{\"1\":{\"88\":1}}],[\"缩小\",{\"1\":{\"244\":1}}],[\"匹配到第一个\",{\"1\":{\"244\":1}}],[\"匹配\",{\"1\":{\"244\":1}}],[\"转换\",{\"1\":{\"244\":1}}],[\"转换为方法区中的运行时数据结构\",{\"1\":{\"193\":1}}],[\"转换为方法区的运行时数据结构\",{\"0\":{\"193\":1},\"1\":{\"195\":1}}],[\"转换为\",{\"1\":{\"89\":1}}],[\"过程中遇到过的最大挑战是什么\",{\"0\":{\"722\":1}}],[\"过程层网络是各个间隔保护装置之间的信息传输通道\",{\"1\":{\"628\":1}}],[\"过程层网络\",{\"1\":{\"628\":1}}],[\"过程层网络结构示意图\",{\"1\":{\"627\":1}}],[\"过程层设备包括变压器\",{\"1\":{\"628\":1}}],[\"过程层\",{\"1\":{\"628\":1}}],[\"过多的线程可能会导致系统资源的竞争和浪费\",{\"1\":{\"453\":1}}],[\"过滤\",{\"1\":{\"244\":1}}],[\"过大的堆内存可能会导致gc停顿时间增加\",{\"1\":{\"87\":1}}],[\"亦或是\",{\"1\":{\"244\":1}}],[\"表中的所有数据\",{\"1\":{\"618\":1}}],[\"表明这是该类的⼀个静态资源\",{\"1\":{\"482\":1}}],[\"表示该锁对象已经被其他线程抢占\",{\"1\":{\"494\":1}}],[\"表示锁重入\",{\"1\":{\"494\":1}}],[\"表示进⼊同步代码前要获得\",{\"1\":{\"482\":1}}],[\"表示进⼊同步代码库前要获得给定对象的锁\",{\"1\":{\"482\":1}}],[\"表示要计算斐波那契数列的第10个数\",{\"1\":{\"480\":1}}],[\"表示要计算斐波那契数列的第\",{\"1\":{\"480\":1}}],[\"表示这是一个有返回值的递归任务\",{\"1\":{\"480\":1}}],[\"表示有3个停车位\",{\"1\":{\"357\":1,\"358\":1}}],[\"表示当前线程已经执行完毕\",{\"1\":{\"345\":1}}],[\"表示线程池已经完全终止\",{\"1\":{\"473\":1}}],[\"表示线程进入等待状态\",{\"1\":{\"345\":1}}],[\"表示线程阻塞于锁\",{\"1\":{\"345\":1}}],[\"表示具体的一个\",{\"1\":{\"286\":1}}],[\"表示不确定的\",{\"1\":{\"286\":1}}],[\"表示式\",{\"1\":{\"241\":1}}],[\"表达式了解多少\",{\"0\":{\"241\":1}}],[\"表达式最好不要超过3行\",{\"1\":{\"240\":1}}],[\"表达式使代码更加简洁\",{\"1\":{\"240\":1}}],[\"表达式本质上是一段匿名内部类\",{\"1\":{\"240\":1,\"241\":1}}],[\"表达式和函数式接口\",{\"1\":{\"240\":1}}],[\"才能缩写成\",{\"1\":{\"241\":1}}],[\"才会被视为重复并去除\",{\"1\":{\"606\":1}}],[\"才会加载到内存\",{\"1\":{\"565\":1}}],[\"才会返回插入的值\",{\"1\":{\"554\":1}}],[\"才会由自身进行加载\",{\"1\":{\"205\":1}}],[\"才会抛出outofmemoryerror异常\",{\"1\":{\"128\":1}}],[\"聚合等操作\",{\"1\":{\"240\":1}}],[\"排序\",{\"1\":{\"240\":1,\"244\":1,\"618\":1}}],[\"排查指南\",{\"1\":{\"88\":1}}],[\"排查内存飙高问题的步骤如下\",{\"1\":{\"86\":1}}],[\"映射方式相比\",{\"0\":{\"711\":1,\"739\":1}}],[\"映射吗\",{\"0\":{\"711\":1}}],[\"映射文件中\",{\"0\":{\"731\":1,\"751\":1}}],[\"映射文件中编写动态的\",{\"1\":{\"656\":1}}],[\"映射文件的\",{\"0\":{\"726\":1,\"746\":1}}],[\"映射文件相比有什么优缺点\",{\"0\":{\"700\":1}}],[\"映射文件通常包含sql语句\",{\"1\":{\"656\":1}}],[\"映射文件是xml格式的文件\",{\"1\":{\"656\":1}}],[\"映射文件\",{\"1\":{\"656\":1}}],[\"映射到mms的报告和文件操作服务\",{\"1\":{\"652\":1}}],[\"映射到mms的读写服务\",{\"1\":{\"652\":1}}],[\"映射到mms的读写和报告服务\",{\"1\":{\"652\":3}}],[\"映射到所采用的具体协议栈\",{\"1\":{\"636\":1}}],[\"映射端口时8090\",{\"1\":{\"595\":1}}],[\"映射\",{\"0\":{\"739\":1},\"1\":{\"240\":1}}],[\"服务器结构数据模型\",{\"1\":{\"636\":1}}],[\"服务器端得到通知\",{\"1\":{\"238\":1}}],[\"服务器端用一个线程处理多个连接\",{\"1\":{\"238\":1}}],[\"服务打包的最终名称\",{\"1\":{\"600\":1}}],[\"服务端\",{\"1\":{\"567\":1,\"568\":1}}],[\"服务端程序启动线程去处理\",{\"1\":{\"238\":1}}],[\"服务使用\",{\"1\":{\"252\":1}}],[\"服务加载\",{\"1\":{\"252\":1}}],[\"服务加载器\",{\"1\":{\"252\":1}}],[\"服务提供者配置文件\",{\"1\":{\"252\":1}}],[\"服务提供者\",{\"1\":{\"252\":1}}],[\"服务接口\",{\"1\":{\"252\":1}}],[\"回滚和关闭\",{\"1\":{\"656\":1}}],[\"回收进程占用的内存\",{\"1\":{\"577\":1}}],[\"回收空闲线程等\",{\"1\":{\"403\":1}}],[\"回收其占用的内存\",{\"1\":{\"139\":1}}],[\"回调\",{\"1\":{\"238\":1}}],[\"发送命令或者请求到docker服务端\",{\"1\":{\"568\":1}}],[\"发送邮件给\",{\"1\":{\"436\":1}}],[\"发现是a就会执行修改\",{\"1\":{\"504\":1}}],[\"发起进攻\",{\"1\":{\"353\":1}}],[\"发起连接请求\",{\"1\":{\"238\":1}}],[\"发生哈希碰撞的概率就降低了\",{\"1\":{\"541\":1}}],[\"发生概率仅为0\",{\"1\":{\"539\":1}}],[\"发生异常\",{\"1\":{\"377\":1,\"378\":1}}],[\"发生下面几种情况才会返回\",{\"1\":{\"344\":1}}],[\"发生在具有继承关系的父子类中\",{\"1\":{\"296\":1}}],[\"发生在同一个类中\",{\"1\":{\"296\":1}}],[\"发布完成后\",{\"1\":{\"21\":1}}],[\"发布到github\",{\"0\":{\"15\":1}}],[\"客户通过acsi\",{\"1\":{\"636\":1}}],[\"客户端\",{\"1\":{\"567\":1,\"568\":1}}],[\"客户端发送的连接请求会注册到多路复用器上\",{\"1\":{\"238\":1}}],[\"客户端有连接请求时服务器端就需要启动一个线程进行处理\",{\"1\":{\"238\":1}}],[\"客观原因\",{\"0\":{\"113\":1}}],[\"尤其对于复杂的映射和查询\",{\"1\":{\"655\":1}}],[\"尤其是当涉及到国际化和本地化时\",{\"1\":{\"237\":1}}],[\"尤其在大堆内存环境下\",{\"1\":{\"147\":1}}],[\"视频等\",{\"1\":{\"237\":1}}],[\"音频\",{\"1\":{\"237\":1}}],[\"节点重新hash获取位置\",{\"1\":{\"544\":1}}],[\"节点增减刚好在8附近\",{\"1\":{\"539\":1}}],[\"节点个数为8的情况\",{\"1\":{\"539\":1}}],[\"节点颜色\",{\"1\":{\"527\":1}}],[\"节点流\",{\"1\":{\"236\":1}}],[\"节省了内存空间\",{\"1\":{\"210\":1}}],[\"前阻塞\",{\"1\":{\"355\":1}}],[\"前两种面向字节\",{\"1\":{\"351\":1}}],[\"前会先执行\",{\"1\":{\"282\":1}}],[\"前缀\",{\"1\":{\"265\":1}}],[\"前者是字节输出流\",{\"1\":{\"236\":1}}],[\"前者是字节输入流\",{\"1\":{\"236\":1}}],[\"前端\",{\"2\":{\"25\":1}}],[\"输入流\",{\"1\":{\"236\":1}}],[\"输出电压大小正比于被测电流大小\",{\"1\":{\"635\":1}}],[\"输出至合并单元\",{\"1\":{\"633\":1}}],[\"输出终端\",{\"1\":{\"579\":1}}],[\"输出流主要包括了如下4种具体实现\",{\"1\":{\"351\":1}}],[\"输出流不同之处在于\",{\"1\":{\"351\":1}}],[\"输出流或者网络输入\",{\"1\":{\"351\":1}}],[\"输出流和普通的文件输入\",{\"1\":{\"351\":1}}],[\"输出流\",{\"1\":{\"236\":1,\"351\":1}}],[\"输出的信息是\",{\"1\":{\"220\":1}}],[\"输出的值就是线程栈信息中的\",{\"1\":{\"89\":1}}],[\"输出可能是\",{\"1\":{\"190\":1}}],[\"输出每个类的对象数量\",{\"1\":{\"89\":1}}],[\"输出\",{\"1\":{\"89\":1,\"207\":1}}],[\"流量调节和差错控制等\",{\"1\":{\"637\":1}}],[\"流中的元素总数\",{\"1\":{\"244\":1}}],[\"流\",{\"1\":{\"244\":2}}],[\"流用过吗\",{\"0\":{\"244\":1}}],[\"流分为几种\",{\"0\":{\"236\":1}}],[\"流程图\",{\"0\":{\"28\":1}}],[\"符\",{\"1\":{\"351\":1}}],[\"符合双亲委派模型的设计原则\",{\"1\":{\"233\":1}}],[\"符号引用是指在字节码中使用符号\",{\"1\":{\"187\":1}}],[\"都能为继电保护自动装置提供能够真实反映一次设备运行状态的测量数据\",{\"1\":{\"625\":1}}],[\"都是基于dockerfile临时构建的\",{\"1\":{\"598\":1}}],[\"都是硬盘中的一个个的字节形成的文件\",{\"1\":{\"565\":1}}],[\"都是往自己的threadlocalmap里存\",{\"1\":{\"328\":1}}],[\"都可以协调多线程的结束动作\",{\"1\":{\"354\":1}}],[\"都在屏障后的写操作之前被刷新到主内存中\",{\"1\":{\"324\":1}}],[\"都会检测\",{\"1\":{\"520\":1}}],[\"都会回收该对象占用的内存\",{\"1\":{\"329\":1}}],[\"都会返回一个新的\",{\"1\":{\"267\":1}}],[\"都会触发full\",{\"1\":{\"135\":1}}],[\"都有自己的类加载器\",{\"1\":{\"224\":1}}],[\"绕过了双亲委派模型的限制\",{\"1\":{\"223\":1}}],[\"绕过双亲委派机制\",{\"1\":{\"215\":1,\"220\":1}}],[\"第57技术委员会于2004年颁布的\",{\"1\":{\"636\":1}}],[\"第一次增加\",{\"1\":{\"538\":1}}],[\"第一次破坏\",{\"0\":{\"222\":1}}],[\"第二次增加2^2\",{\"1\":{\"538\":1}}],[\"第二次破坏\",{\"0\":{\"223\":1}}],[\"第二步和第三步就可能会重排序\",{\"1\":{\"319\":1}}],[\"第3和第4句其实是等效的\",{\"1\":{\"317\":1}}],[\"第2句先读i的值\",{\"1\":{\"317\":1}}],[\"第1句是基本类型赋值\",{\"1\":{\"317\":1}}],[\"第三次破坏\",{\"0\":{\"224\":1}}],[\"之前执行\",{\"1\":{\"619\":1}}],[\"之前被刷新到主内存中\",{\"1\":{\"324\":1}}],[\"之前\",{\"1\":{\"222\":1,\"282\":1,\"615\":1}}],[\"历史上有哪几次双亲委派机制的破坏\",{\"0\":{\"221\":1}}],[\"委派给父类加载器加载\",{\"1\":{\"220\":1}}],[\"委派给父加载器\",{\"1\":{\"206\":1}}],[\"演示了如何使用fork\",{\"1\":{\"480\":1}}],[\"演示了如何使用setcontextclassloader方法绕过双亲委派机制\",{\"1\":{\"220\":1}}],[\"演示了如何通过自定义类加载器破坏双亲委派机制\",{\"1\":{\"215\":1}}],[\"否则向链表中插入数据\",{\"1\":{\"531\":1}}],[\"否则需要覆盖\",{\"1\":{\"531\":1}}],[\"否则抛出异常\",{\"1\":{\"520\":1}}],[\"否则执行6\",{\"1\":{\"494\":1}}],[\"否则执行\",{\"1\":{\"494\":1}}],[\"否则进入步骤\",{\"1\":{\"493\":1}}],[\"否则推荐使用静态内部类\",{\"1\":{\"313\":1}}],[\"否则会报错\",{\"1\":{\"299\":1}}],[\"否则会有可读性等问题\",{\"1\":{\"240\":1}}],[\"否则\",{\"1\":{\"269\":1,\"271\":1,\"445\":1,\"458\":1,\"480\":1,\"532\":2}}],[\"否则我们自己加载该类\",{\"1\":{\"215\":1}}],[\"否则重试\",{\"1\":{\"120\":1}}],[\"破坏双亲委派机制意味着绕过了java类加载器的默认委派规则\",{\"1\":{\"214\":1}}],[\"稳定性和可靠性\",{\"1\":{\"213\":1}}],[\"稳定性和可维护性方面都有显著提升\",{\"1\":{\"116\":1}}],[\"某个类只会被加载一次\",{\"1\":{\"209\":1}}],[\"某个类由同一个类加载器加载\",{\"1\":{\"207\":1}}],[\"直采直跳\",{\"0\":{\"629\":1},\"1\":{\"627\":5,\"629\":3,\"637\":2,\"640\":1}}],[\"直至找到空闲的位置\",{\"1\":{\"538\":1}}],[\"直至找到空闲位置\",{\"1\":{\"538\":1}}],[\"直至占有资源的线程释放该资源\",{\"1\":{\"512\":1}}],[\"直到计数器清零\",{\"1\":{\"489\":1}}],[\"直到计数器为0\",{\"1\":{\"356\":1}}],[\"直到计算到基本情况\",{\"1\":{\"480\":1}}],[\"直到任务队列为空为止\",{\"1\":{\"480\":1}}],[\"直到拆分的任务足够小而可以被快速处理为止\",{\"1\":{\"480\":1}}],[\"直到达到拆分任务的终止条件\",{\"1\":{\"480\":1}}],[\"直到达到预期的效果\",{\"1\":{\"476\":1}}],[\"直到达到最大线程数\",{\"1\":{\"448\":1}}],[\"直到所有小任务的结果都被合并到大任务的结果中为止\",{\"1\":{\"480\":1}}],[\"直到所有任务执行完毕后才会关闭\",{\"1\":{\"452\":1}}],[\"直到所有线程都到达\",{\"1\":{\"355\":1}}],[\"直到线程数量等于核心线程数\",{\"1\":{\"448\":1}}],[\"直到队列有空闲位置\",{\"1\":{\"400\":1}}],[\"直到队列非空\",{\"1\":{\"400\":1}}],[\"直到另一个线程也调用\",{\"1\":{\"362\":1}}],[\"直到对方也到达此同步点\",{\"1\":{\"362\":1}}],[\"直到有可用许可为止\",{\"1\":{\"358\":1}}],[\"直到最后一个线程到达屏障时\",{\"1\":{\"354\":1}}],[\"直到其他线程通过\",{\"1\":{\"344\":1}}],[\"直到到达顶层的引导类加载器\",{\"1\":{\"209\":1}}],[\"直到引导类加载器\",{\"1\":{\"206\":1}}],[\"直接进入保护及测控装置的采样运算\",{\"1\":{\"633\":1}}],[\"直接将一次高电压转换成为与其成正比的0～5v的交流小信号\",{\"1\":{\"632\":1}}],[\"直接挂载模式\",{\"1\":{\"587\":1}}],[\"直接基于打包的函数库\",{\"1\":{\"561\":1}}],[\"直接调用hashmap的put方法\",{\"1\":{\"554\":1}}],[\"直接调用classloader\",{\"0\":{\"216\":1}}],[\"直接根据\",{\"1\":{\"537\":1}}],[\"直接定址法\",{\"1\":{\"537\":1}}],[\"直接插入或者删除就可以了\",{\"1\":{\"515\":1}}],[\"直接\",{\"1\":{\"282\":1}}],[\"直接返回字符串常量池中的字符串\",{\"1\":{\"271\":1}}],[\"直接返回\",{\"1\":{\"263\":1,\"480\":1,\"532\":1}}],[\"直接返回加载的类\",{\"1\":{\"206\":1}}],[\"直接由自定义类加载器加载类\",{\"1\":{\"233\":1}}],[\"直接加载特定的类\",{\"1\":{\"215\":1}}],[\"直接使用自定义的类加载器加载类\",{\"1\":{\"214\":1}}],[\"直接可达的对象\",{\"1\":{\"139\":1}}],[\"直接指针访问方式\",{\"1\":{\"122\":1}}],[\"逐级返回\",{\"1\":{\"206\":1}}],[\"逐级向上委派\",{\"1\":{\"206\":1}}],[\"逐步改用本地内存\",{\"1\":{\"114\":1}}],[\"重入多少次\",{\"1\":{\"496\":1}}],[\"重用性\",{\"1\":{\"355\":1}}],[\"重要注意事项\",{\"0\":{\"355\":1,\"359\":1,\"363\":1}}],[\"重排序可以分为编译器重排序和处理器重排序\",{\"1\":{\"324\":1}}],[\"重排序分3种类型\",{\"1\":{\"319\":1}}],[\"重载\",{\"0\":{\"296\":1}}],[\"重写call\",{\"1\":{\"341\":1}}],[\"重写run\",{\"1\":{\"341\":2}}],[\"重写克隆方法\",{\"1\":{\"307\":2}}],[\"重写方法的访问权限可以更广\",{\"1\":{\"296\":1}}],[\"重写方法不能抛出范围更大的受控异常\",{\"1\":{\"296\":1}}],[\"重写\",{\"1\":{\"233\":7}}],[\"重写了loadclass方法\",{\"1\":{\"215\":1}}],[\"重复步骤1和步骤2\",{\"1\":{\"206\":1}}],[\"重新tag本地镜像\",{\"1\":{\"604\":1}}],[\"重新加载\",{\"1\":{\"575\":1}}],[\"重新计算冲突元素的地址\",{\"1\":{\"538\":1}}],[\"重新计算各个区域的存活对象\",{\"1\":{\"142\":1}}],[\"重新标记和并发清理四个阶段\",{\"1\":{\"139\":1}}],[\"重新标记\",{\"1\":{\"139\":1}}],[\"重新定义类\",{\"1\":{\"56\":1}}],[\"父子线程怎么共享数据\",{\"0\":{\"335\":1}}],[\"父类不希望子类出现更多的异常\",{\"1\":{\"296\":1}}],[\"父类加载器接到请求后\",{\"1\":{\"206\":1}}],[\"父类名\",{\"1\":{\"195\":1}}],[\"父加载器处理\",{\"1\":{\"206\":1}}],[\"具备下列优势\",{\"1\":{\"562\":1}}],[\"具体唤醒哪个等待的线程是随机的\",{\"1\":{\"344\":1}}],[\"具体的类加载器如下\",{\"1\":{\"234\":1}}],[\"具体来说\",{\"1\":{\"205\":1,\"410\":1}}],[\"具有实时\",{\"1\":{\"622\":1}}],[\"具有确保电力信息安全的能力\",{\"1\":{\"622\":1}}],[\"具有保存key\",{\"1\":{\"548\":1}}],[\"具有排他性\",{\"1\":{\"488\":1}}],[\"具有固定容量的特点\",{\"1\":{\"450\":1}}],[\"具有高吞吐量和无限容量的特点\",{\"1\":{\"450\":1}}],[\"具有高效\",{\"1\":{\"145\":1}}],[\"具有以下特点\",{\"1\":{\"129\":1}}],[\"热部署等\",{\"1\":{\"204\":1}}],[\"子句\",{\"1\":{\"616\":8,\"618\":4}}],[\"子线程使用countdownlatch\",{\"1\":{\"353\":2}}],[\"子线程\",{\"1\":{\"335\":1,\"336\":1}}],[\"子类可以扩大方法的访问范围\",{\"1\":{\"296\":1}}],[\"子加载器加载\",{\"1\":{\"206\":1}}],[\"子加载器才会尝试加载\",{\"1\":{\"203\":1}}],[\"子网掩码\",{\"1\":{\"54\":1}}],[\"工作窃取发生的时候\",{\"1\":{\"480\":1}}],[\"工作窃取算法\",{\"1\":{\"480\":1}}],[\"工作窃取队列通常用于实现任务并行化的线程池\",{\"1\":{\"450\":1}}],[\"工作窃取队列是一种用于并行计算的特殊队列\",{\"1\":{\"450\":1}}],[\"工作窃取队列\",{\"1\":{\"450\":1}}],[\"工作流程\",{\"1\":{\"457\":1,\"458\":1,\"459\":1,\"460\":1,\"522\":1}}],[\"工作原理\",{\"0\":{\"206\":1}}],[\"工作\",{\"1\":{\"203\":1,\"356\":1}}],[\"工具类来创建不同类型的线程池\",{\"1\":{\"390\":1}}],[\"工具查看\",{\"1\":{\"89\":1}}],[\"工具\",{\"1\":{\"65\":1,\"70\":1,\"89\":1}}],[\"工具名称\",{\"1\":{\"56\":1}}],[\"工具名\",{\"1\":{\"54\":1,\"55\":1}}],[\"形成qq镜像\",{\"1\":{\"565\":1}}],[\"形成多个容器进程\",{\"1\":{\"565\":1}}],[\"形成进程\",{\"1\":{\"565\":2}}],[\"形成可移植镜像\",{\"1\":{\"562\":1}}],[\"形成了一个等待环路\",{\"1\":{\"512\":1}}],[\"形成树形层次结构\",{\"1\":{\"203\":1}}],[\"形参与成员变量名字重名\",{\"1\":{\"298\":1}}],[\"形参相同\",{\"1\":{\"296\":1}}],[\"形参不同\",{\"1\":{\"296\":1}}],[\"形式编写的java程序\",{\"1\":{\"177\":1}}],[\"加锁\",{\"1\":{\"522\":1}}],[\"加版本号\",{\"1\":{\"505\":1}}],[\"加强代码的重用\",{\"1\":{\"294\":1}}],[\"加入到已注册的通道列表\",{\"1\":{\"238\":1}}],[\"加密文件等加载类\",{\"1\":{\"202\":1}}],[\"加载本地文件\",{\"1\":{\"574\":1}}],[\"加载操作\",{\"1\":{\"324\":1}}],[\"加载并使用testclass类\",{\"1\":{\"220\":1}}],[\"加载类的字节码\",{\"1\":{\"220\":1}}],[\"加载类的安全性\",{\"0\":{\"211\":1}}],[\"加载类\",{\"1\":{\"216\":1}}],[\"加载自定义类的字节码\",{\"1\":{\"220\":1}}],[\"加载自定义类\",{\"1\":{\"215\":1}}],[\"加载失败抛异常\",{\"1\":{\"206\":1}}],[\"加载阶段是jvm类加载机制的起点\",{\"1\":{\"197\":1}}],[\"加载阶段结束后\",{\"0\":{\"196\":1}}],[\"加载到内存中的起点\",{\"1\":{\"191\":1}}],[\"加载到运行时常量池中\",{\"1\":{\"108\":1}}],[\"加载\",{\"0\":{\"184\":1},\"1\":{\"180\":1,\"183\":1}}],[\"加载代码\",{\"1\":{\"178\":1}}],[\"上传到任意目录\",{\"1\":{\"602\":1}}],[\"上面的compose文件就描述一个项目\",{\"1\":{\"595\":1}}],[\"上面的代码示例中int\",{\"0\":{\"106\":1}}],[\"上个案例中\",{\"1\":{\"586\":1}}],[\"上个卫生间\",{\"1\":{\"353\":1}}],[\"上的类\",{\"1\":{\"201\":1}}],[\"嵌入在jvm内部\",{\"1\":{\"199\":1}}],[\"允许在\",{\"1\":{\"656\":1}}],[\"允许我们与容器交互\",{\"1\":{\"579\":1}}],[\"允许一个线程二次请求自己持有对象锁的临界资源\",{\"1\":{\"489\":1}}],[\"允许键和值为null\",{\"1\":{\"291\":1}}],[\"允许把函数作为一个方法的参数\",{\"1\":{\"240\":1}}],[\"允许程序通过class对象访问类的元数据和结构信息\",{\"1\":{\"194\":1}}],[\"允许用户通过参数\",{\"1\":{\"148\":1}}],[\"获得数据对象值列表的服务等\",{\"1\":{\"636\":1}}],[\"获得与一次电流成比例的电压信号\",{\"1\":{\"634\":1}}],[\"获得堆内存的dump文件\",{\"1\":{\"84\":1}}],[\"获取mapper接口实例\",{\"1\":{\"656\":1}}],[\"获取节点\",{\"1\":{\"532\":1}}],[\"获取新的哈希值\",{\"1\":{\"532\":1}}],[\"获取一个新的哈希值\",{\"1\":{\"531\":1}}],[\"获取一个许可\",{\"1\":{\"357\":1}}],[\"获取失败的话\",{\"1\":{\"500\":1}}],[\"获取不到才会到等待队列的队尾等待\",{\"1\":{\"499\":1}}],[\"获取state的方式分为两种\",{\"1\":{\"496\":1}}],[\"获取\",{\"1\":{\"485\":1}}],[\"获取当前的latch数量\",{\"1\":{\"353\":1}}],[\"获取到key的哈希值\",{\"1\":{\"533\":1}}],[\"获取到锁的线程可以重入\",{\"1\":{\"496\":1}}],[\"获取到\",{\"1\":{\"344\":1}}],[\"获取二进制字节流\",{\"0\":{\"192\":1},\"1\":{\"195\":1}}],[\"卸载旧的类\",{\"0\":{\"230\":1}}],[\"卸载\",{\"0\":{\"190\":1}}],[\"细节\",{\"1\":{\"184\":1,\"185\":1,\"186\":1,\"187\":1,\"188\":1,\"189\":1,\"190\":1}}],[\"库和函数\",{\"1\":{\"179\":1}}],[\"非公平锁让获取锁的时间变得更加不确定\",{\"1\":{\"501\":1}}],[\"非公平锁会有更好的性能\",{\"1\":{\"501\":1}}],[\"非公平锁会直接\",{\"1\":{\"501\":1}}],[\"非公平锁会尝试去获取锁\",{\"1\":{\"500\":1}}],[\"非公平锁在\",{\"1\":{\"501\":1}}],[\"非公平锁在调用\",{\"1\":{\"501\":1}}],[\"非公平锁和公平锁的两处不同\",{\"1\":{\"501\":1}}],[\"非公平锁的优点是可以减少唤起线程的开销\",{\"1\":{\"499\":1}}],[\"非公平锁是多个线程加锁时直接尝试获取锁\",{\"1\":{\"499\":1}}],[\"非公平锁\",{\"0\":{\"499\":1}}],[\"非核心线程空闲存活时间为60秒\",{\"1\":{\"458\":1}}],[\"非静态内部类\",{\"0\":{\"311\":1}}],[\"非静态内部类会隐式地持有其外部类实例的引用\",{\"1\":{\"309\":1}}],[\"非final修饰的成员变量具有默认值\",{\"1\":{\"300\":1}}],[\"非线程安全\",{\"1\":{\"268\":1}}],[\"非java\",{\"1\":{\"179\":1}}],[\"非常适合需要双向数据传递的场景\",{\"1\":{\"363\":1}}],[\"非常适合对响应时间有严格要求的应用\",{\"1\":{\"154\":1}}],[\"非常大堆内存\",{\"1\":{\"159\":1}}],[\"负责创建sqlsession实例\",{\"1\":{\"656\":1}}],[\"负责处理docker指令\",{\"1\":{\"567\":1}}],[\"负责将类文件加载到java虚拟机中\",{\"1\":{\"198\":1}}],[\"负责自动回收不再使用的内存\",{\"1\":{\"179\":1}}],[\"负责执行字节码\",{\"1\":{\"179\":1}}],[\"负责加载web应用程序目录下的class文件\",{\"1\":{\"234\":1}}],[\"负责加载java的核心类库\",{\"1\":{\"234\":1}}],[\"负责加载应用程序类路径\",{\"1\":{\"201\":1}}],[\"负责加载扩展库中的类\",{\"1\":{\"200\":1}}],[\"负责加载核心java类库\",{\"1\":{\"199\":1}}],[\"负责加载\",{\"1\":{\"179\":1}}],[\"全偏移短路电流\",{\"1\":{\"635\":1}}],[\"全光纤等构成\",{\"1\":{\"635\":1}}],[\"全军出击\",{\"1\":{\"353\":1}}],[\"全称为java虚拟机\",{\"1\":{\"177\":1}}],[\"全栈监控解决方案\",{\"1\":{\"67\":1,\"70\":1}}],[\"原子操作类的优点在于\",{\"1\":{\"510\":1}}],[\"原子操作类一般都是通过底层的cas\",{\"1\":{\"510\":1}}],[\"原子操作类是java提供的一组线程安全的工具类\",{\"1\":{\"510\":1}}],[\"原子操作类了解多少\",{\"0\":{\"510\":1}}],[\"原子性保证了对共享变量的操作是原子的\",{\"1\":{\"316\":1}}],[\"原子性是指一个操作是不可分割的\",{\"1\":{\"316\":1}}],[\"原子性\",{\"0\":{\"318\":1},\"1\":{\"316\":2,\"318\":1}}],[\"原子性操作\",{\"1\":{\"120\":1}}],[\"原理的互感器\",{\"1\":{\"634\":1}}],[\"原理很简单\",{\"1\":{\"336\":1}}],[\"原理\",{\"0\":{\"273\":1,\"769\":1},\"1\":{\"273\":1,\"520\":2}}],[\"原理是什么\",{\"0\":{\"248\":1}}],[\"原始代码\",{\"0\":{\"172\":1}}],[\"降低投资成本和运行维护成本\",{\"1\":{\"622\":1}}],[\"降低电网损耗\",{\"1\":{\"622\":1}}],[\"降低系统性能\",{\"1\":{\"416\":1}}],[\"降低系统的稳定性和安全性\",{\"1\":{\"214\":1,\"219\":1}}],[\"降低了功率消耗\",{\"1\":{\"635\":1}}],[\"降低了设备投资\",{\"1\":{\"630\":1}}],[\"降低了哈希冲突的概率\",{\"1\":{\"533\":1}}],[\"降低了出现类加载相关问题的可能性\",{\"1\":{\"212\":1}}],[\"降低了垃圾收集的停顿时间\",{\"1\":{\"151\":1}}],[\"降低gc压力\",{\"1\":{\"167\":1}}],[\"编写入口entrypoint\",{\"1\":{\"593\":1}}],[\"编写dockerfile文件\",{\"1\":{\"593\":1}}],[\"编写服务提供者配置文件\",{\"1\":{\"252\":1}}],[\"编写服务提供者\",{\"1\":{\"252\":2}}],[\"编写的程序需要先经过编译步骤\",{\"1\":{\"250\":1}}],[\"编写一次\",{\"1\":{\"177\":1}}],[\"编译打包好的app\",{\"1\":{\"601\":1}}],[\"编译器在生成字节码时\",{\"1\":{\"324\":1}}],[\"编译器在不改变单线程程序语义的前提下\",{\"1\":{\"319\":1}}],[\"编译器\",{\"1\":{\"321\":1}}],[\"编译器和处理器不会对存在数据依赖关系的操作做重排序\",{\"1\":{\"321\":1}}],[\"编译器和处理器为了提高并行度\",{\"1\":{\"321\":1}}],[\"编译器和处理器常常会对指令做重排序\",{\"1\":{\"319\":1}}],[\"编译器优化的重排序\",{\"1\":{\"319\":1}}],[\"编译器会强制检查并要求处理的异常\",{\"1\":{\"279\":1}}],[\"编译器可以分析对象的使用情况\",{\"1\":{\"170\":1}}],[\"编译器可以将对象的成员变量直接分配在栈上\",{\"1\":{\"164\":1}}],[\"编译\",{\"1\":{\"249\":1}}],[\"编译与解释并存\",{\"0\":{\"250\":1},\"1\":{\"246\":1}}],[\"编辑此页\",{\"0\":{\"23\":1}}],[\"逃逸分析中标量替换的工作原理是怎样的\",{\"0\":{\"169\":1}}],[\"逃逸分析的优势\",{\"0\":{\"167\":1}}],[\"逃逸分析的应用示例\",{\"0\":{\"165\":1}}],[\"逃逸分析是一种编译时技术\",{\"1\":{\"164\":1}}],[\"逃逸分析\",{\"0\":{\"164\":1}}],[\"逃逸分析可以分析对象的作用域\",{\"1\":{\"87\":1}}],[\"栈上分配\",{\"1\":{\"164\":1}}],[\"栈用于存储局部变量和方法调用栈帧\",{\"1\":{\"163\":1}}],[\"栈内存的分配和释放由jvm自动管理\",{\"1\":{\"163\":1}}],[\"栈内存\",{\"1\":{\"163\":1}}],[\"栈中的变量是线程私有的\",{\"1\":{\"92\":1}}],[\"结构包括\",{\"1\":{\"561\":1}}],[\"结构如下\",{\"1\":{\"561\":1}}],[\"结合监控告警机制\",{\"1\":{\"476\":1}}],[\"结合监控机制建立告警机制\",{\"1\":{\"476\":1}}],[\"结合实际测试和调优\",{\"1\":{\"161\":1}}],[\"结束当前的方法\",{\"1\":{\"263\":1}}],[\"结束当前的循环体\",{\"1\":{\"263\":1}}],[\"结束正在执行的循环\",{\"1\":{\"263\":1}}],[\"结果集的处理等\",{\"1\":{\"656\":1}}],[\"结果映射等信息\",{\"1\":{\"656\":1}}],[\"结果映射等\",{\"1\":{\"656\":1}}],[\"结果为\",{\"1\":{\"618\":2}}],[\"结果为直接保留hash值对\",{\"1\":{\"535\":1}}],[\"结果如图\",{\"1\":{\"574\":1}}],[\"结果正确\",{\"0\":{\"509\":1}}],[\"结果合并\",{\"1\":{\"480\":1}}],[\"结果3\",{\"1\":{\"375\":1,\"383\":1}}],[\"结果2\",{\"1\":{\"375\":1,\"383\":1}}],[\"结果1\",{\"1\":{\"375\":1,\"383\":1}}],[\"结果\",{\"1\":{\"282\":1,\"367\":1,\"380\":1,\"381\":1,\"383\":1,\"388\":1,\"391\":1,\"392\":2,\"574\":2,\"584\":2}}],[\"结果就大量的请求进入到后台\",{\"1\":{\"84\":1}}],[\"结果在测试的过程中发现导出订单的按钮前端居然没有做点击后按钮置灰交互事件\",{\"1\":{\"84\":1}}],[\"考虑应用未来的增长和变化\",{\"1\":{\"160\":1}}],[\"考虑未来需求\",{\"1\":{\"160\":1}}],[\"测控装置经过逻辑五防校验后发出遥控操作指令\",{\"1\":{\"639\":1}}],[\"测控装置及合并单元等设备\",{\"1\":{\"639\":1}}],[\"测控装置与合并单元及智能终端的通信规约为iec\",{\"1\":{\"637\":1}}],[\"测控装置\",{\"1\":{\"628\":1}}],[\"测量上送功能\",{\"1\":{\"652\":2}}],[\"测量和保护可共用一个铁心线圈式低功率电流互感器\",{\"1\":{\"635\":1}}],[\"测量\",{\"1\":{\"623\":1,\"632\":1}}],[\"测量gc停顿时间\",{\"1\":{\"160\":1}}],[\"测试环境\",{\"1\":{\"656\":1}}],[\"测试等环境会存在差异\",{\"1\":{\"560\":1}}],[\"测试\",{\"1\":{\"476\":1,\"477\":1,\"559\":1,\"562\":1}}],[\"测试和验证\",{\"0\":{\"232\":1}}],[\"测试类\",{\"1\":{\"215\":1,\"220\":1}}],[\"测试方法\",{\"1\":{\"215\":1}}],[\"测试验证\",{\"1\":{\"82\":1}}],[\"多字段去重示例\",{\"0\":{\"612\":1}}],[\"多字段去重\",{\"0\":{\"609\":1}}],[\"多数情况下\",{\"1\":{\"515\":1}}],[\"多余的空闲线程在终止前等待新任务的最长时间\",{\"1\":{\"408\":1}}],[\"多个线程可以共享同一实\",{\"1\":{\"343\":1}}],[\"多个线程共用进程的堆和方法区资源\",{\"1\":{\"340\":1}}],[\"多个线程操作这个变量的时候\",{\"1\":{\"326\":1}}],[\"多个⼦类对同⼀⽅法的重写\",{\"1\":{\"295\":1}}],[\"多操作系统运行\",{\"1\":{\"248\":1}}],[\"多态\",{\"1\":{\"246\":1,\"295\":1}}],[\"多路复用器轮询到连接有io请求就进行处理\",{\"1\":{\"238\":1}}],[\"多线程的put可能导致元素的丢失\",{\"1\":{\"545\":1}}],[\"多线程下扩容死循环\",{\"1\":{\"545\":1}}],[\"多线程下会有什么问题\",{\"0\":{\"545\":1}}],[\"多线程限量操作\",{\"1\":{\"357\":1}}],[\"多线程调度\",{\"1\":{\"274\":1}}],[\"多线程环境下操作大量的数据\",{\"1\":{\"268\":1}}],[\"多线程\",{\"1\":{\"159\":1}}],[\"多处理器环境\",{\"1\":{\"159\":1}}],[\"多核处理器可以利用并行gc和并发gc\",{\"1\":{\"158\":1}}],[\"小电流接地选线\",{\"1\":{\"630\":1}}],[\"小于1\",{\"1\":{\"620\":1}}],[\"小结\",{\"0\":{\"197\":1,\"562\":1,\"568\":1,\"580\":1,\"588\":1,\"594\":1},\"1\":{\"563\":1,\"584\":1,\"594\":1}}],[\"小堆内存\",{\"1\":{\"159\":1}}],[\"小到中等堆内存\",{\"1\":{\"158\":1}}],[\"单字段去重示例\",{\"0\":{\"611\":1}}],[\"单字段去重\",{\"0\":{\"608\":1}}],[\"单点模式启动\",{\"1\":{\"598\":1}}],[\"单机线程池执行断电了应该怎么处理\",{\"0\":{\"478\":1}}],[\"单线程的程序能保证最终结果是有序的\",{\"1\":{\"488\":1}}],[\"单线程的程序一定是顺序的吗\",{\"0\":{\"321\":1}}],[\"单线程线程池只包含一个线程\",{\"1\":{\"455\":1}}],[\"单线程线程池\",{\"0\":{\"459\":1},\"1\":{\"406\":1,\"455\":1}}],[\"单线程池\",{\"0\":{\"396\":1}}],[\"单线程程序的执行结果不能被改变\",{\"1\":{\"321\":1}}],[\"单线程环境下操作大量的数据\",{\"1\":{\"268\":1}}],[\"单线程\",{\"1\":{\"159\":1}}],[\"单处理器或低并发应用\",{\"1\":{\"159\":1}}],[\"单方面的加大了堆内存从4g调整到8g\",{\"1\":{\"84\":1}}],[\"低碳\",{\"1\":{\"623\":1}}],[\"低位是与1做位运算\",{\"1\":{\"535\":1}}],[\"低\",{\"1\":{\"268\":2}}],[\"低延迟应用\",{\"1\":{\"158\":1}}],[\"低停顿时间\",{\"1\":{\"143\":1,\"158\":1,\"159\":1}}],[\"低停顿\",{\"1\":{\"139\":1}}],[\"几十gb到几tb\",{\"1\":{\"158\":1}}],[\"几百mb到几gb\",{\"1\":{\"158\":1}}],[\"几乎没有直接作用\",{\"1\":{\"128\":1}}],[\"后的变化\",{\"1\":{\"633\":1}}],[\"后台监控\",{\"1\":{\"625\":1}}],[\"后台运行容器\",{\"1\":{\"578\":1}}],[\"后台任务等对响应时间不敏感的应用\",{\"1\":{\"158\":1}}],[\"后继节点和插入节点的指向就行了\",{\"1\":{\"515\":1}}],[\"后被其他进入的线程获得\",{\"1\":{\"485\":1}}],[\"后\",{\"1\":{\"303\":1,\"501\":1}}],[\"后缀\",{\"1\":{\"265\":1}}],[\"后解释两个步骤\",{\"1\":{\"250\":1}}],[\"后者是字符输出流\",{\"1\":{\"236\":1}}],[\"后者是字符输入流\",{\"1\":{\"236\":1}}],[\"后端代码加分布式锁\",{\"1\":{\"84\":1}}],[\"后端也没有做防止重复提交\",{\"1\":{\"84\":1}}],[\"证券交易所\",{\"1\":{\"155\":1}}],[\"金融机构\",{\"1\":{\"155\":1}}],[\"成本平衡的考虑\",{\"1\":{\"541\":1}}],[\"成本和\",{\"1\":{\"541\":1}}],[\"成对使用\",{\"1\":{\"363\":1}}],[\"成功\",{\"1\":{\"377\":1,\"378\":1}}],[\"成功后进入停车场\",{\"1\":{\"358\":1}}],[\"成功进入停车场\",{\"1\":{\"357\":1}}],[\"成熟度不如g1和cms\",{\"1\":{\"151\":1}}],[\"成员变量的默认值根据其类型而定\",{\"1\":{\"300\":1}}],[\"成员变量包括实例变量和静态变量\",{\"1\":{\"300\":1}}],[\"成员变量是在类中声明的变量\",{\"1\":{\"300\":1}}],[\"成员变量与局部变量的区别有哪些\",{\"0\":{\"300\":1}}],[\"成员变量\",{\"1\":{\"121\":1,\"300\":1,\"351\":1}}],[\"相关配置内容重新配置生成的配置文件\",{\"1\":{\"638\":1}}],[\"相关信息等\",{\"1\":{\"121\":1}}],[\"相位调制和偏振调制等\",{\"1\":{\"635\":1}}],[\"相互隔离\",{\"1\":{\"562\":1}}],[\"相比电磁电流互感器也存在以下两个缺点\",{\"1\":{\"633\":1}}],[\"相比于链表的o\",{\"1\":{\"543\":1}}],[\"相比于平衡二叉树\",{\"1\":{\"529\":1}}],[\"相比synchronized的加锁方式来解决共享变量的内存可见性问题\",{\"1\":{\"323\":1}}],[\"相反\",{\"0\":{\"721\":1},\"1\":{\"344\":1}}],[\"相对来说\",{\"1\":{\"501\":1}}],[\"相对重量级锁\",{\"1\":{\"491\":1}}],[\"相对较高\",{\"1\":{\"343\":2}}],[\"相对较低\",{\"1\":{\"343\":2}}],[\"相对新\",{\"1\":{\"151\":1}}],[\"相当于顺序执行\",{\"1\":{\"342\":1}}],[\"相当于取余\",{\"1\":{\"332\":1}}],[\"相等吗\",{\"0\":{\"272\":1}}],[\"相应的栈帧和局部变量会被释放\",{\"1\":{\"163\":1}}],[\"初识dockercompose\",{\"0\":{\"595\":1}}],[\"初期调优可能需要一定时间\",{\"1\":{\"151\":1}}],[\"初始状态\",{\"1\":{\"345\":1}}],[\"初始标记\",{\"1\":{\"139\":1,\"142\":1}}],[\"初始化数组\",{\"1\":{\"549\":1}}],[\"初始化时\",{\"1\":{\"536\":1}}],[\"初始化线程池\",{\"1\":{\"447\":1}}],[\"初始化及其在内存中的管理\",{\"1\":{\"190\":1}}],[\"初始化阶段是类的主动使用阶段\",{\"1\":{\"188\":1}}],[\"初始化\",{\"0\":{\"188\":1},\"1\":{\"117\":1,\"180\":1,\"183\":1,\"441\":1}}],[\"初始化零值\",{\"1\":{\"117\":1}}],[\"现有采用\",{\"1\":{\"637\":1}}],[\"现有智能变电站的通信规约主要有ft3规约\",{\"1\":{\"637\":1}}],[\"现有智能变电站\",{\"0\":{\"637\":1}}],[\"现有智能变电站中高级应用功能一般有哪些\",{\"0\":{\"630\":1}}],[\"现有的智能变电站\",{\"0\":{\"627\":1},\"1\":{\"627\":1}}],[\"现有的智能变电站一般是以采用iec\",{\"1\":{\"625\":1}}],[\"现在\",{\"1\":{\"578\":1}}],[\"现在位置=原先位置+oldcap\",{\"1\":{\"542\":1}}],[\"现在位置=原先位置\",{\"1\":{\"542\":1}}],[\"现代处理器采用了指令级并行技术\",{\"1\":{\"319\":1}}],[\"现代化的java应用\",{\"1\":{\"151\":1}}],[\"现象指的是在执行垃圾回收时\",{\"1\":{\"138\":1}}],[\"优先级队列根据元素的优先级来决定元素的顺序\",{\"1\":{\"450\":1}}],[\"优先级队列\",{\"1\":{\"450\":1}}],[\"优先级等属性\",{\"1\":{\"448\":1}}],[\"优雅关闭\",{\"1\":{\"446\":1}}],[\"优点\",{\"1\":{\"151\":3,\"287\":1}}],[\"优化了结构设计\",{\"1\":{\"632\":1,\"633\":1}}],[\"优化六大要求的主要措施\",{\"1\":{\"630\":1}}],[\"优化资产的利用\",{\"1\":{\"622\":1}}],[\"优化算法\",{\"1\":{\"479\":1}}],[\"优化\",{\"1\":{\"173\":1,\"622\":1}}],[\"优化后的代码\",{\"0\":{\"173\":1}}],[\"优化对象的生命周期\",{\"1\":{\"87\":1}}],[\"优化代码和算法\",{\"1\":{\"81\":1}}],[\"优化垃圾回收策略\",{\"1\":{\"81\":1}}],[\"曾广泛用于响应时间要求高的应用\",{\"1\":{\"151\":1}}],[\"虽然电容式电压互感器同样采用分压原理将一次设备的高电压u1降低到一定程度\",{\"1\":{\"632\":1}}],[\"虽然电阻分压式电压互感器与常规电容式电压互感器都是采用分压原理的电压互感器\",{\"1\":{\"632\":1}}],[\"虽然我们可以基于ubuntu基础镜像\",{\"1\":{\"593\":1}}],[\"虽然解决了不同应用的兼容问题\",{\"1\":{\"560\":1}}],[\"虽然以上方法可以破坏双亲委派机制\",{\"1\":{\"219\":1}}],[\"虽然这是jvm在底层进行的优化\",{\"1\":{\"173\":1}}],[\"虽然java对象通常分配在堆中\",{\"1\":{\"168\":1}}],[\"虽然cms在降低停顿时间方面表现优秀\",{\"1\":{\"149\":1}}],[\"虽然可以通过\",{\"1\":{\"113\":1}}],[\"还应对电压切换回路\",{\"1\":{\"644\":1}}],[\"还必须增加功能强大的光纤网络通信软件\",{\"1\":{\"631\":1}}],[\"还额外有cas操作的开销\",{\"1\":{\"491\":1}}],[\"还可以节省内存空间\",{\"1\":{\"518\":1}}],[\"还可以利用图形化工具\",{\"1\":{\"513\":1}}],[\"还可以存活60秒\",{\"1\":{\"458\":1}}],[\"还可以接受callable接口类型的任务作为参数\",{\"1\":{\"451\":1}}],[\"还需要考虑任务的执行时间\",{\"1\":{\"453\":1}}],[\"还提供了join\",{\"1\":{\"351\":1}}],[\"还能确保线程安全\",{\"1\":{\"309\":1}}],[\"还是引用传递\",{\"0\":{\"306\":1}}],[\"还会通过\",{\"1\":{\"269\":1}}],[\"还有什么其它办法\",{\"0\":{\"337\":1}}],[\"还有编译器\",{\"1\":{\"247\":1}}],[\"还有许多可视化工具可以用于性能监控和故障处理\",{\"1\":{\"57\":1}}],[\"还支持并行回收\",{\"1\":{\"148\":1}}],[\"碎片化会导致分配大对象时频繁触发full\",{\"1\":{\"147\":1}}],[\"碎片化问题\",{\"1\":{\"139\":1}}],[\"毫秒\",{\"1\":{\"144\":1}}],[\"涉及将存活对象从一个区域复制到另一个区域\",{\"1\":{\"142\":1}}],[\"涉及的是字面值\",{\"1\":{\"106\":1}}],[\"遍历node数组\",{\"1\":{\"549\":1}}],[\"遍历hashentry\",{\"1\":{\"548\":1}}],[\"遍历hashmap的几种方法\",{\"0\":{\"292\":1}}],[\"遍历链表查找\",{\"1\":{\"532\":1}}],[\"遍历下一个元素之前\",{\"1\":{\"520\":1}}],[\"遍历完成之后\",{\"1\":{\"334\":1}}],[\"遍历对象图\",{\"1\":{\"142\":1}}],[\"遍历整个对象图\",{\"1\":{\"139\":1}}],[\"扫描在初始标记阶段确定的根区域\",{\"1\":{\"142\":1}}],[\"一对多的关联查询吗\",{\"0\":{\"768\":1}}],[\"一级缓存是sqlsession级别的缓存\",{\"1\":{\"656\":1}}],[\"一定程度上也避免了电场干扰对二次控制设备影响\",{\"1\":{\"625\":1}}],[\"一切应用最终都是代码组成\",{\"1\":{\"565\":1}}],[\"一直不成功\",{\"1\":{\"506\":1}}],[\"一直找到\",{\"1\":{\"333\":1}}],[\"一般情况下\",{\"1\":{\"638\":1}}],[\"一般情况下由顺控操作\",{\"1\":{\"630\":1}}],[\"一般跟finally配合释放锁\",{\"1\":{\"495\":1}}],[\"一般是lock\",{\"1\":{\"495\":1}}],[\"一般适用于连接数较多且连接时间较长的应用\",{\"1\":{\"238\":1}}],[\"一次只能被一个线程拥有\",{\"1\":{\"488\":1}}],[\"一次编译\",{\"1\":{\"248\":1}}],[\"一开始会创建一定数量的线程\",{\"1\":{\"454\":1}}],[\"一旦创建\",{\"1\":{\"656\":1}}],[\"一旦创建就不能修改其值\",{\"1\":{\"268\":1}}],[\"一旦完成数据卷挂载\",{\"1\":{\"582\":1}}],[\"一旦超出这个范围就不再有效\",{\"1\":{\"300\":1}}],[\"一旦应用加载了大量类或使用了大量字符串常量\",{\"1\":{\"113\":1}}],[\"一个mybatis应用通常会有多个不同的运行环境\",{\"1\":{\"656\":1}}],[\"一个基于docker\",{\"1\":{\"595\":1}}],[\"一个基于mysql\",{\"1\":{\"595\":1}}],[\"一个镜像托管的服务器\",{\"1\":{\"568\":1}}],[\"一个镜像可以运行多个容器\",{\"1\":{\"568\":1}}],[\"一个任务一个任务地执行\",{\"1\":{\"459\":1}}],[\"一个用于在两个线程之间交换数据的同步点\",{\"1\":{\"362\":1}}],[\"一个共享变量上可能会有多个线程在等待\",{\"1\":{\"344\":1}}],[\"一个线程使用共享方式获取了资源\",{\"1\":{\"496\":1}}],[\"一个线程使用独占方式获取了资源\",{\"1\":{\"496\":1}}],[\"一个线程执行任务\",{\"1\":{\"459\":1}}],[\"一个线程生成任务\",{\"1\":{\"360\":1}}],[\"一个线程a调用共享对象的\",{\"1\":{\"344\":1}}],[\"一个线程中的每个操作\",{\"1\":{\"320\":1}}],[\"一个进程中至少有一个线程\",{\"1\":{\"340\":1}}],[\"一个进程中有多个线程\",{\"1\":{\"340\":1}}],[\"一个table数组\",{\"1\":{\"332\":1}}],[\"一个变量被声明为volatile时\",{\"1\":{\"323\":1}}],[\"一个抽象概念\",{\"1\":{\"315\":1}}],[\"一个对象的\",{\"1\":{\"303\":1}}],[\"一个类不管创建多少个对象\",{\"1\":{\"301\":1}}],[\"一个类可以实现多个接口\",{\"1\":{\"299\":1}}],[\"一个类在java虚拟机\",{\"1\":{\"183\":1}}],[\"一个或两个\",{\"1\":{\"269\":1}}],[\"一个方法\",{\"1\":{\"243\":1}}],[\"一些java应用服务器\",{\"1\":{\"219\":1}}],[\"一些基于java的模块化开发框架\",{\"1\":{\"218\":1}}],[\"一致性和高效性\",{\"1\":{\"207\":1}}],[\"一部分需要stw\",{\"1\":{\"142\":1}}],[\"一起执行\",{\"1\":{\"142\":1}}],[\"传输到接收方的数据都带有自我说明\",{\"1\":{\"636\":1}}],[\"传输系统用光纤\",{\"1\":{\"635\":1}}],[\"传输容量更大\",{\"1\":{\"625\":1}}],[\"传智教育欢迎您\",{\"1\":{\"579\":2}}],[\"传的不是2的倍数时\",{\"1\":{\"536\":1}}],[\"传一个17的值\",{\"0\":{\"536\":1}}],[\"传递性\",{\"1\":{\"320\":1}}],[\"传递的是该引用的副本\",{\"1\":{\"306\":1}}],[\"传递的是该值的副本\",{\"1\":{\"306\":1}}],[\"传统方法通常分为年轻代收集和老年代收集\",{\"1\":{\"141\":1}}],[\"传送门\",{\"1\":{\"1\":1}}],[\"混合回收\",{\"1\":{\"141\":1}}],[\"根节点是黑色的\",{\"1\":{\"527\":1}}],[\"根节点和叶子节点\",{\"1\":{\"527\":1}}],[\"根区域扫描\",{\"1\":{\"141\":1,\"142\":1}}],[\"根据智能电网的六大要求\",{\"1\":{\"630\":1}}],[\"根据继电保护采样跳闸方式的不同\",{\"1\":{\"627\":1}}],[\"根据命令后跟随的command来确定下一步的操作\",{\"1\":{\"583\":1}}],[\"根据查看到的镜像名称\",{\"1\":{\"573\":1}}],[\"根据哈希值计算下标\",{\"1\":{\"531\":1}}],[\"根据任务执行日志来回滚已经执行成功但未持久化的任务\",{\"1\":{\"478\":1}}],[\"根据实际情况动态调整线程池的配置\",{\"1\":{\"476\":1}}],[\"根据需要创建新线程的线程池\",{\"1\":{\"406\":1}}],[\"根据类的全限定名查找和读取相应的字节码文件\",{\"1\":{\"195\":1}}],[\"根据逃逸分析的结果\",{\"1\":{\"164\":1}}],[\"根据测量结果\",{\"1\":{\"160\":1}}],[\"根据对象的存活周期将java堆划分为新生代和老年代两个部分\",{\"1\":{\"131\":1}}],[\"根据对象的引用强度和生命周期的不同\",{\"1\":{\"128\":1}}],[\"根据堆栈信息定位到可能的问题代码段\",{\"1\":{\"90\":1}}],[\"根据堆栈信息\",{\"1\":{\"90\":1}}],[\"根据监控数据和反馈信息\",{\"1\":{\"83\":1}}],[\"根据制定的调优策略修改jvm的配置参数\",{\"1\":{\"82\":1}}],[\"根据应用程序的内存使用模式和性能需求调整垃圾回收器的参数\",{\"1\":{\"81\":1}}],[\"根据应用程序的内存使用情况和性能需求调整堆大小\",{\"1\":{\"81\":1}}],[\"根据应用程序的特性和性能需求选择合适的垃圾回收器\",{\"1\":{\"81\":1}}],[\"根据性能问题的严重程度和影响范围确定调优的重点和优先级\",{\"1\":{\"80\":1}}],[\"根据具体需求\",{\"1\":{\"70\":1}}],[\"目录挂载耦合度高\",{\"1\":{\"588\":1}}],[\"目录挂载与数据卷挂载的语法是类似的\",{\"1\":{\"587\":1}}],[\"目录下的配置文件\",{\"1\":{\"252\":1}}],[\"目录下\",{\"1\":{\"252\":2}}],[\"目标\",{\"1\":{\"575\":1}}],[\"目标是实现高吞吐量与低停顿时间之间的平衡\",{\"1\":{\"140\":1}}],[\"目前用于智能变电站\",{\"0\":{\"635\":1},\"1\":{\"635\":1}}],[\"目前无法直接保证操作的原子性的\",{\"1\":{\"508\":1}}],[\"目前主流的访问方式有使用句柄和直接指针两种\",{\"1\":{\"122\":1}}],[\"目的是为了写出通用的代码\",{\"1\":{\"294\":1}}],[\"旨在提高性能并优化资源使用\",{\"1\":{\"402\":1}}],[\"旨在替代cms\",{\"1\":{\"140\":1}}],[\"旨在最小化应用程序的停顿时间\",{\"1\":{\"139\":1}}],[\"尽可能的少的分配线程\",{\"1\":{\"457\":1}}],[\"尽管都是继电和保护测控装置测量一次设备电流的主要设备\",{\"1\":{\"633\":1}}],[\"尽管字节流可以处理所有类型的数据\",{\"1\":{\"237\":1}}],[\"尽管cms\",{\"1\":{\"146\":1}}],[\"尽管cms降低了停顿时间\",{\"1\":{\"139\":1}}],[\"尽量减少垃圾收集对应用程序的影响\",{\"1\":{\"139\":1}}],[\"尽量减少对象的生命周期\",{\"1\":{\"87\":1}}],[\"算法进行full\",{\"1\":{\"147\":1}}],[\"算法\",{\"1\":{\"139\":1,\"148\":1}}],[\"安其拉\",{\"1\":{\"353\":4}}],[\"安全\",{\"1\":{\"621\":1}}],[\"安全失败\",{\"1\":{\"520\":1}}],[\"安全问题\",{\"1\":{\"326\":1}}],[\"安全性和可靠性\",{\"1\":{\"267\":1}}],[\"安全性\",{\"1\":{\"207\":1}}],[\"安全性等功能的关键组件\",{\"1\":{\"181\":1}}],[\"安全性管理\",{\"1\":{\"178\":1}}],[\"安全点\",{\"1\":{\"138\":1}}],[\"安装jdk\",{\"1\":{\"592\":1}}],[\"安装dockercompose\",{\"0\":{\"596\":1}}],[\"安装docker\",{\"0\":{\"569\":1}}],[\"安装依赖\",{\"1\":{\"11\":1}}],[\"安装pnpm\",{\"1\":{\"9\":1}}],[\"安装nodejs\",{\"1\":{\"9\":1}}],[\"z\",{\"1\":{\"137\":1,\"151\":1,\"159\":1,\"244\":2}}],[\"zgc适合需要极低停顿时间和处理超大堆内存的应用\",{\"1\":{\"156\":1}}],[\"zgc的自动管理和优化能力强\",{\"1\":{\"154\":1}}],[\"zgc的设计目标是实现极低的停顿时间\",{\"1\":{\"154\":1}}],[\"zgc能够处理数tb的堆内存\",{\"1\":{\"154\":1}}],[\"zgc是一种低延迟的垃圾收集器\",{\"1\":{\"137\":1}}],[\"zgc\",{\"1\":{\"137\":1,\"151\":1,\"159\":1}}],[\"zh\",{\"1\":{\"17\":1}}],[\"知道最后一个线程达到屏障点\",{\"1\":{\"355\":1}}],[\"知道有哪些垃圾收集器吗\",{\"0\":{\"137\":1}}],[\"知道了问题就容易解决了\",{\"1\":{\"84\":1}}],[\"年龄大于或等于该年龄的对象就可以直接进入老年代\",{\"1\":{\"136\":1}}],[\"年轻代大小\",{\"1\":{\"81\":1}}],[\"占用部分资源的线程进一步申请其他资源时\",{\"1\":{\"512\":1}}],[\"占用大量连续内存空间的对象\",{\"1\":{\"136\":1}}],[\"占个位\",{\"0\":{\"3\":1},\"1\":{\"3\":1}}],[\"手动调用system\",{\"1\":{\"135\":1}}],[\"空心线圈往往由漆包线均匀绕制在环形骨架上制成\",{\"1\":{\"635\":1}}],[\"空心线圈电流互感器\",{\"1\":{\"635\":1}}],[\"空位比较多的时候就扩容了\",{\"1\":{\"541\":1}}],[\"空位比较少的时候才扩容\",{\"1\":{\"541\":1}}],[\"空间成本就增加了\",{\"1\":{\"541\":1}}],[\"空间\",{\"1\":{\"541\":1}}],[\"空间分配担保\",{\"1\":{\"136\":1}}],[\"空间分配担保失败\",{\"1\":{\"135\":1}}],[\"空闲核心线程执行任务\",{\"1\":{\"444\":1,\"447\":1}}],[\"空闲线程在被终止前等待新任务的最长时间\",{\"1\":{\"448\":1}}],[\"空闲线程存活时间\",{\"1\":{\"442\":1}}],[\"空闲线程的存活时间\",{\"1\":{\"408\":1}}],[\"空闲列表适用于\",{\"1\":{\"118\":1}}],[\"空闲列表\",{\"1\":{\"118\":2}}],[\"什么也不写\",{\"1\":{\"297\":1}}],[\"什么时候会触发full\",{\"0\":{\"135\":1}}],[\"什么是通信规约\",{\"0\":{\"637\":1}}],[\"什么是智能变电站\",{\"0\":{\"623\":1}}],[\"什么是智能电网\",{\"0\":{\"621\":1}}],[\"什么是数据卷\",{\"0\":{\"582\":1}}],[\"什么是docker\",{\"0\":{\"558\":1}}],[\"什么是红黑树\",{\"0\":{\"527\":1}}],[\"什么是cas\",{\"0\":{\"502\":1}}],[\"什么是线程池\",{\"0\":{\"402\":1}}],[\"什么是线程上下文切换\",{\"0\":{\"348\":1}}],[\"什么是深拷贝和浅拷贝\",{\"0\":{\"307\":1}}],[\"什么是hashcode\",{\"1\":{\"305\":1}}],[\"什么是泛型擦除\",{\"0\":{\"287\":1}}],[\"什么是泛型\",{\"0\":{\"284\":1}}],[\"什么是反序列化\",{\"0\":{\"276\":1}}],[\"什么是反射\",{\"0\":{\"254\":1}}],[\"什么是序列化\",{\"0\":{\"276\":1}}],[\"什么是integer缓存\",{\"1\":{\"272\":1}}],[\"什么是自动拆箱\",{\"0\":{\"260\":1}}],[\"什么是自动类型转换\",{\"0\":{\"259\":1}}],[\"什么是字节码\",{\"0\":{\"249\":1}}],[\"什么是双亲委派机制\",{\"0\":{\"205\":1}}],[\"什么是jvm\",{\"0\":{\"177\":1}}],[\"什么是安全点\",{\"0\":{\"138\":1}}],[\"什么是\",{\"0\":{\"138\":1,\"655\":1,\"658\":1,\"665\":1,\"670\":1,\"681\":1,\"692\":1,\"701\":1}}],[\"什么是stop\",{\"0\":{\"138\":1}}],[\"什么是内存溢出\",{\"0\":{\"123\":1}}],[\"什么是tlab\",{\"0\":{\"119\":1}}],[\"什么是空闲列表\",{\"0\":{\"118\":1}}],[\"什么是指针碰撞\",{\"0\":{\"118\":1}}],[\"新建一个空的目录\",{\"1\":{\"593\":1}}],[\"新建一个空文件夹docker\",{\"1\":{\"592\":1}}],[\"新建线程执行任务\",{\"1\":{\"459\":1}}],[\"新hash值保留了高低位的特征\",{\"1\":{\"534\":1}}],[\"新任务将在任务队列中等待\",{\"1\":{\"455\":2}}],[\"新任务将被拒绝\",{\"1\":{\"450\":1}}],[\"新任务会被拒绝\",{\"1\":{\"450\":1}}],[\"新任务会触发创建额外的线程\",{\"1\":{\"448\":1}}],[\"新任务也可以被放入队列等待执行\",{\"1\":{\"450\":1}}],[\"新类的定义可以增加新的属性或新的方法\",{\"1\":{\"295\":1}}],[\"新的任务会被放入一个队列中等待执行\",{\"1\":{\"403\":1}}],[\"新的api解决了旧的date和calendar类在处理日期和时间时的一些问题\",{\"1\":{\"240\":1}}],[\"新的日期和时间api\",{\"1\":{\"240\":1}}],[\"新对象通常会被分配到eden区\",{\"1\":{\"134\":1}}],[\"新生代的一部分\",{\"1\":{\"134\":1}}],[\"新生代的垃圾回收可以避免内存碎片的产生\",{\"1\":{\"132\":1}}],[\"新生代垃圾回收\",{\"1\":{\"132\":1}}],[\"新生代通常使用复制算法\",{\"1\":{\"131\":1}}],[\"新生代通常被划分为三个区域\",{\"1\":{\"130\":1,\"132\":1}}],[\"新生代是java堆的一部分\",{\"1\":{\"130\":1,\"132\":1}}],[\"新生代\",{\"1\":{\"130\":1}}],[\"新生代又可以进一步划分为伊甸园区\",{\"1\":{\"92\":1}}],[\"新生代和老年代分别采用了哪些垃圾收集器\",{\"1\":{\"88\":1}}],[\"新生代和老年代的大小\",{\"1\":{\"88\":1}}],[\"被窃取任务线程永远从双端队列的头部拿\",{\"1\":{\"480\":1}}],[\"被销毁\",{\"1\":{\"458\":1}}],[\"被垃圾回收器回收了\",{\"1\":{\"329\":1}}],[\"被定义出来屏蔽各种硬件和操作系统的内存访问差异\",{\"1\":{\"315\":1}}],[\"被调用不一定会立即回收该对象\",{\"1\":{\"303\":1}}],[\"被final修饰的变量必须被显式第指定初始值\",{\"1\":{\"302\":1}}],[\"被final修饰的变量不可变\",{\"1\":{\"302\":1}}],[\"被final修饰的方法不可以被重写\",{\"1\":{\"302\":1}}],[\"被final修饰的类不可以被继承\",{\"1\":{\"302\":1}}],[\"被\",{\"1\":{\"276\":1}}],[\"被推荐使用的做法\",{\"1\":{\"243\":1}}],[\"被自定义类加载器重复加载或篡改\",{\"1\":{\"207\":1}}],[\"被新对象填满时\",{\"1\":{\"134\":1}}],[\"被取出并赋值给局部变量\",{\"1\":{\"108\":1}}],[\"该标准定义了采用设备名\",{\"1\":{\"636\":1}}],[\"该如何避免死锁呢\",{\"1\":{\"512\":1}}],[\"该如何避免\",{\"0\":{\"512\":1}}],[\"该状态达到阈值40则执行批量撤销\",{\"1\":{\"493\":1}}],[\"该状态达到阈值20则执行批量重偏向\",{\"1\":{\"493\":1}}],[\"该状态不同于\",{\"1\":{\"345\":1}}],[\"该线程将被终止\",{\"1\":{\"445\":1}}],[\"该方法返回一个包装后的线程安全list\",{\"1\":{\"521\":1}}],[\"该方法会阻塞\",{\"1\":{\"362\":1}}],[\"该方法如果发现当前线程被中断\",{\"1\":{\"344\":1}}],[\"该实例也无法被垃圾回收\",{\"1\":{\"331\":1}}],[\"该引⽤变量发出的⽅法调⽤到底是哪个类中实现的⽅法\",{\"1\":{\"295\":1}}],[\"该对象又不需要被回收了\",{\"1\":{\"303\":1}}],[\"该对象被回收的时候被调用\",{\"1\":{\"303\":1}}],[\"该对象包含了类的名称\",{\"1\":{\"256\":1}}],[\"该对象就被认为是存活的\",{\"1\":{\"126\":1}}],[\"该文件包含了全站智能组件的全部信息及各智能组件之间的通信信息\",{\"1\":{\"638\":1}}],[\"该文件包含了服务接口的实现类的全限定名\",{\"1\":{\"252\":1}}],[\"该文件描述ied提供的基本数据模型及服务\",{\"1\":{\"638\":1}}],[\"该文件位于\",{\"1\":{\"252\":1}}],[\"该阶段和应用线程并发运行\",{\"1\":{\"142\":1}}],[\"该算法将内存空间分为两个相等大小的区域\",{\"1\":{\"132\":1}}],[\"增删速率\",{\"1\":{\"515\":1}}],[\"增加\",{\"1\":{\"520\":1}}],[\"增加了过程层接口插件一块\",{\"1\":{\"631\":1}}],[\"增加了一些高级功能\",{\"1\":{\"495\":1}}],[\"增加了适应性自旋\",{\"1\":{\"495\":1}}],[\"增加了系统调用的开销\",{\"1\":{\"413\":1}}],[\"增加堆内存的大小\",{\"1\":{\"87\":1}}],[\"增量为\",{\"1\":{\"332\":1}}],[\"增量式垃圾收集算法将垃圾回收过程分解成多个阶段\",{\"1\":{\"131\":1}}],[\"增量式垃圾收集算法\",{\"1\":{\"131\":1}}],[\"弱电转换方式将隔离开关\",{\"1\":{\"639\":1}}],[\"弱\",{\"1\":{\"627\":1}}],[\"弱分代假设\",{\"1\":{\"131\":1}}],[\"弱引用很容易被回收\",{\"1\":{\"329\":1}}],[\"弱引用可以防止内存泄漏\",{\"1\":{\"128\":1}}],[\"弱引用都会被回收\",{\"1\":{\"128\":1}}],[\"弱引用的生命周期比软引用更短\",{\"1\":{\"128\":1}}],[\"弱引用\",{\"1\":{\"128\":1,\"329\":1}}],[\"整体的吞吐效率高\",{\"1\":{\"499\":1}}],[\"整数类型\",{\"1\":{\"258\":1}}],[\"整理\",{\"1\":{\"147\":1}}],[\"整理和清理来实现高吞吐和低停顿\",{\"1\":{\"137\":1}}],[\"整理算法结合了标记\",{\"1\":{\"131\":1}}],[\"整理算法\",{\"1\":{\"131\":2,\"137\":2}}],[\"整合jrockit功能\",{\"1\":{\"114\":1,\"116\":1}}],[\"复制原数组元素到新数组\",{\"1\":{\"516\":1}}],[\"复制成功之后\",{\"1\":{\"494\":1}}],[\"复制和压缩回收\",{\"1\":{\"153\":1}}],[\"复制\",{\"1\":{\"142\":1,\"148\":1}}],[\"复制的开销较小\",{\"1\":{\"131\":1}}],[\"复制算法和多线程并行的方式实现高吞吐量的垃圾收集\",{\"1\":{\"137\":1}}],[\"复制算法适用于新生代的垃圾回收\",{\"1\":{\"131\":1}}],[\"复制算法将内存空间划分为两个相等大小的区域\",{\"1\":{\"131\":1}}],[\"复制算法\",{\"1\":{\"131\":1,\"137\":2}}],[\"容器不仅仅可以挂载数据卷\",{\"1\":{\"587\":1}}],[\"容器数据管理\",{\"0\":{\"581\":1}}],[\"容器内文\",{\"1\":{\"588\":1}}],[\"容器内文件\",{\"1\":{\"581\":1,\"587\":1}}],[\"容器内目录\",{\"1\":{\"587\":3,\"588\":2}}],[\"容器内没有vi命令\",{\"1\":{\"579\":1}}],[\"容器内部会模拟一个独立的linux文件系统\",{\"1\":{\"579\":1}}],[\"容器是隔离环境\",{\"1\":{\"578\":1}}],[\"容器保护三个状态\",{\"1\":{\"577\":1}}],[\"容器相关命令\",{\"0\":{\"577\":1}}],[\"容器操作的命令如图\",{\"1\":{\"577\":1}}],[\"容器操作\",{\"0\":{\"576\":1}}],[\"容器等\",{\"1\":{\"567\":1}}],[\"容器呢\",{\"1\":{\"565\":1}}],[\"容器\",{\"1\":{\"565\":1,\"567\":1,\"568\":1}}],[\"容器图\",{\"0\":{\"41\":1}}],[\"容易出现兼容性问题\",{\"1\":{\"559\":1}}],[\"容易导致内存分配失败\",{\"1\":{\"131\":1}}],[\"容量大小为原数组1\",{\"1\":{\"516\":1}}],[\"释放它们持有的资源\",{\"1\":{\"513\":1}}],[\"释放它们所占用的内存空间\",{\"1\":{\"131\":1}}],[\"释放多少次\",{\"1\":{\"496\":1}}],[\"释放资源的时候\",{\"1\":{\"496\":1}}],[\"释放资源等\",{\"1\":{\"129\":1}}],[\"释放锁并进入等待队列\",{\"1\":{\"400\":1}}],[\"释放许可\",{\"1\":{\"357\":1}}],[\"释放出连续的内存空间\",{\"1\":{\"131\":1}}],[\"应尽量减少线程上下文切换的次数\",{\"1\":{\"348\":1}}],[\"应谨慎使用\",{\"1\":{\"129\":1}}],[\"应用于变电站通信网络和系统的国际标准\",{\"1\":{\"636\":1}}],[\"应用于计算机交互的流程如下\",{\"1\":{\"561\":1}}],[\"应用过滤条件\",{\"1\":{\"616\":1}}],[\"应用调用操作系统应用\",{\"1\":{\"561\":1}}],[\"应用部署的环境问题\",{\"0\":{\"559\":1}}],[\"应用场景\",{\"1\":{\"357\":1,\"363\":1}}],[\"应用服务器\",{\"0\":{\"219\":1}}],[\"应用类型\",{\"1\":{\"158\":1}}],[\"应用线程和垃圾收集线程并发运行\",{\"1\":{\"139\":1}}],[\"应用程序可以复用一组数据库连接\",{\"1\":{\"427\":1}}],[\"应用程序可以在不修改源代码的情况下\",{\"1\":{\"252\":1}}],[\"应用程序可以在缓冲区中读取或写入数据\",{\"1\":{\"238\":1}}],[\"应用程序定义一个接口\",{\"1\":{\"252\":1}}],[\"应用程序\",{\"1\":{\"238\":1}}],[\"应用程序类加载器\",{\"0\":{\"201\":1},\"1\":{\"207\":1}}],[\"应用程序偶尔会耗尽连接对象\",{\"1\":{\"89\":1}}],[\"应用程序抛出\",{\"1\":{\"89\":1}}],[\"应用程序长时间连续运行时性能严重下降\",{\"1\":{\"89\":1}}],[\"应用\",{\"1\":{\"67\":1}}],[\"应用性能管理和业务监控\",{\"1\":{\"70\":1}}],[\"应用性能管理和业务监控工具\",{\"1\":{\"66\":1}}],[\"应用性能管理\",{\"1\":{\"65\":1,\"70\":1}}],[\"推送镜像\",{\"1\":{\"604\":1}}],[\"推送镜像到私有镜像服务必须先tag\",{\"1\":{\"604\":1}}],[\"推送\",{\"0\":{\"604\":1}}],[\"推送新分支到github\",{\"0\":{\"19\":1}}],[\"推荐使用静态内部类的原因主要有以下几个方面\",{\"1\":{\"309\":1}}],[\"推荐使用try\",{\"1\":{\"129\":1}}],[\"缺点是处于等待队列中的线程可能会饿死\",{\"1\":{\"499\":1}}],[\"缺点是整体吞吐效率相对非公平锁要低\",{\"1\":{\"498\":1}}],[\"缺点\",{\"1\":{\"129\":1,\"151\":3,\"287\":1,\"520\":1,\"522\":1}}],[\"同理\",{\"1\":{\"641\":1}}],[\"同一厂家同一型号和版本的设备的icd文件是相同的\",{\"1\":{\"638\":1}}],[\"同步是锁住的什么东西\",{\"1\":{\"485\":1}}],[\"同步移交队列是一种特殊的队列\",{\"1\":{\"450\":1}}],[\"同步移交队列\",{\"1\":{\"450\":1}}],[\"同步开销\",{\"0\":{\"416\":1}}],[\"同步屏障\",{\"0\":{\"354\":1}}],[\"同步非阻塞io\",{\"1\":{\"238\":1}}],[\"同步阻塞io\",{\"1\":{\"238\":1}}],[\"同步消除减少了不必要的锁开销\",{\"1\":{\"167\":1}}],[\"同步消除\",{\"1\":{\"164\":1}}],[\"同时还支持动态条件拼接和参数绑定等功能\",{\"1\":{\"656\":1}}],[\"同时其所有输出端口全部输出ⅰ母电压信号\",{\"1\":{\"641\":1}}],[\"同时其所有输出端口全部输出ⅱ母电压信号\",{\"1\":{\"641\":1}}],[\"同时吸收了很多先进的技术\",{\"1\":{\"636\":1}}],[\"同时\",{\"1\":{\"625\":1,\"630\":1}}],[\"同时也支持自定义typehandler来处理特定类型的转换\",{\"1\":{\"656\":1}}],[\"同时也减少了由于绝缘油绝缘性能下降对设备安全的影响\",{\"1\":{\"632\":1,\"633\":1}}],[\"同时也使采用功能强大的一次设备在线监测成为可能\",{\"1\":{\"625\":1}}],[\"同时也可以在创建锁构造函数中传入具体参数创建公平锁\",{\"1\":{\"501\":1}}],[\"同时可以包含\",{\"1\":{\"616\":1}}],[\"同时可以避免一些内存泄漏问题\",{\"1\":{\"128\":1}}],[\"同时该等待线程进入\",{\"1\":{\"485\":1}}],[\"同时具备延迟加载的特性\",{\"1\":{\"309\":1}}],[\"同时提供⼀些可以被外界访问的属性的⽅法\",{\"1\":{\"295\":1}}],[\"同时针对新生代和老年代进行回收\",{\"1\":{\"133\":1}}],[\"同时清空原来的eden区和使用过的survivor区\",{\"1\":{\"132\":1}}],[\"同时执行效率不稳定\",{\"1\":{\"131\":1}}],[\"同样是输出\",{\"1\":{\"89\":1}}],[\"虚引用的唯一目的是在对象被垃圾回收器回收时收到一个系统通知\",{\"1\":{\"128\":1}}],[\"虚引用是最弱的引用\",{\"1\":{\"128\":1}}],[\"虚引用\",{\"1\":{\"128\":1}}],[\"虚拟机体积大\",{\"1\":{\"563\":1}}],[\"虚拟机是在操作系统中的操作系统\",{\"1\":{\"563\":1}}],[\"虚拟机即时编译器在运行时\",{\"1\":{\"491\":1}}],[\"虚拟机内置的类加载器\",{\"1\":{\"234\":1}}],[\"虚拟机执行java字节码\",{\"1\":{\"249\":1}}],[\"虚拟机执行\",{\"0\":{\"182\":1}}],[\"虚拟机会执行垃圾回收操作\",{\"1\":{\"138\":1}}],[\"虚拟机栈\",{\"1\":{\"127\":1}}],[\"虚拟机栈中的引用\",{\"1\":{\"127\":1}}],[\"虚拟机栈溢出\",{\"1\":{\"124\":2}}],[\"虚拟机\",{\"1\":{\"119\":1,\"247\":1,\"563\":1}}],[\"强\",{\"1\":{\"627\":1}}],[\"强制终止一个或多个进程\",{\"1\":{\"513\":1}}],[\"强制关闭\",{\"1\":{\"446\":1}}],[\"强制类型转换\",{\"0\":{\"259\":1},\"1\":{\"259\":1}}],[\"强引用是最常见的引用类型\",{\"1\":{\"128\":1}}],[\"强引用\",{\"1\":{\"128\":1}}],[\"强大的预警和预防控制能力\",{\"1\":{\"622\":1}}],[\"强大的分布式追踪能力\",{\"1\":{\"69\":1,\"70\":1}}],[\"强大的日志搜索和分析能力\",{\"1\":{\"64\":1,\"70\":1}}],[\"强大的数据收集和查询能力\",{\"1\":{\"63\":1,\"70\":1}}],[\"反序列化\",{\"1\":{\"276\":1}}],[\"反射的实现原理\",{\"0\":{\"256\":1}}],[\"反射的应用场景\",{\"0\":{\"255\":1}}],[\"反射相关类\",{\"1\":{\"254\":1}}],[\"反射\",{\"0\":{\"253\":1},\"1\":{\"254\":1,\"274\":1}}],[\"反之就尾插法\",{\"1\":{\"549\":1}}],[\"反之\",{\"1\":{\"126\":1,\"259\":1,\"453\":1}}],[\"反编译java类\",{\"1\":{\"56\":1}}],[\"计量装置\",{\"1\":{\"640\":2}}],[\"计量装置等\",{\"1\":{\"628\":1}}],[\"计量等负载装置使用\",{\"1\":{\"632\":1}}],[\"计量采样等通过专用的网络实现独立于站控层网络\",{\"1\":{\"627\":1}}],[\"计量采样等所有功能\",{\"1\":{\"627\":1}}],[\"计量和监测等基本功能\",{\"1\":{\"623\":1}}],[\"计算机硬件\",{\"1\":{\"561\":1}}],[\"计算hash\",{\"1\":{\"548\":1}}],[\"计算数组下标\",{\"1\":{\"532\":1}}],[\"计算新数组容量\",{\"1\":{\"516\":1}}],[\"计算密集型\",{\"1\":{\"453\":1}}],[\"计算存活对象和各区域的存活数据\",{\"1\":{\"142\":1}}],[\"计数器就会\",{\"1\":{\"489\":1}}],[\"计数器\",{\"1\":{\"485\":1}}],[\"计数器减一\",{\"1\":{\"126\":1}}],[\"计数\",{\"1\":{\"244\":1}}],[\"计划将jrockit中的优秀功能\",{\"1\":{\"114\":1}}],[\"综上所述\",{\"1\":{\"125\":1,\"213\":1,\"232\":1,\"233\":1,\"451\":1,\"453\":1,\"478\":1,\"479\":1}}],[\"定值区切换\",{\"1\":{\"652\":1}}],[\"定值控制功能\",{\"1\":{\"652\":1}}],[\"定位到segment\",{\"1\":{\"548\":1}}],[\"定位到table中的位置\",{\"1\":{\"333\":1}}],[\"定期执行任务\",{\"1\":{\"440\":1}}],[\"定时数据同步等\",{\"1\":{\"455\":1}}],[\"定时备份数据库等\",{\"1\":{\"438\":1}}],[\"定时任务线程池用于执行定时任务和周期性任务\",{\"1\":{\"455\":1}}],[\"定时任务线程池\",{\"0\":{\"460\":1},\"1\":{\"455\":1}}],[\"定时任务\",{\"0\":{\"437\":1}}],[\"定时或周期性执行任务的线程池\",{\"1\":{\"406\":1}}],[\"定要记得使用remove方法来进行清除\",{\"1\":{\"125\":1}}],[\"定义mybatis的运行环境\",{\"1\":{\"656\":1}}],[\"定义sql语句和结果映射\",{\"1\":{\"656\":1}}],[\"定义了sql语句的参数映射规则\",{\"1\":{\"656\":1}}],[\"定义了结果集到java对象的映射规则\",{\"1\":{\"656\":1}}],[\"定义了对象之间的通信服务\",{\"1\":{\"636\":1}}],[\"定义了基于客户机\",{\"1\":{\"636\":1}}],[\"定义了变电站的信息分层结构\",{\"1\":{\"636\":1}}],[\"定义了服务的契约\",{\"1\":{\"252\":1}}],[\"定义三个异步任务\",{\"1\":{\"383\":1}}],[\"定义服务接口\",{\"1\":{\"252\":1}}],[\"定义在object类中\",{\"1\":{\"129\":1}}],[\"定义\",{\"1\":{\"103\":1,\"104\":1,\"344\":1,\"357\":1}}],[\"外部类的实例也无法被垃圾回收\",{\"1\":{\"125\":1}}],[\"外在病症表现可能有\",{\"1\":{\"89\":1}}],[\"静态内部类也具有明显的优势\",{\"1\":{\"313\":1}}],[\"静态内部类\",{\"0\":{\"312\":1},\"1\":{\"501\":1}}],[\"静态内部类实现方式\",{\"1\":{\"309\":1}}],[\"静态内部类常常用于实现单例模式中的\",{\"1\":{\"309\":1}}],[\"静态内部类在编译时不需要持有外部类的引用\",{\"1\":{\"309\":1}}],[\"静态内部类不依赖于外部类的实例\",{\"1\":{\"309\":1}}],[\"静态方法里不能访问类的非静态成员变量和方法\",{\"1\":{\"301\":1}}],[\"静态方法\",{\"0\":{\"301\":1},\"1\":{\"301\":1}}],[\"静态代码块执行\",{\"1\":{\"190\":2}}],[\"静态集合\",{\"1\":{\"125\":1}}],[\"静态变量可以实现让多个对象共享内存\",{\"1\":{\"301\":1}}],[\"静态变量在内存中有且仅有一个副本\",{\"1\":{\"301\":1}}],[\"静态变量在类被加载至数据区后\",{\"1\":{\"300\":1}}],[\"静态变量和实例变量的区别\",{\"0\":{\"301\":1}}],[\"静态变量存储在方法区\",{\"1\":{\"300\":1}}],[\"静态变量属于类的状态信息\",{\"1\":{\"276\":1}}],[\"静态变量初始化\",{\"1\":{\"190\":2}}],[\"静态变量\",{\"1\":{\"92\":1,\"114\":1,\"130\":1,\"300\":1,\"301\":1}}],[\"注入的情况吗\",{\"0\":{\"733\":1,\"753\":1}}],[\"注入攻击\",{\"0\":{\"670\":1,\"733\":1,\"753\":1}}],[\"注入\",{\"0\":{\"670\":1}}],[\"注解吗\",{\"0\":{\"700\":1}}],[\"注解是什么\",{\"0\":{\"700\":1}}],[\"注解生命周期\",{\"1\":{\"289\":1}}],[\"注解可以标记在类上\",{\"1\":{\"289\":1}}],[\"注解\",{\"0\":{\"288\":1}}],[\"注解的接口\",{\"1\":{\"242\":1}}],[\"注册回调处理结果\",{\"1\":{\"392\":1}}],[\"注册\",{\"1\":{\"238\":1}}],[\"注册了监听器或回调函数\",{\"1\":{\"125\":1}}],[\"注意事项\",{\"0\":{\"613\":1}}],[\"注意\",{\"1\":{\"89\":1,\"297\":2,\"520\":1,\"601\":1}}],[\"缓存查询结果\",{\"1\":{\"656\":1}}],[\"缓存结果和优化算法等策略\",{\"1\":{\"479\":1}}],[\"缓存结果\",{\"1\":{\"479\":1}}],[\"缓存线程池可以根据需要创建新线程\",{\"1\":{\"455\":1}}],[\"缓存线程池\",{\"0\":{\"395\":1,\"458\":1},\"1\":{\"455\":1}}],[\"缓存通常用于临时存储对象以提高访问速度\",{\"1\":{\"125\":1}}],[\"缓存导致的引用保留\",{\"1\":{\"125\":1}}],[\"未清理到任何数据\",{\"1\":{\"334\":1}}],[\"未规定此区域的具体数据结构\",{\"1\":{\"196\":1}}],[\"未及时释放资源\",{\"1\":{\"125\":1}}],[\"未来发展规划\",{\"1\":{\"114\":1}}],[\"递归调用自身\",{\"1\":{\"124\":1}}],[\"递归调用层次过深\",{\"1\":{\"123\":1}}],[\"甚至三开qq\",{\"1\":{\"565\":1}}],[\"甚至会有冲突\",{\"1\":{\"559\":1}}],[\"甚至还有可能触发扩容\",{\"1\":{\"515\":1}}],[\"甚至系统崩溃\",{\"1\":{\"123\":1}}],[\"甚至耗尽系统的可用内存\",{\"1\":{\"123\":1}}],[\"甚至到\",{\"1\":{\"89\":1}}],[\"句柄中包含了对象实例数据与类型数据各自具体的地址信息\",{\"1\":{\"122\":1}}],[\"句柄访问方式\",{\"1\":{\"122\":1}}],[\"引擎会根据指定的字段组合来检查重复\",{\"1\":{\"613\":1}}],[\"引⽤数据类型==比较的是内存地址\",{\"1\":{\"304\":1}}],[\"引入了双亲委派模型\",{\"1\":{\"222\":1}}],[\"引入了tlab\",{\"1\":{\"117\":1}}],[\"引导类加载器尝试加载核心java类库\",{\"1\":{\"206\":1}}],[\"引导类加载器尝试加载\",{\"1\":{\"206\":1}}],[\"引言\",{\"0\":{\"176\":1,\"365\":1,\"555\":1}}],[\"引用本类的构造函数\",{\"1\":{\"298\":1}}],[\"引用数据类型\",{\"1\":{\"258\":1,\"267\":1}}],[\"引用类型变量单独克隆\",{\"1\":{\"307\":1}}],[\"引用类型变量修改\",{\"1\":{\"307\":1}}],[\"引用类型默认为null\",{\"1\":{\"300\":1}}],[\"引用类型初始化为null\",{\"1\":{\"186\":1}}],[\"引用类型则存储指向实际对象数据的指针\",{\"1\":{\"121\":1}}],[\"引用\",{\"1\":{\"127\":1}}],[\"引用计数器就加一\",{\"1\":{\"126\":1}}],[\"引用计数\",{\"1\":{\"126\":2}}],[\"常用于web应用中\",{\"1\":{\"277\":2}}],[\"常用类\",{\"0\":{\"266\":1}}],[\"常见参数包括\",{\"1\":{\"408\":1}}],[\"常见垃圾收集器选项\",{\"0\":{\"159\":1}}],[\"常见的电磁式电流互感器是根据与变压器完全相同的电磁感应原理制造而成的\",{\"1\":{\"633\":1}}],[\"常见的镜像在dockerhub就能找到\",{\"1\":{\"588\":1}}],[\"常见的镜像操作命令如图\",{\"1\":{\"572\":1}}],[\"常见的同步移交队列包括synchronousqueue\",{\"1\":{\"450\":1}}],[\"常见的有界队列包括arrayblockingqueue\",{\"1\":{\"450\":1}}],[\"常见的无界队列包括linkedblockingqueue\",{\"1\":{\"450\":1}}],[\"常见的线程池包括以下几种\",{\"1\":{\"455\":1}}],[\"常见的线程池工作队列包括\",{\"1\":{\"450\":1}}],[\"常见的线程池类型\",{\"0\":{\"406\":1}}],[\"常见的任务队列包括有界队列\",{\"1\":{\"448\":1}}],[\"常见的拒绝策略包括抛出异常\",{\"1\":{\"444\":1,\"448\":1}}],[\"常见的阻塞队列有\",{\"1\":{\"400\":1}}],[\"常见的垃圾收集器\",{\"0\":{\"151\":1}}],[\"常见的垃圾收集器有cms\",{\"1\":{\"150\":1}}],[\"常见的内存溢出场景包括\",{\"1\":{\"123\":1}}],[\"常见的解决方案包括\",{\"1\":{\"120\":1}}],[\"常常使用g1或zgc来处理大规模服务和数据处理系统\",{\"1\":{\"155\":1}}],[\"常量池等\",{\"1\":{\"130\":1,\"195\":1}}],[\"常量表\",{\"1\":{\"104\":1}}],[\"常量\",{\"1\":{\"92\":1}}],[\"里面已经编写好了docker\",{\"1\":{\"597\":1,\"598\":1}}],[\"里面包含一个segment数组\",{\"1\":{\"548\":1}}],[\"里面的\",{\"1\":{\"282\":1}}],[\"里定义的方法\",{\"1\":{\"303\":1}}],[\"里不按套路出牌\",{\"1\":{\"282\":1}}],[\"里的\",{\"1\":{\"282\":1}}],[\"里\",{\"0\":{\"120\":1}}],[\"技术的使用可以减少多线程情况下的内存分配竞争\",{\"1\":{\"119\":1}}],[\"无非是系统应用不同\",{\"1\":{\"561\":1}}],[\"无锁化读取\",{\"1\":{\"549\":1}}],[\"无锁\",{\"1\":{\"492\":1,\"522\":1}}],[\"无界队列可以存储无限数量的任务\",{\"1\":{\"450\":1}}],[\"无界队列\",{\"1\":{\"450\":1}}],[\"无序\",{\"1\":{\"291\":1}}],[\"无需再操作系统上安装这些\",{\"1\":{\"560\":1}}],[\"无需复杂调优\",{\"1\":{\"151\":1,\"154\":1,\"159\":1}}],[\"无需进行同步操作\",{\"1\":{\"119\":1}}],[\"无论内存是否充足\",{\"1\":{\"128\":1}}],[\"无限循环创建对象等\",{\"1\":{\"123\":1}}],[\"无法直接修改\",{\"1\":{\"579\":1}}],[\"无法继续执行\",{\"1\":{\"346\":1}}],[\"无法避免子类覆盖父类加载方法的可能性\",{\"1\":{\"222\":1}}],[\"无法加载\",{\"1\":{\"206\":1}}],[\"无法被垃圾回收器回收\",{\"1\":{\"125\":1}}],[\"无法获得足够的内存空间\",{\"1\":{\"123\":1}}],[\"无法动态调整\",{\"1\":{\"113\":1}}],[\"区时\",{\"1\":{\"485\":1}}],[\"区别在于前者实现的是编译时的多态性\",{\"1\":{\"296\":1}}],[\"区别\",{\"0\":{\"269\":1,\"297\":1}}],[\"区别总结\",{\"0\":{\"105\":1}}],[\"区域控制\",{\"1\":{\"630\":1}}],[\"区域不够大或者无法分配时\",{\"1\":{\"119\":1}}],[\"区域中进行分配\",{\"1\":{\"119\":1}}],[\"区域内分配对象时\",{\"1\":{\"119\":1}}],[\"区域\",{\"1\":{\"119\":2}}],[\"能分享一些实际应用的经验吗\",{\"0\":{\"715\":1,\"736\":1}}],[\"能分享一些应用经验吗\",{\"0\":{\"707\":1}}],[\"能分享一些使用经验吗\",{\"0\":{\"696\":1}}],[\"能有效可靠地工作\",{\"1\":{\"634\":1}}],[\"能简单说一下线程池的工作流程吗\",{\"0\":{\"441\":1}}],[\"能说说工作中线程池的应用吗\",{\"0\":{\"420\":1}}],[\"能说一下concurrenthashmap的具体实现吗\",{\"0\":{\"547\":1}}],[\"能说一下hashmap的数据结构吗\",{\"0\":{\"525\":1}}],[\"能说一下线程池有几种状态吗\",{\"0\":{\"468\":1}}],[\"能说一下四种常见线程池的原理吗\",{\"0\":{\"456\":1}}],[\"能说一下类的生命周期吗\",{\"0\":{\"183\":1}}],[\"能说一下对象的内存布局吗\",{\"0\":{\"121\":1}}],[\"能说一下jvm的内存区域吗\",{\"0\":{\"92\":1}}],[\"能够将一组电流或一组电压数据扩展成多组输出\",{\"1\":{\"640\":1}}],[\"能够将电流采集器和电压采集器上送的ft3通信规约数据转换成标准的iec\",{\"1\":{\"640\":1}}],[\"能够根据一次设备的运行方式\",{\"1\":{\"640\":1}}],[\"能够根据应用的运行状况自动调整垃圾收集的行为和策略\",{\"1\":{\"148\":1}}],[\"能够检测自身所有光通道及开入\",{\"1\":{\"639\":1}}],[\"能够实现与用户的交互和高效互动\",{\"1\":{\"622\":1}}],[\"能够正确地工作并保持一致性\",{\"1\":{\"305\":1}}],[\"能够在执行代码前对其进行验证\",{\"1\":{\"178\":1}}],[\"能够高效地处理大堆内存中的垃圾\",{\"1\":{\"153\":1}}],[\"能够高效管理和回收大堆内存中的垃圾\",{\"1\":{\"148\":1}}],[\"能够自动调整行为以满足用户设定的停顿时间目标\",{\"1\":{\"145\":1}}],[\"能够有效地处理多线程环境下的堆内存分配问题\",{\"1\":{\"120\":1}}],[\"能高效管理和利用资源\",{\"1\":{\"143\":1}}],[\"能详细说一下cms收集器的垃圾收集过程吗\",{\"0\":{\"139\":1}}],[\"能手写内存溢出的例子吗\",{\"0\":{\"124\":1}}],[\"能更好地处理内存碎片化的情况\",{\"1\":{\"118\":1}}],[\"划分给对象实例\",{\"1\":{\"118\":1}}],[\"已经知道nginx的html目录所在位置\",{\"1\":{\"586\":1}}],[\"已经明示了它的原理\",{\"1\":{\"522\":1}}],[\"已经有了\",{\"1\":{\"333\":1}}],[\"已经被修改为\",{\"1\":{\"282\":1}}],[\"已被使用的内存和空闲的内存相互交错\",{\"1\":{\"118\":1}}],[\"已移出永久代\",{\"1\":{\"114\":1}}],[\"总不能为了某个玩家等到天荒地老\",{\"1\":{\"353\":1}}],[\"总之\",{\"1\":{\"129\":1,\"452\":1,\"652\":1}}],[\"总体而言\",{\"1\":{\"121\":1}}],[\"总的来说\",{\"1\":{\"117\":1,\"224\":1,\"400\":1}}],[\"总结来说\",{\"1\":{\"139\":1,\"181\":1}}],[\"总结\",{\"0\":{\"101\":1,\"110\":1,\"116\":1,\"145\":1,\"149\":1,\"156\":1,\"161\":1,\"168\":1,\"175\":1,\"313\":1,\"386\":1,\"619\":1},\"1\":{\"207\":1}}],[\"总结表格\",{\"0\":{\"70\":1}}],[\"会发现找不到或者不匹配\",{\"1\":{\"561\":1}}],[\"会发生链表和红黑树的不断转换\",{\"1\":{\"539\":1}}],[\"会调用内核指令\",{\"1\":{\"561\":1}}],[\"会遇到各种问题\",{\"1\":{\"558\":1}}],[\"会根据返回值是否为空来判断是否插入元素成功\",{\"1\":{\"554\":1}}],[\"会根据配置参数创建一定数量的核心线程\",{\"1\":{\"442\":1}}],[\"会带来一定的内存开销\",{\"1\":{\"522\":1}}],[\"会有一个自旋次数的限制\",{\"1\":{\"507\":1}}],[\"会给cpu带来非常大的执行开销\",{\"1\":{\"506\":1}}],[\"会使用cas操作将state修改为0\",{\"1\":{\"496\":1}}],[\"会使用locksupport\",{\"1\":{\"496\":1}}],[\"会作⽤于类的所有对象实例\",{\"1\":{\"482\":1}}],[\"会进入\",{\"1\":{\"472\":1,\"473\":1}}],[\"会不断地从任务队列中取出任务来执行\",{\"1\":{\"454\":1}}],[\"会将内存位置\",{\"1\":{\"502\":1}}],[\"会将其结果合并到大任务的结果中\",{\"1\":{\"480\":1}}],[\"会将异常包装在executionexception中重新抛出\",{\"1\":{\"451\":1}}],[\"会将该通道标记为就绪状态\",{\"1\":{\"238\":1}}],[\"会丢弃任务队列中最旧的任务\",{\"1\":{\"449\":1}}],[\"会默默地丢弃被拒绝的任务\",{\"1\":{\"449\":1}}],[\"会对热点代码进行优化\",{\"1\":{\"419\":1}}],[\"会对整个java堆进行回收\",{\"1\":{\"133\":1}}],[\"会抛出rejectedexecutionexception异常\",{\"1\":{\"449\":1}}],[\"会抛出\",{\"1\":{\"355\":1,\"359\":1,\"363\":1}}],[\"会继续往下执行\",{\"1\":{\"344\":1}}],[\"会唤醒一个在这个共享变量上调用\",{\"1\":{\"344\":1}}],[\"会先于\",{\"1\":{\"615\":1}}],[\"会先创建一条线程\",{\"1\":{\"342\":1}}],[\"会先去清理过期的entry\",{\"1\":{\"334\":1}}],[\"会先将\",{\"1\":{\"282\":1}}],[\"会先将请求委派给父类加载器\",{\"1\":{\"205\":1}}],[\"会在调用线程中直接执行被拒绝的任务\",{\"1\":{\"449\":1}}],[\"会在指令序列中插入内存屏障来禁止特定类型的处理器重排序\",{\"1\":{\"324\":1}}],[\"会在java堆内存中实例化一个java\",{\"1\":{\"196\":1}}],[\"会从主内存重新获取最新值\",{\"1\":{\"323\":1}}],[\"会从列表中找到一块足够大的空间\",{\"1\":{\"118\":1}}],[\"会影响原对象\",{\"1\":{\"307\":1}}],[\"会影响性能等\",{\"1\":{\"129\":1}}],[\"会写入\",{\"1\":{\"289\":2}}],[\"会返回之前暂存的结果\",{\"1\":{\"282\":1}}],[\"会返回一个指向新创建对象的引用\",{\"1\":{\"117\":1}}],[\"会比较序列化类的版本号和当前类的版本号是否一致\",{\"1\":{\"276\":1}}],[\"会产生大量的临时对象\",{\"1\":{\"268\":1}}],[\"会处理这个事件\",{\"1\":{\"238\":1}}],[\"会直接使用已加载的类\",{\"1\":{\"210\":1}}],[\"会直接进入老年代\",{\"1\":{\"136\":1}}],[\"会执行任务的run\",{\"1\":{\"454\":1}}],[\"会执行类构造器<clinit>\",{\"1\":{\"188\":1}}],[\"会执行以下步骤\",{\"1\":{\"117\":1}}],[\"会负责回收堆内存中的对象\",{\"1\":{\"163\":1}}],[\"会退化为单线程的标记\",{\"1\":{\"147\":1}}],[\"会逐渐晋升到老年代\",{\"1\":{\"136\":1}}],[\"会触发条件变量的通知操作\",{\"1\":{\"400\":1}}],[\"会触发full\",{\"1\":{\"135\":1}}],[\"会触发minor\",{\"1\":{\"134\":1}}],[\"会导致较长时间的应用程序暂停\",{\"1\":{\"133\":1}}],[\"会被加入\",{\"1\":{\"485\":1}}],[\"会被加入到\",{\"1\":{\"485\":1}}],[\"会被移动到老年代\",{\"1\":{\"132\":1}}],[\"会被垃圾回收器回收\",{\"1\":{\"128\":1}}],[\"会尝试为该线程重新分配更大的\",{\"1\":{\"119\":1}}],[\"会为其分配一个\",{\"1\":{\"119\":1}}],[\"返回类型等信息\",{\"1\":{\"656\":1}}],[\"返回\",{\"1\":{\"344\":1,\"351\":1,\"502\":2}}],[\"返回前先执行\",{\"1\":{\"282\":1}}],[\"返回值类型为\",{\"1\":{\"480\":1}}],[\"返回值类型\",{\"1\":{\"451\":1}}],[\"返回值是\",{\"1\":{\"244\":1}}],[\"返回值等\",{\"1\":{\"56\":1}}],[\"返回给子加载器\",{\"1\":{\"206\":1}}],[\"返回对象引用\",{\"1\":{\"117\":1}}],[\"准备执行下一个任务\",{\"1\":{\"445\":1}}],[\"准备处理数据并与生产者交换\",{\"1\":{\"362\":1}}],[\"准备阶段为类的静态变量分配内存空间\",{\"1\":{\"186\":1}}],[\"准备和解析三个阶段合称为连接\",{\"1\":{\"183\":1}}],[\"准备和解析步骤\",{\"1\":{\"180\":1}}],[\"准备\",{\"0\":{\"186\":1},\"1\":{\"117\":1,\"183\":1}}],[\"准备运行环境\",{\"0\":{\"9\":1}}],[\"验证阶段主要是对字节码文件进行验证\",{\"1\":{\"185\":1}}],[\"验证\",{\"0\":{\"185\":1},\"1\":{\"117\":1,\"183\":2,\"244\":2}}],[\"验证调优效果是否达到预期的目标性能指标\",{\"1\":{\"82\":1}}],[\"更迅速\",{\"1\":{\"630\":1}}],[\"更可靠\",{\"1\":{\"625\":1}}],[\"更高效\",{\"1\":{\"543\":1}}],[\"更高的回收效率\",{\"1\":{\"115\":1}}],[\"更多的是一种兜底的策略\",{\"1\":{\"539\":1}}],[\"更多对象分配在栈上或优化掉\",{\"1\":{\"167\":1}}],[\"更易于并行处理数据集合的方式\",{\"1\":{\"240\":1}}],[\"更新数据时\",{\"1\":{\"656\":1}}],[\"更新缓存等操作\",{\"1\":{\"656\":1}}],[\"更新详细语法说明\",{\"1\":{\"590\":1}}],[\"更新失败\",{\"1\":{\"494\":1}}],[\"更新成功\",{\"1\":{\"494\":1}}],[\"更新已加载类的实例\",{\"0\":{\"229\":1}}],[\"更新博客只在master分支上改\",{\"0\":{\"22\":1}}],[\"更好的大堆支持\",{\"1\":{\"148\":1}}],[\"更好的类加载和卸载支持\",{\"1\":{\"115\":1}}],[\"改进性能和内存管理\",{\"1\":{\"116\":1}}],[\"改进的性能和垃圾回收\",{\"1\":{\"115\":1}}],[\"改用元空间\",{\"1\":{\"114\":1}}],[\"简要描述一下它的执行流程\",{\"0\":{\"657\":1}}],[\"简称\",{\"1\":{\"496\":1}}],[\"简略的锁升级过程\",{\"1\":{\"494\":1}}],[\"简单地说\",{\"1\":{\"625\":1}}],[\"简单来说\",{\"1\":{\"244\":1,\"247\":1,\"333\":1,\"589\":1}}],[\"简单\",{\"1\":{\"159\":1}}],[\"简化编程\",{\"1\":{\"404\":1}}],[\"简化内存管理\",{\"1\":{\"116\":1}}],[\"简化内存管理等\",{\"1\":{\"111\":1}}],[\"简化了对数据的管理和维护工作\",{\"1\":{\"636\":1}}],[\"简化了继电保护装置结构\",{\"1\":{\"625\":1}}],[\"简化了并发编程的复杂性\",{\"1\":{\"404\":1}}],[\"简化了jvm的内存管理\",{\"1\":{\"115\":1}}],[\"简化了内存管理\",{\"1\":{\"115\":1}}],[\"简化管理\",{\"1\":{\"115\":1}}],[\"简体中文\",{\"1\":{\"11\":1}}],[\"替换等\",{\"1\":{\"267\":1}}],[\"替换为元空间\",{\"1\":{\"92\":1,\"96\":1}}],[\"替代永久代\",{\"1\":{\"116\":1}}],[\"替代了永久代\",{\"1\":{\"111\":1}}],[\"专门用于在两个线程之间交换数据\",{\"1\":{\"360\":1}}],[\"专门用于加载tomcat的共享类库\",{\"1\":{\"234\":1}}],[\"专门用于存储字符串字面值\",{\"1\":{\"105\":1}}],[\"专门存储字符串字面值\",{\"1\":{\"110\":1}}],[\"时不能再使用\",{\"1\":{\"356\":1}}],[\"时被阻塞\",{\"1\":{\"354\":1}}],[\"时机\",{\"1\":{\"334\":1}}],[\"时必须重写\",{\"1\":{\"305\":1}}],[\"时的\",{\"0\":{\"297\":1}}],[\"时\",{\"1\":{\"108\":1,\"136\":1,\"201\":1,\"224\":1,\"306\":1,\"479\":1,\"613\":1}}],[\"时间\",{\"1\":{\"541\":1}}],[\"时间复杂度都是o\",{\"1\":{\"515\":1}}],[\"时间复杂度是o\",{\"1\":{\"515\":2}}],[\"时间单位\",{\"1\":{\"442\":1,\"448\":1}}],[\"时间片时\",{\"1\":{\"349\":1}}],[\"时间片分配给另一个处于就绪状态的线程\",{\"1\":{\"349\":3}}],[\"时间等信息\",{\"1\":{\"86\":1}}],[\"时间线图\",{\"0\":{\"46\":1}}],[\"局部变量在使用前必须显式地进行初始化\",{\"1\":{\"300\":1}}],[\"局部变量只在方法或代码块内有效\",{\"1\":{\"300\":1}}],[\"局部变量存在栈内存中\",{\"1\":{\"300\":1}}],[\"局部变量是在方法中或代码块中声明的变量\",{\"1\":{\"300\":1}}],[\"局部变量a存储在java栈中\",{\"1\":{\"109\":1}}],[\"局部变量\",{\"1\":{\"108\":2}}],[\"解耦合\",{\"1\":{\"584\":1}}],[\"解耦了服务的实现和调用方\",{\"1\":{\"252\":1}}],[\"解锁操作连接在一起\",{\"1\":{\"491\":1}}],[\"解决哈希冲突有哪些方法呢\",{\"0\":{\"538\":1}}],[\"解决方案\",{\"0\":{\"423\":1,\"427\":1,\"431\":1,\"435\":1,\"439\":1}}],[\"解决了标准的稳定性与未来网络技术发展之间的矛盾\",{\"1\":{\"636\":1}}],[\"解决了常规变电站中电流\",{\"1\":{\"625\":1}}],[\"解决了线程池等场景下inheritablethreadlocal\",{\"1\":{\"337\":1}}],[\"解决了字符串常量池引起的内存管理问题\",{\"1\":{\"99\":1}}],[\"解决了因为permgen空间不足导致的outofmemoryerror的问题\",{\"1\":{\"95\":1}}],[\"解析器是如何工作的\",{\"0\":{\"742\":1}}],[\"解析器吗\",{\"0\":{\"695\":1,\"742\":1}}],[\"解析器\",{\"0\":{\"695\":1}}],[\"解析阶段主要是将符号引用转换为直接引用\",{\"1\":{\"187\":1}}],[\"解析\",{\"0\":{\"187\":1},\"1\":{\"183\":1,\"282\":2}}],[\"解析和初始化阶段\",{\"1\":{\"117\":1}}],[\"解释成操作系统能识别的机器码\",{\"1\":{\"250\":1}}],[\"解释\",{\"0\":{\"108\":1,\"358\":1,\"362\":1},\"1\":{\"181\":1,\"249\":1,\"656\":22}}],[\"我们都可以在一些安装了部分软件的基础镜像上做改造\",{\"1\":{\"593\":1}}],[\"我们的镜像的组成\",{\"1\":{\"590\":1}}],[\"我们只需要告诉docker\",{\"1\":{\"590\":1}}],[\"我们要构建镜像\",{\"1\":{\"589\":1}}],[\"我们要使用docker来操作镜像\",{\"1\":{\"567\":1}}],[\"我们以mysql为例\",{\"1\":{\"589\":1}}],[\"我们进入nginx容器内部\",{\"1\":{\"586\":1}}],[\"我们在创建容器时\",{\"1\":{\"585\":1}}],[\"我们创建的html这个数据卷关联的宿主机目录为\",{\"1\":{\"584\":1}}],[\"我们创建了一个自定义的类加载器customclassloader\",{\"1\":{\"220\":1}}],[\"我们创建了一个arraylist\",{\"1\":{\"124\":1}}],[\"我们操作宿主机的\",{\"1\":{\"582\":1}}],[\"我们用下面的命令来修改\",{\"1\":{\"579\":1}}],[\"我们执行命令\",{\"1\":{\"579\":1}}],[\"我们直接访问宿主机的80端口\",{\"1\":{\"578\":1}}],[\"我们一方面可以将自己的镜像共享到dockerhub\",{\"1\":{\"566\":1}}],[\"我们设的比较小的话\",{\"1\":{\"541\":1}}],[\"我们来看看它的状态变化\",{\"1\":{\"490\":1}}],[\"我们定义了一个继承自recursivetask<integer>的fibonaccitask类\",{\"1\":{\"480\":1}}],[\"我们定义了一个自定义的类加载器customclassloader\",{\"1\":{\"215\":1}}],[\"我们重写了\",{\"1\":{\"480\":1}}],[\"我们就可以在编译或者运行阶段去识别这些标记\",{\"1\":{\"289\":1}}],[\"我们就可以考虑用\",{\"1\":{\"243\":1}}],[\"我们能够将\",{\"1\":{\"244\":1}}],[\"我们可以使用同步机制\",{\"1\":{\"316\":1}}],[\"我们可以获取到class对象信息\",{\"1\":{\"256\":1}}],[\"我们可以避免空指针异常\",{\"1\":{\"240\":1}}],[\"我们可以对集合进行过滤\",{\"1\":{\"240\":1}}],[\"我们可以在\",{\"1\":{\"233\":1}}],[\"我们可以更好地理解类的加载\",{\"1\":{\"190\":1}}],[\"我们需要将文件整个cloud\",{\"1\":{\"602\":1}}],[\"我们需要把这个目录挂载到html这个数据卷上\",{\"1\":{\"586\":1}}],[\"我们需要自己实现类的查找逻辑\",{\"1\":{\"233\":1}}],[\"我们需要根据具体情况权衡利弊\",{\"1\":{\"224\":1}}],[\"我们需要澄清几点\",{\"1\":{\"106\":1}}],[\"我们尝试加载了testclass类\",{\"1\":{\"220\":1}}],[\"我们使用自定义类加载器加载了一个testclass类\",{\"1\":{\"215\":1}}],[\"我们首先判断类名是否以\",{\"1\":{\"215\":1}}],[\"我们无法正确输出子进程的进度条\",{\"1\":{\"11\":1}}],[\"因争夺资源而造成的互相等待的现象\",{\"1\":{\"512\":1}}],[\"因此应该在方法内部使用\",{\"1\":{\"656\":1}}],[\"因此需要一个更加完善的通信平台\",{\"1\":{\"648\":1}}],[\"因此需要一些机制来处理这种情况\",{\"1\":{\"478\":1}}],[\"因此其可靠性必然受光源发生元件自身寿命的影响\",{\"1\":{\"633\":1}}],[\"因此其电流变换的线性度更好\",{\"1\":{\"633\":1}}],[\"因此其电压变换的线性度更好\",{\"1\":{\"632\":1}}],[\"因此其精度和性能必然受电磁铁心特性的影响\",{\"1\":{\"632\":1}}],[\"因此数字化继电保护装置在硬件方面与常规微机型继电保护装置差异很大\",{\"1\":{\"631\":1}}],[\"因此数字化继电保护装置除了具有常规微机型继电保护装置的保护逻辑软件和人机接口软件外\",{\"1\":{\"631\":1}}],[\"因此较此前的人为监测和调节更全面\",{\"1\":{\"630\":1}}],[\"因此我们的每个微服务都需要用这个名称\",{\"1\":{\"600\":1}}],[\"因此我们在centos下安装docker\",{\"1\":{\"569\":1}}],[\"因此一个镜像可以启动多次\",{\"1\":{\"565\":1}}],[\"因此适用于写操作较少\",{\"1\":{\"522\":1}}],[\"因此可以更细粒度地优化和控制数据库访问\",{\"1\":{\"655\":1}}],[\"因此可以在任意linux操作系统上运行\",{\"1\":{\"562\":1}}],[\"因此可以在多线程环境下安全地进行读操作\",{\"1\":{\"522\":1}}],[\"因此可以通过键值来遍历\",{\"1\":{\"552\":1}}],[\"因此可以暂停执行进行垃圾回收操作\",{\"1\":{\"138\":1}}],[\"因此要等到safepoint时执行\",{\"1\":{\"493\":1}}],[\"因此它可以独立存在\",{\"1\":{\"309\":1}}],[\"因此java语言可以实现跨平\",{\"1\":{\"247\":1}}],[\"因此java程序无需修改即可在不同操作系统上运行\",{\"1\":{\"181\":1}}],[\"因此引入了线程上下文类加载器的概念\",{\"1\":{\"223\":1}}],[\"因此输出的信息是\",{\"1\":{\"215\":1}}],[\"因此容易导致堆内存碎片化\",{\"1\":{\"147\":1}}],[\"因此不推荐使用\",{\"1\":{\"303\":1}}],[\"因此不再受到java堆的大小限制\",{\"1\":{\"130\":1}}],[\"因此不能依赖于finalize\",{\"1\":{\"129\":1}}],[\"因此对象的访问方式由虚拟机实现而定\",{\"1\":{\"122\":1}}],[\"因此在二次传输回路上产生的电压降明显降低\",{\"1\":{\"632\":1}}],[\"因此在遍历集合时使用的迭代器可能不反映最新的修改\",{\"1\":{\"522\":1}}],[\"因此在读多写少的场景中\",{\"1\":{\"521\":1}}],[\"因此在并发环境下可以安全地进行读写操作\",{\"1\":{\"521\":1}}],[\"因此在开发过程中需要仔细管理和释放对象和资源\",{\"1\":{\"125\":1}}],[\"因此在实例数据之后可能会添加一些填充字节\",{\"1\":{\"121\":1}}],[\"因此在多线程环境下可能会发生堆内存的抢占现象\",{\"1\":{\"120\":1}}],[\"因此在jdk\",{\"1\":{\"116\":1}}],[\"因此\",{\"1\":{\"106\":1,\"108\":1,\"126\":1,\"129\":1,\"134\":1,\"165\":1,\"220\":1,\"272\":1,\"306\":1,\"313\":1,\"348\":1,\"400\":1,\"520\":1,\"629\":1}}],[\"因为需要对结果进行去重操作\",{\"1\":{\"613\":1}}],[\"因为之前查看到dockerfile中的jar包名称都是app\",{\"1\":{\"600\":1}}],[\"因为微服务将来要部署为docker容器\",{\"1\":{\"599\":1}}],[\"因为除了clone\",{\"1\":{\"554\":1}}],[\"因为任意数\",{\"1\":{\"535\":1}}],[\"因为哈希值\",{\"1\":{\"534\":1}}],[\"因为每次写操作都会创建一个新的副本\",{\"1\":{\"522\":1}}],[\"因为每个线程都会占用较多的cpu资源\",{\"1\":{\"453\":1}}],[\"因为用锁为的就是互斥\",{\"1\":{\"512\":1}}],[\"因为线程有几率不阻塞直接获得锁\",{\"1\":{\"499\":1}}],[\"因为线程在执行任务时会阻塞等待i\",{\"1\":{\"453\":1}}],[\"因为as\",{\"1\":{\"488\":1}}],[\"因为静态成员不属于任何⼀个实例对象\",{\"1\":{\"482\":1}}],[\"因为斐波那契数列的第一个数和第二个数都是1\",{\"1\":{\"480\":1}}],[\"因为没有核心线程\",{\"1\":{\"458\":1}}],[\"因为它用于提交不需要返回结果的任务\",{\"1\":{\"451\":1}}],[\"因为它的吞吐量比较大\",{\"1\":{\"501\":1}}],[\"因为它的不可变性保证了多个线程可以安全地共享string对象\",{\"1\":{\"268\":1}}],[\"因为它的哈希值是固定的\",{\"1\":{\"267\":1}}],[\"因为调用线程需要承担执行任务的负责\",{\"1\":{\"449\":1}}],[\"因为操作系统需要保存和恢复线程的上下文信息\",{\"1\":{\"348\":1}}],[\"因为切换的时间特别短\",{\"1\":{\"339\":1}}],[\"因为前面调用过一次\",{\"1\":{\"303\":1}}],[\"因为根据实践发现大部分的数据操作都集中在值比较小的范围\",{\"1\":{\"272\":1}}],[\"因为\",{\"1\":{\"250\":1,\"550\":1}}],[\"因为栈上的对象在方法结束时自动释放\",{\"1\":{\"164\":1}}],[\"因为这种重排序会改变执行结果\",{\"1\":{\"321\":1}}],[\"因为这可能会导致类加载的混乱和冲突\",{\"1\":{\"219\":1}}],[\"因为这些垃圾收集器能够在保持高吞吐量的同时提供可预测的低停顿时间\",{\"1\":{\"155\":1}}],[\"因为这个区域是私有的\",{\"1\":{\"119\":1}}],[\"因为只需要标记gc\",{\"1\":{\"139\":1}}],[\"因为minor\",{\"1\":{\"134\":1}}],[\"因为新生代中的对象存活时间短\",{\"1\":{\"131\":1}}],[\"因为该算法无法处理循环引用的情况\",{\"1\":{\"126\":1}}],[\"因为避免了一次指针定位的时间开销\",{\"1\":{\"122\":1}}],[\"因为不要求内存是连续的\",{\"1\":{\"118\":1}}],[\"因为指针碰到对象后会被挪动到下一个可用位置\",{\"1\":{\"118\":1}}],[\"因为str1和str2指向同一个字符串常量池中的对象\",{\"1\":{\"103\":1}}],[\"因为导出订单数据本来就非常慢\",{\"1\":{\"84\":1}}],[\"因为订单信息导出这个方法可能会有几万的数据量\",{\"1\":{\"84\":1}}],[\"因为是偶发性的\",{\"1\":{\"84\":1}}],[\"然而\",{\"1\":{\"106\":1,\"139\":1,\"162\":1}}],[\"然后对去重后的结果集应用\",{\"1\":{\"619\":1}}],[\"然后按照指定的字段排序\",{\"1\":{\"614\":1}}],[\"然后在目录中新建一个文件\",{\"1\":{\"593\":1}}],[\"然后进入docker\",{\"1\":{\"592\":1}}],[\"然后进行相应的操作\",{\"1\":{\"351\":1}}],[\"然后编写好启动脚本打包在一起形成的文件\",{\"1\":{\"589\":1}}],[\"然后运行下面的命令\",{\"1\":{\"602\":1}}],[\"然后运行命令\",{\"1\":{\"574\":1}}],[\"然后运行另一个操作系统\",{\"1\":{\"563\":1}}],[\"然后再通过load加载回来\",{\"1\":{\"574\":1}}],[\"然后再将哈希值右移16位\",{\"1\":{\"533\":1}}],[\"然后你可以启动多次\",{\"1\":{\"565\":1}}],[\"然后把它们的叠加和作为映射的位置\",{\"1\":{\"537\":1}}],[\"然后把订单信息生成excel\",{\"1\":{\"84\":1}}],[\"然后与哈希值本身异或\",{\"1\":{\"533\":1}}],[\"然后将各个功能分解到逻辑节点\",{\"1\":{\"650\":1}}],[\"然后将键值对存储在该桶中\",{\"1\":{\"525\":1}}],[\"然后将第一个子任务和第二个子任务的结果相加\",{\"1\":{\"480\":1}}],[\"然后重新尝试\",{\"1\":{\"512\":1}}],[\"然后直接返回\",{\"1\":{\"500\":1}}],[\"然后设置当前锁的拥有者为当前线程\",{\"1\":{\"500\":1}}],[\"然后当前线程栈帧中增加一个锁记录第一部分\",{\"1\":{\"494\":1}}],[\"然后被阻塞在安全点的线程继续往下执行同步代码块\",{\"1\":{\"493\":1}}],[\"然后执行\",{\"1\":{\"493\":1}}],[\"然后执行这些代码\",{\"1\":{\"178\":1}}],[\"然后继续执行任务队列中的任务\",{\"1\":{\"478\":1}}],[\"然后逐个调用线程的interrupt方法来中断线程\",{\"1\":{\"452\":1}}],[\"然后逐一跟进业务线程看了下代码\",{\"1\":{\"84\":1}}],[\"然后恢复即将执行线程的状态\",{\"1\":{\"415\":1}}],[\"然后恢复下一个线程的上下文\",{\"1\":{\"348\":1}}],[\"然后又开始执行\",{\"1\":{\"355\":1}}],[\"然后table引用指向\",{\"1\":{\"334\":1}}],[\"然后放到新的newtab\",{\"1\":{\"334\":1}}],[\"然后遍历老的table数组\",{\"1\":{\"334\":1}}],[\"然后还要根据条件判断size\",{\"1\":{\"334\":1}}],[\"然后判断该槽位entry对象中的key是否和get的key一致\",{\"1\":{\"333\":1}}],[\"然后和table数组长度减一\",{\"1\":{\"332\":1}}],[\"然后到了真正要被回收的时候\",{\"1\":{\"303\":1}}],[\"然后用函数把这些步骤一步一步实现\",{\"1\":{\"294\":1}}],[\"然后搞一些事情\",{\"1\":{\"289\":1}}],[\"然后创建了一个新的线程\",{\"1\":{\"220\":1}}],[\"然后调用了它的sayhello方法\",{\"1\":{\"215\":1}}],[\"然后通过loadclass方法加载类\",{\"1\":{\"204\":1}}],[\"然后让程序继续执行\",{\"1\":{\"131\":1}}],[\"然后清空from区\",{\"1\":{\"131\":1}}],[\"然后经过一次minor\",{\"1\":{\"130\":1}}],[\"然后尝试不断地向其中添加1mb大小的字节数组对象\",{\"1\":{\"124\":1}}],[\"然后分析jvm参数设置是否合理\",{\"1\":{\"88\":1}}],[\"然后\",{\"1\":{\"85\":1,\"282\":1,\"391\":1}}],[\"然后就一直点\",{\"1\":{\"84\":1}}],[\"由图1\",{\"1\":{\"640\":1}}],[\"由智能终端装置驱动有关元件实现断路器的跳\",{\"1\":{\"639\":1}}],[\"由智能变电站的系统集成商进行配置生成的配置文件\",{\"1\":{\"638\":1}}],[\"由各装置厂商根据scd文件中与各自设备\",{\"1\":{\"638\":1}}],[\"由专用通信服务映射\",{\"1\":{\"636\":1}}],[\"由被测电流调制的光波物理特征\",{\"1\":{\"635\":1}}],[\"由这个罗哥夫斯基线圈得到了与一次电流i1的时间微分成比例的二次电压e2\",{\"1\":{\"634\":1}}],[\"由罗氏线圈组成的电子式电流互感器原理图\",{\"1\":{\"634\":1}}],[\"由罗氏线圈组成的电子式电流互感器原理图如图1\",{\"1\":{\"634\":1}}],[\"由罗氏线圈\",{\"1\":{\"634\":1}}],[\"由st4\",{\"1\":{\"633\":1}}],[\"由电磁原理可知φ=i̇1×n1=i̇2×n2\",{\"1\":{\"633\":1}}],[\"由电磁感应原理可知φ=i̇1×n1\",{\"1\":{\"633\":1}}],[\"由docker来管理目录\",{\"1\":{\"588\":1}}],[\"由两部分组成\",{\"1\":{\"567\":1}}],[\"由线程\",{\"1\":{\"407\":1,\"409\":1}}],[\"由创建出来的新线程去执行thread的run方法\",{\"1\":{\"342\":1}}],[\"由\",{\"1\":{\"250\":1}}],[\"由子加载器继续尝试加载\",{\"1\":{\"206\":1}}],[\"由开发者根据需要自定义的类加载器\",{\"1\":{\"202\":1}}],[\"由java实现\",{\"1\":{\"200\":1,\"201\":1}}],[\"由jvm自动管理\",{\"1\":{\"105\":1}}],[\"由c++语言实现\",{\"1\":{\"199\":1}}],[\"由执行引擎将字节码解释或编译为机器码并执行\",{\"1\":{\"180\":1}}],[\"由于数字化继电保护装置没有出口插件\",{\"1\":{\"639\":1}}],[\"由于数据本身带有说明\",{\"1\":{\"636\":1}}],[\"由于受光学互感器自身工作原理的局限\",{\"1\":{\"633\":1}}],[\"由于铁心二次侧缠绕有二次绕组n2\",{\"1\":{\"633\":1}}],[\"由于其二次电压只有0～5v\",{\"1\":{\"632\":1}}],[\"由于智能变电站采用光纤网络作为保护采样和跳闸的通道\",{\"1\":{\"631\":1}}],[\"由于智能变电站广泛采用光纤网络实现保护采样和跳闸功能\",{\"1\":{\"631\":1}}],[\"由于高级应用功能是在线运行的软件程序\",{\"1\":{\"630\":1}}],[\"由于采用法拉第磁旋光效应原理\",{\"1\":{\"633\":1}}],[\"由于采用特殊的采样原理\",{\"1\":{\"632\":1}}],[\"由于采用不同的网络结构模式\",{\"1\":{\"627\":1}}],[\"由于采用光纤进行数字化传输\",{\"1\":{\"625\":1}}],[\"由于采用光纤\",{\"1\":{\"625\":1}}],[\"由于这些数字化互感器彻底摒弃了传统互感器电磁感应的原理\",{\"1\":{\"625\":1}}],[\"由于扩容过程中元素迁移的不可见性\",{\"1\":{\"545\":1}}],[\"由于哈希函数的计算结果可能会出现冲突\",{\"1\":{\"525\":1}}],[\"由于copyonwritearraylist在每次写操作时都会创建副本\",{\"1\":{\"522\":1}}],[\"由于copyonwritearraylist在写操作时会创建副本\",{\"1\":{\"522\":1}}],[\"由于读操作不需要加锁\",{\"1\":{\"521\":1}}],[\"由于迭代时是对原集合的拷贝进行遍历\",{\"1\":{\"520\":1}}],[\"由于撤销需要知道当前持有该偏向锁的线程栈状态\",{\"1\":{\"493\":1}}],[\"由于处理器使用缓存和读\",{\"1\":{\"319\":1}}],[\"由于指令重排序和编译器优化的存在\",{\"1\":{\"316\":1}}],[\"由于每个线程都有自己的本地内存\",{\"1\":{\"316\":1}}],[\"由于同步的开销\",{\"1\":{\"268\":1}}],[\"由于不可变性的特性\",{\"1\":{\"268\":1}}],[\"由于字符串是不可变的\",{\"1\":{\"267\":1}}],[\"由于启动类加载器无法加载这些实现\",{\"1\":{\"223\":1}}],[\"由于设置了自定义的上下文类加载器\",{\"1\":{\"220\":1}}],[\"由于testclass类是由自定义类加载器加载的\",{\"1\":{\"215\":1}}],[\"由于是并发进行\",{\"1\":{\"139\":1}}],[\"由于并发标记阶段和应用线程并发运行\",{\"1\":{\"139\":1}}],[\"由于与应用线程并发运行\",{\"1\":{\"139\":1}}],[\"由于没有对添加的对象进行释放\",{\"1\":{\"124\":1}}],[\"由于对象访问在java中非常频繁\",{\"1\":{\"122\":1}}],[\"由于虚拟机内存访问要求数据存储在特定的内存地址上\",{\"1\":{\"121\":1}}],[\"由永久代\",{\"1\":{\"94\":1}}],[\"内核指令操作计算机硬件\",{\"1\":{\"561\":1}}],[\"内核可以与计算机硬件交互\",{\"1\":{\"561\":1}}],[\"内部节点的顺序是无序的\",{\"1\":{\"550\":1}}],[\"内部节点是有序的吗\",{\"0\":{\"550\":1}}],[\"内部捕获并处理异常\",{\"1\":{\"462\":1}}],[\"内部同时还启动了很多守护线程\",{\"1\":{\"350\":1}}],[\"内部类\",{\"1\":{\"309\":1}}],[\"内部类持有外部类的引用\",{\"1\":{\"125\":1}}],[\"内部错误\",{\"1\":{\"279\":1}}],[\"内容如下\",{\"1\":{\"593\":1,\"598\":2}}],[\"内容\",{\"1\":{\"105\":1}}],[\"内存空间不连续\",{\"1\":{\"515\":1}}],[\"内存占用\",{\"1\":{\"515\":1}}],[\"内存位置\",{\"1\":{\"502\":1}}],[\"内存等\",{\"1\":{\"453\":1}}],[\"内存开销\",{\"0\":{\"412\":1}}],[\"内存泄露是怎么回事\",{\"0\":{\"329\":1}}],[\"内存泄漏通常是由于程序中持续保留了不再需要的对象或资源而引起的\",{\"1\":{\"125\":1}}],[\"内存泄漏通常发生在程序中频繁动态分配内存却未及时释放\",{\"1\":{\"123\":1}}],[\"内存泄漏可能由以下几种常见原因导致\",{\"1\":{\"125\":1}}],[\"内存泄漏可能由哪些原因导致呢\",{\"0\":{\"125\":1}}],[\"内存泄漏指的是程序中已经不再使用的内存没有被正确释放\",{\"1\":{\"123\":1}}],[\"内存泄漏是内在病源\",{\"1\":{\"89\":1}}],[\"内存泄漏\",{\"0\":{\"123\":1},\"1\":{\"88\":2,\"123\":1}}],[\"内存系统的重排序\",{\"1\":{\"319\":1}}],[\"内存碎片化问题\",{\"1\":{\"151\":1}}],[\"内存碎片化\",{\"1\":{\"147\":1}}],[\"内存溢出和内存泄漏都是需要注意和及时解决的内存管理问题\",{\"1\":{\"123\":1}}],[\"内存溢出可能会导致程序崩溃\",{\"1\":{\"123\":1}}],[\"内存溢出指的是程序在申请内存时\",{\"1\":{\"123\":1}}],[\"内存溢出\",{\"1\":{\"123\":2}}],[\"内存溢出问题\",{\"1\":{\"113\":1}}],[\"内存分配的方式通常是指针碰撞和空闲列表两种\",{\"1\":{\"118\":1}}],[\"内存分配\",{\"1\":{\"117\":1}}],[\"内存分析工具\",{\"1\":{\"90\":1}}],[\"内存管理\",{\"0\":{\"91\":1},\"1\":{\"178\":1,\"181\":1}}],[\"内存管理参数\",{\"0\":{\"72\":1}}],[\"内存大小\",{\"1\":{\"89\":1}}],[\"内存飙高问题怎么排查\",{\"0\":{\"86\":1}}],[\"内存\",{\"1\":{\"54\":1,\"90\":1,\"561\":1}}],[\"内存使用情况\",{\"1\":{\"54\":2}}],[\"数字化微机型继电保护装置减少了交流输入插件两块\",{\"1\":{\"631\":1}}],[\"数字化微机型继电保护是为了满足智能变电站一次\",{\"1\":{\"631\":1}}],[\"数字化微机型继电保护与常规微机型继电保护的区别主要体现在以下两个方面\",{\"1\":{\"631\":1}}],[\"数字化微机型继电保护与常规微机型继电保护有什么不同\",{\"0\":{\"631\":1}}],[\"数字化变电站\",{\"0\":{\"627\":1,\"635\":1,\"637\":1},\"1\":{\"627\":1,\"629\":1,\"635\":1}}],[\"数字化变电站在以太网通信的基础上\",{\"1\":{\"624\":1}}],[\"数字化变电站已经具有一定程度的设备集成和功能优化的概念\",{\"1\":{\"624\":1}}],[\"数字化变电站主要从满足变电站自身的需求出发\",{\"1\":{\"624\":1}}],[\"数字化变电站是智能变电站的前提和基础\",{\"1\":{\"624\":1}}],[\"数字保护\",{\"1\":{\"626\":1}}],[\"数字分析法\",{\"1\":{\"537\":1}}],[\"数字的二进制位左移三位相当于乘以2的三次方\",{\"1\":{\"264\":1}}],[\"数\",{\"1\":{\"356\":1}}],[\"数组+链表+红黑树\",{\"1\":{\"549\":1}}],[\"数组中key和hash一样就直接替换\",{\"1\":{\"548\":1}}],[\"数组中的每个元素称为一个桶\",{\"1\":{\"525\":1}}],[\"数组大小为2的倍数\",{\"1\":{\"535\":1}}],[\"数组大小\",{\"1\":{\"535\":6}}],[\"数组长度\",{\"1\":{\"534\":1}}],[\"数组可能长度100\",{\"1\":{\"518\":1}}],[\"数组满了\",{\"1\":{\"516\":1}}],[\"数组下标越界等等\",{\"1\":{\"279\":1}}],[\"数组\",{\"1\":{\"258\":1,\"525\":2}}],[\"数值型\",{\"1\":{\"258\":1}}],[\"数值类型的变量初始化为0\",{\"1\":{\"186\":1}}],[\"数值常量10存储在运行时常量池中\",{\"1\":{\"104\":1,\"109\":1}}],[\"数百gb到数tb\",{\"1\":{\"159\":1}}],[\"数tb\",{\"1\":{\"151\":1}}],[\"数据类型转换等信息\",{\"1\":{\"656\":1}}],[\"数据源等\",{\"1\":{\"656\":1}}],[\"数据模型和数据集模型\",{\"1\":{\"636\":1}}],[\"数据自描述\",{\"1\":{\"636\":1}}],[\"数据对象则是由数据属性构成的公用数据类的命名实例\",{\"1\":{\"636\":1}}],[\"数据集操作命令\",{\"0\":{\"583\":1}}],[\"数据卷挂载\",{\"1\":{\"598\":1}}],[\"数据卷挂载耦合度低\",{\"1\":{\"588\":1}}],[\"数据卷挂载与目录直接挂载的\",{\"1\":{\"588\":1}}],[\"数据卷操作\",{\"1\":{\"584\":1}}],[\"数据卷操作的基本语法如下\",{\"1\":{\"583\":1}}],[\"数据卷的作用\",{\"1\":{\"584\":1}}],[\"数据卷\",{\"0\":{\"581\":1},\"1\":{\"582\":1,\"587\":1}}],[\"数据拷贝在add方法中进行\",{\"1\":{\"523\":1}}],[\"数据拷贝的过程中\",{\"0\":{\"523\":1}}],[\"数据结构和hashmap是一样的\",{\"1\":{\"549\":1}}],[\"数据结构\",{\"1\":{\"543\":1,\"549\":1}}],[\"数据结构示意图\",{\"1\":{\"525\":1}}],[\"数据结构不同\",{\"1\":{\"515\":1}}],[\"数据结构或者并行计算等技术来优化耗时操作的执行效率\",{\"1\":{\"479\":1}}],[\"数据即使成功修改\",{\"1\":{\"504\":1}}],[\"数据处理通常可以并行化以提高效率\",{\"1\":{\"430\":1}}],[\"数据都已经放入到\",{\"1\":{\"334\":1}}],[\"数据库列名\",{\"1\":{\"656\":1}}],[\"数据库操作通常是io密集型的\",{\"1\":{\"426\":1}}],[\"数据库驱动\",{\"1\":{\"252\":1}}],[\"数据库\",{\"1\":{\"202\":1,\"598\":1}}],[\"数据库等来源获取字节流\",{\"1\":{\"192\":1}}],[\"数据库连接池\",{\"0\":{\"425\":1}}],[\"数据库连接\",{\"1\":{\"125\":1}}],[\"数据可视化平台\",{\"1\":{\"62\":1,\"70\":1}}],[\"数据包图\",{\"0\":{\"51\":1}}],[\"=key\",{\"1\":{\"531\":1}}],[\"=expectedmodcount\",{\"1\":{\"520\":1}}],[\"=128\",{\"0\":{\"272\":1}}],[\"=serviceloader\",{\"1\":{\"252\":2}}],[\"==null\",{\"1\":{\"554\":1}}],[\"==和\",{\"0\":{\"304\":1}}],[\"==\",{\"1\":{\"103\":1,\"204\":1,\"215\":1,\"304\":2,\"334\":1,\"336\":1,\"463\":1,\"501\":1,\"516\":1,\"531\":9,\"532\":5,\"549\":11,\"554\":1}}],[\"=\",{\"0\":{\"106\":1,\"108\":1,\"269\":2,\"272\":1},\"1\":{\"103\":3,\"104\":2,\"106\":1,\"108\":2,\"109\":2,\"110\":1,\"124\":1,\"128\":1,\"165\":3,\"172\":5,\"173\":4,\"190\":2,\"204\":11,\"207\":1,\"215\":6,\"220\":5,\"243\":1,\"244\":6,\"269\":2,\"282\":3,\"300\":1,\"311\":3,\"312\":2,\"317\":3,\"326\":1,\"332\":2,\"334\":14,\"335\":2,\"336\":6,\"353\":12,\"355\":3,\"357\":3,\"359\":3,\"361\":7,\"363\":1,\"367\":2,\"369\":1,\"373\":1,\"374\":3,\"375\":7,\"377\":1,\"378\":2,\"380\":1,\"381\":1,\"383\":5,\"385\":8,\"388\":1,\"390\":1,\"391\":1,\"392\":2,\"394\":1,\"395\":1,\"396\":1,\"397\":1,\"398\":2,\"406\":4,\"407\":3,\"409\":3,\"424\":3,\"428\":4,\"432\":2,\"436\":1,\"440\":1,\"442\":1,\"443\":1,\"462\":1,\"463\":4,\"464\":3,\"465\":2,\"467\":4,\"477\":12,\"480\":8,\"485\":16,\"501\":3,\"511\":1,\"516\":3,\"531\":17,\"532\":14,\"549\":18,\"554\":3}}],[\"示例说明\",{\"0\":{\"617\":1},\"1\":{\"207\":1}}],[\"示例代码\",{\"0\":{\"171\":1,\"204\":1},\"1\":{\"357\":1}}],[\"示例\",{\"0\":{\"310\":1,\"383\":1,\"610\":1},\"1\":{\"103\":1,\"104\":1,\"190\":1}}],[\"则这些行被视为重复行\",{\"1\":{\"613\":1}}],[\"则这次只是简单地把aqs\",{\"1\":{\"500\":1}}],[\"则为一个全是1的二进制数\",{\"1\":{\"535\":1}}],[\"则需要把链表转换为红黑树\",{\"1\":{\"531\":1}}],[\"则异常不会抛出\",{\"1\":{\"520\":1}}],[\"则释放已持有的资源\",{\"1\":{\"512\":1}}],[\"则请求者只能等待\",{\"1\":{\"512\":1}}],[\"则以原子方式将引用值和印戳标志的值更新为给定的更新值\",{\"1\":{\"505\":1}}],[\"则调用该方法线程会被放入\",{\"1\":{\"500\":1}}],[\"则调用父类加载器加载\",{\"1\":{\"215\":1}}],[\"则当前线程会获取到该锁\",{\"1\":{\"500\":1}}],[\"则当前线程持有该对象锁\",{\"1\":{\"494\":1}}],[\"则\",{\"1\":{\"494\":1}}],[\"则进行\",{\"1\":{\"494\":1}}],[\"则进入步骤\",{\"1\":{\"493\":1}}],[\"则执行\",{\"1\":{\"493\":1,\"494\":1}}],[\"则查看线程id是否为当前线程\",{\"1\":{\"493\":1}}],[\"则直接插入即可\",{\"1\":{\"531\":1}}],[\"则直接撤销偏向锁\",{\"1\":{\"493\":1}}],[\"则直接返回n\",{\"1\":{\"480\":1}}],[\"则直接由核心线程执行任务\",{\"1\":{\"444\":1}}],[\"则将并列把手qk至于\",{\"1\":{\"641\":2}}],[\"则将t线程的偏向锁\",{\"1\":{\"493\":1}}],[\"则将markword中线程id设置为当前线程id\",{\"1\":{\"493\":1}}],[\"则将问题拆分成两个子任务\",{\"1\":{\"480\":1}}],[\"则将任务分配给该线程执行\",{\"1\":{\"455\":1}}],[\"则将任务分配给空闲线程执行\",{\"1\":{\"455\":2}}],[\"则将任务放入任务队列等待执行\",{\"1\":{\"444\":1}}],[\"则取消调用并释放资源\",{\"1\":{\"479\":1}}],[\"则线程会被终止\",{\"1\":{\"448\":1}}],[\"则线程会被唤醒\",{\"1\":{\"344\":1}}],[\"则根据设置的拒绝策略处理新任务\",{\"1\":{\"444\":1}}],[\"则创建新的非核心线程执行任务\",{\"1\":{\"444\":1}}],[\"则使用默认的\",{\"1\":{\"398\":1}}],[\"则处于await的线程都会\",{\"1\":{\"356\":1}}],[\"则必\",{\"1\":{\"356\":1}}],[\"则必须重写方法\",{\"1\":{\"299\":1}}],[\"则阻塞\",{\"1\":{\"355\":1}}],[\"则会抛出concurrent\",{\"1\":{\"520\":1}}],[\"则会抛出invalidclassexception异常\",{\"1\":{\"276\":1}}],[\"则会在当前线程栈帧中划出一块空间\",{\"1\":{\"494\":1}}],[\"则会递归调用\",{\"1\":{\"480\":1}}],[\"则会放行\",{\"1\":{\"355\":1}}],[\"则会清除中断标志\",{\"1\":{\"344\":1}}],[\"则该class\",{\"1\":{\"305\":1}}],[\"则它们的\",{\"1\":{\"305\":1}}],[\"则视为重载\",{\"1\":{\"296\":1}}],[\"则是一个\",{\"1\":{\"269\":1}}],[\"则对象可以在栈上分配而不是在堆上\",{\"1\":{\"164\":1}}],[\"则被认为是可回收的垃圾对象\",{\"1\":{\"126\":1}}],[\"则说明该对象不可达\",{\"1\":{\"126\":1}}],[\"则说明对象没有被引用\",{\"1\":{\"126\":1}}],[\"则更新为新值\",{\"1\":{\"120\":1}}],[\"则先执行类加载过程\",{\"1\":{\"117\":1}}],[\"则在池中创建该字符串并返回引用\",{\"1\":{\"103\":1}}],[\"则返回该字符串的引用\",{\"1\":{\"103\":1}}],[\"功能强大的一体化平台\",{\"1\":{\"625\":1}}],[\"功能特点\",{\"1\":{\"495\":1}}],[\"功能\",{\"1\":{\"324\":3}}],[\"功能基本不变\",{\"1\":{\"96\":1}}],[\"功能链接跳转不对问题\",{\"0\":{\"23\":1}}],[\"部分系统函数库文件一起打包形成的文件包\",{\"1\":{\"565\":1}}],[\"部分数据\",{\"1\":{\"114\":1}}],[\"部分数据迁移到堆中\",{\"1\":{\"95\":1}}],[\"部署\",{\"0\":{\"602\":1},\"1\":{\"602\":1}}],[\"部署微服务集群\",{\"0\":{\"597\":1}}],[\"部署时需要依赖于node\",{\"1\":{\"559\":1}}],[\"部署时会碰到一些问题\",{\"1\":{\"559\":1}}],[\"部署图\",{\"0\":{\"44\":1}}],[\"分页插件吗\",{\"0\":{\"699\":1,\"718\":1}}],[\"分布式系统中\",{\"1\":{\"558\":1}}],[\"分布非常均匀\",{\"1\":{\"332\":1}}],[\"分段锁\",{\"0\":{\"548\":1},\"1\":{\"547\":1}}],[\"分割成位数相同的几段\",{\"1\":{\"537\":1}}],[\"分而治之\",{\"1\":{\"480\":1}}],[\"分而治之和工作窃取算法\",{\"1\":{\"480\":1}}],[\"分钟等\",{\"1\":{\"448\":1}}],[\"分区管理\",{\"1\":{\"159\":1}}],[\"分区区域\",{\"1\":{\"141\":1}}],[\"分代式垃圾收集\",{\"1\":{\"148\":1}}],[\"分代算法基于\",{\"1\":{\"131\":1}}],[\"分代算法\",{\"1\":{\"131\":1}}],[\"分别运行于哪些地方\",{\"0\":{\"637\":1}}],[\"分别计算第\",{\"1\":{\"480\":1}}],[\"分别为\",{\"1\":{\"350\":1}}],[\"分别代表\",{\"1\":{\"286\":1}}],[\"分别称为from区和to区\",{\"1\":{\"132\":1}}],[\"分别采用不同的垃圾回收算法和策略\",{\"1\":{\"131\":1}}],[\"分为两个阶段\",{\"1\":{\"131\":1}}],[\"分为新生代和老年代\",{\"1\":{\"94\":1}}],[\"分配原则\",{\"1\":{\"119\":1}}],[\"分配内存空间\",{\"1\":{\"319\":1}}],[\"分配内存\",{\"1\":{\"117\":1}}],[\"分析\",{\"1\":{\"586\":1}}],[\"分析线程池的问题或者可优化点\",{\"1\":{\"476\":1}}],[\"分析下面几行代码的原子性\",{\"0\":{\"317\":1}}],[\"分析堆转储文件以查找内存泄漏或异常的对象\",{\"1\":{\"90\":1}}],[\"分析堆栈信息\",{\"1\":{\"90\":1}}],[\"分析会占比较大的内存\",{\"1\":{\"89\":1}}],[\"分析收集的数据\",{\"1\":{\"80\":1}}],[\"分析问题和瓶颈\",{\"0\":{\"80\":1}}],[\"分析java虚拟机中的堆转储快照\",{\"1\":{\"55\":1}}],[\"字符型\",{\"1\":{\"258\":1}}],[\"字符流会自动处理字符编码和解码\",{\"1\":{\"237\":1}}],[\"字符流以字符为单位进行输入输出\",{\"1\":{\"237\":1}}],[\"字符流更适合读取和写入文本文件\",{\"1\":{\"237\":1}}],[\"字符流\",{\"1\":{\"236\":1,\"237\":1}}],[\"字符串拼接是如何实现的\",{\"0\":{\"270\":1}}],[\"字符串对象实例\",{\"1\":{\"269\":1}}],[\"字符串的不可变性\",{\"1\":{\"267\":1}}],[\"字符串字面值\",{\"1\":{\"104\":1,\"109\":1}}],[\"字符串常量\",{\"1\":{\"104\":1,\"105\":1}}],[\"字符串常量池的优化\",{\"1\":{\"267\":1}}],[\"字符串常量池被移到java堆\",{\"1\":{\"103\":1}}],[\"字符串常量池被移到java堆中\",{\"1\":{\"95\":1}}],[\"字符串常量池位于永久代\",{\"1\":{\"103\":1}}],[\"字符串常量池和运行时常量池虽然名称相似\",{\"1\":{\"102\":1}}],[\"字符串常量池和运行时常量池有啥区别\",{\"0\":{\"102\":1}}],[\"字符串常量池和运行时常量池继续在java堆中\",{\"1\":{\"101\":1}}],[\"字符串常量池移到java堆中\",{\"1\":{\"99\":1}}],[\"字符串常量池在永久代中\",{\"1\":{\"99\":1}}],[\"字符串常量池\",{\"0\":{\"99\":1,\"103\":1},\"1\":{\"103\":1,\"105\":4,\"110\":1}}],[\"字符串池移出永久代\",{\"1\":{\"95\":1}}],[\"字节\",{\"1\":{\"258\":1}}],[\"字节码能够被虚拟机识别\",{\"1\":{\"249\":1}}],[\"字节流通常用于处理文件和网络连接中的数据传输\",{\"1\":{\"237\":1}}],[\"字节流以字节为单位进行输入输出\",{\"1\":{\"237\":1}}],[\"字节流则更适合处理二进制数据\",{\"1\":{\"237\":1}}],[\"字节流\",{\"1\":{\"236\":1,\"237\":1}}],[\"字节单位\",{\"1\":{\"89\":1}}],[\"字面值\",{\"1\":{\"108\":1}}],[\"字段的唯一值\",{\"1\":{\"608\":1}}],[\"字段信息\",{\"1\":{\"195\":1}}],[\"字段和方法数据\",{\"1\":{\"193\":1}}],[\"字段访问等操作\",{\"1\":{\"189\":1}}],[\"字段或方法\",{\"1\":{\"187\":1}}],[\"字段引用\",{\"1\":{\"104\":1,\"105\":1}}],[\"字段\",{\"1\":{\"94\":1,\"107\":1,\"256\":1}}],[\"中执行存储过程\",{\"0\":{\"679\":1}}],[\"中执行批量插入操作\",{\"0\":{\"660\":1}}],[\"中防止\",{\"0\":{\"670\":1}}],[\"中实现分页查询\",{\"0\":{\"668\":1}}],[\"中进行参数绑定\",{\"0\":{\"663\":1}}],[\"中用于从结果集中去除重复的行\",{\"1\":{\"606\":1}}],[\"中用于垃圾收集的一种算法\",{\"1\":{\"139\":1}}],[\"中会将竞争共享资源失败的线程添加到队列中\",{\"1\":{\"496\":1}}],[\"中断处理\",{\"1\":{\"363\":1}}],[\"中断\",{\"1\":{\"359\":1}}],[\"中断线程\",{\"1\":{\"344\":1}}],[\"中了\",{\"1\":{\"334\":1}}],[\"中所有的\",{\"1\":{\"334\":1}}],[\"中有两种形式可以实现多态\",{\"1\":{\"295\":1}}],[\"中异常层级结构\",{\"0\":{\"279\":1}}],[\"中引入了枚举类型\",{\"1\":{\"262\":1}}],[\"中文翻译为\",{\"1\":{\"244\":1}}],[\"中字符串开头为\",{\"1\":{\"244\":1}}],[\"中间可能发生了a变b\",{\"1\":{\"504\":1}}],[\"中间操作\",{\"1\":{\"244\":1}}],[\"中间有一个指针作为分界点指示器\",{\"1\":{\"118\":1}}],[\"中通道的读写事件\",{\"1\":{\"238\":1}}],[\"中添加了一个新的\",{\"1\":{\"222\":1}}],[\"中从加载到卸载整个生命周期包括以下七个阶段\",{\"1\":{\"183\":1}}],[\"中等到大堆内存\",{\"1\":{\"159\":2}}],[\"中小型web应用\",{\"1\":{\"155\":1}}],[\"中一种相对现代的垃圾收集器\",{\"1\":{\"140\":1}}],[\"中一种用于提高多线程并发性能的技术\",{\"1\":{\"119\":1}}],[\"中常见的垃圾收集器包括\",{\"1\":{\"137\":1}}],[\"中分配内存\",{\"1\":{\"120\":1}}],[\"中的懒加载问题的\",{\"0\":{\"741\":1}}],[\"中的批量更新操作是如何实现的\",{\"0\":{\"729\":1,\"749\":1}}],[\"中的事务管理有何了解\",{\"0\":{\"706\":1,\"738\":1}}],[\"中的缓存机制包括一级缓存和二级缓存\",{\"0\":{\"716\":1}}],[\"中的缓存机制是如何工作的\",{\"0\":{\"702\":1}}],[\"中的缓存是如何工作的\",{\"0\":{\"661\":1}}],[\"中的连接池和数据库连接管理是如何工作的\",{\"0\":{\"698\":1}}],[\"中的连接池是如何配置的\",{\"0\":{\"680\":1}}],[\"中的延迟加载机制有何理解\",{\"0\":{\"709\":1}}],[\"中的延迟加载\",{\"0\":{\"686\":1}}],[\"中的动态\",{\"0\":{\"659\":1,\"678\":1,\"691\":1,\"703\":1,\"736\":1}}],[\"中的作用是什么\",{\"0\":{\"658\":1}}],[\"中的一个功能\",{\"1\":{\"656\":1}}],[\"中的一个同步辅助类\",{\"1\":{\"360\":1}}],[\"中的⽅法\",{\"1\":{\"554\":1}}],[\"中的线程中断是一种线程间的协作模式\",{\"1\":{\"344\":1}}],[\"中的集合类\",{\"1\":{\"305\":1}}],[\"中的各个类加载器之间的关系\",{\"1\":{\"234\":1}}],[\"中的本地变量表和操作栈中的引用\",{\"1\":{\"127\":1}}],[\"中的\",{\"0\":{\"669\":1,\"672\":1,\"673\":1,\"674\":1,\"676\":1,\"688\":1,\"695\":1,\"696\":1,\"700\":1,\"708\":1,\"719\":1,\"727\":1,\"747\":1},\"1\":{\"110\":1}}],[\"中的用途和实现方式有所不同\",{\"1\":{\"102\":1}}],[\"中提取\",{\"1\":{\"104\":1}}],[\"中\",{\"0\":{\"236\":1,\"685\":1,\"689\":1,\"699\":1,\"707\":1,\"710\":1,\"713\":1,\"718\":1,\"733\":1,\"739\":1,\"753\":1},\"1\":{\"93\":1,\"108\":1,\"118\":1,\"120\":1,\"222\":1,\"238\":1,\"244\":2,\"262\":1,\"315\":1,\"485\":1,\"550\":1,\"552\":1,\"608\":1,\"609\":1}}],[\"说说mybatis的一级\",{\"0\":{\"773\":1}}],[\"说说有哪些常见集合\",{\"0\":{\"556\":1}}],[\"说说有哪些常见的序列化方式\",{\"0\":{\"277\":1}}],[\"说说synchronized和reentrantlock的区别\",{\"0\":{\"495\":1}}],[\"说说阻塞队列是怎么实现的\",{\"0\":{\"400\":1}}],[\"说说你对completablefuture的理解\",{\"0\":{\"364\":1}}],[\"说说你对原子性\",{\"0\":{\"316\":1}}],[\"说说线程有几种创建方式\",{\"0\":{\"341\":1}}],[\"说说什么是mybatis\",{\"0\":{\"756\":1}}],[\"说说什么是进程和线程\",{\"0\":{\"340\":1}}],[\"说说什么是跨平台性\",{\"0\":{\"248\":1}}],[\"说说自增自减运算\",{\"0\":{\"265\":1}}],[\"说下什么是java的spi机制\",{\"0\":{\"252\":1}}],[\"说明需要扩容\",{\"1\":{\"549\":1}}],[\"说明内存位置\",{\"1\":{\"502\":2}}],[\"说明内存飙高是由于对象创建速度过快导致\",{\"1\":{\"86\":1}}],[\"说明\",{\"1\":{\"345\":1}}],[\"说明本次young\",{\"1\":{\"135\":1}}],[\"说一下你对java内存模型\",{\"0\":{\"315\":1}}],[\"说一下你对注解的理解\",{\"0\":{\"289\":1}}],[\"说一下新生代的区域划分\",{\"0\":{\"132\":1}}],[\"说一下对象有哪几种引用\",{\"0\":{\"128\":1}}],[\"说一下jdk1\",{\"0\":{\"93\":1}}],[\"本地内存是jmm的\",{\"1\":{\"315\":1}}],[\"本地内存中存储了该线程以读\",{\"1\":{\"315\":1}}],[\"本地内存\",{\"1\":{\"315\":1}}],[\"本地方法接口\",{\"1\":{\"179\":1}}],[\"本地方法栈中的jni\",{\"1\":{\"127\":1}}],[\"本地方法栈仍然保留\",{\"1\":{\"96\":1}}],[\"本地方法栈\",{\"1\":{\"92\":1,\"94\":1}}],[\"本地线程分配缓冲\",{\"1\":{\"120\":1}}],[\"本来想跟踪着string对象找到其引用的地方\",{\"1\":{\"84\":1}}],[\"它如何提高系统性能\",{\"0\":{\"709\":1}}],[\"它如何处理事务的提交和回滚\",{\"0\":{\"706\":1,\"738\":1}}],[\"它对连接池有何要求\",{\"0\":{\"705\":1,\"737\":1}}],[\"它支持哪些基本类型和复杂类型的映射\",{\"0\":{\"677\":1}}],[\"它支持哪些事务管理方式\",{\"0\":{\"671\":1}}],[\"它有什么作用\",{\"0\":{\"669\":1}}],[\"它有哪些级别\",{\"0\":{\"661\":1}}],[\"它描述了sql语句中的参数位置\",{\"1\":{\"656\":1}}],[\"它描述了查询结果集中每一列与java对象属性之间的对应关系\",{\"1\":{\"656\":1}}],[\"它代表了一个映射文件中的一个sql语句\",{\"1\":{\"656\":1}}],[\"它根据sql语句中的参数信息\",{\"1\":{\"656\":1}}],[\"它根据sql的类型和配置信息选择合适的执行方式\",{\"1\":{\"656\":1}}],[\"它通常在应用程序启动时使用一次\",{\"1\":{\"656\":1}}],[\"它通过底层的jdbc接口与数据库交互\",{\"1\":{\"656\":1}}],[\"它通过使用xml或注解配置文件来映射java对象和关系型数据库中的记录\",{\"1\":{\"655\":1}}],[\"它通过哈希函数将键映射到桶\",{\"1\":{\"550\":1}}],[\"它通过在修改时创建副本来实现并发访问\",{\"1\":{\"521\":1}}],[\"它通过在java线程运行的情况下执行并发标记\",{\"1\":{\"137\":1}}],[\"它通过协调各个线程\",{\"1\":{\"357\":1}}],[\"它通过确保类的唯一性和一致性\",{\"1\":{\"213\":1}}],[\"它通过加载\",{\"1\":{\"181\":1}}],[\"它通过并发标记和并发清除来实现低停顿时间的垃圾收集\",{\"1\":{\"137\":1}}],[\"它与全自动的区别在哪里\",{\"0\":{\"757\":1}}],[\"它与其他\",{\"0\":{\"655\":1}}],[\"它与常规的电压并列有什么不同点\",{\"0\":{\"641\":1}}],[\"它规范了变电站内智能电子设备\",{\"1\":{\"647\":1}}],[\"它规定了类加载器在加载类时的顺序和方式\",{\"1\":{\"205\":1}}],[\"它显示了各个智能设备的功能输出\",{\"1\":{\"638\":1}}],[\"它将结果集转换为java对象或基本数据类型\",{\"1\":{\"656\":1}}],[\"它将不仅应用在变电站内\",{\"1\":{\"636\":1}}],[\"它将堆内存划分为多个区域\",{\"1\":{\"137\":1}}],[\"它按照高阻抗电阻设计\",{\"1\":{\"635\":1}}],[\"它由罗哥夫斯基线圈\",{\"1\":{\"634\":1}}],[\"它可以通过\",{\"1\":{\"656\":1}}],[\"它可以用于单个字段\",{\"1\":{\"606\":1}}],[\"它可以被用作map的键\",{\"1\":{\"267\":1}}],[\"它使用了构建器模式\",{\"1\":{\"656\":1}}],[\"它使用\",{\"1\":{\"517\":1}}],[\"它使得java具有跨平台特性\",{\"1\":{\"177\":1}}],[\"它没有实现randmoaccess\",{\"1\":{\"515\":1}}],[\"它没有上下文切换的额外开销成本\",{\"1\":{\"323\":1}}],[\"它也实现了randmoaccess\",{\"1\":{\"515\":1}}],[\"它去其它线程的队列里窃取一个任务来执行\",{\"1\":{\"480\":1}}],[\"它提供了一种将java对象与数据库表之间的映射关系描述出来的方式\",{\"1\":{\"656\":1}}],[\"它提供了一种简洁而强大的方式来处理异步操作\",{\"1\":{\"365\":1}}],[\"它提供了执行sql语句\",{\"1\":{\"656\":1}}],[\"它提供了更加灵活的异常处理方式\",{\"1\":{\"466\":1}}],[\"它实现线程安全的关键点在于put流程\",{\"1\":{\"549\":1}}],[\"它实现了模块化热部署\",{\"1\":{\"224\":1}}],[\"它实际上不存储任何元素\",{\"1\":{\"450\":1}}],[\"它基于数组实现\",{\"1\":{\"450\":1}}],[\"它基于链表实现\",{\"1\":{\"450\":1}}],[\"它和countdownlatch类似\",{\"1\":{\"354\":1}}],[\"它要做的事情是\",{\"1\":{\"354\":1}}],[\"它主要用于线程之间的数据传输\",{\"1\":{\"351\":1}}],[\"它主要确保多个线程在同一个时刻\",{\"1\":{\"351\":1}}],[\"它保证了线程对变量访问的可见性和排他性\",{\"1\":{\"351\":1}}],[\"它能保证所有线程对变量访问的可见性\",{\"1\":{\"351\":1}}],[\"它能够创建和编译程序\",{\"1\":{\"247\":1}}],[\"它能够统计\",{\"1\":{\"244\":1}}],[\"它能够运行以字节码\",{\"1\":{\"177\":1}}],[\"它还提供了自定义初始化方法和支持传递不可序列化对象的功能\",{\"1\":{\"337\":1}}],[\"它就会新增\",{\"1\":{\"332\":1}}],[\"它这时候如果不被回收\",{\"1\":{\"329\":1}}],[\"它只是作为一个key来让线程往threadlocalmap里存取值\",{\"1\":{\"328\":1}}],[\"它确保在不同的编译器和不同的处理器平台之上\",{\"1\":{\"319\":1}}],[\"它不存储任务\",{\"1\":{\"450\":1}}],[\"它不持有outerclass实例的引用\",{\"1\":{\"312\":1}}],[\"它不能⽤于创建新程序\",{\"1\":{\"247\":1}}],[\"它持有outerclass实例的引用\",{\"1\":{\"311\":1}}],[\"它属于类\",{\"1\":{\"301\":1}}],[\"它存储了所有字符串字面量的唯一实例\",{\"1\":{\"267\":1}}],[\"它真正的功能实现就是利用反射\",{\"1\":{\"255\":1}}],[\"它允许多个线程在队列为空或者队列已满时进行阻塞等待\",{\"1\":{\"400\":1}}],[\"它允许第三方组件在不修改源代码的情况下\",{\"1\":{\"252\":1}}],[\"它允许在对象被回收之前执行一些特定的清理工作\",{\"1\":{\"129\":1}}],[\"它拥有\",{\"1\":{\"247\":1}}],[\"它会怎么处理\",{\"0\":{\"536\":1}}],[\"它会在等待队列中等待\",{\"1\":{\"344\":1}}],[\"它会将加载任务交给共享的commonclassloader\",{\"1\":{\"234\":1}}],[\"它会首先委派给父类加载器\",{\"1\":{\"209\":1}}],[\"它适用于现代大内存和多处理器的环境\",{\"1\":{\"145\":1}}],[\"它决定了当老年代使用率达到多少时\",{\"1\":{\"139\":1}}],[\"它关注的是吞吐量\",{\"1\":{\"137\":1}}],[\"它是如何实现的\",{\"0\":{\"717\":1}}],[\"它是如何工作的\",{\"0\":{\"683\":1,\"699\":1,\"732\":1,\"752\":1}}],[\"它是在sql语句执行前由sqlsource生成的\",{\"1\":{\"656\":1}}],[\"它是非线程安全的\",{\"1\":{\"656\":1}}],[\"它是传统电磁式电流互感器的一种发展\",{\"1\":{\"635\":1}}],[\"它是建立在集成的高速双向通信网络基础上\",{\"1\":{\"621\":1}}],[\"它是可重入的独占锁\",{\"1\":{\"497\":1}}],[\"它是可以在指定\",{\"1\":{\"345\":1}}],[\"它是java并发包的根基\",{\"1\":{\"496\":1}}],[\"它是斐波那契数\",{\"1\":{\"332\":1}}],[\"它是功能⻬全的\",{\"1\":{\"247\":1}}],[\"它是运⾏已编译\",{\"1\":{\"247\":1}}],[\"它是单线程的收集器\",{\"1\":{\"137\":1}}],[\"它是线程私有的\",{\"1\":{\"92\":1}}],[\"它们与\",{\"0\":{\"700\":1}}],[\"它们应该如何选择使用\",{\"0\":{\"672\":1}}],[\"它们各自的作用是什么\",{\"0\":{\"656\":1}}],[\"它们分别使用在不同的网络中\",{\"1\":{\"637\":1}}],[\"它们的工作基本原理不同\",{\"1\":{\"633\":1}}],[\"它们在空间占用上都有一些额外的消耗\",{\"1\":{\"515\":1}}],[\"它们提供了一种更高效的线程安全机制\",{\"1\":{\"510\":1}}],[\"它们会访问同一个队列\",{\"1\":{\"480\":1}}],[\"它们会竞争堆内存的分配\",{\"1\":{\"120\":1}}],[\"它们是处理数据的底层工具\",{\"1\":{\"237\":1}}],[\"它们表示不同类型的垃圾回收操作\",{\"1\":{\"133\":1}}],[\"它们之间会进行对象的交换\",{\"1\":{\"132\":1}}],[\"它们仍然会被集合保留\",{\"1\":{\"125\":1}}],[\"它的性能如何\",{\"0\":{\"703\":1}}],[\"它的原理是什么\",{\"0\":{\"666\":1}}],[\"它的原理是遍历线程池中的工作线程\",{\"1\":{\"452\":1}}],[\"它的学习曲线相对较低\",{\"1\":{\"655\":1}}],[\"它的作用是什么\",{\"0\":{\"675\":1,\"695\":1,\"700\":1,\"719\":1,\"742\":1}}],[\"它的作用十分重要\",{\"1\":{\"639\":1,\"640\":1}}],[\"它的作用在于减少线程间因为对象分配而频繁竞争内存分配的情况\",{\"1\":{\"119\":1}}],[\"它的优点主要体现在以下4个方面\",{\"1\":{\"630\":1}}],[\"它的名字叫\",{\"1\":{\"522\":1}}],[\"它的compareandset方法首先检查当前的对象引用值是否等于预期引用\",{\"1\":{\"505\":1}}],[\"它的主要应用场景包括\",{\"1\":{\"360\":1}}],[\"它的主要任务是通过全限定名获取类的字节码文件\",{\"1\":{\"197\":1}}],[\"它的生命周期与程序的生命周期相同\",{\"1\":{\"300\":1}}],[\"它的方法没有使用synchronized关键字进行同步\",{\"1\":{\"268\":1}}],[\"它的值可以被修改\",{\"1\":{\"268\":1}}],[\"它的返回类型是\",{\"1\":{\"244\":1}}],[\"它的出现主要有以下几个原因\",{\"1\":{\"208\":1}}],[\"它的工作过程可以分为以下几个阶段\",{\"1\":{\"139\":1}}],[\"它的目标是清理新生代中的垃圾对象\",{\"1\":{\"134\":1}}],[\"它的一部分也被称为永久代\",{\"1\":{\"92\":1}}],[\"它相对于指针碰撞更加灵活\",{\"1\":{\"118\":1}}],[\"它在项目中的应用场景是什么\",{\"0\":{\"704\":1}}],[\"它在\",{\"0\":{\"658\":1}}],[\"它在运行时查找并加载meta\",{\"1\":{\"252\":1}}],[\"它在系统即将发生内存溢出之前\",{\"1\":{\"128\":1}}],[\"它在方法调用时存储在当前线程的java栈的当前栈帧中\",{\"1\":{\"108\":1}}],[\"它在编译时会被存储在类文件的常量池中\",{\"1\":{\"108\":1}}],[\"它包含类中所有字面值和符号引用\",{\"1\":{\"104\":1}}],[\"当向数据库插入\",{\"1\":{\"656\":1}}],[\"当查询结果从数据库返回时\",{\"1\":{\"656\":1}}],[\"当满足并列条件\",{\"1\":{\"641\":1}}],[\"当母联间隔的所有刀闸及断路器在合闸位置时即两条母线并列运行时\",{\"1\":{\"641\":1}}],[\"当继电保护装置动作出口时\",{\"1\":{\"639\":1}}],[\"当光学电流互感器一次载流导体上通过电流时\",{\"1\":{\"633\":1}}],[\"当一束光通过一个磁场后\",{\"1\":{\"633\":1}}],[\"当一个大任务到来时\",{\"1\":{\"480\":1}}],[\"当一个任务被提交到线程池后\",{\"1\":{\"444\":1}}],[\"当一个执行中的线程a调用了thread的sleep方法后\",{\"1\":{\"344\":1}}],[\"当一个线程执行put操作导致扩容时\",{\"1\":{\"545\":1}}],[\"当一个线程执行完一个小任务后\",{\"1\":{\"480\":1}}],[\"当一个线程获取了对象的内置锁时\",{\"1\":{\"485\":1}}],[\"当一个线程因为等待某些事件\",{\"1\":{\"349\":1}}],[\"当一个线程的时间片用完时\",{\"1\":{\"349\":1}}],[\"当一个线程调用了\",{\"1\":{\"349\":1}}],[\"当一个线程调用\",{\"1\":{\"344\":1}}],[\"当一个线程a调用一个共享变量的\",{\"1\":{\"344\":1}}],[\"当一个线程开始执行时\",{\"1\":{\"119\":1}}],[\"当一个类的实例被序列化后\",{\"1\":{\"276\":1}}],[\"当一个类被序列化后\",{\"1\":{\"276\":1}}],[\"当一个类加载器尝试加载一个类时\",{\"1\":{\"209\":1}}],[\"当一个类加载器收到类加载请求时\",{\"1\":{\"206\":1}}],[\"当一个类不再被引用\",{\"1\":{\"190\":1}}],[\"当一个对象在方法内部创建且使用时\",{\"1\":{\"170\":1}}],[\"当一个字符串字面值被创建时\",{\"1\":{\"103\":1}}],[\"当电流互感器的一次侧n1通过电流时\",{\"1\":{\"633\":1}}],[\"当在多个字段上使用\",{\"1\":{\"613\":1}}],[\"当用于多个字段时\",{\"1\":{\"606\":1}}],[\"当我们访问宿主机的80端口时\",{\"1\":{\"578\":1}}],[\"当我们定义了\",{\"1\":{\"243\":1}}],[\"当多个线程同时进行扩容操作时\",{\"1\":{\"545\":1}}],[\"当多个线程同时执行put操作时\",{\"1\":{\"545\":1}}],[\"当多个线程同时执行\",{\"1\":{\"120\":1}}],[\"当插入新的键值对时\",{\"1\":{\"543\":1}}],[\"当发生哈希碰撞时\",{\"1\":{\"543\":1}}],[\"当哈希冲突较多时\",{\"1\":{\"543\":1}}],[\"当桶中的元素较多时\",{\"1\":{\"525\":1}}],[\"当桶中的元素较少时\",{\"1\":{\"525\":1}}],[\"当且仅当预期值\",{\"1\":{\"502\":1}}],[\"当达到safepoint时获得偏向锁的线程被挂起\",{\"1\":{\"493\":1}}],[\"当系统重新启动时\",{\"1\":{\"478\":1}}],[\"当系统发生断电时\",{\"1\":{\"478\":1}}],[\"当系统内存不足时\",{\"1\":{\"128\":1}}],[\"当单机线程池执行断电时\",{\"1\":{\"478\":1}}],[\"当调用\",{\"1\":{\"470\":1,\"471\":1}}],[\"当任务无法被执行时\",{\"1\":{\"449\":3}}],[\"当任务无法被接受执行时的处理策略\",{\"1\":{\"448\":1}}],[\"当核心线程都在忙碌\",{\"1\":{\"448\":1}}],[\"当所有线程都在忙碌时\",{\"1\":{\"403\":1}}],[\"当所有等待线程都被释放后\",{\"1\":{\"355\":1}}],[\"当队列已满时\",{\"1\":{\"400\":1,\"450\":1}}],[\"当队列为空时\",{\"1\":{\"400\":1}}],[\"当线程池中存在一个调用特别耗时的\",{\"1\":{\"479\":1}}],[\"当线程池中的线程数超过核心线程数时\",{\"1\":{\"408\":1}}],[\"当线程池在\",{\"1\":{\"472\":1,\"473\":1}}],[\"当线程取出任务后\",{\"1\":{\"454\":1}}],[\"当线程数超过核心线程数时\",{\"1\":{\"448\":1}}],[\"当线程a运行时\",{\"1\":{\"344\":1}}],[\"当线程需要分配对象时\",{\"1\":{\"119\":1}}],[\"当其它线程读取该共享变量\",{\"1\":{\"323\":1}}],[\"当传递对象引用时\",{\"1\":{\"306\":1}}],[\"当传递基本数据类型\",{\"1\":{\"306\":1}}],[\"当对象被反序列化时\",{\"1\":{\"276\":1}}],[\"当对象被移动时\",{\"1\":{\"122\":1}}],[\"当反序列化时\",{\"1\":{\"276\":1}}],[\"当运算符放在变量之后时\",{\"1\":{\"265\":1}}],[\"当有任务需要执行时\",{\"1\":{\"454\":1}}],[\"当有新任务提交时\",{\"1\":{\"448\":1,\"455\":3}}],[\"当有新的连接请求到达时\",{\"1\":{\"238\":1}}],[\"当有其他线程向队列中添加或取出元素时\",{\"1\":{\"400\":1}}],[\"当有事件触发时\",{\"1\":{\"238\":1}}],[\"当某个通道\",{\"1\":{\"238\":1}}],[\"当webappclassloader无法加载类时\",{\"1\":{\"234\":1}}],[\"当希望完全掌控类的加载过程时\",{\"1\":{\"233\":1}}],[\"当希望继承父类加载器的双亲委派行为时\",{\"1\":{\"233\":1}}],[\"当监视器检测到类文件的变化时\",{\"1\":{\"228\":1}}],[\"当类的字节码已经在内存中\",{\"1\":{\"233\":1}}],[\"当类文件被修改或者更新时\",{\"1\":{\"227\":1}}],[\"当类加载完成时\",{\"1\":{\"138\":1}}],[\"当需要更换一个\",{\"1\":{\"224\":1}}],[\"当前hashmap的元素个数达到一个临界值的时候\",{\"1\":{\"540\":1,\"542\":1}}],[\"当前节点是否为树节点\",{\"1\":{\"532\":1}}],[\"当前节点和key匹配\",{\"1\":{\"532\":1}}],[\"当前\",{\"1\":{\"482\":1}}],[\"当前对象实例的锁\",{\"1\":{\"482\":1}}],[\"当前的唯一线程\",{\"1\":{\"459\":1}}],[\"当前线程执行轻量级锁状态下的锁获取步骤\",{\"1\":{\"493\":1}}],[\"当前线程执行的字节码的行号指示器\",{\"1\":{\"92\":1}}],[\"当前线程是最后一个到达的线程await时\",{\"1\":{\"355\":1}}],[\"当前线程a等待thread线程终止之后才从thread\",{\"1\":{\"351\":1}}],[\"当前线程a等待thread线程终止之后从thread\",{\"1\":{\"344\":1}}],[\"当前类加载器尝试自己加载该类\",{\"1\":{\"206\":1}}],[\"当你调用classloader\",{\"1\":{\"201\":1}}],[\"当方法调用结束时\",{\"1\":{\"163\":1}}],[\"当cms收集器无法获取足够的内存空间时\",{\"1\":{\"147\":1}}],[\"当迭代年龄达到一定阈值\",{\"1\":{\"136\":1}}],[\"当要进行young\",{\"1\":{\"135\":1}}],[\"当老年代的内存空间不足以容纳新对象\",{\"1\":{\"135\":1}}],[\"当老年代的内存空间不足时\",{\"1\":{\"133\":1}}],[\"当新生代的to区放不下从eden和from区拷贝过来的对象\",{\"1\":{\"135\":1}}],[\"当新生代的survivor区也无法容纳存活对象时\",{\"1\":{\"134\":1}}],[\"当新生代的eden区满时\",{\"1\":{\"133\":1}}],[\"当eden区没有足够的空间来分配新对象时\",{\"1\":{\"134\":1}}],[\"当eden区\",{\"1\":{\"134\":1}}],[\"当eden区满时\",{\"1\":{\"132\":1}}],[\"当然也不会出现电压回路二次短路的问题\",{\"1\":{\"625\":1}}],[\"当然可以\",{\"1\":{\"477\":1}}],[\"当然\",{\"1\":{\"131\":1,\"501\":1}}],[\"当垃圾回收器进行垃圾回收时\",{\"1\":{\"128\":1}}],[\"当引用被移除时\",{\"1\":{\"126\":1}}],[\"当构造函数执行完毕后\",{\"1\":{\"117\":1}}],[\"当创建一个对象时\",{\"1\":{\"117\":1}}],[\"当执行完退出后\",{\"1\":{\"485\":1}}],[\"当执行\",{\"1\":{\"108\":1}}],[\"当这些对象的存活年龄超过分代年龄时便会进入老年代\",{\"1\":{\"88\":1}}],[\"动态调整链表和红黑树的阈值\",{\"1\":{\"543\":1}}],[\"动态调整内存大小\",{\"1\":{\"115\":1}}],[\"动态地替换\",{\"1\":{\"252\":1}}],[\"动态加载和卸载类的操作\",{\"1\":{\"232\":1}}],[\"动态加载新的类\",{\"0\":{\"228\":1}}],[\"动态年龄判断\",{\"1\":{\"136\":1}}],[\"动态链接\",{\"1\":{\"92\":1}}],[\"动态图\",{\"0\":{\"43\":1}}],[\"操作人员将并列把手合上后\",{\"1\":{\"641\":1}}],[\"操作闭锁\",{\"1\":{\"628\":1}}],[\"操作在\",{\"1\":{\"619\":1}}],[\"操作\",{\"1\":{\"616\":1,\"618\":1}}],[\"操作镜像或容器\",{\"1\":{\"568\":1}}],[\"操作来实现的\",{\"1\":{\"510\":1}}],[\"操作成功\",{\"1\":{\"502\":1}}],[\"操作成功返回\",{\"1\":{\"320\":1}}],[\"操作失败\",{\"1\":{\"502\":1}}],[\"操作包含三个操作数\",{\"1\":{\"502\":1}}],[\"操作系统本身提供的应用\",{\"1\":{\"561\":1}}],[\"操作系统版本也会有差异\",{\"1\":{\"560\":1}}],[\"操作系统通过线程调度器在多个线程之间切换执行\",{\"1\":{\"415\":1}}],[\"操作系统为每个线程分配了一些内核对象和数据结构\",{\"1\":{\"413\":1}}],[\"操作系统资源\",{\"0\":{\"413\":1}}],[\"操作系统会将\",{\"1\":{\"349\":2}}],[\"操作系统会强制进行线程上下文切换\",{\"1\":{\"349\":1}}],[\"操作系统会保存当前线程的上下文\",{\"1\":{\"348\":1}}],[\"操作系统工具\",{\"0\":{\"54\":1}}],[\"操作happens\",{\"1\":{\"320\":1}}],[\"操作的数据量较小\",{\"1\":{\"268\":1}}],[\"操作码是否合法\",{\"1\":{\"185\":1}}],[\"操作可以比较并交换共享变量的值\",{\"1\":{\"120\":1}}],[\"操作创建对象时\",{\"1\":{\"120\":1}}],[\"操作数栈\",{\"1\":{\"92\":1,\"94\":1}}],[\"所谓按序申请\",{\"1\":{\"512\":1}}],[\"所谓的公平锁就是先等待的线程先获得锁\",{\"1\":{\"495\":1}}],[\"所谓多态就是指程序中定义的引⽤变量所指向的具体类型和通过该引⽤变量发出的⽅法调⽤在编程时并不确定\",{\"1\":{\"295\":1}}],[\"所拥有的⼀\",{\"1\":{\"247\":1}}],[\"所取代\",{\"1\":{\"130\":1}}],[\"所有linux发行版的内核都是linux\",{\"1\":{\"561\":1}}],[\"所有任务都已完成\",{\"1\":{\"472\":1}}],[\"所有任务按照顺序在这个线程中执行\",{\"1\":{\"455\":1}}],[\"所有的线程完成任务\",{\"1\":{\"356\":1}}],[\"所有的输入流的基类\",{\"1\":{\"236\":1}}],[\"所有线程到达屏障点后执行的代码\",{\"1\":{\"355\":1}}],[\"所有线程到达屏障点时执行\",{\"1\":{\"355\":1}}],[\"所有线程已到达屏障点\",{\"1\":{\"355\":5}}],[\"所有被屏障拦截的线程才会继续运行\",{\"1\":{\"354\":1}}],[\"所有玩家已经就位\",{\"1\":{\"353\":1}}],[\"所有对象共享同一份静态变量的拷贝\",{\"1\":{\"300\":1}}],[\"所有对象都在堆上分配\",{\"1\":{\"92\":1}}],[\"所有输出流的基类\",{\"1\":{\"236\":1}}],[\"所有已被使用的内存和空闲的内存分别放在堆的两端\",{\"1\":{\"118\":1}}],[\"所以传输时可以不受预先定义限制\",{\"1\":{\"636\":1}}],[\"所以传入17\",{\"1\":{\"536\":1}}],[\"所以大多数情况下\",{\"1\":{\"593\":1}}],[\"所以get是不需要加锁的\",{\"1\":{\"548\":1}}],[\"所以转红黑树\",{\"1\":{\"539\":1}}],[\"所以对扰动函数通过对哈希值进行变换\",{\"1\":{\"534\":1}}],[\"所以在遍历过程中对原集合所作的修改并不能被迭代器检测到\",{\"1\":{\"520\":1}}],[\"所以每个节点会占用更多的空间\",{\"1\":{\"515\":1}}],[\"所以它没法根据序号直接获取元素\",{\"1\":{\"515\":1}}],[\"所以它可以根据下标查找\",{\"1\":{\"515\":1}}],[\"所以当前线程会被阻塞\",{\"1\":{\"512\":1}}],[\"所以synchronized保证的有序是执行结果的有序性\",{\"1\":{\"488\":1}}],[\"所以synchronized保证同一时刻\",{\"1\":{\"488\":1}}],[\"所以我们就知道了\",{\"1\":{\"485\":1}}],[\"所以任务直接加到synchronousqueue队列\",{\"1\":{\"458\":1}}],[\"所以无法响应中断的任务可能永远无法终止\",{\"1\":{\"452\":1}}],[\"所以基本对于用户是无感知的\",{\"1\":{\"339\":1}}],[\"所以不会触发concurrent\",{\"1\":{\"520\":1}}],[\"所以不会再次调用\",{\"1\":{\"303\":1}}],[\"所以不能使用private修饰符\",{\"1\":{\"299\":1}}],[\"所以即使\",{\"1\":{\"282\":1}}],[\"所以是先输出\",{\"1\":{\"282\":1}}],[\"所以显示为null\",{\"1\":{\"207\":1}}],[\"所以分析排查内存泄漏问题首先还得从查看\",{\"1\":{\"89\":1}}],[\"所以最终导致内存溢出\",{\"1\":{\"84\":1}}],[\"所以第一次简单的认为就是堆内存不足导致\",{\"1\":{\"84\":1}}],[\"所以进程可能会看似未响应\",{\"1\":{\"11\":1}}],[\"生产环境等\",{\"1\":{\"656\":1}}],[\"生产环境有差异的问题\",{\"1\":{\"562\":1}}],[\"生产环境有差异\",{\"1\":{\"559\":1}}],[\"生产了数据\",{\"1\":{\"361\":1}}],[\"生产的数据\",{\"1\":{\"361\":1}}],[\"生产者\",{\"1\":{\"361\":1}}],[\"生存周期\",{\"1\":{\"300\":1}}],[\"生命周期不受方法调用结束的影响\",{\"1\":{\"163\":1}}],[\"生命周期\",{\"0\":{\"761\":1},\"1\":{\"92\":5}}],[\"生成数据并与消费者交换\",{\"1\":{\"362\":1}}],[\"生成字节码\",{\"1\":{\"250\":1}}],[\"生成报告和图表\",{\"1\":{\"54\":1}}],[\"生成模板\",{\"1\":{\"11\":1}}],[\"生成\",{\"1\":{\"11\":1,\"89\":2}}],[\"作者\",{\"1\":{\"240\":1}}],[\"作为基于网信通信平台的变电站唯一的国际标准\",{\"1\":{\"636\":1}}],[\"作为该平台的重要节点\",{\"1\":{\"624\":1}}],[\"作为该锁的锁记录\",{\"1\":{\"494\":1}}],[\"作为注册中心和配置中心\",{\"1\":{\"598\":1}}],[\"作为映射的位置\",{\"1\":{\"537\":1}}],[\"作为默认线程池来执行异步任务\",{\"1\":{\"387\":1}}],[\"作为tomcat的catalina容器的类加载器\",{\"1\":{\"234\":1}}],[\"作为方法区的实现带来了以下好处\",{\"1\":{\"116\":1}}],[\"作为常量被存储在运行时常量池中\",{\"1\":{\"110\":1}}],[\"作为字面值\",{\"1\":{\"108\":1}}],[\"作为后续调优的基准\",{\"1\":{\"79\":1}}],[\"作用于当前对象实例加锁\",{\"1\":{\"482\":1}}],[\"作用\",{\"1\":{\"92\":5,\"129\":1,\"656\":22}}],[\"每一个指令都会形成一层layer\",{\"1\":{\"590\":1}}],[\"每当迭代器使用hashnext\",{\"1\":{\"520\":1}}],[\"每当有一个新的引用指向对象时\",{\"1\":{\"126\":1}}],[\"每重入一次\",{\"1\":{\"496\":1}}],[\"每种状态都表示线程池当前的不同运行阶段\",{\"1\":{\"468\":1}}],[\"每种垃圾收集器都有其自己的特点和适用场景\",{\"1\":{\"137\":1}}],[\"每次切换执行线程时\",{\"1\":{\"415\":1}}],[\"每创建一个threadlocal对象\",{\"1\":{\"332\":1}}],[\"每个环境都可以有自己独立的配置信息\",{\"1\":{\"656\":1}}],[\"每个sqlsession都会关联一个数据库连接\",{\"1\":{\"656\":1}}],[\"每个功能的保护数据映射到数据对象\",{\"1\":{\"650\":1}}],[\"每个服务器本身又包含一个或多个逻辑设备\",{\"1\":{\"636\":1}}],[\"每个服务提供者将自己的实现类配置到一个特定的配置文件中\",{\"1\":{\"252\":1}}],[\"每个ied包含一个或多个服务器\",{\"1\":{\"636\":1}}],[\"每个微服务的app\",{\"1\":{\"601\":1}}],[\"每个微服务都需要修改\",{\"1\":{\"600\":1}}],[\"每个节点要么是红色\",{\"1\":{\"527\":1}}],[\"每个键值对根据哈希函数计算得到一个桶的索引\",{\"1\":{\"525\":1}}],[\"每个桶存储一个键值对\",{\"1\":{\"525\":1}}],[\"每个对象都有一个内置锁\",{\"1\":{\"485\":1}}],[\"每个对象都会被分配一块内存空间\",{\"1\":{\"121\":1}}],[\"每个工作线程会不断地从任务队列中获取任务并执行\",{\"1\":{\"480\":1}}],[\"每个请求可能涉及复杂的处理逻辑\",{\"1\":{\"422\":1}}],[\"每个threadlocal实例都对应着一个threadlocalmap对象\",{\"1\":{\"331\":1}}],[\"每个entry代表一个完整的对象\",{\"1\":{\"328\":1}}],[\"每个类都有一个对应的class对象\",{\"1\":{\"256\":1}}],[\"每个实现类占据一行\",{\"1\":{\"252\":1}}],[\"每个web应用程序都有独立的类加载器\",{\"1\":{\"234\":1}}],[\"每个web应用程序都有自己的独立的webappclassloader\",{\"1\":{\"234\":1}}],[\"每个程序模块\",{\"1\":{\"224\":1}}],[\"每个加载的类在堆中都有一个对应的class对象\",{\"1\":{\"195\":1}}],[\"每个区域可以是年轻代\",{\"1\":{\"141\":1}}],[\"每个区域都有其特定的用途和生命周期\",{\"1\":{\"92\":1}}],[\"每个阶段只收集部分对象\",{\"1\":{\"131\":1}}],[\"每个线程的堆栈大小可能是1mb或者更大\",{\"1\":{\"412\":1}}],[\"每个线程在创建时需要分配内存\",{\"1\":{\"412\":1}}],[\"每个线程在往threadlocal里设置值的时候\",{\"1\":{\"328\":1}}],[\"每个线程需要创建新实\",{\"1\":{\"343\":1}}],[\"每个线程有自己的程序计数器和栈\",{\"1\":{\"340\":1}}],[\"每个线程有一个独立的程序计数器\",{\"1\":{\"94\":1}}],[\"每个线程有一个独立的java栈\",{\"1\":{\"92\":1,\"94\":1}}],[\"每个线程分配自己的\",{\"1\":{\"119\":1}}],[\"每个线程都有自己的工作队列\",{\"1\":{\"450\":1}}],[\"每个线程都有一个属于自己的threadlocalmap\",{\"1\":{\"328\":1}}],[\"每个线程都有一个私有的\",{\"1\":{\"315\":1}}],[\"每个线程都有一个java栈\",{\"1\":{\"107\":1}}],[\"每个线程都有独立的程序计数器\",{\"1\":{\"92\":1}}],[\"每个部分有其特定的用途和生命周期\",{\"1\":{\"92\":1}}],[\"每隔5秒执行一次\",{\"1\":{\"440\":1}}],[\"每隔\",{\"1\":{\"89\":1}}],[\"每隔一秒打印一次\",{\"1\":{\"86\":1}}],[\"来构建动态查询语句吗\",{\"0\":{\"715\":1,\"736\":1}}],[\"来部署\",{\"1\":{\"597\":1}}],[\"来看看镜像的组成结构\",{\"1\":{\"589\":1}}],[\"来映射到对应的数组位置\",{\"1\":{\"537\":1}}],[\"来计算存储位置\",{\"1\":{\"525\":1}}],[\"来存储数据\",{\"1\":{\"525\":1}}],[\"来存储字符串\",{\"1\":{\"268\":1}}],[\"来进行序列化和反序列化\",{\"1\":{\"519\":1}}],[\"来表示同步状态\",{\"1\":{\"496\":1}}],[\"来实现原子性\",{\"1\":{\"509\":1}}],[\"来实现这个机制\",{\"1\":{\"495\":1}}],[\"来实现方法区\",{\"1\":{\"111\":1,\"114\":1}}],[\"来捕获和处理异常\",{\"1\":{\"467\":1}}],[\"来处理异常情况\",{\"1\":{\"465\":1}}],[\"来处理数据\",{\"1\":{\"238\":1}}],[\"来决定是否需要扩容\",{\"1\":{\"334\":1}}],[\"来约束\",{\"1\":{\"320\":1}}],[\"来将多条指令重叠执行\",{\"1\":{\"319\":1}}],[\"来保证程序执行的顺序与代码的顺序一致\",{\"1\":{\"318\":1}}],[\"来保证对共享变量的修改对其他线程是可见的\",{\"1\":{\"318\":1}}],[\"来控制对arraylist的读写操作\",{\"1\":{\"521\":1}}],[\"来控制对共享变量的访问和操作\",{\"1\":{\"318\":1}}],[\"来控制线程的访问和操作\",{\"1\":{\"316\":1}}],[\"来确保多线程程序的可见性\",{\"1\":{\"315\":1}}],[\"来包装它\",{\"1\":{\"243\":1}}],[\"来获取定义此类的二进制字节流\",{\"1\":{\"192\":1}}],[\"来引用类\",{\"1\":{\"187\":1}}],[\"来提高内存分配的效率\",{\"1\":{\"117\":1}}],[\"来检查应用程序的内存使用情况\",{\"1\":{\"90\":1}}],[\"来分析gc日志\",{\"1\":{\"87\":1}}],[\"你觉得其中哪些是最常用的\",{\"0\":{\"731\":1,\"751\":1}}],[\"你觉得应该怎么实现一个热部署功能\",{\"0\":{\"225\":1}}],[\"你是如何处理\",{\"0\":{\"741\":1}}],[\"你是如何进行连接池优化的\",{\"0\":{\"743\":1}}],[\"你是如何进行\",{\"0\":{\"730\":1,\"735\":1,\"750\":1}}],[\"你是如何组织和管理\",{\"0\":{\"726\":1,\"746\":1}}],[\"你是如何克服的\",{\"0\":{\"722\":1}}],[\"你会考虑哪些因素\",{\"0\":{\"744\":1}}],[\"你会优先考虑哪些因素\",{\"0\":{\"734\":1,\"754\":1}}],[\"你会采取什么样的方法来实现分页\",{\"0\":{\"718\":1}}],[\"你会看到类似以下的信息\",{\"1\":{\"90\":1}}],[\"你认为单元测试对于\",{\"0\":{\"730\":1,\"750\":1}}],[\"你认为\",{\"0\":{\"714\":1,\"724\":1,\"734\":1,\"754\":1}}],[\"你更倾向于使用哪一种\",{\"0\":{\"711\":1,\"727\":1,\"739\":1,\"747\":1}}],[\"你对\",{\"0\":{\"697\":1,\"706\":1,\"709\":1,\"724\":1,\"738\":1}}],[\"你对红黑树了解多少\",{\"0\":{\"526\":1}}],[\"你何时选择使用延迟加载\",{\"0\":{\"686\":1}}],[\"你如何执行批量删除操作\",{\"0\":{\"685\":1}}],[\"你如何在\",{\"0\":{\"670\":1}}],[\"你有哪些应对策略\",{\"0\":{\"723\":1}}],[\"你有遇到过\",{\"0\":{\"733\":1,\"753\":1}}],[\"你有遇到过缓存失效的情况吗\",{\"0\":{\"702\":1}}],[\"你有遇到过类型转换问题吗\",{\"0\":{\"694\":1}}],[\"你有进行过复杂的多表查询吗\",{\"0\":{\"701\":1}}],[\"你有进行过连接池的配置和优化吗\",{\"0\":{\"698\":1}}],[\"你有自定义过\",{\"0\":{\"695\":1,\"719\":1,\"742\":1}}],[\"你有在项目中实践过连接超时和重试策略吗\",{\"0\":{\"725\":1,\"745\":1}}],[\"你有在项目中应用过吗\",{\"0\":{\"692\":1}}],[\"你有在项目中使用过缓存吗\",{\"0\":{\"740\":1}}],[\"你有在项目中使用过\",{\"0\":{\"732\":1,\"743\":1,\"752\":1}}],[\"你有在项目中使用过这种集成方式吗\",{\"0\":{\"720\":1}}],[\"你有在项目中使用过这些机制吗\",{\"0\":{\"707\":1}}],[\"你有在项目中使用过动态\",{\"0\":{\"703\":1}}],[\"你有在项目中使用\",{\"0\":{\"675\":1}}],[\"你有集成经验吗\",{\"0\":{\"684\":1}}],[\"你有使用过注解方式定义\",{\"0\":{\"727\":1,\"747\":1}}],[\"你有使用过动态\",{\"0\":{\"710\":1,\"715\":1,\"736\":1}}],[\"你有使用过复杂的映射关系吗\",{\"0\":{\"712\":1}}],[\"你有使用过复杂的\",{\"0\":{\"708\":1}}],[\"你有使用过\",{\"0\":{\"696\":1,\"699\":1,\"700\":1,\"711\":1,\"713\":1,\"717\":1,\"718\":1,\"728\":1,\"748\":1}}],[\"你有使用\",{\"0\":{\"683\":1,\"687\":1}}],[\"你有什么经验可以分享吗\",{\"0\":{\"680\":1}}],[\"你在使用\",{\"0\":{\"722\":1}}],[\"你在项目中是如何优化\",{\"0\":{\"697\":1}}],[\"你在项目中是如何应用的\",{\"0\":{\"682\":1}}],[\"你在项目中是如何处理\",{\"0\":{\"667\":1}}],[\"你在工作中用到过threadlocal吗\",{\"0\":{\"327\":1}}],[\"你能否自定义一个拦截器\",{\"0\":{\"681\":1}}],[\"你能否自定义一个\",{\"0\":{\"676\":1}}],[\"你能否自定义一个插件\",{\"0\":{\"665\":1}}],[\"你能举例说明如何使用动态\",{\"0\":{\"659\":1}}],[\"你能自己设计实现一个hashmap吗\",{\"0\":{\"544\":1}}],[\"你能设计实现一个线程池吗\",{\"0\":{\"477\":1}}],[\"你还知道哪些哈希函数的构造方法呢\",{\"0\":{\"537\":1}}],[\"你还可以在异步任务链中的不同部分使用不同的线程池\",{\"1\":{\"398\":1}}],[\"你还可以调用这些方法和属性\",{\"1\":{\"254\":1}}],[\"你需要确保你的线程池的线程数不要超过系统资源的限制\",{\"1\":{\"453\":1}}],[\"你可以根据实际需求和场景进一步扩展和优化这个线程池的实现\",{\"1\":{\"477\":1}}],[\"你可以精细控制线程池的各种参数\",{\"1\":{\"409\":1}}],[\"你可以更好地控制\",{\"1\":{\"398\":1}}],[\"你可以使用threadpoolexecutor来创建自定义线程池\",{\"1\":{\"409\":1}}],[\"你可以使用\",{\"1\":{\"389\":1,\"390\":1}}],[\"你可以使用静态工厂方法来创建\",{\"1\":{\"367\":1}}],[\"你必须在构造中指定\",{\"1\":{\"356\":1}}],[\"你们线上用的什么垃圾收集器\",{\"0\":{\"150\":1}}],[\"你想要创建什么类型的项目\",{\"1\":{\"11\":1}}],[\"再经信号处理及光电转换单元转换成光数字信号供给保护\",{\"1\":{\"632\":1}}],[\"再遍历链表定位到具体的元素上\",{\"1\":{\"548\":1}}],[\"再建一个数组\",{\"1\":{\"538\":1}}],[\"再哈希法\",{\"1\":{\"538\":1}}],[\"再插入时\",{\"1\":{\"516\":1}}],[\"再申请资源序号大的\",{\"1\":{\"512\":1}}],[\"再继续取\",{\"1\":{\"459\":1}}],[\"再次放行\",{\"1\":{\"355\":1}}],[\"再进行屏障后的写操作\",{\"1\":{\"324\":1}}],[\"再进行屏障后的读操作\",{\"1\":{\"324\":1}}],[\"再+1\",{\"1\":{\"317\":1}}],[\"再反序列化成拷贝对象\",{\"1\":{\"307\":1}}],[\"再输出\",{\"1\":{\"282\":1}}],[\"再catch中return\",{\"1\":{\"282\":1}}],[\"再自增\",{\"1\":{\"265\":1}}],[\"再赋值到j\",{\"1\":{\"317\":1}}],[\"再赋值\",{\"1\":{\"265\":1}}],[\"再由操作系统执行\",{\"1\":{\"250\":1}}],[\"再查对其的引用\",{\"1\":{\"89\":1}}],[\"再对步骤1中列出的可能原因做排除法\",{\"1\":{\"88\":1}}],[\"也利用抑制雷电过电压和操作过电压的措施\",{\"1\":{\"634\":1}}],[\"也就降低了传输误差\",{\"1\":{\"632\":1}}],[\"也就减少了硬件故障率\",{\"1\":{\"631\":1}}],[\"也就是支持16个线程的并发写\",{\"1\":{\"548\":1}}],[\"也就是给当前类加锁\",{\"1\":{\"482\":1}}],[\"也就是说\",{\"1\":{\"489\":1}}],[\"也就是说一个线程可以根据一个threadlocal对象查询到绑定在这个线程上的一个值\",{\"1\":{\"351\":1}}],[\"也就是说守护线程是否结束并不影响\",{\"1\":{\"350\":1}}],[\"也就是\",{\"1\":{\"334\":1}}],[\"也就是线程本地变量\",{\"1\":{\"326\":1}}],[\"也就是基本数据类型变量的值\",{\"1\":{\"307\":1}}],[\"也就是运行的时候就没这个信息了\",{\"1\":{\"289\":1}}],[\"也就是内容一样\",{\"1\":{\"271\":1}}],[\"也改进了常规变电站中运行操作受运行人员素质影响的缺陷\",{\"1\":{\"630\":1}}],[\"也彻底解决了常规变电站连接二次设备的二次电缆在强电场中穿越的干扰问题\",{\"1\":{\"625\":1}}],[\"也被称为\",{\"1\":{\"621\":1}}],[\"也被称为类方法\",{\"1\":{\"301\":1}}],[\"也能在一个操作系统中\",{\"1\":{\"563\":1}}],[\"也能在性能方面接近手动内存管理的编程语言\",{\"1\":{\"168\":1}}],[\"也保护应用所需要的libs\",{\"1\":{\"560\":1}}],[\"也达到了取余的效果\",{\"1\":{\"535\":1}}],[\"也可能有问题\",{\"1\":{\"504\":1}}],[\"也可以使用第三方的连接池实现\",{\"1\":{\"656\":1}}],[\"也可以使⽤\",{\"1\":{\"301\":1}}],[\"也可以用于多个字段\",{\"1\":{\"606\":1}}],[\"也可以直接挂载到宿主机目录上\",{\"1\":{\"587\":1}}],[\"也可以按照固定的时间间隔执行任务\",{\"1\":{\"455\":1}}],[\"也可以提交需要返回结果的任务\",{\"1\":{\"451\":1}}],[\"也可以叫同步点\",{\"1\":{\"354\":1}}],[\"也可以继承父类的属性和方法\",{\"1\":{\"295\":1}}],[\"也可以将hessian格式\",{\"1\":{\"277\":1}}],[\"也可以将protobuf格式的数据反序列化为java对象\",{\"1\":{\"277\":1}}],[\"也可以将xml格式的数据反序列化为java对象\",{\"1\":{\"277\":1}}],[\"也可以将json格式的数据反序列化为java对象\",{\"1\":{\"277\":1}}],[\"也可以将对象序列化为json\",{\"1\":{\"277\":1}}],[\"也可以放在变量之后\",{\"1\":{\"265\":1}}],[\"也可以是其他人制作好的镜像\",{\"1\":{\"594\":1}}],[\"也可以是\",{\"1\":{\"262\":1}}],[\"也可以是一段可以传递的代码\",{\"1\":{\"241\":1}}],[\"也可以是从父类继承而来的构造函数\",{\"1\":{\"117\":1}}],[\"也不处理队列中的任务\",{\"1\":{\"471\":1}}],[\"也不会被回收\",{\"1\":{\"448\":1}}],[\"也不会回收强引用的对象\",{\"1\":{\"128\":1}}],[\"也有oom的风险\",{\"1\":{\"460\":1}}],[\"也有可能非空的时候\",{\"1\":{\"243\":1}}],[\"也有可能非\",{\"1\":{\"243\":1}}],[\"也有可能不会被调用\",{\"1\":{\"129\":1}}],[\"也叫空心线圈\",{\"1\":{\"634\":1}}],[\"也叫\",{\"1\":{\"332\":1}}],[\"也会根据threadlocal对象的hash值\",{\"1\":{\"333\":1}}],[\"也会生成oopmap\",{\"1\":{\"138\":1}}],[\"也会触发full\",{\"1\":{\"135\":1}}],[\"也使用标记\",{\"1\":{\"137\":1}}],[\"也称为类变量\",{\"1\":{\"301\":1}}],[\"也称为throughput\",{\"1\":{\"159\":1}}],[\"也称为old\",{\"1\":{\"133\":1}}],[\"也称为young\",{\"1\":{\"133\":1,\"134\":1}}],[\"也称为吞吐量垃圾回收器\",{\"1\":{\"73\":1}}],[\"也是取余的效果\",{\"1\":{\"535\":1}}],[\"也是使用标记\",{\"1\":{\"137\":1}}],[\"也是线程私有的\",{\"1\":{\"92\":1}}],[\"也是个图形化工具\",{\"1\":{\"89\":1}}],[\"自愈\",{\"1\":{\"622\":1,\"630\":1}}],[\"自然就不存在不同应用之间的兼容问题了\",{\"1\":{\"560\":1}}],[\"自然也就走不到\",{\"1\":{\"282\":1}}],[\"自旋超过次数就阻塞获取\",{\"1\":{\"548\":1}}],[\"自旋cas\",{\"1\":{\"506\":1}}],[\"自旋一定次数后\",{\"1\":{\"496\":1}}],[\"自旋等待\",{\"1\":{\"494\":1}}],[\"自旋锁\",{\"1\":{\"491\":1}}],[\"自定义线程池\",{\"0\":{\"409\":1,\"463\":1}}],[\"自定义加载逻辑\",{\"1\":{\"215\":1}}],[\"自定义类加载器时\",{\"1\":{\"233\":1}}],[\"自定义类加载器可以绕过父类加载器的委派\",{\"1\":{\"215\":1}}],[\"自定义类加载器\",{\"0\":{\"202\":1,\"215\":1},\"1\":{\"215\":1,\"220\":1}}],[\"自动实施的功能\",{\"1\":{\"630\":1}}],[\"自动完成信息采集\",{\"1\":{\"623\":1}}],[\"自动装箱的时候会去缓存池里取integer对象\",{\"1\":{\"272\":1}}],[\"自动类型转换\",{\"1\":{\"259\":1}}],[\"自动调优\",{\"1\":{\"148\":1,\"151\":1,\"153\":1}}],[\"自动化监控\",{\"1\":{\"67\":1,\"70\":1}}],[\"自我清理或释放资源的操作\",{\"1\":{\"129\":1}}],[\"自带的\",{\"1\":{\"89\":1}}],[\"端口映射\",{\"1\":{\"598\":1}}],[\"端口8080\",{\"1\":{\"424\":1}}],[\"端口是\",{\"1\":{\"89\":1}}],[\"端到端性能监控\",{\"1\":{\"70\":1}}],[\"浏览器访问\",{\"1\":{\"89\":1}}],[\"文析结果中查找存在大量的对象\",{\"1\":{\"89\":1}}],[\"文件操作等\",{\"1\":{\"453\":1}}],[\"文件操作和计算等\",{\"1\":{\"422\":1}}],[\"文件上传等\",{\"1\":{\"434\":1}}],[\"文件名为服务接口的全限定名\",{\"1\":{\"252\":1}}],[\"文件较大的话\",{\"1\":{\"89\":1}}],[\"文件分析\",{\"1\":{\"89\":1}}],[\"文件\",{\"1\":{\"89\":4,\"250\":1,\"289\":3}}],[\"文档所在分支\",{\"1\":{\"23\":1}}],[\"及其运行环境\",{\"1\":{\"565\":1}}],[\"及时发现线程池的异常情况\",{\"1\":{\"476\":1}}],[\"及时发现和修复这些问题是保证程序性能和稳定性的重要一环\",{\"1\":{\"123\":1}}],[\"及时发现和解决性能问题\",{\"1\":{\"83\":1}}],[\"及时调用remove\",{\"1\":{\"330\":1}}],[\"及全限定类名\",{\"1\":{\"89\":1}}],[\"就应该在应用程序的整个生命周期中保持不变\",{\"1\":{\"656\":1}}],[\"就不存在二次传输的电压损耗问题\",{\"1\":{\"632\":1}}],[\"就必须先了解镜像的结构才行\",{\"1\":{\"588\":1}}],[\"就必须要安装docker\",{\"1\":{\"567\":1}}],[\"就等于操作容器内的\",{\"1\":{\"582\":1}}],[\"就像github的代码共享一样\",{\"1\":{\"566\":1}}],[\"就使用synchronized写入数据\",{\"1\":{\"549\":1}}],[\"就使用了自旋加锁的方式\",{\"1\":{\"491\":1}}],[\"就通过cas+自旋的方式初始化数组\",{\"1\":{\"549\":1}}],[\"就需要把插入位置后的元素都向前或者向后移动\",{\"1\":{\"515\":1}}],[\"就需要老年代进行分配担保\",{\"1\":{\"136\":1}}],[\"就停止自旋\",{\"1\":{\"507\":1}}],[\"就释放锁了\",{\"1\":{\"489\":1}}],[\"就新建一个线程执行\",{\"1\":{\"458\":1}}],[\"就去取出任务执行\",{\"1\":{\"458\":1}}],[\"就起不到多线程的效果\",{\"1\":{\"342\":1}}],[\"就把它赋给当前线程\",{\"1\":{\"336\":1}}],[\"就开始执行\",{\"1\":{\"334\":1}}],[\"就判断下一个位置\",{\"1\":{\"333\":1}}],[\"就会在铁心中产生磁通φ\",{\"1\":{\"633\":1}}],[\"就会被映射到容器的80\",{\"1\":{\"578\":1}}],[\"就会报错了\",{\"1\":{\"561\":1}}],[\"就会导致后一个key覆盖前一个key\",{\"1\":{\"545\":1}}],[\"就会导致内存泄漏\",{\"1\":{\"309\":1}}],[\"就会改变\",{\"1\":{\"520\":1}}],[\"就会造成了内存泄漏问题\",{\"1\":{\"329\":1}}],[\"就会出现这种情况\",{\"1\":{\"329\":1}}],[\"就会触发扩容\",{\"1\":{\"540\":1,\"542\":1}}],[\"就会触发full\",{\"1\":{\"135\":1}}],[\"就会触发minor\",{\"1\":{\"134\":1}}],[\"就会触发自动发布\",{\"1\":{\"21\":1}}],[\"就是指把继电保护的交流采样sv网\",{\"1\":{\"627\":1}}],[\"就是电网的智能化\",{\"1\":{\"621\":1}}],[\"就是将这些文件中编写的程序\",{\"1\":{\"565\":1}}],[\"就是把一个应用在硬盘上的文件\",{\"1\":{\"565\":1}}],[\"就是和hashmap一样\",{\"1\":{\"548\":1}}],[\"就是由加载因子和当前容器的容量大小来确定的\",{\"1\":{\"540\":1}}],[\"就是告知程序任何对该变量的访问均需要从共享内存中获取\",{\"1\":{\"351\":1}}],[\"就是这个坑被人占了\",{\"1\":{\"333\":1}}],[\"就是通过分别限制这两种类型的重排序\",{\"1\":{\"324\":1}}],[\"就是注解在编译期的运行\",{\"1\":{\"289\":1}}],[\"就是\",{\"1\":{\"238\":1}}],[\"就可得到原问题的解\",{\"1\":{\"480\":1}}],[\"就可能绕过双亲委派机制\",{\"1\":{\"216\":1}}],[\"就可以使用该类创建对象\",{\"1\":{\"189\":1}}],[\"就很大概率存在内存泄漏了\",{\"1\":{\"89\":1}}],[\"关系映射\",{\"1\":{\"655\":1}}],[\"关联关系如下\",{\"1\":{\"587\":1}}],[\"关闭调度器\",{\"1\":{\"440\":1}}],[\"关闭线程池\",{\"1\":{\"392\":1,\"407\":1,\"409\":1,\"477\":1}}],[\"关键字适用于所有字段的组合\",{\"1\":{\"613\":1}}],[\"关键字在\",{\"1\":{\"606\":1}}],[\"关键字或其他同步机制\",{\"1\":{\"546\":1}}],[\"关键字synchronized可以修饰方法或者以同步块的形式来进行使用\",{\"1\":{\"351\":1}}],[\"关键字volatile可以用来修饰字段\",{\"1\":{\"351\":1}}],[\"关键字的作用是让被修饰的成员属性不被序列化\",{\"1\":{\"517\":1}}],[\"关键字的作用\",{\"1\":{\"276\":1}}],[\"关键字修饰\",{\"1\":{\"276\":1}}],[\"关键参数\",{\"1\":{\"159\":1}}],[\"关键考虑因素\",{\"0\":{\"158\":1}}],[\"关键是要根据应用的具体需求和运行环境来做出决策\",{\"1\":{\"156\":1}}],[\"关注老年代内存使用是否达到阀值\",{\"1\":{\"89\":1}}],[\"关于作者\",{\"0\":{\"2\":1},\"1\":{\"2\":1}}],[\"关于网站\",{\"0\":{\"1\":1}}],[\"摘要信息\",{\"1\":{\"89\":1}}],[\"或调度人员\",{\"1\":{\"639\":1}}],[\"或数字化变电站\",{\"1\":{\"632\":1,\"641\":1}}],[\"或称为监视器锁\",{\"1\":{\"485\":1}}],[\"或在\",{\"1\":{\"472\":1}}],[\"或st5\",{\"1\":{\"633\":1}}],[\"或shutdownnow\",{\"1\":{\"446\":1,\"452\":1}}],[\"或submit\",{\"1\":{\"443\":1}}],[\"或\",{\"1\":{\"344\":2,\"389\":1,\"462\":1}}],[\"或与底层设备进行通信时\",{\"1\":{\"237\":1}}],[\"或老年代\",{\"1\":{\"141\":1}}],[\"或者进行控制的装置\",{\"1\":{\"626\":1}}],[\"或者向外部发送数据\",{\"1\":{\"626\":1}}],[\"或者等很久才会获得锁\",{\"1\":{\"499\":1}}],[\"或者等待时间到期\",{\"1\":{\"344\":1}}],[\"或者已经不再存活\",{\"1\":{\"493\":1}}],[\"或者通过轮询isterminated\",{\"1\":{\"452\":1}}],[\"或者\",{\"1\":{\"344\":1,\"550\":1}}],[\"或者使用json序列化\",{\"1\":{\"308\":1}}],[\"或者自定义的类加载器来实现这个功能\",{\"1\":{\"226\":1}}],[\"或者新生代对象的gc年龄到达阈值需要晋升到老年代\",{\"1\":{\"135\":1}}],[\"或者老年代中的对象存活时间过长\",{\"1\":{\"135\":1}}],[\"或者当长时间存活的对象需要晋升到老年代时\",{\"1\":{\"133\":1}}],[\"或者是持有对某些对象的引用却未能及时释放这些引用\",{\"1\":{\"123\":1}}],[\"或者出现异常错误\",{\"1\":{\"123\":1}}],[\"或以使用\",{\"1\":{\"89\":1}}],[\"或使用类似jmap\",{\"1\":{\"135\":1}}],[\"或使用在线分析平台\",{\"1\":{\"89\":1}}],[\"或使用第三方式具分析的\",{\"1\":{\"89\":1}}],[\"或使用\",{\"1\":{\"89\":2}}],[\"或元空间\",{\"1\":{\"81\":1,\"133\":1}}],[\"不仅减少了保护装置硬件故障的概率\",{\"1\":{\"625\":1}}],[\"不仅节省了设备的占地面积\",{\"1\":{\"625\":1}}],[\"不仅节省了设备投资\",{\"1\":{\"625\":1}}],[\"不仅精度更高\",{\"1\":{\"625\":1}}],[\"不论是正常运行还是事故状态\",{\"1\":{\"625\":1}}],[\"不过目录容易寻找查看\",{\"1\":{\"588\":1}}],[\"不过其他三个条件都是有办法破坏掉的\",{\"1\":{\"512\":1}}],[\"不好找\",{\"1\":{\"588\":1}}],[\"不存在谐振问题\",{\"1\":{\"632\":1}}],[\"不存在二次短路烧坏电压互感器的问题\",{\"1\":{\"632\":1}}],[\"不存在铁磁畸变和饱和问题\",{\"1\":{\"632\":1,\"633\":1}}],[\"不存在电磁感应回路\",{\"1\":{\"632\":1,\"633\":1}}],[\"不存在就再插入链表\",{\"1\":{\"548\":1}}],[\"不存在与其他线程的竞争\",{\"1\":{\"119\":1}}],[\"不可避免地要受电源可靠性的影响\",{\"1\":{\"633\":1}}],[\"不可剥夺\",{\"1\":{\"512\":1}}],[\"不可剥夺条件\",{\"1\":{\"512\":1}}],[\"不可变\",{\"1\":{\"268\":1}}],[\"不必唤醒所有线程\",{\"1\":{\"499\":1}}],[\"不处理队列中的任务\",{\"1\":{\"471\":1}}],[\"不接受新任务\",{\"1\":{\"470\":1,\"471\":1}}],[\"不需要大规模重构或修改代码\",{\"1\":{\"655\":1}}],[\"不需要再对数据进行工程物理量对应\",{\"1\":{\"636\":1}}],[\"不需要移动元素\",{\"1\":{\"515\":1}}],[\"不需要像synchronized关键字那样对整个代码块进行加锁\",{\"1\":{\"510\":1}}],[\"不需要并发执行的场景\",{\"1\":{\"455\":1}}],[\"不需要通过外部类的实例来创建\",{\"1\":{\"309\":1}}],[\"不方便\",{\"1\":{\"343\":1}}],[\"不为空\",{\"1\":{\"336\":1}}],[\"不擅技术\",{\"1\":{\"335\":1}}],[\"不管\",{\"1\":{\"482\":1}}],[\"不管jvm的内存空间是否充足\",{\"1\":{\"329\":1}}],[\"不管怎么重排序\",{\"1\":{\"321\":1}}],[\"不推荐使用\",{\"1\":{\"303\":1,\"521\":1}}],[\"不属于类的任何一个对象\",{\"1\":{\"301\":1}}],[\"不属于java\",{\"1\":{\"199\":1}}],[\"不能在多线程下发生并发修改\",{\"1\":{\"520\":1}}],[\"不能依赖于这个异常是否抛出而进行并发操作的编程\",{\"1\":{\"520\":1}}],[\"不能保证原子性\",{\"1\":{\"317\":2}}],[\"不能被访问控制修饰符及static所修饰\",{\"1\":{\"300\":1}}],[\"不能有其他类型的变量\",{\"1\":{\"299\":1}}],[\"不能实现\",{\"1\":{\"299\":1}}],[\"不能修饰外部类\",{\"1\":{\"297\":2}}],[\"不能修饰类和方法\",{\"1\":{\"276\":1}}],[\"不使用任何修饰符\",{\"1\":{\"297\":1}}],[\"不允许键和值为null\",{\"1\":{\"291\":1}}],[\"不包含静态变量\",{\"1\":{\"276\":1}}],[\"不行\",{\"1\":{\"267\":1}}],[\"不是通过插入顺序遍历\",{\"1\":{\"552\":1}}],[\"不是线程安全的\",{\"1\":{\"545\":1}}],[\"不是引用指向的内容的不可变\",{\"1\":{\"302\":1}}],[\"不是\",{\"1\":{\"267\":1}}],[\"不断监听通道列表\",{\"1\":{\"238\":1}}],[\"不同组件依赖的兼容性问题\",{\"1\":{\"562\":1}}],[\"不同组件之间部署时往往会产生一些冲突\",{\"1\":{\"558\":1}}],[\"不同于在共享变量上调用\",{\"1\":{\"344\":1}}],[\"不同系统安装不同java虚拟机\",{\"1\":{\"248\":1}}],[\"不同厂商提供了各自的\",{\"1\":{\"223\":1}}],[\"不同的线程在同一个计数器上\",{\"1\":{\"356\":1}}],[\"不同的是\",{\"1\":{\"344\":1}}],[\"不同的jvm\",{\"1\":{\"247\":1}}],[\"不同的类加载器可以通过不同的方式获取字节流\",{\"1\":{\"195\":1}}],[\"不同的gc适用于不同的应用场景和需求\",{\"1\":{\"157\":1}}],[\"不同的算法适用于不同的场景和需求\",{\"1\":{\"131\":1}}],[\"不会在二次开路时产生危及人身安全的高电压\",{\"1\":{\"633\":1}}],[\"不会抛出异常也不会进行任何处理\",{\"1\":{\"449\":1}}],[\"不会被其他线程中断\",{\"1\":{\"316\":1}}],[\"不会写入\",{\"1\":{\"289\":1}}],[\"不会出现线程安全问题\",{\"1\":{\"267\":1}}],[\"不会出现线程间的数据共享问题\",{\"1\":{\"92\":1}}],[\"不会移动存活对象\",{\"1\":{\"147\":1}}],[\"不会导致应用线程停顿\",{\"1\":{\"139\":1}}],[\"不建议过度依赖finalize\",{\"1\":{\"129\":1}}],[\"不确定性高\",{\"1\":{\"129\":1}}],[\"不再采用绝缘油作为绝缘介质\",{\"1\":{\"633\":1}}],[\"不再有任何活动线程\",{\"1\":{\"473\":1}}],[\"不再执行任何代码\",{\"1\":{\"347\":1}}],[\"不再执行下面的代码\",{\"1\":{\"263\":1}}],[\"不再执行循环\",{\"1\":{\"263\":1}}],[\"不再需要手动调整类似\",{\"1\":{\"115\":1}}],[\"不再使用堆内存\",{\"1\":{\"96\":1}}],[\"不受堆内存大小的限制\",{\"1\":{\"115\":1}}],[\"不受堆内存大小限制\",{\"1\":{\"98\":1}}],[\"不增加或增加缓慢\",{\"1\":{\"89\":1}}],[\"不要动gh\",{\"0\":{\"22\":1}}],[\"通道a\",{\"1\":{\"631\":1}}],[\"通道b\",{\"1\":{\"631\":1}}],[\"通信规约的多样化并不利于智能变电站的发展\",{\"1\":{\"648\":1}}],[\"通信规约又名通信协议\",{\"1\":{\"637\":1}}],[\"通信系统\",{\"1\":{\"628\":1}}],[\"通信平台网络化\",{\"1\":{\"623\":1}}],[\"通知机制\",{\"1\":{\"351\":2,\"495\":1}}],[\"通知或中断\",{\"1\":{\"345\":1}}],[\"通常任务会使用双端队列\",{\"1\":{\"480\":1}}],[\"通常为秒\",{\"1\":{\"448\":1}}],[\"通常是因为调用了wait\",{\"1\":{\"346\":1}}],[\"通常是因为等待获取锁\",{\"1\":{\"346\":1}}],[\"通常是通过读取字节码文件并调用\",{\"1\":{\"233\":1}}],[\"通常位于meta\",{\"1\":{\"252\":1}}],[\"通常返回这个类加载器\",{\"1\":{\"201\":1}}],[\"通常用于动态分配对象\",{\"1\":{\"163\":1}}],[\"通常会重写\",{\"1\":{\"233\":2}}],[\"通常会与年轻代的垃圾收集\",{\"1\":{\"142\":1}}],[\"通常会出现\",{\"1\":{\"89\":1}}],[\"通常需要根据具体的场景进行选择和调优\",{\"1\":{\"137\":1}}],[\"通常在1\",{\"1\":{\"151\":1,\"154\":1,\"159\":1}}],[\"通常在以下情况下会触发\",{\"1\":{\"135\":1}}],[\"通常在32位jvm中占用4个字节\",{\"1\":{\"121\":1}}],[\"通常情况下\",{\"1\":{\"134\":1,\"203\":1,\"226\":1,\"453\":1,\"656\":1}}],[\"通常存放在老年代的对象经过多次垃圾回收后仍然存活\",{\"1\":{\"130\":1}}],[\"通常\",{\"1\":{\"90\":2}}],[\"通常使用图形化工具分析\",{\"1\":{\"89\":1}}],[\"通过resultmap\",{\"1\":{\"656\":1}}],[\"通过mappedstatement可以获取sql语句的执行信息\",{\"1\":{\"656\":1}}],[\"通过iec61850的控制相关数据结构实现\",{\"1\":{\"652\":1}}],[\"通过定值控制块\",{\"1\":{\"652\":1}}],[\"通过数字运算\",{\"1\":{\"634\":1}}],[\"通过先进的传感和测量技术\",{\"1\":{\"621\":1}}],[\"通过指令定义集群中的每个容器如何运行\",{\"1\":{\"595\":1}}],[\"通过指令描述镜像的构建过程\",{\"1\":{\"594\":1}}],[\"通过load命令加载为镜像\",{\"1\":{\"587\":1}}],[\"通过lock\",{\"1\":{\"495\":1}}],[\"通过命令\",{\"1\":{\"573\":2}}],[\"通过命令或restapi向docker服务端发送指令\",{\"1\":{\"567\":1}}],[\"通过atomicreference来保证原子性\",{\"1\":{\"508\":1}}],[\"通过native方法实现以原子方式将引用值和印戳标志的值更新为给定的更新值\",{\"1\":{\"505\":1}}],[\"通过cas操作竞争锁\",{\"1\":{\"493\":1}}],[\"通过异步调用\",{\"1\":{\"479\":1}}],[\"通过持久化任务队列\",{\"1\":{\"478\":1}}],[\"通过以上评估方案\",{\"1\":{\"476\":1}}],[\"通过测试可以验证线程池的配置是否合理\",{\"1\":{\"476\":1}}],[\"通过对比可知\",{\"1\":{\"631\":1}}],[\"通过对系统负载\",{\"1\":{\"476\":1}}],[\"通过对象之间的引用关系进行遍历\",{\"1\":{\"126\":1}}],[\"通过覆盖\",{\"1\":{\"463\":1}}],[\"通过覆盖findclass方法实现从指定路径加载类文件\",{\"1\":{\"204\":1}}],[\"通过调用\",{\"1\":{\"475\":1}}],[\"通过调用schedule\",{\"1\":{\"455\":1}}],[\"通过调用shutdown\",{\"1\":{\"452\":1}}],[\"通过调整这个参数\",{\"1\":{\"139\":1}}],[\"通过使用动态\",{\"1\":{\"656\":1}}],[\"通过使用锁分段技术和cas操作来实现高效的并发性能\",{\"1\":{\"546\":1}}],[\"通过使用scheduledthreadpoolexecutor\",{\"1\":{\"439\":1}}],[\"通过使用数据库连接池\",{\"1\":{\"427\":1}}],[\"通过使用线程池\",{\"1\":{\"423\":1,\"431\":1,\"435\":1}}],[\"通过使用泛型\",{\"1\":{\"284\":1}}],[\"通过自定义线程池\",{\"1\":{\"409\":1}}],[\"通过设置自定义线程池\",{\"1\":{\"398\":1}}],[\"通过设置线程的中断标志并不能直接终止该线程的执行\",{\"1\":{\"344\":1}}],[\"通过在代理类中封装线程池\",{\"1\":{\"475\":1}}],[\"通过在构造函数中传入\",{\"1\":{\"359\":1}}],[\"通过在classpath中提供配置文件\",{\"1\":{\"252\":1}}],[\"通过\",{\"1\":{\"333\":1,\"362\":1}}],[\"通过禁止特定类型的编译器重排序和处理器重排序\",{\"1\":{\"319\":1}}],[\"通过序列化机制\",{\"1\":{\"308\":1}}],[\"通过继承可以很方便地进行代码复用\",{\"1\":{\"295\":1}}],[\"通过实现serializable接口和externalizable接口来实现对象的序列化和反序列化\",{\"1\":{\"277\":1}}],[\"通过反射机制\",{\"1\":{\"308\":1}}],[\"通过反射\",{\"1\":{\"256\":1}}],[\"通过反射你可以获取任意一个类的所有属性和方法\",{\"1\":{\"254\":1}}],[\"通过入参的\",{\"1\":{\"244\":1}}],[\"通过optional类\",{\"1\":{\"240\":1}}],[\"通过stream\",{\"1\":{\"240\":1}}],[\"通过选择器\",{\"1\":{\"238\":1}}],[\"通过合理设计和实现\",{\"1\":{\"232\":1}}],[\"通过thread\",{\"1\":{\"220\":1}}],[\"通过编写自定义的类加载器\",{\"1\":{\"215\":1}}],[\"通过逐级向上委派类加载请求\",{\"1\":{\"207\":1,\"209\":1}}],[\"通过委派机制\",{\"1\":{\"207\":1}}],[\"通过理解和使用不同的类加载器\",{\"1\":{\"204\":1}}],[\"通过类的全限定名\",{\"1\":{\"192\":1}}],[\"通过类加载器将\",{\"1\":{\"180\":1}}],[\"通过了解类的生命周期\",{\"1\":{\"190\":1}}],[\"通过垃圾回收机制回收不再使用的对象\",{\"1\":{\"178\":1}}],[\"通过标量替换优化\",{\"1\":{\"172\":1}}],[\"通过逃逸分析\",{\"1\":{\"165\":1}}],[\"通过评估应用的停顿时间需求\",{\"1\":{\"161\":1}}],[\"通过压缩阶段\",{\"1\":{\"148\":1}}],[\"通过分区和并发标记\",{\"1\":{\"143\":1}}],[\"通过分析占用内存较多的对象类型\",{\"1\":{\"86\":1}}],[\"通过分析线程的堆栈信息\",{\"1\":{\"85\":1}}],[\"通过并发的方式来实现在非常短的停顿时间内完成垃圾收集\",{\"1\":{\"137\":1}}],[\"通过并发标记\",{\"1\":{\"137\":1}}],[\"通过多线程并行收集实现高吞吐量\",{\"1\":{\"137\":1}}],[\"通过将不同类型的对象放置在不同的区域中\",{\"1\":{\"130\":1}}],[\"通过虚引用可以跟踪对象被垃圾回收的状态\",{\"1\":{\"128\":1}}],[\"通过栈上的reference数据来操作堆上的具体对象\",{\"1\":{\"122\":1}}],[\"通过这个链表\",{\"1\":{\"551\":1}}],[\"通过这个引用\",{\"1\":{\"117\":1}}],[\"通过这些方法\",{\"1\":{\"467\":1}}],[\"通过这些对象可以遍历到所有活动对象\",{\"1\":{\"127\":1}}],[\"通过这些解决方案\",{\"1\":{\"120\":1}}],[\"通过移动指针来分配内存\",{\"1\":{\"118\":1}}],[\"通过动态调整减少配置的复杂性\",{\"1\":{\"116\":1}}],[\"通过上述对比\",{\"1\":{\"105\":1}}],[\"通过可疑对象定位到具体代码再次分析\",{\"1\":{\"88\":1}}],[\"通过监控和分析gc日志\",{\"1\":{\"87\":1}}],[\"通过工具提供的分析功能\",{\"1\":{\"86\":1}}],[\"通过观察gc次数和回收的内存空间\",{\"1\":{\"86\":1}}],[\"通过观察线程的cpu占用率\",{\"1\":{\"85\":1}}],[\"通过观察cpu占用率较高的进程\",{\"1\":{\"85\":1}}],[\"通过线程进行分析\",{\"1\":{\"84\":1}}],[\"通过jprofiler查看到占用内存最大的对象是string对象\",{\"1\":{\"84\":1}}],[\"通过开启了\",{\"1\":{\"84\":1}}],[\"通过系统性的分析和优化来达到最佳的性能和资源利用率\",{\"1\":{\"83\":1}}],[\"通过优化java代码和算法来减少内存使用和垃圾回收的压力\",{\"1\":{\"81\":1}}],[\"次数太多\",{\"1\":{\"89\":1}}],[\"次数\",{\"1\":{\"89\":1}}],[\"次\",{\"1\":{\"89\":1}}],[\"秒输出\",{\"1\":{\"89\":1}}],[\"抓取线程栈\",{\"1\":{\"89\":1}}],[\"抓取网络数据包\",{\"1\":{\"54\":1}}],[\"进度\",{\"1\":{\"620\":1,\"642\":1}}],[\"进⼊同步代码前要获得当前\",{\"1\":{\"482\":1}}],[\"进入cloud\",{\"1\":{\"602\":1}}],[\"进入docker\",{\"1\":{\"592\":1}}],[\"进入html数据卷所在位置\",{\"1\":{\"586\":1}}],[\"进入该目录\",{\"1\":{\"579\":1,\"586\":1}}],[\"进入该状态表示当前线\",{\"1\":{\"345\":1}}],[\"进入nginx的html所在目录\",{\"1\":{\"579\":1}}],[\"进入nginx容器\",{\"1\":{\"579\":1}}],[\"进入我们刚刚创建的nginx容器的命令为\",{\"1\":{\"579\":1}}],[\"进入容器后执行的命令\",{\"1\":{\"579\":1}}],[\"进入容器内部\",{\"1\":{\"579\":1}}],[\"进入容器要用到docker\",{\"1\":{\"579\":1}}],[\"进入容器\",{\"0\":{\"579\":1},\"1\":{\"579\":1}}],[\"进入阻塞状态\",{\"1\":{\"496\":1}}],[\"进入同步代码前要获得\",{\"1\":{\"482\":1}}],[\"进入下一个循环条件\",{\"1\":{\"263\":1}}],[\"进而产生问题\",{\"1\":{\"303\":1}}],[\"进而用到了integercache\",{\"1\":{\"272\":1}}],[\"进而导致长时间的停顿\",{\"1\":{\"147\":1}}],[\"进行远方遥控操作时\",{\"1\":{\"639\":1}}],[\"进行去重\",{\"1\":{\"614\":1}}],[\"进行了一系列判断\",{\"1\":{\"554\":1}}],[\"进行一次抢锁\",{\"1\":{\"501\":1}}],[\"进行加锁操作时\",{\"1\":{\"494\":1}}],[\"进行阻塞\",{\"1\":{\"353\":2}}],[\"进行倒数计数\",{\"1\":{\"353\":2}}],[\"进行过滤\",{\"1\":{\"244\":1}}],[\"进行相应的处理\",{\"1\":{\"238\":1}}],[\"进行垃圾回收和区域回收\",{\"1\":{\"142\":1}}],[\"进行垃圾回收操作\",{\"1\":{\"138\":1}}],[\"进行对象的初始化\",{\"1\":{\"117\":1}}],[\"进制值\",{\"1\":{\"89\":1}}],[\"进制\",{\"1\":{\"89\":1}}],[\"进程终止\",{\"1\":{\"577\":1}}],[\"进程暂停\",{\"1\":{\"577\":1}}],[\"进程正常运行\",{\"1\":{\"577\":1}}],[\"进程id\",{\"1\":{\"513\":1}}],[\"进程中的多个线程共享进程的资源\",{\"1\":{\"340\":1}}],[\"进程是代码在数据集合上的一次运行活动\",{\"1\":{\"340\":1}}],[\"进程\",{\"1\":{\"54\":1,\"89\":1,\"340\":1}}],[\"进程信息等\",{\"1\":{\"54\":1}}],[\"严重内存泄漏往往伴随频繁的\",{\"1\":{\"89\":1}}],[\"错误处理和回滚等\",{\"1\":{\"232\":1}}],[\"错误处理和回滚\",{\"0\":{\"231\":1}}],[\"错误\",{\"1\":{\"89\":1}}],[\"错误监控\",{\"1\":{\"65\":1,\"70\":1}}],[\"弄清楚可疑对象是否满足了进入到老年代的条件才能下结论\",{\"1\":{\"88\":1}}],[\"其内容应该包括如下四个方面\",{\"1\":{\"644\":1}}],[\"其内部调用的是\",{\"1\":{\"344\":1}}],[\"其主要作用有以下4个方面\",{\"1\":{\"639\":1}}],[\"其输出为电压信号\",{\"1\":{\"635\":1}}],[\"其相对磁导率与空气的相对磁导率相同\",{\"1\":{\"635\":1}}],[\"其偏振角发生变化\",{\"1\":{\"633\":1}}],[\"其偏振面就会发生偏转\",{\"1\":{\"633\":1}}],[\"其偏转角φ是对被测电流i\",{\"1\":{\"633\":1}}],[\"其余为备用插件\",{\"1\":{\"631\":1}}],[\"其各自的优缺点见表1\",{\"1\":{\"627\":1}}],[\"其网络结构示意图如图1\",{\"1\":{\"627\":2}}],[\"其功能的整合以统一标准为纽带\",{\"1\":{\"624\":1}}],[\"其次要考虑的是你的系统资源\",{\"1\":{\"453\":1}}],[\"其实dockercompose文件可以看做是将多个docker\",{\"1\":{\"595\":1}}],[\"其实就是实现上述打包的过程\",{\"1\":{\"589\":1}}],[\"其实就体现了分治思想\",{\"1\":{\"480\":1}}],[\"其实都是基于对象的内置锁\",{\"1\":{\"485\":1}}],[\"其实在jvm\",{\"1\":{\"350\":1}}],[\"其实是会生成新的对象\",{\"1\":{\"270\":1}}],[\"其含义是\",{\"1\":{\"344\":1,\"351\":1}}],[\"其它的原子操作类基本都是大同小异\",{\"1\":{\"511\":1}}],[\"其它获取该锁的线程会被阻塞而被放入该锁的阻塞队列里面\",{\"1\":{\"497\":1}}],[\"其它线程就会在获取失败后被阻塞\",{\"1\":{\"496\":1}}],[\"其它线程无法获取主内存中的共享变量\",{\"1\":{\"487\":1}}],[\"其它\",{\"0\":{\"251\":1}}],[\"其父加载器是扩展类加载器\",{\"1\":{\"201\":1}}],[\"其父加载器是启动类加载器\",{\"1\":{\"200\":1}}],[\"其中定义的方法与sql语句相对应\",{\"1\":{\"656\":1}}],[\"其中保护装置\",{\"1\":{\"637\":1}}],[\"其中goose网主要传送一些开关量信息\",{\"1\":{\"628\":1}}],[\"其中有我提前准备好的数据\",{\"1\":{\"598\":1}}],[\"其中包含5个service服务\",{\"1\":{\"598\":1}}],[\"其中包含两个容器\",{\"1\":{\"595\":1}}],[\"其中包含一个个的指令\",{\"1\":{\"590\":1}}],[\"其中的ip改成你的虚拟机ip\",{\"1\":{\"592\":1}}],[\"其中的内容如下\",{\"1\":{\"592\":1}}],[\"其中的线程会等待\",{\"1\":{\"356\":1}}],[\"其中n是树中节点的数量\",{\"1\":{\"528\":1}}],[\"其中每个线程都有自己的控制器和运算器\",{\"1\":{\"315\":1}}],[\"其中\",{\"1\":{\"183\":1,\"512\":1,\"577\":1}}],[\"其中元空间被打满\",{\"1\":{\"88\":1}}],[\"其工作过程可以概括为以下几个阶段\",{\"1\":{\"140\":1}}],[\"其过程比较耗时\",{\"1\":{\"133\":1}}],[\"其他⽅法都是直接调⽤\",{\"1\":{\"554\":1}}],[\"其他线程必须等待该线程释放锁后才能获取锁\",{\"1\":{\"485\":1}}],[\"其他线程不\",{\"1\":{\"356\":1}}],[\"其他线程调用了线程a的\",{\"1\":{\"344\":1}}],[\"其他线程调用了线程a共享对象\",{\"1\":{\"344\":1}}],[\"其他线程能够立即看到这个修改\",{\"1\":{\"316\":1}}],[\"其他线程无法访问\",{\"1\":{\"119\":1}}],[\"其他类加载器再次加载同样的类时\",{\"1\":{\"210\":1}}],[\"其他jvm如j9和jrockit不会因为固定大小的永久代而遭遇内存溢出问题\",{\"1\":{\"113\":1}}],[\"其他jvm的优势\",{\"1\":{\"113\":1}}],[\"其他内存区域\",{\"1\":{\"96\":1}}],[\"其他常见参数\",{\"0\":{\"76\":1}}],[\"基础镜像可以是基本操作系统\",{\"1\":{\"594\":1}}],[\"基础\",{\"0\":{\"338\":1,\"605\":1,\"755\":1}}],[\"基础语法\",{\"0\":{\"257\":1}}],[\"基础组件升级等情况\",{\"1\":{\"88\":1}}],[\"基于nacos\",{\"1\":{\"598\":1}}],[\"基于ubuntu镜像构建一个新镜像\",{\"1\":{\"592\":1}}],[\"基于ubuntu构建java项目\",{\"0\":{\"592\":1}}],[\"基于拷贝内容的优点是避免了concurrent\",{\"1\":{\"520\":1}}],[\"基于cas来操作int类型变量\",{\"1\":{\"511\":1}}],[\"基于java\",{\"1\":{\"593\":2}}],[\"基于java8构建java项目\",{\"0\":{\"593\":1}}],[\"基于java虚拟机\",{\"1\":{\"256\":1}}],[\"基于jvm实现\",{\"1\":{\"495\":1}}],[\"基于红黑树实现的有序map\",{\"1\":{\"291\":1}}],[\"基于哈希表实现的线程安全的map\",{\"1\":{\"291\":1}}],[\"基于哈希表实现的map\",{\"1\":{\"291\":2}}],[\"基于哈希表和双向链表实现的map\",{\"1\":{\"291\":1}}],[\"基于vuepress\",{\"1\":{\"8\":1}}],[\"基本语法\",{\"0\":{\"607\":1}}],[\"基本概念\",{\"0\":{\"366\":1}}],[\"基本类型\",{\"1\":{\"258\":1}}],[\"基本数据类型==比较的是值\",{\"1\":{\"304\":1}}],[\"基本数据类型相同\",{\"1\":{\"296\":1}}],[\"基本数据类型吗\",{\"0\":{\"267\":1}}],[\"基本数据类型\",{\"1\":{\"258\":1}}],[\"基本数据类型直接存储其值\",{\"1\":{\"121\":1}}],[\"基本就能定位到问题在那了使用\",{\"1\":{\"89\":1}}],[\"显然也就起到了降低一次电流值\",{\"1\":{\"633\":1}}],[\"显然电阻分压式电压互感器不存在电磁感应元件\",{\"1\":{\"632\":1}}],[\"显著减少了内存碎片化问题\",{\"1\":{\"148\":1,\"153\":1}}],[\"显式调用了gc\",{\"1\":{\"88\":1}}],[\"显示一个或多个volume的信息\",{\"1\":{\"583\":1}}],[\"显示线程的信息\",{\"1\":{\"56\":1}}],[\"显示jvm的信息\",{\"1\":{\"56\":1}}],[\"显示arthas的帮助文档\",{\"1\":{\"56\":1}}],[\"显示arthas的仪表盘\",{\"1\":{\"56\":1}}],[\"显示系统中的进程信息\",{\"1\":{\"54\":1}}],[\"即sgcb来实现选择定值区进行召唤\",{\"1\":{\"652\":1}}],[\"即urcb来实现\",{\"1\":{\"652\":1}}],[\"即brcb来实现\",{\"1\":{\"652\":1}}],[\"即是建立配置基础\",{\"1\":{\"651\":1}}],[\"即ied之间的通信行为和相关的系统要求\",{\"1\":{\"647\":1}}],[\"即变电站能力描述文本\",{\"1\":{\"644\":1}}],[\"即变电站层\",{\"1\":{\"636\":1}}],[\"即当网络技术发展时只要改动scsm\",{\"1\":{\"636\":1}}],[\"即支持iec\",{\"1\":{\"631\":1}}],[\"即goose网和sv网\",{\"1\":{\"628\":1}}],[\"即gh\",{\"1\":{\"22\":1}}],[\"即站控层网络\",{\"1\":{\"628\":1}}],[\"即站控层\",{\"1\":{\"628\":1}}],[\"即可看到结果\",{\"1\":{\"579\":1}}],[\"即保护装置\",{\"1\":{\"645\":1}}],[\"即保留了低位hash值\",{\"1\":{\"535\":1}}],[\"即保证了代码的串行语义\",{\"1\":{\"316\":1}}],[\"即不同的键计算得到相同的桶索引\",{\"1\":{\"525\":1}}],[\"即迭代器创建时的集合状态\",{\"1\":{\"522\":1}}],[\"即该资源同时只由一个线程占用\",{\"1\":{\"512\":1}}],[\"即表示此对象处于轻量级锁状态\",{\"1\":{\"494\":1}}],[\"即将任务提交到线程池后立即返回\",{\"1\":{\"479\":1}}],[\"即要么任务执行成功\",{\"1\":{\"478\":1}}],[\"即无限大\",{\"1\":{\"458\":1}}],[\"即适用执行长期的任务\",{\"1\":{\"457\":1}}],[\"即keepalivetime为0\",{\"1\":{\"457\":1}}],[\"即在指定延迟时间之后才能被消费\",{\"1\":{\"450\":1}}],[\"即线程变量\",{\"1\":{\"351\":1}}],[\"即防止读操作重排序到写操作之后\",{\"1\":{\"324\":1}}],[\"即防止写操作重排序到读操作之后\",{\"1\":{\"324\":1}}],[\"即确保第一个加载操作的结果对后续的加载操作可见\",{\"1\":{\"324\":1}}],[\"即确保第一个存储操作的结果对后续的存储操作可见\",{\"1\":{\"324\":1}}],[\"即能够正确读取到最新的值\",{\"1\":{\"316\":1}}],[\"即默认\",{\"1\":{\"297\":1}}],[\"即⼀个引⽤变量到底会指向哪个类的实例对象\",{\"1\":{\"295\":1}}],[\"即equals\",{\"1\":{\"271\":1}}],[\"即eden区和survivor区\",{\"1\":{\"133\":1}}],[\"即返回\",{\"1\":{\"244\":1}}],[\"即一个类加载请求会先委派给父类加载器处理\",{\"1\":{\"203\":1}}],[\"即\",{\"1\":{\"177\":1,\"193\":1,\"520\":1,\"627\":1}}],[\"即大多数对象的生命周期很短\",{\"1\":{\"131\":1}}],[\"即使电流通道开路也就不会出现危及人身安全的高电压\",{\"1\":{\"625\":1}}],[\"即使线程池中的线程都在忙碌\",{\"1\":{\"450\":1}}],[\"即使线程处于空闲状态\",{\"1\":{\"448\":1}}],[\"即使这两个对象指向相同的数据\",{\"1\":{\"305\":1}}],[\"即使系统出现内存溢出\",{\"1\":{\"128\":1}}],[\"即使在程序的其他部分不再需要这些对象\",{\"1\":{\"125\":1}}],[\"即java代码调用本地方法时传递的对象引用\",{\"1\":{\"127\":1}}],[\"即静态成员变量\",{\"1\":{\"127\":1}}],[\"即为\",{\"1\":{\"126\":1}}],[\"即reference中存储的是稳定的句柄地址\",{\"1\":{\"122\":1}}],[\"即时编译器编译后的代码等\",{\"1\":{\"92\":1}}],[\"即本文中的案例\",{\"1\":{\"88\":1}}],[\"长期存活的对象\",{\"1\":{\"136\":2}}],[\"长时间存活的缓存对象等\",{\"1\":{\"136\":1}}],[\"长时间运行的程序可能会持续产生新对象而不释放旧对象\",{\"1\":{\"125\":1}}],[\"长时间运行的程序\",{\"1\":{\"125\":1}}],[\"长时间运行的程序中如果存在内存泄漏\",{\"1\":{\"123\":1}}],[\"长时间的垃圾回收停顿等\",{\"1\":{\"80\":1}}],[\"长生命周期的对象\",{\"1\":{\"88\":1}}],[\"先进的控制方法及先进的决策支持系统技术的应用\",{\"1\":{\"621\":1}}],[\"先进的设备技术\",{\"1\":{\"621\":1}}],[\"先删除本地的nginx镜像\",{\"1\":{\"574\":1}}],[\"先读取i的值\",{\"1\":{\"317\":1}}],[\"先finally\",{\"1\":{\"282\":1}}],[\"先赋值\",{\"1\":{\"265\":1}}],[\"先自增\",{\"1\":{\"265\":1}}],[\"先对\",{\"1\":{\"244\":1}}],[\"先引发fgc\",{\"1\":{\"88\":1}}],[\"先找到了几个正在运行的业务线程\",{\"1\":{\"84\":1}}],[\"大量省去保护装置内部的继电器\",{\"1\":{\"625\":1}}],[\"大型项目组件较多\",{\"1\":{\"559\":1}}],[\"大型互联网公司\",{\"1\":{\"155\":1}}],[\"大于1\",{\"1\":{\"480\":1}}],[\"大任务拆成了若干个小任务\",{\"1\":{\"480\":1}}],[\"大乔\",{\"1\":{\"353\":4}}],[\"大数据处理\",{\"1\":{\"158\":1}}],[\"大数据处理和金融系统\",{\"1\":{\"151\":1}}],[\"大堆内存\",{\"1\":{\"158\":1,\"159\":2}}],[\"大公司和常见应用中的选择\",{\"0\":{\"155\":1}}],[\"大部分高级应用功能只是一个运行于一体化平台服务器的系统软件\",{\"1\":{\"630\":1}}],[\"大部分的垃圾收集工作与应用程序并发进行\",{\"1\":{\"139\":1}}],[\"大部分公司都会有\",{\"1\":{\"88\":1}}],[\"大多数对象都会被分配到eden区\",{\"1\":{\"132\":1}}],[\"大多数对象从新生代晋升到老年代\",{\"1\":{\"130\":1}}],[\"大多数对象在被分配时会被分配在eden区\",{\"1\":{\"130\":1}}],[\"大对象\",{\"1\":{\"88\":1,\"136\":1}}],[\"大小等内存参数\",{\"1\":{\"81\":1}}],[\"清理过期entry\",{\"1\":{\"334\":1}}],[\"清理\",{\"1\":{\"142\":1}}],[\"清除\",{\"1\":{\"139\":1}}],[\"清除和复制算法的优点\",{\"1\":{\"131\":1}}],[\"清除所有未标记的对象\",{\"1\":{\"131\":1}}],[\"清除算法存在的问题是产生大量的内存碎片\",{\"1\":{\"131\":1}}],[\"清除算法是最基本的垃圾收集算法之一\",{\"1\":{\"131\":1}}],[\"清除算法\",{\"1\":{\"131\":1,\"147\":1}}],[\"清除垃圾回收的线程数\",{\"1\":{\"73\":1}}],[\"清除垃圾回收器\",{\"1\":{\"73\":1}}],[\"清楚主变压器相关二次回路\",{\"1\":{\"644\":1}}],[\"清楚排查问题时能使用哪些工具\",{\"1\":{\"88\":1}}],[\"清楚从程序角度\",{\"1\":{\"88\":1}}],[\"如制造报文规范\",{\"1\":{\"636\":1}}],[\"如获取和设定对象值的通信服务\",{\"1\":{\"636\":1}}],[\"如遥信\",{\"1\":{\"628\":1}}],[\"如遥控\",{\"1\":{\"628\":1}}],[\"如电子多功能仪表\",{\"1\":{\"626\":1}}],[\"如下所示\",{\"1\":{\"599\":1}}],[\"如下是\",{\"1\":{\"89\":1}}],[\"如ubuntu\",{\"1\":{\"594\":1}}],[\"如urlclassloader\",{\"1\":{\"216\":1}}],[\"如图1\",{\"1\":{\"633\":1,\"637\":1,\"641\":1}}],[\"如图\",{\"1\":{\"561\":1,\"563\":1,\"567\":1,\"571\":1,\"587\":1}}],[\"如使用synchronized关键字或lock\",{\"1\":{\"521\":1}}],[\"如atomicboolean\",{\"1\":{\"510\":1}}],[\"如arrayblockingqueue\",{\"1\":{\"448\":1}}],[\"如reentrantlock\",{\"1\":{\"509\":1,\"546\":1}}],[\"如等待可中断\",{\"1\":{\"495\":1}}],[\"如增加了适应性自旋\",{\"1\":{\"491\":1}}],[\"如哈希码\",{\"1\":{\"490\":1}}],[\"如线程池过载\",{\"1\":{\"476\":1}}],[\"如监控\",{\"1\":{\"475\":1}}],[\"如网络请求\",{\"1\":{\"453\":1}}],[\"如linkedblockingqueue\",{\"1\":{\"448\":1}}],[\"如无空闲核心线程则将任务加入队列\",{\"1\":{\"447\":1}}],[\"如创建新线程\",{\"1\":{\"403\":1}}],[\"如数组或者链表\",{\"1\":{\"400\":1}}],[\"如数据库连接池\",{\"1\":{\"357\":1}}],[\"如数据处理系统和大规模微服务架构\",{\"1\":{\"151\":1}}],[\"如提高性能或控制资源使用\",{\"1\":{\"387\":1}}],[\"如双缓冲区交换\",{\"1\":{\"360\":1}}],[\"如生产者和消费者模式中的数据交换\",{\"1\":{\"360\":1}}],[\"如控制多个线程对某个资源的访问\",{\"1\":{\"357\":1}}],[\"如限制同时处理的请求数量\",{\"1\":{\"357\":1}}],[\"如再次await\",{\"1\":{\"355\":1}}],[\"如if\",{\"1\":{\"656\":1}}],[\"如i\",{\"1\":{\"349\":1}}],[\"如int\",{\"1\":{\"306\":1}}],[\"如int类型的0\",{\"1\":{\"117\":1}}],[\"如上图所示\",{\"1\":{\"333\":1}}],[\"如synchronized关键字\",{\"1\":{\"318\":3}}],[\"如锁\",{\"1\":{\"316\":1}}],[\"如单例模式的实现\",{\"1\":{\"313\":1}}],[\"如hessian\",{\"1\":{\"277\":1}}],[\"如拼接\",{\"1\":{\"267\":1}}],[\"如tomcat\",{\"0\":{\"219\":1},\"1\":{\"219\":1}}],[\"如osgi\",{\"1\":{\"218\":1}}],[\"如何获取生成的主键\",{\"0\":{\"770\":1}}],[\"如何使用注解方式定义\",{\"0\":{\"739\":1}}],[\"如何使用动态\",{\"0\":{\"710\":1}}],[\"如何防范\",{\"0\":{\"733\":1,\"753\":1}}],[\"如何解读性能分析报告\",{\"0\":{\"713\":1}}],[\"如何解决\",{\"0\":{\"503\":1}}],[\"如何进行\",{\"0\":{\"733\":1,\"753\":1}}],[\"如何进行性能分析和调优\",{\"0\":{\"713\":1}}],[\"如何进行批量更新和批量\",{\"0\":{\"693\":1}}],[\"如何避免动态\",{\"0\":{\"710\":1}}],[\"如何定义一个复杂的\",{\"0\":{\"708\":1}}],[\"如何支持数据库的分页查询\",{\"0\":{\"690\":1}}],[\"如何处理复杂的结果集映射\",{\"0\":{\"712\":1}}],[\"如何处理缓存失效\",{\"0\":{\"702\":1}}],[\"如何处理多表查询结果的映射\",{\"0\":{\"701\":1}}],[\"如何处理动态条件\",{\"0\":{\"691\":1}}],[\"如何处理数据库的连接异常\",{\"0\":{\"723\":1}}],[\"如何处理数据库的分页查询\",{\"0\":{\"718\":1}}],[\"如何处理数据库的乐观锁和悲观锁\",{\"0\":{\"707\":1}}],[\"如何处理数据库连接的超时和重试机制\",{\"0\":{\"725\":1,\"745\":1}}],[\"如何处理数据库连接的管理和释放\",{\"0\":{\"705\":1,\"737\":1}}],[\"如何处理数据库连接的异常和超时\",{\"0\":{\"689\":1}}],[\"如何处理数据库分页\",{\"0\":{\"699\":1}}],[\"如何处理数据库字段和\",{\"0\":{\"694\":1}}],[\"如何处理数据库事务\",{\"0\":{\"671\":1}}],[\"如何处理乐观锁和悲观锁\",{\"0\":{\"682\":1}}],[\"如何处理\",{\"0\":{\"678\":1}}],[\"如何处理结果集的映射\",{\"0\":{\"677\":1,\"712\":1}}],[\"如何处理懒加载\",{\"0\":{\"666\":1}}],[\"如何在\",{\"0\":{\"660\":1,\"663\":1,\"668\":1,\"679\":1}}],[\"如何做到的\",{\"1\":{\"512\":1}}],[\"如何保证多线程下i++\",{\"0\":{\"509\":1}}],[\"如何破坏双亲委派机制\",{\"0\":{\"214\":1}}],[\"如何判断对象仍然存活\",{\"0\":{\"126\":1}}],[\"如动态加载\",{\"1\":{\"204\":1}}],[\"如从文件系统\",{\"1\":{\"192\":1}}],[\"如com\",{\"1\":{\"192\":1}}],[\"如基本数据类型或其他不包含引用的变量\",{\"1\":{\"169\":1}}],[\"如jaxb\",{\"1\":{\"277\":1}}],[\"如jackson\",{\"1\":{\"277\":1}}],[\"如java\",{\"1\":{\"114\":1,\"199\":1,\"206\":1,\"207\":1}}],[\"如jvisualvm\",{\"1\":{\"160\":1}}],[\"如批处理\",{\"1\":{\"158\":1}}],[\"如金融交易\",{\"1\":{\"158\":1}}],[\"如银行\",{\"1\":{\"155\":1}}],[\"如getandincrement\",{\"1\":{\"510\":1}}],[\"如google\",{\"1\":{\"155\":1}}],[\"如gcviewer\",{\"1\":{\"87\":1}}],[\"如实时系统\",{\"1\":{\"151\":1,\"158\":1}}],[\"如web服务器和交易系统\",{\"1\":{\"151\":1}}],[\"如启动阈值\",{\"1\":{\"147\":1}}],[\"如通过反射机制获取类的方法和字段信息\",{\"1\":{\"195\":1}}],[\"如通过\",{\"1\":{\"141\":1}}],[\"如内存碎片化问题和某些情况下的长停顿时间\",{\"1\":{\"139\":1}}],[\"如大数组或长字符串\",{\"1\":{\"136\":1}}],[\"如全局变量\",{\"1\":{\"136\":1}}],[\"如永久代\",{\"1\":{\"133\":1}}],[\"如垃圾收集时\",{\"1\":{\"122\":1}}],[\"如32位或64位jvm\",{\"1\":{\"117\":1}}],[\"如字符串常量池中的字符串对象\",{\"1\":{\"127\":1}}],[\"如字符串常量池\",{\"1\":{\"114\":1}}],[\"如类名\",{\"1\":{\"187\":1,\"195\":1}}],[\"如类\",{\"1\":{\"107\":1}}],[\"如整数\",{\"1\":{\"107\":1}}],[\"如运行时常量池\",{\"1\":{\"95\":1}}],[\"如mat\",{\"1\":{\"90\":1}}],[\"如\",{\"1\":{\"89\":2,\"247\":1,\"656\":1}}],[\"如果ⅱ母电压互感器停运\",{\"1\":{\"641\":1}}],[\"如果ⅰ母电压互感器停运\",{\"1\":{\"641\":1}}],[\"如果n2=k×n1\",{\"1\":{\"633\":1}}],[\"如果n的值小于等于1\",{\"1\":{\"480\":1}}],[\"如果忽略漏磁\",{\"1\":{\"633\":1}}],[\"如果用于智能变电站\",{\"1\":{\"632\":1}}],[\"如果两个或多个行的所有字段都相同\",{\"1\":{\"613\":1}}],[\"如果两个对象根据\",{\"1\":{\"305\":1}}],[\"如果我们将qq在磁盘上的运行文件及其运行的操作系统依赖打包\",{\"1\":{\"565\":1}}],[\"如果我们插入一个value=27的数据\",{\"1\":{\"333\":1}}],[\"如果都不满足\",{\"1\":{\"549\":1}}],[\"如果hash==moved\",{\"1\":{\"549\":1}}],[\"如果正在初始化或者扩容\",{\"1\":{\"549\":1}}],[\"如果数组是空的话\",{\"1\":{\"549\":1}}],[\"如果获取锁失败则尝试自旋\",{\"1\":{\"548\":1}}],[\"如果计算出来的索引位置相同\",{\"1\":{\"545\":1}}],[\"如果计数器为零\",{\"1\":{\"126\":1}}],[\"如果初始化hashmap\",{\"0\":{\"536\":1}}],[\"如果链表中插入节点的时候\",{\"1\":{\"531\":1}}],[\"如果写操作频繁或对实时性要求较高\",{\"1\":{\"522\":1}}],[\"如果集合发生变化时修改modcount值刚好又设置为了expectedmodcount值\",{\"1\":{\"520\":1}}],[\"如果超过一定时间没有获取到资源\",{\"1\":{\"512\":1}}],[\"如果申请不到\",{\"1\":{\"512\":1}}],[\"如果此时还有其它线程请求获取获取该资源\",{\"1\":{\"512\":1}}],[\"如果对应下标正好没有存放数据\",{\"1\":{\"531\":1}}],[\"如果对多个变量操作时\",{\"1\":{\"508\":1}}],[\"如果对象的所有字段都可以直接在局部变量中使用\",{\"1\":{\"170\":1}}],[\"如果对象不会逃逸并且可以分解为多个标量变量\",{\"1\":{\"164\":1}}],[\"如果一直循环执行\",{\"1\":{\"506\":1}}],[\"如果一个线程a执行了thread\",{\"1\":{\"344\":1,\"351\":1}}],[\"如果一个操作happens\",{\"1\":{\"320\":1}}],[\"如果一个类已经被加载到内存中\",{\"1\":{\"210\":1}}],[\"如果一个对象具有强引用\",{\"1\":{\"128\":1}}],[\"如果全部相等\",{\"1\":{\"505\":1}}],[\"如果相等\",{\"1\":{\"502\":1}}],[\"如果这个时候恰巧锁没有被占用\",{\"1\":{\"501\":1}}],[\"如果锁当前没有被其它线程占用\",{\"1\":{\"500\":1}}],[\"如果共享资源被占用\",{\"1\":{\"496\":1}}],[\"如果成功\",{\"1\":{\"494\":1}}],[\"如果竞争成功\",{\"1\":{\"493\":1}}],[\"如果需要有序的存储和遍历元素\",{\"1\":{\"550\":1}}],[\"如果需要继续拆分任务\",{\"1\":{\"480\":1}}],[\"如果需要低停顿时间和大堆内存支持\",{\"1\":{\"156\":1}}],[\"如果是则进行扩容操作\",{\"1\":{\"531\":1}}],[\"如果是则执行\",{\"1\":{\"494\":1}}],[\"如果是则委派给父类加载器加载\",{\"1\":{\"215\":1}}],[\"如果是可偏向状态\",{\"1\":{\"493\":1}}],[\"如果是\",{\"1\":{\"480\":1,\"493\":1}}],[\"如果调用超过预设的时间仍未返回结果\",{\"1\":{\"479\":1}}],[\"如果测试发现线程池存在性能瓶颈或者稳定性问题\",{\"1\":{\"476\":1}}],[\"如果你的任务执行时间较长\",{\"1\":{\"453\":1}}],[\"如果你的任务是i\",{\"1\":{\"453\":1}}],[\"如果你的任务是cpu密集型的\",{\"1\":{\"453\":1}}],[\"如果任务被拒绝执行\",{\"1\":{\"465\":1}}],[\"如果任务队列容量较大\",{\"1\":{\"453\":1}}],[\"如果任务队列容量较小\",{\"1\":{\"453\":1}}],[\"如果任务队列已满且线程数未达到最大线程数\",{\"1\":{\"444\":1}}],[\"如果任务抛出了异常\",{\"1\":{\"451\":1}}],[\"如果任务抛出了未捕获的异常\",{\"1\":{\"451\":1}}],[\"如果任务执行完成且当前线程数超过核心线程数\",{\"1\":{\"445\":1}}],[\"如果线程a遍历过程中\",{\"1\":{\"520\":1}}],[\"如果线程a执行操作threadb\",{\"1\":{\"320\":2}}],[\"如果线程调用了\",{\"1\":{\"485\":1}}],[\"如果线程执行完任务\",{\"1\":{\"457\":1}}],[\"如果线程正在执行任务\",{\"1\":{\"455\":1}}],[\"如果线程池中的线程空闲\",{\"1\":{\"455\":1}}],[\"如果线程池中的线程都在执行任务\",{\"1\":{\"455\":2}}],[\"如果线程池中有空闲的线程\",{\"1\":{\"455\":2}}],[\"如果线程池无法接受新任务\",{\"1\":{\"449\":1}}],[\"如果线程数等于核心线程\",{\"1\":{\"457\":1}}],[\"如果线程数少于核心线程\",{\"1\":{\"457\":1}}],[\"如果线程数过多\",{\"1\":{\"453\":1}}],[\"如果线程数已达到最大线程数且任务队列已满\",{\"1\":{\"444\":1}}],[\"如果线程空闲时间超过该值\",{\"1\":{\"448\":1}}],[\"如果线程在等待交换数据时被中断\",{\"1\":{\"363\":1}}],[\"如果线程在等待许可时被中断\",{\"1\":{\"359\":1}}],[\"如果某\",{\"1\":{\"356\":1}}],[\"如果某个线程遇到了中\",{\"1\":{\"356\":1}}],[\"如果某个线程在等待时被中断\",{\"1\":{\"355\":1}}],[\"如果某个对象无法通过任何引用链与gc\",{\"1\":{\"126\":1}}],[\"如果使用带超时参数的\",{\"1\":{\"355\":1}}],[\"如果等待时间到期而线程没有获取到锁\",{\"1\":{\"344\":1}}],[\"如果直接调用thread的run\",{\"1\":{\"342\":1}}],[\"如果直接调用classloader\",{\"1\":{\"216\":1}}],[\"如果父线程的\",{\"1\":{\"336\":1}}],[\"如果父类加载器均无法加载该类\",{\"1\":{\"206\":1}}],[\"如果父类加载器无法加载该类\",{\"1\":{\"203\":1,\"205\":1}}],[\"如果执行完启发式清理工作后\",{\"1\":{\"334\":1}}],[\"如果将一个ubuntu版本的mysql应用安装到centos系统\",{\"1\":{\"561\":1}}],[\"如果将threadlocal实例作为强引用存储在threadlocalmap中\",{\"1\":{\"331\":1}}],[\"如果将对象添加到静态集合中\",{\"1\":{\"125\":1}}],[\"如果threadlocal\",{\"1\":{\"329\":1}}],[\"如果try块中的代码导致了线程死锁\",{\"1\":{\"281\":1}}],[\"如果try块中的代码导致了无限循环或无限递归\",{\"1\":{\"281\":1}}],[\"如果操作之间不存在数据依赖关系\",{\"1\":{\"321\":1}}],[\"如果a\",{\"1\":{\"320\":1}}],[\"如果重排序之后的执行结果\",{\"1\":{\"320\":1}}],[\"如果内部类的生命周期超出了外部类实例的生命周期\",{\"1\":{\"309\":1}}],[\"如果内部类持有对外部类的引用\",{\"1\":{\"125\":1}}],[\"如果没有\",{\"1\":{\"459\":1}}],[\"如果没有空闲线程\",{\"1\":{\"458\":1}}],[\"如果没有空闲线程可用\",{\"1\":{\"450\":1}}],[\"如果没有空闲的核心线程且任务队列未满\",{\"1\":{\"444\":1}}],[\"如果没有可用许可\",{\"1\":{\"358\":1}}],[\"如果没有重写\",{\"1\":{\"305\":1}}],[\"如果没有则会在常量池中创建\",{\"1\":{\"269\":1}}],[\"如果同时实现两个接口\",{\"1\":{\"299\":1}}],[\"如果新版本的类和旧版本的类具有相同的serialversionuid\",{\"1\":{\"276\":1}}],[\"如果新生代仍有大量对象存活\",{\"1\":{\"136\":1}}],[\"如果不使用插件\",{\"0\":{\"718\":1}}],[\"如果不相等\",{\"1\":{\"502\":1}}],[\"如果不是\",{\"1\":{\"494\":1}}],[\"如果不一致\",{\"1\":{\"276\":1,\"333\":1}}],[\"如果不存在数据依赖性\",{\"1\":{\"319\":1}}],[\"如果不存在\",{\"1\":{\"103\":1}}],[\"如果后续对该类进行了修改\",{\"1\":{\"276\":1}}],[\"如果整型字面量的值在\",{\"1\":{\"272\":1}}],[\"如果拼接多次\",{\"1\":{\"270\":1}}],[\"如果字符串常量池已经有\",{\"1\":{\"269\":1}}],[\"如果有则不去抢锁\",{\"1\":{\"501\":1}}],[\"如果有则直接使用\",{\"1\":{\"269\":1}}],[\"如果有\",{\"1\":{\"458\":1,\"459\":1}}],[\"如果有空闲的核心线程\",{\"1\":{\"444\":1}}],[\"如果有一个线程没有配对线程来交换数据\",{\"1\":{\"363\":1}}],[\"如果有一批对象需要放入老年代\",{\"1\":{\"135\":1}}],[\"如果有些变量不想序列化\",{\"1\":{\"276\":1}}],[\"如果多个应用程序共享同一个类加载器\",{\"1\":{\"234\":1}}],[\"如果出现了不可恢复的错误\",{\"1\":{\"231\":1}}],[\"如果已经存在该类的实例\",{\"1\":{\"229\":1}}],[\"如果已经加载\",{\"1\":{\"206\":1}}],[\"如果修改了classloader类的defineclass方法\",{\"1\":{\"217\":1}}],[\"如果资源不存在\",{\"1\":{\"215\":1}}],[\"如果引导类加载器无法加载该类\",{\"1\":{\"206\":1}}],[\"如果当前数组位置是空则直接通过cas自旋写入数据\",{\"1\":{\"549\":1}}],[\"如果当前线程之前己经获取过该锁\",{\"1\":{\"500\":1}}],[\"如果当前线程是最后一个到达的线程\",{\"1\":{\"355\":1}}],[\"如果当前线程正在执行的是本地方法\",{\"1\":{\"92\":1}}],[\"如果当前字符串内容存在于字符串常量池\",{\"1\":{\"271\":1}}],[\"如果当前类加载器仍无法加载该类\",{\"1\":{\"206\":1}}],[\"如果当前类加载器尚未加载该类\",{\"1\":{\"206\":1}}],[\"如果通过逃逸分析确定一个对象不会逃逸出方法的作用域\",{\"1\":{\"169\":1}}],[\"如果通过逃逸分析确定对象不会逃逸到多个线程中\",{\"1\":{\"164\":1}}],[\"如果通过逃逸分析确定对象不会逃逸出当前方法\",{\"1\":{\"164\":1}}],[\"如果在这期间\",{\"1\":{\"458\":1}}],[\"如果在后续的版本中对该类进行了修改\",{\"1\":{\"276\":1}}],[\"如果在cms的并发阶段内没有足够的空闲内存\",{\"1\":{\"147\":1}}],[\"如果在survivor空间中相同年龄所有对象大小的总和大于survivor空间的一半\",{\"1\":{\"136\":1}}],[\"如果方法区由永久代实现\",{\"1\":{\"135\":1}}],[\"如果堆中包含大量对象\",{\"1\":{\"131\":1}}],[\"如果回收后还是没有足够的内存\",{\"1\":{\"128\":1}}],[\"如果期望值与当前值一致\",{\"1\":{\"120\":1}}],[\"如果该锁己经被其他线程持有\",{\"1\":{\"500\":1}}],[\"如果该区域空间不足\",{\"1\":{\"119\":1}}],[\"如果该类尚未加载\",{\"1\":{\"117\":1}}],[\"如果存在锁竞争\",{\"1\":{\"491\":1}}],[\"如果存在\",{\"1\":{\"103\":1}}],[\"如果\",{\"1\":{\"89\":1,\"480\":1}}],[\"如果发现锁这个时候被释放了\",{\"1\":{\"501\":1}}],[\"如果发现老年代可用的连续内存空间小于新生代历次young\",{\"1\":{\"135\":1}}],[\"如果发现\",{\"1\":{\"89\":1}}],[\"如果每次回收的内存较多\",{\"1\":{\"86\":1}}],[\"如果垃圾回收次数频繁且每次回收的内存空间较小\",{\"1\":{\"86\":1}}],[\"提示\",{\"1\":{\"579\":1,\"586\":1}}],[\"提示java堆内存溢出\",{\"1\":{\"124\":1}}],[\"提交\",{\"1\":{\"656\":1}}],[\"提交任务\",{\"1\":{\"457\":1,\"458\":1,\"459\":1,\"477\":1}}],[\"提交异步任务\",{\"1\":{\"436\":1}}],[\"提交异步任务并使用自定义线程池\",{\"1\":{\"392\":1}}],[\"提交多个任务\",{\"1\":{\"407\":1,\"409\":1}}],[\"提升了synchronized的性能\",{\"1\":{\"491\":1}}],[\"提升应用程序的响应速度和用户体验\",{\"1\":{\"139\":1}}],[\"提升jvm的性能和稳定性\",{\"1\":{\"101\":1}}],[\"提高查询性能\",{\"1\":{\"656\":2}}],[\"提高其硬件与软件的标准化程度\",{\"1\":{\"624\":1}}],[\"提高能源利用效率\",{\"1\":{\"622\":1}}],[\"提高插入操作的效率\",{\"1\":{\"543\":1}}],[\"提高线程池的性能和响应速度\",{\"1\":{\"479\":1}}],[\"提高线程池的响应速度\",{\"1\":{\"479\":1}}],[\"提高线程池的并发能力\",{\"1\":{\"479\":1}}],[\"提高任务的并发性和执行效率\",{\"1\":{\"479\":1}}],[\"提高并发编程的效率和资源利用率\",{\"1\":{\"441\":1}}],[\"提高数据处理的速度\",{\"1\":{\"431\":1}}],[\"提高类的独立性和性能\",{\"1\":{\"313\":1}}],[\"提高类加载安全性\",{\"1\":{\"213\":1}}],[\"提高系统的性能和响应速度\",{\"1\":{\"479\":1}}],[\"提高系统的可靠性和可维护性\",{\"1\":{\"476\":1}}],[\"提高系统的灵活性和可维护性\",{\"1\":{\"232\":1}}],[\"提高系统的响应速度\",{\"1\":{\"131\":1}}],[\"提高垃圾回收的效率\",{\"1\":{\"132\":1}}],[\"提高垃圾回收效率\",{\"1\":{\"116\":1}}],[\"提高内存利用率和性能\",{\"1\":{\"116\":1}}],[\"提高了互感器的耐冲击特性\",{\"1\":{\"634\":1}}],[\"提高了保护及测控等装置的采样精度\",{\"1\":{\"633\":1}}],[\"提高了保护装置的可靠性\",{\"1\":{\"631\":1}}],[\"提高了保护装置自身的运行可靠性\",{\"1\":{\"625\":1}}],[\"提高了运行效率和可靠性\",{\"1\":{\"630\":1}}],[\"提高了插入和删除操作的效率\",{\"1\":{\"529\":1}}],[\"提高了线程的利用率和任务的并行性\",{\"1\":{\"480\":1}}],[\"提高了代码的运行效率和与旧版本\",{\"1\":{\"287\":1}}],[\"提高了代码的可读性和简洁性\",{\"1\":{\"240\":1}}],[\"提高了系统的可维护性和可扩展性\",{\"1\":{\"213\":1}}],[\"提高了系统的稳定性和可靠性\",{\"1\":{\"212\":1}}],[\"提高了系统性能\",{\"1\":{\"210\":1}}],[\"提高了程序的运行性能\",{\"1\":{\"167\":1}}],[\"提高了垃圾回收的效率\",{\"1\":{\"136\":1}}],[\"提高了内存回收效率\",{\"1\":{\"148\":1}}],[\"提高了内存分配的效率\",{\"1\":{\"120\":1}}],[\"提高了内存利用率和性能\",{\"1\":{\"115\":1}}],[\"提高了并发性能\",{\"1\":{\"120\":1,\"167\":1}}],[\"提高了\",{\"1\":{\"119\":1}}],[\"提高了分配对象的效率\",{\"1\":{\"119\":1}}],[\"提高了回收效率\",{\"1\":{\"115\":1}}],[\"提高整体性能\",{\"1\":{\"115\":1}}],[\"提高性能\",{\"1\":{\"111\":1,\"404\":1}}],[\"提高gc的效率\",{\"1\":{\"87\":1}}],[\"提供的性能分析工具吗\",{\"0\":{\"713\":1}}],[\"提供的一种编程式地构建\",{\"1\":{\"656\":1}}],[\"提供的函数库有差异\",{\"1\":{\"561\":1}}],[\"提供数据库连接\",{\"1\":{\"656\":1}}],[\"提供额外功能\",{\"1\":{\"656\":1}}],[\"提供了统一的接口来管理和调度线程\",{\"1\":{\"404\":1}}],[\"提供了更好的日期和时间处理方式\",{\"1\":{\"240\":1}}],[\"提供了最基本的输入输出操作\",{\"1\":{\"237\":1}}],[\"提供了自己的类加载器实现\",{\"1\":{\"218\":1}}],[\"提供了可预测的低停顿时间和自动调优能力\",{\"1\":{\"156\":1}}],[\"提供了一系列的\",{\"1\":{\"656\":1}}],[\"提供了一系列的标签和函数\",{\"1\":{\"656\":1}}],[\"提供了一种动态生成\",{\"1\":{\"656\":1}}],[\"提供了一种简洁而强大的方式来处理异\",{\"1\":{\"386\":1}}],[\"提供了一种平衡高吞吐量和低停顿时间的垃圾收集解决方案\",{\"1\":{\"145\":1}}],[\"提供了一个更加高效和灵活的垃圾收集解决方案\",{\"1\":{\"149\":1}}],[\"提供足够的空间给新对象分配\",{\"1\":{\"133\":2}}],[\"提供更好的类加载和卸载支持\",{\"1\":{\"116\":1}}],[\"提供全链路性能监控\",{\"1\":{\"70\":1}}],[\"提供全链路的性能监控\",{\"1\":{\"69\":1}}],[\"提供端到端的性能监控\",{\"1\":{\"66\":1}}],[\"提供详细的性能报告\",{\"1\":{\"68\":1,\"70\":1}}],[\"提供详细的性能分析和诊断功能\",{\"1\":{\"60\":1}}],[\"提供详细的事务跟踪\",{\"1\":{\"65\":1}}],[\"提供可视化的性能报告\",{\"1\":{\"61\":1}}],[\"提供实时的性能指\",{\"1\":{\"54\":1}}],[\"避免互相干扰\",{\"1\":{\"560\":1}}],[\"避免重复调用同一个耗时操作\",{\"1\":{\"479\":1}}],[\"避免重复加载类\",{\"0\":{\"210\":1},\"1\":{\"213\":1}}],[\"避免重复加载\",{\"1\":{\"207\":1}}],[\"避免线程池中的任务过多导致资源耗尽和性能下降\",{\"1\":{\"479\":1}}],[\"避免问题进一步恶化\",{\"1\":{\"476\":1}}],[\"避免内存泄漏\",{\"1\":{\"309\":1}}],[\"避免可能导致系统崩溃或者数据丢失的错误\",{\"1\":{\"232\":1}}],[\"避免了环形链表的问题\",{\"1\":{\"545\":1}}],[\"避免了一次性重新计算所有键的哈希值和索引位置\",{\"1\":{\"543\":1}}],[\"避免了这种退化情况\",{\"1\":{\"528\":1}}],[\"避免了频繁创建和销毁线程的开销\",{\"1\":{\"402\":1}}],[\"避免了线程\",{\"1\":{\"326\":1}}],[\"避免了重复加载和类冲突问题\",{\"1\":{\"207\":1}}],[\"避免了重复加载和冲突\",{\"1\":{\"205\":1}}],[\"避免了不必要的堆内存分配\",{\"1\":{\"175\":1}}],[\"避免了永久代空间不足的问题\",{\"1\":{\"100\":1}}],[\"避免碎片化\",{\"1\":{\"148\":1}}],[\"避免永久代空间不足问题\",{\"1\":{\"116\":1}}],[\"避免oom错误\",{\"1\":{\"115\":1}}],[\"避免不必要的对象引用\",{\"1\":{\"90\":1}}],[\"避免出现无效的引用或者内存泄漏\",{\"1\":{\"87\":1}}],[\"避免对象在eden区存活时间过长\",{\"1\":{\"87\":1}}],[\"查询缓存\",{\"1\":{\"656\":1}}],[\"查询中\",{\"1\":{\"619\":1}}],[\"查询示例\",{\"0\":{\"618\":1}}],[\"查询会首先通过\",{\"1\":{\"615\":1}}],[\"查询的执行过程中\",{\"1\":{\"615\":1}}],[\"查找时间成本降低\",{\"1\":{\"541\":1}}],[\"查找的时间成本就增加了\",{\"1\":{\"541\":1}}],[\"查找红黑树\",{\"1\":{\"532\":1}}],[\"查找速率\",{\"1\":{\"515\":1}}],[\"查找占用内存较高的对象\",{\"1\":{\"86\":1}}],[\"查看微服务目录\",{\"1\":{\"598\":1}}],[\"查看mysql目录\",{\"1\":{\"598\":1}}],[\"查看课前资料提供的cloud\",{\"1\":{\"597\":1,\"598\":1}}],[\"查看html数据卷的位置\",{\"1\":{\"586\":1}}],[\"查看数据卷详细信息\",{\"1\":{\"584\":1}}],[\"查看数据卷详细信息卷\",{\"1\":{\"584\":1}}],[\"查看所有数据卷\",{\"1\":{\"584\":1}}],[\"查看所有数据\",{\"1\":{\"584\":1}}],[\"查看所有容器\",{\"1\":{\"580\":1}}],[\"查看容器状态\",{\"1\":{\"580\":1}}],[\"查看容器日志的命令\",{\"1\":{\"580\":1}}],[\"查看目录下文件\",{\"1\":{\"579\":1}}],[\"查看dockerhub网站中的nginx页面\",{\"1\":{\"579\":1}}],[\"查看redis镜像的名称和版本\",{\"1\":{\"575\":1}}],[\"查看save命令用法\",{\"1\":{\"574\":1}}],[\"查看拉取到的镜像\",{\"1\":{\"573\":1}}],[\"查看镜像\",{\"0\":{\"573\":1}}],[\"查看应用程序的错误日志\",{\"1\":{\"90\":1}}],[\"查看错误日志\",{\"1\":{\"90\":1}}],[\"查看堆的摘要信息\",{\"1\":{\"89\":1}}],[\"查看堆内存使用情况\",{\"1\":{\"90\":1}}],[\"查看堆内存中的存活对象\",{\"1\":{\"88\":1}}],[\"查看堆内存各区域的使用率以及gc情况\",{\"1\":{\"88\":1}}],[\"查看堆内存占用空间最大的对象类型\",{\"1\":{\"86\":1}}],[\"查看堆内存\",{\"1\":{\"55\":1}}],[\"查看进程下的所有线程占\",{\"1\":{\"89\":1}}],[\"查看进程使用\",{\"1\":{\"89\":1}}],[\"查看运行的\",{\"1\":{\"89\":1}}],[\"查看监控\",{\"1\":{\"88\":1}}],[\"查看和修改类的信息\",{\"1\":{\"56\":1}}],[\"查看和配置网络接口的信息\",{\"1\":{\"54\":1}}],[\"查看java虚拟机中的线程堆栈信息\",{\"1\":{\"55\":1}}],[\"查看java虚拟机中的进程信息\",{\"1\":{\"55\":1}}],[\"查看java虚拟机的配置信息\",{\"1\":{\"55\":1}}],[\"查看网络连接数\",{\"1\":{\"54\":1}}],[\"查看\",{\"1\":{\"11\":1,\"89\":1}}],[\"观察垃圾回收情况\",{\"1\":{\"86\":1}}],[\"将查询结果转换为java对象的集合或嵌套对象\",{\"1\":{\"656\":1}}],[\"将结果集中的数据映射到java对象的属性上\",{\"1\":{\"656\":1}}],[\"将java对象的属性值设置到preparedstatement对象中\",{\"1\":{\"656\":1}}],[\"将java对象中的属性值绑定到sql语句中的参数位置\",{\"1\":{\"656\":1}}],[\"将变电站的通信体系分为3个层次\",{\"1\":{\"636\":1}}],[\"将该二次电压e2进行积分处理\",{\"1\":{\"634\":1}}],[\"将一次侧大电流转换成二次的低电压模拟量输出或数字量输出\",{\"1\":{\"634\":1}}],[\"将一个java项目构建为镜像\",{\"1\":{\"593\":1}}],[\"将一个规模为n的问题分解为k个规模较小的子问题\",{\"1\":{\"480\":1}}],[\"将五防系统\",{\"1\":{\"625\":1}}],[\"将cloud\",{\"1\":{\"597\":1}}],[\"将打包好的app\",{\"1\":{\"597\":1}}],[\"将项目中的每个微服务都打包为app\",{\"1\":{\"597\":1}}],[\"将数据库\",{\"1\":{\"597\":1}}],[\"将之前学习的cloud\",{\"1\":{\"597\":1}}],[\"将app\",{\"1\":{\"593\":1}}],[\"将准备好的docker\",{\"1\":{\"592\":1}}],[\"将来docker会帮助我们构建镜像\",{\"1\":{\"590\":1}}],[\"将课前资料提供的hmy\",{\"1\":{\"587\":1}}],[\"将宿主机目录直接挂载到容器\",{\"1\":{\"587\":1}}],[\"将宿主机端口与容器端口映射\",{\"1\":{\"578\":1}}],[\"将容器与数据分离\",{\"1\":{\"584\":1}}],[\"将容器的80与宿主机的80关联起来\",{\"1\":{\"578\":1}}],[\"将应用程序及其依赖\",{\"1\":{\"568\":1}}],[\"将应用的libs\",{\"1\":{\"560\":1}}],[\"将每个应用放到一个隔离容器去运行\",{\"1\":{\"560\":1}}],[\"将添加的元素作为key\",{\"1\":{\"554\":1}}],[\"将扩容操作分散到多次进行\",{\"1\":{\"543\":1}}],[\"将新键值对插入链表或红黑树末尾\",{\"1\":{\"543\":1}}],[\"将已经产生hash碰撞的元素完美的转移到新的table中去\",{\"1\":{\"535\":1}}],[\"将链表转换为红黑树\",{\"1\":{\"525\":1}}],[\"将原数组拷贝一份\",{\"1\":{\"522\":1}}],[\"将这些资源分配给其他等待进程\",{\"1\":{\"513\":1}}],[\"将会看到线程的死锁信息\",{\"1\":{\"513\":1}}],[\"将多个变量封装成一个对象\",{\"1\":{\"508\":1}}],[\"将多个连续的加锁\",{\"1\":{\"491\":1}}],[\"将内存位置\",{\"1\":{\"502\":1}}],[\"将清空工作内存中共享变量的值\",{\"1\":{\"487\":1}}],[\"将问题拆分成两个子任务并使用fork\",{\"1\":{\"480\":1}}],[\"将耗时的操作拆分为多个小任务\",{\"1\":{\"479\":1}}],[\"将耗时的\",{\"1\":{\"479\":1}}],[\"将任务队列中的任务持久化到可靠的存储介质中\",{\"1\":{\"478\":1}}],[\"将任务加到阻塞队列\",{\"1\":{\"459\":1}}],[\"将任务放入任务队列中\",{\"1\":{\"454\":1}}],[\"将创建新的线程来处理新任务\",{\"1\":{\"455\":1}}],[\"将自定义线程池传递给\",{\"1\":{\"391\":1}}],[\"将对象序列化为hessian格式\",{\"1\":{\"277\":1}}],[\"将对象序列化为protobuf格式\",{\"1\":{\"277\":1}}],[\"将对象序列化为xml格式\",{\"1\":{\"277\":1}}],[\"将对象序列化为json格式\",{\"1\":{\"277\":1}}],[\"将此string对象添加到池中\",{\"1\":{\"271\":1}}],[\"将包装类型转换为基本数据类型\",{\"1\":{\"260\":1}}],[\"将基本类型用它们对应的引用类型包装起来\",{\"1\":{\"260\":1}}],[\"将通道\",{\"1\":{\"238\":1}}],[\"将请求委派给父类加载器\",{\"1\":{\"206\":1}}],[\"将字节码文件转换为方法区的运行时数据结构\",{\"1\":{\"197\":1}}],[\"将获取到的字节流所代表的静态存储结构\",{\"1\":{\"193\":1}}],[\"将类的字节码文件\",{\"1\":{\"191\":1}}],[\"将类的字节码文件加载到内存中\",{\"1\":{\"184\":1}}],[\"将其转换为内存中的数据结构\",{\"1\":{\"184\":1}}],[\"将\",{\"1\":{\"173\":1,\"349\":1,\"535\":1,\"537\":1}}],[\"将某些对象分配在栈上或者进行标量替换\",{\"1\":{\"168\":1}}],[\"将point对象分配在栈上而不是堆上\",{\"1\":{\"165\":1}}],[\"将survivor区无法容纳的对象直接送入老年代\",{\"1\":{\"136\":1}}],[\"将eden区和其中一个survivor区的存活对象复制到另一个survivor区\",{\"1\":{\"132\":1}}],[\"将eden区中存活的对象复制到survivor区\",{\"1\":{\"132\":1}}],[\"将它们移动到内存的一端\",{\"1\":{\"131\":1}}],[\"将存活对象压缩\",{\"1\":{\"131\":1}}],[\"将存活的对象复制到to区\",{\"1\":{\"131\":1}}],[\"将指针向空闲空间方向挪动与对象大小相等的距离即可\",{\"1\":{\"118\":1}}],[\"将线程池的参数配置在外部的配置文件或者配置中心中\",{\"1\":{\"475\":1}}],[\"将线程\",{\"1\":{\"89\":1}}],[\"将线程id转换为16进制格式\",{\"1\":{\"85\":1}}],[\"将堆内存信息保存为hprof格式的文件\",{\"1\":{\"86\":1}}],[\"将垃圾回收日志输出到指定文件\",{\"1\":{\"75\":1}}],[\"<artifactid>spring\",{\"1\":{\"600\":1}}],[\"<groupid>org\",{\"1\":{\"600\":1}}],[\"<plugin>\",{\"1\":{\"600\":1}}],[\"<plugins>\",{\"1\":{\"600\":1}}],[\"<p>defaults\",{\"1\":{\"289\":1}}],[\"<finalname>app<\",{\"1\":{\"600\":1}}],[\"<build>\",{\"1\":{\"600\":1}}],[\"<head><meta\",{\"1\":{\"579\":1}}],[\"<head>\",{\"1\":{\"579\":1}}],[\"<\",{\"1\":{\"407\":1,\"409\":1,\"477\":2,\"516\":1,\"549\":2,\"600\":4}}],[\"<=\",{\"1\":{\"355\":1,\"357\":1,\"480\":1,\"516\":2,\"549\":1}}],[\"<t>\",{\"1\":{\"285\":4}}],[\"<<\",{\"1\":{\"264\":1,\"549\":1}}],[\"<clinit>\",{\"1\":{\"188\":1}}],[\"<转换后的线程id>\",{\"1\":{\"85\":1}}],[\"<线程id>\",{\"1\":{\"85\":1}}],[\"<进程id>\",{\"1\":{\"85\":2,\"86\":3}}],[\"找到空闲位置的方法也有很多\",{\"1\":{\"538\":1}}],[\"找到对应线程id后\",{\"1\":{\"85\":1}}],[\"找出所有能够被直接或间接引用到的对象\",{\"1\":{\"126\":1}}],[\"找出热点代码和性能瓶颈\",{\"1\":{\"61\":1}}],[\"首先去镜像仓库搜索nginx镜像\",{\"1\":{\"573\":1}}],[\"首先来看下镜像的名称组成\",{\"1\":{\"571\":1}}],[\"首先计算hash\",{\"1\":{\"549\":1}}],[\"首先进行哈希值的扰动\",{\"1\":{\"531\":1}}],[\"首先就会调用\",{\"1\":{\"501\":1}}],[\"首先判断当前要计算的斐波那契数列的位置\",{\"1\":{\"480\":1}}],[\"首先需要理解两个点\",{\"1\":{\"480\":1}}],[\"首先要考虑的是你的任务的性质\",{\"1\":{\"453\":1}}],[\"首先要从数据库里面查询出来订单信息\",{\"1\":{\"84\":1}}],[\"首先尝试在自己的\",{\"1\":{\"120\":1}}],[\"首先会在自己的\",{\"1\":{\"119\":1}}],[\"首先\",{\"1\":{\"85\":1,\"90\":1,\"252\":1,\"390\":1,\"633\":1}}],[\"线行探查法\",{\"1\":{\"538\":1}}],[\"线上服务cpu占用过高怎么排查\",{\"0\":{\"85\":1}}],[\"线程b对集合对象的内容进行了修改\",{\"1\":{\"520\":1}}],[\"线程b可以调用线程interrupt\",{\"1\":{\"344\":1}}],[\"线程己经持有了至少一个资源\",{\"1\":{\"512\":1}}],[\"线程死锁了解吗\",{\"0\":{\"512\":1}}],[\"线程死锁等\",{\"1\":{\"476\":1}}],[\"线程直接进入队列中排队\",{\"1\":{\"498\":1}}],[\"线程进入队列后会进行自旋\",{\"1\":{\"496\":1}}],[\"线程解锁前\",{\"1\":{\"487\":1}}],[\"线程加锁后\",{\"1\":{\"487\":1}}],[\"线程加锁前\",{\"1\":{\"487\":1}}],[\"线程执行任务\",{\"1\":{\"477\":2}}],[\"线程执行任务时\",{\"1\":{\"445\":1}}],[\"线程从delayqueue中获取已到期的scheduledfuturetask\",{\"1\":{\"460\":1}}],[\"线程并不会立即销毁\",{\"1\":{\"454\":1}}],[\"线程工厂\",{\"1\":{\"448\":1}}],[\"线程空闲时间\",{\"1\":{\"448\":1}}],[\"线程空闲或终止\",{\"1\":{\"447\":1}}],[\"线程将继续处于空闲状态\",{\"1\":{\"445\":1}}],[\"线程的创建和销毁需要在操作系统和jvm内部进行同步\",{\"1\":{\"416\":1}}],[\"线程的信息\",{\"1\":{\"89\":1}}],[\"线程管理\",{\"1\":{\"403\":1}}],[\"线程复用\",{\"1\":{\"403\":1}}],[\"线程阻塞和唤醒机制\",{\"1\":{\"400\":1}}],[\"线程池并发调用api\",{\"0\":{\"479\":1}}],[\"线程池调优了解吗\",{\"0\":{\"476\":1}}],[\"线程池如何实现参数的动态修改\",{\"0\":{\"475\":1}}],[\"线程池完全终止\",{\"1\":{\"473\":1}}],[\"线程池不再接受新任务\",{\"1\":{\"470\":1,\"471\":1}}],[\"线程池进入\",{\"1\":{\"470\":1,\"471\":1}}],[\"线程池可以接受新任务\",{\"1\":{\"469\":1}}],[\"线程池可以通过调用shutdown\",{\"1\":{\"446\":1}}],[\"线程池异常处理是一个常见的问题\",{\"1\":{\"461\":1}}],[\"线程池异常怎么处理知道吗\",{\"0\":{\"461\":1}}],[\"线程池特点\",{\"1\":{\"457\":1,\"458\":1,\"459\":1,\"460\":1}}],[\"线程池是否有一条线程在\",{\"1\":{\"459\":1}}],[\"线程池是怎么实现线程复用的\",{\"0\":{\"454\":1}}],[\"线程池是一种管理和控制多个线程并发执行的机制\",{\"1\":{\"402\":1}}],[\"线程池将不再接受新的任务\",{\"1\":{\"452\":1}}],[\"线程池怎么关闭知道吗\",{\"0\":{\"452\":1}}],[\"线程池提交execute和submit有什么区别\",{\"0\":{\"451\":1}}],[\"线程池通常使用工作队列来存储等待执行的任务\",{\"1\":{\"450\":1}}],[\"线程池通过预先创建一组线程\",{\"1\":{\"402\":1}}],[\"线程池有哪几种工作队列\",{\"0\":{\"450\":1}}],[\"线程池会尝试停止所有正在执行的任务\",{\"1\":{\"452\":1}}],[\"线程池会将其记录下来\",{\"1\":{\"451\":1}}],[\"线程池会优先使用核心线程来处理任务\",{\"1\":{\"448\":1}}],[\"线程池会自动管理线程的生命周期\",{\"1\":{\"403\":1}}],[\"线程池中没有活动的线程\",{\"1\":{\"472\":2}}],[\"线程池中的线程数量会根据任务的数量自动调整\",{\"1\":{\"455\":1}}],[\"线程池中的线程数量不会发生变化\",{\"1\":{\"455\":1}}],[\"线程池中的线程就实现了复用\",{\"1\":{\"454\":1}}],[\"线程池中的线程作为消费者\",{\"1\":{\"454\":1}}],[\"线程池中的线程会在处理完一个请求后立即准备处理下一个请求\",{\"1\":{\"423\":1}}],[\"线程池中允许存在的最大线程数\",{\"1\":{\"448\":1}}],[\"线程池中保持活动状态的最小线程数\",{\"1\":{\"448\":1}}],[\"线程池主要参数有哪些\",{\"0\":{\"448\":1}}],[\"线程池关闭等\",{\"1\":{\"477\":1}}],[\"线程池关闭等基本功能\",{\"1\":{\"477\":1}}],[\"线程池关闭\",{\"0\":{\"446\":1},\"1\":{\"447\":1}}],[\"线程池按照以下顺序处理任务\",{\"1\":{\"444\":1}}],[\"线程池初始化\",{\"0\":{\"442\":1}}],[\"线程池大小为10\",{\"1\":{\"424\":1}}],[\"线程池大小根据需要动态调整\",{\"1\":{\"395\":1}}],[\"线程池在初始化时\",{\"1\":{\"442\":1}}],[\"线程池在初始化时创建一定数量的线程\",{\"1\":{\"403\":1}}],[\"线程池在实际工作中有着广泛的应用\",{\"1\":{\"420\":1}}],[\"线程池能够创建的最大线程数\",{\"1\":{\"408\":1}}],[\"线程池维护的最小线程数\",{\"1\":{\"408\":1}}],[\"线程池的任务队列也是需要考虑的因素之一\",{\"1\":{\"453\":1}}],[\"线程池的线程数配置需要根据任务性质\",{\"1\":{\"453\":1}}],[\"线程池的线程数配置应该根据你的应用场景和需求来决定\",{\"1\":{\"453\":1}}],[\"线程池的线程数应该怎么配置\",{\"0\":{\"453\":1}}],[\"线程池的关闭可以通过调用shutdown\",{\"1\":{\"452\":1}}],[\"线程池的拒绝策略用于定义当线程池无法接受新任务时应该采取的操作\",{\"1\":{\"449\":1}}],[\"线程池的拒绝策略有哪些\",{\"0\":{\"449\":1}}],[\"线程池的主要参数包括\",{\"1\":{\"448\":1}}],[\"线程池的工作流程如下图所示\",{\"1\":{\"447\":1}}],[\"线程池的工作流程可以分为以下几个步骤\",{\"1\":{\"441\":1}}],[\"线程池的完整工作流程\",{\"0\":{\"447\":1}}],[\"线程池的配置参数影响其行为和性能\",{\"1\":{\"408\":1}}],[\"线程池的配置参数\",{\"0\":{\"408\":1}}],[\"线程池的使用示例\",{\"0\":{\"407\":1}}],[\"线程池的优势\",{\"0\":{\"404\":1}}],[\"线程池的基本概念\",{\"0\":{\"403\":1}}],[\"线程池\",{\"0\":{\"401\":1},\"1\":{\"468\":1}}],[\"线程池类型\",{\"0\":{\"393\":1}}],[\"线程调用此方法进行数据交换\",{\"1\":{\"362\":1}}],[\"线程调用这个方法释放一个许可\",{\"1\":{\"358\":1}}],[\"线程调用这个方法尝试获取一个许可\",{\"1\":{\"358\":1}}],[\"线程首先尝试获取一个许可\",{\"1\":{\"358\":1}}],[\"线程会被阻塞\",{\"1\":{\"358\":1}}],[\"线程会被自动唤醒\",{\"1\":{\"344\":1}}],[\"线程达到公共屏障点\",{\"1\":{\"355\":1}}],[\"线程内\",{\"1\":{\"351\":1}}],[\"线程thread除了提供join\",{\"1\":{\"351\":1}}],[\"线程间有哪些通信方式\",{\"0\":{\"351\":1}}],[\"线程上下文切换\",{\"0\":{\"415\":1}}],[\"线程上下文切换通常发生在以下几种情况下\",{\"0\":{\"349\":1}}],[\"线程上下文切换是一种非常耗时的操作\",{\"1\":{\"348\":1}}],[\"线程上下文切换是指在多线程环境下\",{\"1\":{\"348\":1}}],[\"线程上下文类加载器可以在运行时动态设置\",{\"1\":{\"223\":1}}],[\"线程不会再进入任何状态\",{\"1\":{\"347\":1}}],[\"线程被创建\",{\"1\":{\"345\":1}}],[\"线程共有六种状态\",{\"1\":{\"345\":1}}],[\"线程有几种状态\",{\"0\":{\"345\":1}}],[\"线程有哪些常用的调度方法\",{\"0\":{\"344\":1}}],[\"线程中断\",{\"1\":{\"344\":1,\"355\":1}}],[\"线程休眠\",{\"1\":{\"344\":1}}],[\"线程是不会继续执行的\",{\"1\":{\"344\":1}}],[\"线程是进程的一个执行路径\",{\"1\":{\"340\":1}}],[\"线程a实际并没有被中断\",{\"1\":{\"344\":1}}],[\"线程a会暂时让出指定时间的执行权\",{\"1\":{\"344\":1}}],[\"线程a会被阻塞挂起\",{\"1\":{\"344\":1}}],[\"线程a抛出interruptedexception异常返回\",{\"1\":{\"344\":1}}],[\"线程等待与通知\",{\"1\":{\"344\":1}}],[\"线程可以在任何地方使用localvariable\",{\"1\":{\"326\":1}}],[\"线程之间对共享变量的修改不一定能够及时同步到主内存和其他线程的本地内存中\",{\"1\":{\"316\":1}}],[\"线程之间的共享变量存储在\",{\"1\":{\"315\":1}}],[\"线程安全\",{\"1\":{\"268\":2,\"291\":1,\"309\":1}}],[\"线程安全性\",{\"1\":{\"268\":1,\"400\":1,\"522\":1}}],[\"线程数量等\",{\"1\":{\"147\":1}}],[\"线程在任何地方读取的都是它写入的变量\",{\"1\":{\"326\":1}}],[\"线程在写入变量时不会把值缓存在寄存器或者其他地方\",{\"1\":{\"323\":1}}],[\"线程在分配对象时\",{\"1\":{\"120\":1}}],[\"线程在自己的\",{\"1\":{\"119\":1}}],[\"线程才会在堆的全局空间中进行对象分配\",{\"1\":{\"119\":1}}],[\"线程独立地分配对象\",{\"1\":{\"119\":1}}],[\"线程结束时销毁\",{\"1\":{\"92\":3}}],[\"线程创建时创建\",{\"1\":{\"92\":3}}],[\"线程栈分析可使用\",{\"1\":{\"89\":1}}],[\"线程状态等\",{\"1\":{\"58\":1}}],[\"线程\",{\"1\":{\"56\":1,\"340\":1,\"350\":2,\"355\":34}}],[\"做防重处理\",{\"1\":{\"84\":1}}],[\"只不过要隔离起来\",{\"1\":{\"565\":1}}],[\"只不过实现不同锁语义\",{\"1\":{\"501\":1}}],[\"只是它只包含了单个智能组件的系统信息\",{\"1\":{\"638\":1}}],[\"只是语法稍有差异\",{\"1\":{\"595\":1}}],[\"只是docker会给容器进程做隔离\",{\"1\":{\"565\":1}}],[\"只是在mark\",{\"1\":{\"491\":1}}],[\"只是用于线程之间的任务传递\",{\"1\":{\"450\":1}}],[\"只是做了两个处理\",{\"1\":{\"84\":1}}],[\"只能保证一个变量的原子操作\",{\"0\":{\"508\":1},\"1\":{\"503\":1}}],[\"只能有一个线程可以获取该锁\",{\"1\":{\"497\":1}}],[\"只能有一个线程处于方法或者同步块中\",{\"1\":{\"351\":1}}],[\"只能完成自己的任务\",{\"1\":{\"356\":1}}],[\"只能继承thread类\",{\"1\":{\"343\":1}}],[\"只能定义\",{\"1\":{\"299\":1}}],[\"只能修饰变量\",{\"1\":{\"276\":1}}],[\"只能是\",{\"1\":{\"262\":1}}],[\"只能被应用类加载器加载\",{\"1\":{\"223\":1}}],[\"只能从堆内存信息下手\",{\"1\":{\"84\":1}}],[\"只需要有对应平台的jvm即可\",{\"1\":{\"181\":1}}],[\"只需修改句柄中的实例数据指针\",{\"1\":{\"122\":1}}],[\"只保留对象的字段作为局部变量\",{\"1\":{\"170\":1}}],[\"只有运行时\",{\"1\":{\"565\":1}}],[\"只有在key在table数组中不存在的时候\",{\"1\":{\"554\":1}}],[\"只有在自己使用完毕后才由自己释放该资源\",{\"1\":{\"512\":1}}],[\"只有遇到其他线程竞争时才会执行撤销\",{\"1\":{\"493\":1}}],[\"只有⼀份\",{\"1\":{\"482\":1}}],[\"只有一个执行\",{\"1\":{\"339\":1}}],[\"只有函数式接口\",{\"1\":{\"241\":1}}],[\"只有新生代被回收\",{\"1\":{\"133\":1}}],[\"只有当所有指定的字段的组合都相同时\",{\"1\":{\"606\":1}}],[\"只有当程序结束时才会被销毁\",{\"1\":{\"300\":1}}],[\"只有当\",{\"1\":{\"119\":1,\"120\":1}}],[\"只要垃圾回收机制一运行\",{\"1\":{\"329\":1}}],[\"只要存在一条从gc\",{\"1\":{\"126\":1}}],[\"只要总内存没有达到系统限制\",{\"1\":{\"113\":1}}],[\"最大线程数以及任务队列等参数\",{\"1\":{\"475\":1}}],[\"最大线程数也为1\",{\"1\":{\"459\":1}}],[\"最大线程数为integer\",{\"1\":{\"458\":1,\"460\":1}}],[\"最大线程数\",{\"1\":{\"408\":1,\"442\":1,\"448\":1,\"476\":2}}],[\"最大值\",{\"1\":{\"258\":1}}],[\"最小值改不了\",{\"1\":{\"272\":1}}],[\"最小值\",{\"1\":{\"258\":1}}],[\"最终汇总每个小任务结果后得到大任务结果的框架\",{\"1\":{\"480\":1}}],[\"最终结果为\",{\"1\":{\"618\":1}}],[\"最终结果\",{\"1\":{\"385\":1,\"398\":1}}],[\"最终一定被执行\",{\"1\":{\"303\":1}}],[\"最终返回的还是之前暂存起来的结果\",{\"1\":{\"282\":1}}],[\"最终都调用parseint\",{\"1\":{\"273\":1}}],[\"最终的选择应根据应用的性能需求\",{\"1\":{\"156\":1}}],[\"最终标记\",{\"1\":{\"141\":1,\"142\":1}}],[\"最终抛出stackoverflowerror异常\",{\"1\":{\"124\":1}}],[\"最终抛出outofmemoryerror\",{\"1\":{\"124\":1}}],[\"最终导致程序占用的内存越来越多\",{\"1\":{\"123\":1}}],[\"最终没有调整任何jvm参数\",{\"1\":{\"84\":1}}],[\"最初存储在运行时常量池中\",{\"1\":{\"108\":1}}],[\"最后限制返回的行数为\",{\"1\":{\"614\":1}}],[\"最后访问\",{\"1\":{\"592\":1}}],[\"最后的结果是\",{\"1\":{\"554\":1}}],[\"最后所有元素处理完成后\",{\"1\":{\"531\":1}}],[\"最后赋值到i\",{\"1\":{\"317\":1}}],[\"最后引发fgc\",{\"1\":{\"88\":1}}],[\"最后导致oom\",{\"1\":{\"88\":1}}],[\"最后\",{\"1\":{\"85\":1,\"602\":1}}],[\"最开始也没有认定就是这里的问题\",{\"1\":{\"84\":1}}],[\"导入镜像\",{\"0\":{\"574\":1}}],[\"导致资源浪费\",{\"1\":{\"539\":1}}],[\"导致资源未被释放\",{\"1\":{\"125\":1}}],[\"导致插入和删除操作的效率较低\",{\"1\":{\"529\":1}}],[\"导致插入\",{\"1\":{\"528\":1}}],[\"导致oom\",{\"1\":{\"458\":1}}],[\"导致程序直接退出\",{\"1\":{\"281\":1}}],[\"导致自定义的加载逻辑被执行\",{\"1\":{\"217\":1}}],[\"导致长时间的应用停顿\",{\"1\":{\"147\":1}}],[\"导致老年代的内存使用率达到阈值时\",{\"1\":{\"135\":1}}],[\"导致内存逐渐耗尽\",{\"1\":{\"125\":1}}],[\"导致内存泄漏\",{\"1\":{\"125\":1}}],[\"导致对象仍然被引用\",{\"1\":{\"125\":1}}],[\"导致虚拟机栈溢出\",{\"1\":{\"124\":1}}],[\"导致该内存无法被再次使用\",{\"1\":{\"123\":1}}],[\"导致无法正常执行程序\",{\"1\":{\"123\":1}}],[\"导致大对象进入了老年代\",{\"1\":{\"88\":1}}],[\"导致eden区快速填满\",{\"1\":{\"87\":1}}],[\"导致这一段时间内这些对象都无法被回收\",{\"1\":{\"84\":1}}],[\"导出堆内存文件快照\",{\"1\":{\"86\":1}}],[\"导出订单信息\",{\"1\":{\"84\":1}}],[\"导出java虚拟机中的内存映像\",{\"1\":{\"55\":1}}],[\"而plugin则负责管理和调度interceptor的执行\",{\"1\":{\"656\":1}}],[\"而合并单元与电流采集器\",{\"1\":{\"637\":1}}],[\"而智能变电站设备集成化程度更高\",{\"1\":{\"624\":1}}],[\"而智能变电站则从满足智能电网运行要求出发\",{\"1\":{\"624\":1}}],[\"而容器之间互联不是通过ip地址\",{\"1\":{\"599\":1}}],[\"而描述上述信息的文件就是dockerfile文件\",{\"1\":{\"590\":1}}],[\"而要自定义镜像\",{\"1\":{\"588\":1}}],[\"而其中又数centos发行版占比最多\",{\"1\":{\"569\":1}}],[\"而镜像\",{\"1\":{\"565\":1}}],[\"而以前我们接触的虚拟机\",{\"1\":{\"563\":1}}],[\"而docker确巧妙的解决了这些问题\",{\"1\":{\"560\":1}}],[\"而平衡二叉树要求更严格的平衡条件\",{\"1\":{\"529\":1}}],[\"而红黑树通过自平衡的特性\",{\"1\":{\"528\":1}}],[\"而新资源己被其它线程占有\",{\"1\":{\"512\":1}}],[\"而窃取任务的线程永远从双端队列的尾部拿任务执行\",{\"1\":{\"480\":1}}],[\"而sv网主要传输电流\",{\"1\":{\"628\":1}}],[\"而synchronized不用手动释放锁\",{\"1\":{\"495\":1}}],[\"而synchronized只能是非公平锁\",{\"1\":{\"495\":1}}],[\"而submit\",{\"1\":{\"443\":1,\"451\":1}}],[\"而string对象占用比较多也比较正常\",{\"1\":{\"84\":1}}],[\"而cyclicbarrier中的各个线程可以等待其他线程\",{\"1\":{\"356\":1}}],[\"而cyclicbarrier则可以多次设置屏障\",{\"1\":{\"356\":1}}],[\"而后两种面向字\",{\"1\":{\"351\":1}}],[\"而后者实现的是运行时的多态性\",{\"1\":{\"296\":1}}],[\"而传输的媒介为内存\",{\"1\":{\"351\":1}}],[\"而另一个线程感知到了变化\",{\"1\":{\"351\":1}}],[\"而对它的改变必须同步刷新回共享内存\",{\"1\":{\"351\":1}}],[\"而对于引用类型变量指向的堆中的对象不会拷贝\",{\"1\":{\"307\":1}}],[\"而被阻塞时\",{\"1\":{\"349\":1}}],[\"而terminated状态是永久的\",{\"1\":{\"347\":1}}],[\"而terminated状态表示线程已经执行完毕\",{\"1\":{\"347\":1}}],[\"而threadlocalmap使用threadlocal实例作为键\",{\"1\":{\"331\":1}}],[\"而等待状态是等待其他线程的通知或中断\",{\"1\":{\"346\":1}}],[\"而runnable接口适合定义线程要执行的任务\",{\"1\":{\"343\":1}}],[\"而槽位\",{\"1\":{\"333\":1}}],[\"而静态内部类不会持有外部类的引用\",{\"1\":{\"309\":1}}],[\"而静态变量是类共享的\",{\"1\":{\"300\":1}}],[\"而局部变量没有默认值\",{\"1\":{\"300\":1}}],[\"而接口是对行为的抽象\",{\"1\":{\"299\":1}}],[\"而抽象类中可以包含任意类型的变量\",{\"1\":{\"299\":1}}],[\"而抽象类可以包含非抽象的方法\",{\"1\":{\"299\":1}}],[\"而建立对象的目的也不是为了完成一个个步骤\",{\"1\":{\"294\":1}}],[\"而在运行时\",{\"1\":{\"287\":1}}],[\"而在64位jvm中占用8个字节\",{\"1\":{\"121\":1}}],[\"而中间操作会返回一个\",{\"1\":{\"244\":1}}],[\"而字节流则需要手动处理\",{\"1\":{\"237\":1}}],[\"而无需手动一个个创建和运行容器\",{\"1\":{\"594\":1}}],[\"而无需经过其他方法的中间过程\",{\"1\":{\"233\":1}}],[\"而无法加载多个相同类名的不同版本\",{\"1\":{\"234\":1}}],[\"而重写\",{\"1\":{\"233\":1}}],[\"而且将应用于变电站与调度中心之间以及各级调度中心之间\",{\"1\":{\"636\":1}}],[\"而且也减少了设备振动对保护装置的影响\",{\"1\":{\"625\":1}}],[\"而且使一次\",{\"1\":{\"625\":1}}],[\"而且便于各个子系统之间\",{\"1\":{\"625\":1}}],[\"而且不存在磁饱和问题\",{\"1\":{\"625\":1}}],[\"而且每个微服务都准备了一个独立的目录\",{\"1\":{\"598\":1}}],[\"而且entry数据的key和当前不相等\",{\"1\":{\"333\":1}}],[\"而且第一个操作的执行顺序排在第二个操作之前\",{\"1\":{\"320\":1}}],[\"而且loadclass方法默认是受双亲委派机制控制的\",{\"1\":{\"216\":1}}],[\"而且方法执行非常慢\",{\"1\":{\"84\":1}}],[\"而永久代的空间不足时\",{\"1\":{\"135\":1}}],[\"而老年代放不下时\",{\"1\":{\"135\":1}}],[\"而是采用硅橡胶或瓷质绝缘\",{\"1\":{\"633\":1}}],[\"而是通过容器名\",{\"1\":{\"599\":1}}],[\"而是先复制原有集合内容\",{\"1\":{\"520\":1}}],[\"而是只对需要进行原子操作的代码进行了保护\",{\"1\":{\"510\":1}}],[\"而是回线程池中\",{\"1\":{\"454\":1}}],[\"而是等待所有已提交的任务执行完成后再关闭线程池\",{\"1\":{\"452\":1}}],[\"而是将任务直接移交给线程池中的线程进行执行\",{\"1\":{\"450\":1}}],[\"而是被重用来处理下一个任务\",{\"1\":{\"403\":1}}],[\"而是被中断的线程根据中断状态自行处理\",{\"1\":{\"344\":1}}],[\"而是会把值刷新回主内存\",{\"1\":{\"323\":1}}],[\"而是为了描述某个事件在解决整个问题的过程所发生的行为\",{\"1\":{\"294\":1}}],[\"而是直接引用缓存池中的integer对象\",{\"1\":{\"272\":1}}],[\"而是更复杂的网状结构\",{\"1\":{\"224\":1}}],[\"而是位于本地内存中\",{\"1\":{\"130\":1}}],[\"而是抛出outofmemoryerror异常\",{\"1\":{\"128\":1}}],[\"而不像其他orm框架那样完全隐藏了sql\",{\"1\":{\"655\":1}}],[\"而不发生大面积停电事故\",{\"1\":{\"622\":1}}],[\"而不需要修改acsi\",{\"1\":{\"636\":1}}],[\"而不需要额外的同步措施\",{\"1\":{\"522\":1}}],[\"而不需修改reference本身\",{\"1\":{\"122\":1}}],[\"而不管当前是否存在守护线程\",{\"1\":{\"350\":1}}],[\"而不是按照插入顺序进行存储\",{\"1\":{\"550\":1}}],[\"而不是头插法\",{\"1\":{\"543\":1}}],[\"而不是8\",{\"1\":{\"539\":1}}],[\"而不是防止指令重排的有序性\",{\"1\":{\"488\":1}}],[\"而不是使用当前线程的本地内存中的值\",{\"1\":{\"323\":1}}],[\"而不是对象本身\",{\"1\":{\"306\":1}}],[\"而不是返回\",{\"1\":{\"282\":1}}],[\"而不是从文件或网络中加载时\",{\"1\":{\"233\":1}}],[\"而不是直接重写\",{\"1\":{\"222\":1}}],[\"而不是双亲委派机制下的默认加载流程\",{\"1\":{\"220\":1}}],[\"而不是通过classloader的子类\",{\"1\":{\"216\":1}}],[\"而不是默认的委派加载器加载的信息\",{\"1\":{\"215\":1}}],[\"而不是由应用程序的类加载器加载\",{\"1\":{\"211\":1}}],[\"而不是句柄地址\",{\"1\":{\"122\":1}}],[\"而不会修改原始对象的值\",{\"1\":{\"267\":1}}],[\"而不会与其他应用程序产生冲突\",{\"1\":{\"234\":1}}],[\"而不会影响核心类库和其他模块的正常运行\",{\"1\":{\"213\":1}}],[\"而不会重新加载\",{\"1\":{\"210\":1}}],[\"而不会在堆上创建对象\",{\"1\":{\"170\":1}}],[\"而不会导致程序状态的不一致\",{\"1\":{\"138\":1}}],[\"而不分配整个对象\",{\"1\":{\"164\":1,\"169\":1}}],[\"而不再留在survivor区\",{\"1\":{\"132\":1}}],[\"而空闲列表适用于内存不规整的情况\",{\"1\":{\"118\":1}}],[\"而\",{\"1\":{\"89\":1,\"110\":1}}],[\"于是准备登录后台去测试下\",{\"1\":{\"84\":1}}],[\"于是就从线程信息里面找突破点\",{\"1\":{\"84\":1}}],[\"为光纤插件\",{\"1\":{\"631\":1}}],[\"为光纤接口插件\",{\"1\":{\"631\":1}}],[\"为cpu插件\",{\"1\":{\"631\":1}}],[\"为change\",{\"1\":{\"20\":1}}],[\"为过程层接口插件\",{\"1\":{\"631\":1}}],[\"为稳压电源\",{\"1\":{\"631\":2}}],[\"为通信插件\",{\"1\":{\"631\":1}}],[\"为备用插件\",{\"1\":{\"631\":1}}],[\"为出口插件\",{\"1\":{\"631\":1}}],[\"为信号插件\",{\"1\":{\"631\":1}}],[\"为开入插件\",{\"1\":{\"631\":1}}],[\"为dsp主板\",{\"1\":{\"631\":1}}],[\"为采样保持\",{\"1\":{\"631\":1}}],[\"为交流输入\",{\"1\":{\"631\":1}}],[\"为null\",{\"1\":{\"494\":1}}],[\"为\",{\"1\":{\"329\":1}}],[\"为程序员提供一致的内存可见性保证\",{\"1\":{\"319\":1}}],[\"为每个web容器单独提供一个webappclassloader类加载器\",{\"1\":{\"234\":1}}],[\"为每个线程预先分配一小块内存空间作为本地线程分配缓冲\",{\"1\":{\"120\":1}}],[\"为java应用提供更好的性能和可预测性\",{\"1\":{\"149\":1}}],[\"为什么在开发和调试过程中启用\",{\"0\":{\"674\":1}}],[\"为什么\",{\"0\":{\"543\":1,\"711\":1,\"731\":1,\"739\":1,\"751\":1}}],[\"为什么扩容因子是0\",{\"0\":{\"540\":1}}],[\"为什么hashmap链表转红黑树的阈值为8呢\",{\"0\":{\"539\":1}}],[\"为什么hashmap的容量是2的倍数呢\",{\"0\":{\"535\":1}}],[\"为什么哈希\",{\"0\":{\"534\":1}}],[\"为什么不用平衡二叉树\",{\"0\":{\"529\":1}}],[\"为什么不用二叉树\",{\"0\":{\"526\":1,\"528\":1}}],[\"为什么最arraylist不直接序列化元素数组呢\",{\"0\":{\"518\":1}}],[\"为什么用transient修饰数组\",{\"0\":{\"517\":1}}],[\"为什么我们不能直接调用run\",{\"1\":{\"342\":1}}],[\"为什么调用start\",{\"0\":{\"342\":1}}],[\"为什么key还要设计成弱引用\",{\"0\":{\"331\":1}}],[\"为什么重写\",{\"1\":{\"305\":1}}],[\"为什么说mybatis是半自动orm映射工具\",{\"0\":{\"757\":1}}],[\"为什么说频繁创建和销毁线程的开销大\",{\"0\":{\"410\":1}}],[\"为什么说\",{\"0\":{\"250\":1}}],[\"为什么还要有字符流\",{\"0\":{\"237\":1}}],[\"为什么还要引入g1\",{\"0\":{\"146\":1}}],[\"为什么自定义类加载器\",{\"0\":{\"233\":1}}],[\"为什么要用双亲委派机制\",{\"0\":{\"208\":1}}],[\"为什么要用它\",{\"0\":{\"150\":1}}],[\"为什么选择某种垃圾收集器\",{\"0\":{\"152\":1}}],[\"为什么使用元空间替代永久代作为方法区的实现\",{\"0\":{\"111\":1}}],[\"为了减少哈希冲突发生的概率\",{\"1\":{\"540\":1,\"542\":1}}],[\"为了减少窃取任务线程和被窃取任务线程之间的竞争\",{\"1\":{\"480\":1}}],[\"为了优化这种情况\",{\"1\":{\"479\":1}}],[\"为了避免这些重复劳动\",{\"1\":{\"566\":1}}],[\"为了避免这种问题\",{\"1\":{\"276\":1}}],[\"为了避免错误\",{\"1\":{\"363\":1}}],[\"为了实现volatile的内存语义\",{\"1\":{\"324\":1}}],[\"为了遵守as\",{\"1\":{\"321\":1}}],[\"为了提高性能\",{\"1\":{\"319\":1}}],[\"为了保证原子性\",{\"1\":{\"316\":1}}],[\"为了保证线程安全性\",{\"1\":{\"268\":1}}],[\"为了解决这个问题\",{\"1\":{\"234\":1}}],[\"为了解决多线程环境下的堆内存分配竞争问题\",{\"1\":{\"120\":1}}],[\"为了支持热部署\",{\"1\":{\"226\":1}}],[\"为了向下兼容旧代码\",{\"1\":{\"222\":1}}],[\"为了确保jvm进行标量替换优化\",{\"1\":{\"174\":1}}],[\"为了应对碎片化\",{\"1\":{\"139\":1}}],[\"为了hotspot未来的发展\",{\"1\":{\"114\":1}}],[\"为了更好地解释它们的区别\",{\"1\":{\"106\":1}}],[\"为了验证自己的猜想\",{\"1\":{\"84\":1}}],[\"对保护和控制等自动化产品和变电站自动化系统\",{\"1\":{\"636\":1}}],[\"对时系统等\",{\"1\":{\"628\":1}}],[\"对网络交换机的依赖性\",{\"1\":{\"627\":1}}],[\"对gps对时依赖\",{\"1\":{\"627\":1}}],[\"对结果集进行排序\",{\"1\":{\"616\":1}}],[\"对结果进行处理并返回新的结果\",{\"1\":{\"369\":1}}],[\"对数据进行分组\",{\"1\":{\"616\":1}}],[\"对容器的一切操作都会作用在数据卷对应的宿主机目录了\",{\"1\":{\"582\":1}}],[\"对外不可见\",{\"1\":{\"565\":1}}],[\"对外提供内核指令\",{\"1\":{\"561\":1}}],[\"对比来看\",{\"1\":{\"563\":1}}],[\"对hashmap进行加锁\",{\"1\":{\"546\":1}}],[\"对该对象的操作会自动进行同步\",{\"1\":{\"546\":1}}],[\"对该list的所有操作都会进行同步处理\",{\"1\":{\"521\":1}}],[\"对i++操作加锁\",{\"1\":{\"509\":1}}],[\"对i++操作加锁lock\",{\"1\":{\"509\":1}}],[\"对一些代码上要求同步\",{\"1\":{\"491\":1}}],[\"对一个volatile域的写\",{\"1\":{\"320\":1}}],[\"对一个锁的解锁\",{\"1\":{\"320\":1}}],[\"对一个包含一个或多个元素的集合做各种操作\",{\"1\":{\"244\":1}}],[\"对给定对象\",{\"1\":{\"482\":1}}],[\"对耗时的操作进行算法上的优化\",{\"1\":{\"479\":1}}],[\"对耗时的\",{\"1\":{\"479\":2}}],[\"对应的jvm指令分为三步\",{\"1\":{\"319\":1}}],[\"对应的操作系统执行二进制机器码\",{\"1\":{\"249\":1}}],[\"对形参引用的修改不会影响实参引用的指向\",{\"1\":{\"306\":1}}],[\"对形参的修改不会影响实参\",{\"1\":{\"306\":1}}],[\"对同一包内的类和所有子类可见\",{\"1\":{\"297\":1}}],[\"对所有类可见\",{\"1\":{\"297\":1}}],[\"对类的静态变量和静态代码块进行初始化\",{\"1\":{\"180\":1}}],[\"对停顿时间敏感的应用\",{\"1\":{\"159\":1}}],[\"对停顿时间要求极高\",{\"1\":{\"155\":1}}],[\"对于新手来说更容易上手\",{\"1\":{\"655\":1}}],[\"对于开发人员更熟悉sql的项目团队来说\",{\"1\":{\"655\":1}}],[\"对于综自变电站保护逻辑回路概念的认知度\",{\"1\":{\"644\":1}}],[\"对于\",{\"1\":{\"512\":3}}],[\"对于频繁调用且结果稳定的耗时\",{\"1\":{\"479\":1}}],[\"对于频繁的字符串拼接操作\",{\"1\":{\"268\":1}}],[\"对于需要处理异步任务的情况\",{\"1\":{\"466\":1}}],[\"对于其他类\",{\"1\":{\"220\":1}}],[\"对于java核心类库\",{\"1\":{\"215\":1}}],[\"对于一个对象\",{\"1\":{\"126\":1}}],[\"对于hotspot\",{\"1\":{\"92\":1}}],[\"对齐填充\",{\"1\":{\"121\":2}}],[\"对象之间的类型转换\",{\"0\":{\"694\":1}}],[\"对象列表\",{\"1\":{\"485\":1}}],[\"对象相等性原则\",{\"1\":{\"305\":1}}],[\"对象名\",{\"1\":{\"301\":2}}],[\"对象转字符串\",{\"1\":{\"274\":1}}],[\"对象拷贝\",{\"1\":{\"274\":1}}],[\"对象比较\",{\"1\":{\"274\":1}}],[\"对象创建过程\",{\"1\":{\"269\":1}}],[\"对象创建的过程包括类加载\",{\"1\":{\"117\":1}}],[\"对象创建的过程了解吗\",{\"0\":{\"117\":1}}],[\"对象\",{\"1\":{\"254\":1,\"267\":1,\"269\":1,\"367\":1,\"480\":1,\"485\":1}}],[\"对象分配的基本概念\",{\"0\":{\"163\":1}}],[\"对象可以被分配在栈上或者通过逃逸分析技术进行优化\",{\"1\":{\"162\":1}}],[\"对象一定分配在堆中吗\",{\"0\":{\"162\":1}}],[\"对象将被移入老年代\",{\"1\":{\"136\":1}}],[\"对象的线程进入\",{\"1\":{\"485\":1}}],[\"对象的操作\",{\"1\":{\"267\":1}}],[\"对象的成员变量分解为局部变量\",{\"1\":{\"173\":1}}],[\"对象的迭代年龄会在每次young\",{\"1\":{\"136\":1}}],[\"对象的内存分配通常是在堆中进行的\",{\"1\":{\"162\":1}}],[\"对象的内存分配是连续的\",{\"1\":{\"117\":1}}],[\"对象的内存布局可以用以下示意图表示\",{\"1\":{\"121\":1}}],[\"对象什么时候会进入老年代\",{\"0\":{\"136\":1}}],[\"对象经过几次minor\",{\"1\":{\"134\":1}}],[\"对象怎么访问定位\",{\"0\":{\"122\":1}}],[\"对象头的大小在不同的jvm实现中会有所不同\",{\"1\":{\"121\":1}}],[\"对象头的大小取决于虚拟机的具体实现和运行环境\",{\"1\":{\"117\":1}}],[\"对象头存储了一些元数据\",{\"1\":{\"121\":1}}],[\"对象头\",{\"1\":{\"121\":2}}],[\"对象时\",{\"0\":{\"120\":1}}],[\"对象实例数等信息\",{\"1\":{\"90\":1}}],[\"对\",{\"1\":{\"84\":1}}],[\"但其工作原理完全不同\",{\"1\":{\"633\":1}}],[\"但其采样回路与电磁式电压互感器一样是yh通过电磁感应变压实现的\",{\"1\":{\"632\":1}}],[\"但其实是两种不同类型的电压互感器\",{\"1\":{\"632\":1}}],[\"但其内存碎片化\",{\"1\":{\"149\":1}}],[\"但服务的拆分通用给部署带来了很大的麻烦\",{\"1\":{\"558\":1}}],[\"但hashmap的实际容量是32\",{\"1\":{\"536\":1}}],[\"但同样地\",{\"1\":{\"520\":1}}],[\"但实际只用了50\",{\"1\":{\"518\":1}}],[\"但阻塞\",{\"1\":{\"512\":1}}],[\"但又提出了新的资源请求\",{\"1\":{\"512\":1}}],[\"但如果此时锁刚好可用\",{\"1\":{\"499\":1}}],[\"但如果没有正确管理缓存\",{\"1\":{\"125\":1}}],[\"但需要一些额外的编码工作\",{\"1\":{\"475\":1}}],[\"但并不保证所有任务都能被成功中断\",{\"1\":{\"452\":1}}],[\"但并不能保证在某个时刻被保留\",{\"1\":{\"128\":1}}],[\"但会继续执行已提交的任务和队列中等待的任务\",{\"1\":{\"470\":1}}],[\"但会继续执行已提交的任务\",{\"1\":{\"452\":1}}],[\"但会增加垃圾回收器的复杂度\",{\"1\":{\"131\":1}}],[\"但不包含ied实例名称和通信参数\",{\"1\":{\"638\":1}}],[\"但不会通知调用者\",{\"1\":{\"451\":1}}],[\"但不能通过虚引用获取对象本身\",{\"1\":{\"128\":1}}],[\"但频繁的线程创建和销毁会导致代码路径的变化\",{\"1\":{\"419\":1}}],[\"但在读操作频繁\",{\"1\":{\"522\":1}}],[\"但在空闲时会重用先前创建的线程\",{\"1\":{\"406\":1}}],[\"但在需要更多控制或资源隔离时\",{\"1\":{\"388\":1}}],[\"但在对象不再需要时未能正确注销\",{\"1\":{\"125\":1}}],[\"但你可以指定自定义的线程池来满足特殊需求\",{\"1\":{\"387\":1}}],[\"但还没有调用start\",{\"1\":{\"345\":1}}],[\"但可以通过引用修改对象的状态\",{\"1\":{\"306\":1}}],[\"但只能继承一个抽象类\",{\"1\":{\"299\":1}}],[\"但为了更方便地处理文本数据\",{\"1\":{\"237\":1}}],[\"但为native方法服务\",{\"1\":{\"92\":1}}],[\"但也引入了额外的复杂性\",{\"1\":{\"224\":1}}],[\"但务必注意潜在的风险和影响\",{\"1\":{\"219\":1}}],[\"但开发者应该谨慎使用\",{\"1\":{\"219\":1}}],[\"但我们可以用手动优化的方式来展示结果\",{\"1\":{\"173\":1}}],[\"但通过逃逸分析技术\",{\"1\":{\"168\":1}}],[\"但存在内存碎片化问题\",{\"1\":{\"159\":1}}],[\"但适合内存使用较小且对gc停顿不敏感的应用\",{\"1\":{\"159\":1}}],[\"但随着时间推移越来越成熟\",{\"1\":{\"151\":1}}],[\"但它的性能很低\",{\"1\":{\"521\":1}}],[\"但它们之间有一些细微的差别\",{\"1\":{\"452\":1}}],[\"但它们之间存在一些区别\",{\"1\":{\"451\":1}}],[\"但它们在java虚拟机\",{\"1\":{\"102\":1}}],[\"但它也存在一些局限性和缺点\",{\"1\":{\"146\":1}}],[\"但大部分是并发进行\",{\"1\":{\"142\":1}}],[\"但优化了停顿时间\",{\"1\":{\"142\":1}}],[\"但时间较短\",{\"1\":{\"142\":1}}],[\"但老年代没有足够的内存空间存放这些对象\",{\"1\":{\"135\":1}}],[\"但由于bootstrap\",{\"1\":{\"207\":1}}],[\"但由于碎片化问题和并发的复杂性\",{\"1\":{\"139\":1}}],[\"但由于其不确定性和性能问题\",{\"1\":{\"129\":1}}],[\"但由于hotspot和jrockit对方法区实现的差异\",{\"1\":{\"114\":1}}],[\"但这增加了内存管理的复杂性\",{\"1\":{\"113\":1}}],[\"但是却比较麻烦\",{\"1\":{\"593\":1}}],[\"但是我们自己写的项目就必须自己构建镜像了\",{\"1\":{\"588\":1}}],[\"但是目录较深\",{\"1\":{\"588\":1}}],[\"但是开发\",{\"1\":{\"560\":1}}],[\"但是就需要更多的空间去存储元素\",{\"1\":{\"541\":1}}],[\"但是如果插入中间的位置\",{\"1\":{\"515\":1}}],[\"但是看到的虽然是a\",{\"1\":{\"504\":1}}],[\"但是公平锁会判断等待队列是否有线程处于等待状态\",{\"1\":{\"501\":1}}],[\"但是jdk6开始\",{\"1\":{\"495\":1}}],[\"但是被检测到不可能存在共享数据竞争的锁进行消除\",{\"1\":{\"491\":1}}],[\"但是不保证不会指令重排\",{\"1\":{\"488\":1}}],[\"但是可以设置超时时间\",{\"1\":{\"353\":1}}],[\"但是线程调度器可以无条件忽略这个暗示\",{\"1\":{\"344\":1}}],[\"但是线程a所拥有的监视器资源\",{\"1\":{\"344\":1}}],[\"但是它不会重新尝试获取锁\",{\"1\":{\"344\":1}}],[\"但是一个时间段内\",{\"1\":{\"339\":1}}],[\"但是threadlocalmap生命周期和thread是一样的\",{\"1\":{\"329\":1}}],[\"但是仍然希望能够反序列化之前的序列化数据\",{\"1\":{\"276\":1}}],[\"但是长整型\",{\"1\":{\"262\":1}}],[\"但是也不要滥用\",{\"1\":{\"240\":1}}],[\"但是由于技术限制\",{\"1\":{\"222\":1}}],[\"但是并不保证会调用它\",{\"1\":{\"129\":1}}],[\"但是\",{\"1\":{\"126\":1,\"216\":1,\"223\":1,\"247\":1,\"453\":1,\"491\":1}}],[\"但是无法被回收\",{\"1\":{\"88\":1}}],[\"但是需要注意\",{\"1\":{\"87\":1}}],[\"但是问题依然没有解决\",{\"1\":{\"84\":1}}],[\"但dump文件太大\",{\"1\":{\"84\":1}}],[\"但提供更多的交互式功能和信息展示\",{\"1\":{\"54\":1}}],[\"偶发性的引发oom异常\",{\"1\":{\"84\":1}}],[\"性能监控等\",{\"1\":{\"656\":1}}],[\"性能一般\",{\"1\":{\"563\":1}}],[\"性能好\",{\"1\":{\"563\":1}}],[\"性能更加优秀和稳定\",{\"1\":{\"528\":1}}],[\"性能更好\",{\"1\":{\"268\":1}}],[\"性能指标\",{\"1\":{\"476\":1}}],[\"性能测试\",{\"1\":{\"476\":1}}],[\"性能优化\",{\"1\":{\"309\":1}}],[\"性能\",{\"1\":{\"268\":1,\"495\":1}}],[\"性能提升\",{\"1\":{\"167\":1}}],[\"性能需求和硬件环境\",{\"1\":{\"83\":1}}],[\"性能调优参数\",{\"0\":{\"74\":1}}],[\"并执行sql语句\",{\"1\":{\"656\":1}}],[\"并执行相应的读取或写入操作\",{\"1\":{\"238\":1}}],[\"并为数据库连接提供会话级别的操作\",{\"1\":{\"656\":1}}],[\"并确保了作为叠加值dc分量的电流信号的真实反映\",{\"1\":{\"634\":1}}],[\"并确保在类的修改后\",{\"1\":{\"276\":1}}],[\"并利用去除直流偏置回路和不完全积分器的技术\",{\"1\":{\"634\":1}}],[\"并经过逻辑计算及转换后\",{\"1\":{\"633\":1}}],[\"并可根据需要支持电网实时自动控制\",{\"1\":{\"623\":1}}],[\"并可以选择性地做一些特定的动作\",{\"1\":{\"356\":1}}],[\"并可以与其他接口组合使用\",{\"1\":{\"343\":1}}],[\"并修改html内容\",{\"1\":{\"586\":1}}],[\"并查看数据卷在宿主机的目录位置\",{\"1\":{\"584\":1}}],[\"并查找转换为16进制的线程id对应的线程信息\",{\"1\":{\"85\":1}}],[\"并没有模拟完整的操作系统\",{\"1\":{\"563\":1}}],[\"并重试或采取其他措施\",{\"1\":{\"512\":1}}],[\"并指向mark\",{\"1\":{\"494\":1}}],[\"并输出结果\",{\"1\":{\"480\":1}}],[\"并直接在当前线程中执行第二个子任务的\",{\"1\":{\"480\":1}}],[\"并采取相应的措施进行处理\",{\"1\":{\"476\":1}}],[\"并针对性地配置线程池\",{\"1\":{\"476\":1}}],[\"并实时查看线程池的状态和性能指标\",{\"1\":{\"475\":1}}],[\"并实现相应的错误处理机制\",{\"1\":{\"231\":1}}],[\"并处理已经在队列中的任务\",{\"1\":{\"469\":1}}],[\"并释放线程池所占用的资源\",{\"1\":{\"452\":1}}],[\"并释放许可\",{\"1\":{\"358\":1}}],[\"并尝试重新提交当前任务\",{\"1\":{\"449\":1}}],[\"并返回给调用者\",{\"1\":{\"656\":1}}],[\"并返回未执行的任务列表\",{\"1\":{\"446\":1,\"452\":1}}],[\"并返回string对象的引用\",{\"1\":{\"271\":1}}],[\"并准备好任务队列\",{\"1\":{\"442\":1}}],[\"并提供对用户的增值服务\",{\"1\":{\"622\":1}}],[\"并提供了具体的功能实现\",{\"1\":{\"252\":1}}],[\"并提供了更多的功能和灵活性\",{\"1\":{\"240\":1}}],[\"并提高数据库操作的效率\",{\"1\":{\"427\":1}}],[\"并结合了锁和条件等待机制来实现线程的阻塞和唤醒\",{\"1\":{\"400\":1}}],[\"并对两个excel数据进行校对\",{\"1\":{\"363\":1}}],[\"并设置\",{\"1\":{\"500\":1}}],[\"并设置屏障点操作\",{\"1\":{\"355\":1}}],[\"并设置默认初始值\",{\"1\":{\"186\":1}}],[\"并继续执行\",{\"1\":{\"355\":1}}],[\"并立即返回\",{\"1\":{\"344\":1}}],[\"并行处理每个块\",{\"1\":{\"430\":1}}],[\"并行数据处理\",{\"0\":{\"429\":1}}],[\"并行获取数据\",{\"0\":{\"385\":1}}],[\"并行执行多个任务\",{\"0\":{\"382\":1}}],[\"并行执行\",{\"1\":{\"365\":1}}],[\"并行就是同一时刻\",{\"1\":{\"339\":1}}],[\"并行跟并发有什么区别\",{\"0\":{\"339\":1}}],[\"并行gc和g1\",{\"1\":{\"87\":1}}],[\"并成功返回\",{\"1\":{\"320\":1}}],[\"并不增加屏\",{\"1\":{\"630\":1}}],[\"并不需要一个个文件去拷贝\",{\"1\":{\"590\":1}}],[\"并不释放内存\",{\"1\":{\"577\":1}}],[\"并不意味着java平台的具体实现必须要按照\",{\"1\":{\"320\":1}}],[\"并不真实存在\",{\"1\":{\"315\":1}}],[\"并通过光电转换元件转换为光数字信号上送给继电保护\",{\"1\":{\"639\":1}}],[\"并通过join\",{\"1\":{\"480\":1}}],[\"并通过\",{\"1\":{\"467\":1}}],[\"并通过http协议进行传输\",{\"1\":{\"277\":1}}],[\"并通过配置文件等方式注册到spi框架中\",{\"1\":{\"252\":1}}],[\"并根据配置信息构建sqlsessionfactory实例\",{\"1\":{\"656\":1}}],[\"并根据配置文件中指定的实现类实例化相应的对象\",{\"1\":{\"252\":1}}],[\"并根据任务执行日志来恢复任务的执行状态\",{\"1\":{\"478\":1}}],[\"并根据文件中指定的实现类\",{\"1\":{\"252\":1}}],[\"并更好地处理可能为空的值\",{\"1\":{\"240\":1}}],[\"并更新列表上的记录\",{\"1\":{\"118\":1}}],[\"并将锁记录里的owner指针指向对象头的markword\",{\"1\":{\"494\":1}}],[\"并将这些小任务分配给线程池中的多个线程并行执行\",{\"1\":{\"479\":1}}],[\"并将它们放入线程池中\",{\"1\":{\"454\":1}}],[\"并将新的通道\",{\"1\":{\"238\":1}}],[\"并将其转换为jvm可以使用的内部数据结构\",{\"1\":{\"179\":1}}],[\"并将其转换成可以执行的机器码\",{\"1\":{\"178\":1}}],[\"并从类加载器的缓存中卸载旧的类\",{\"1\":{\"230\":1}}],[\"并从代码逻辑中找到问题所在\",{\"1\":{\"85\":1}}],[\"并使用locksupport\",{\"1\":{\"496\":1}}],[\"并使用交叉规则得出2个交配结果\",{\"1\":{\"363\":1}}],[\"并使用\",{\"1\":{\"228\":1}}],[\"并触发相应的热部署操作\",{\"1\":{\"227\":1}}],[\"并调用了它的sayhello方法\",{\"1\":{\"220\":1}}],[\"并创建了它的实例\",{\"1\":{\"215\":1}}],[\"并创建一个代表该类的class对象\",{\"1\":{\"184\":1}}],[\"并在执行完毕后关闭\",{\"1\":{\"656\":1}}],[\"并在后台执行耗时的操作\",{\"1\":{\"479\":1}}],[\"并在代理类中提供方法来动态修改线程池的参数\",{\"1\":{\"475\":1}}],[\"并在所有已提交任务执行完成后关闭线程池\",{\"1\":{\"446\":1}}],[\"并在所有数据获取完成后进行处理\",{\"1\":{\"385\":1}}],[\"并在运行时动态地操作类和对象\",{\"1\":{\"256\":1}}],[\"并在\",{\"1\":{\"222\":1}}],[\"并在该线程中设置了上下文类加载器为自定义类加载器\",{\"1\":{\"220\":1}}],[\"并在其中重写loadclass\",{\"1\":{\"215\":1}}],[\"并在堆内存中创建一个class对象来表示该类\",{\"1\":{\"197\":1}}],[\"并初始化为默认值\",{\"1\":{\"186\":1}}],[\"并生成一个class对象来表示该类\",{\"1\":{\"184\":1}}],[\"并非所有对象都必须分配在堆中\",{\"1\":{\"162\":1}}],[\"并记录下栈上和寄存器里哪些位置是引用\",{\"1\":{\"138\":1}}],[\"并发修改\",{\"1\":{\"520\":1}}],[\"并发环境下\",{\"1\":{\"504\":1}}],[\"并发包中的锁就是基于aqs实现的\",{\"1\":{\"496\":1}}],[\"并发送告警通知给相关人员进行处理\",{\"1\":{\"476\":1}}],[\"并发队列\",{\"0\":{\"399\":1}}],[\"并发工具类\",{\"0\":{\"352\":1}}],[\"并发的实现依赖于cpu切换线程\",{\"1\":{\"339\":1}}],[\"并发就是同一时刻\",{\"1\":{\"339\":1}}],[\"并发压缩\",{\"1\":{\"159\":1}}],[\"并发线程数\",{\"1\":{\"158\":1}}],[\"并发线程数等\",{\"1\":{\"81\":1}}],[\"并发与并行\",{\"1\":{\"148\":1}}],[\"并发模式失效\",{\"1\":{\"147\":1}}],[\"并发性\",{\"1\":{\"139\":1}}],[\"并发清理\",{\"1\":{\"139\":1}}],[\"并发标记和压缩回收\",{\"1\":{\"159\":1}}],[\"并发标记和清理\",{\"1\":{\"159\":1}}],[\"并发标记和混合回收\",{\"1\":{\"145\":1}}],[\"并发标记开始前\",{\"1\":{\"142\":1}}],[\"并发标记阶段分为初始标记\",{\"1\":{\"141\":1}}],[\"并发标记\",{\"1\":{\"139\":2,\"141\":2,\"142\":1}}],[\"并发整理和并发回收来实现低停顿时间\",{\"1\":{\"137\":1}}],[\"并清空eden区\",{\"1\":{\"132\":1}}],[\"并尽量避免过度依赖\",{\"1\":{\"129\":1}}],[\"并未具体定义如何定位和访问堆中对象的具体位置\",{\"1\":{\"122\":1}}],[\"并引用运行时常量池中的\",{\"1\":{\"108\":1}}],[\"并用于程序运行时的各种操作\",{\"1\":{\"107\":1}}],[\"并动态解析符号引用\",{\"1\":{\"105\":1}}],[\"并且管理一级缓存和二级缓存\",{\"1\":{\"656\":1}}],[\"并且根据功能约束进行拆分并映射到若干个数据属性\",{\"1\":{\"650\":1}}],[\"并且定义了层和层之间的通信接口\",{\"1\":{\"636\":1}}],[\"并且需要对结果进行排序和限制返回的行数\",{\"1\":{\"614\":1}}],[\"并且挂载了两个目录\",{\"1\":{\"595\":1}}],[\"并且因为没有编辑器\",{\"1\":{\"581\":1}}],[\"并且当前印戳\",{\"1\":{\"505\":1}}],[\"并且当前线程之前没有获取过该锁\",{\"1\":{\"500\":1}}],[\"并且对象markword锁标志设置为\",{\"1\":{\"494\":1}}],[\"并且对象可以被分解为多个标量\",{\"1\":{\"169\":1}}],[\"并且将锁对象markword复制到该锁记录中\",{\"1\":{\"494\":1}}],[\"并且将存活对象向一端移动\",{\"1\":{\"131\":1}}],[\"并且会尝试中断正在进行的任务\",{\"1\":{\"471\":1}}],[\"并且可以配合其他配置管理工具来实现自动化管理\",{\"1\":{\"475\":1}}],[\"并且可以处理任务执行过程中抛出的异常\",{\"1\":{\"451\":1}}],[\"并且可以从其他线程的队列中窃取任务来执行\",{\"1\":{\"450\":1}}],[\"并且可以直接使用接口名调用\",{\"1\":{\"299\":1}}],[\"并且任务队列已满时\",{\"1\":{\"448\":1}}],[\"并且这两个线程在此方法处阻塞\",{\"1\":{\"362\":1}}],[\"并且在遍历过程中使用一个modcount\",{\"1\":{\"520\":1}}],[\"并且在获取锁之前\",{\"1\":{\"344\":1}}],[\"并且在运行时为常量池中的符号引用进行解析\",{\"1\":{\"104\":1}}],[\"并且重新尝试获取对象的锁\",{\"1\":{\"344\":1}}],[\"并且接口中定义了相同的默认方法\",{\"1\":{\"299\":1}}],[\"并且希望将其加载到内存中时\",{\"1\":{\"233\":1}}],[\"并且允许在同一个jvm中加载多个版本的相同类\",{\"1\":{\"218\":1}}],[\"并且只在该方法内部使用\",{\"1\":{\"172\":1}}],[\"并且生命周期比外部类长\",{\"1\":{\"125\":1}}],[\"并且是该线程私有的\",{\"1\":{\"119\":1}}],[\"并且字符串常量池的引用在运行时常量池中\",{\"1\":{\"104\":1}}],[\"并连接到运行中的java进程\",{\"1\":{\"90\":1}}],[\"并按空间排序\",{\"1\":{\"88\":1}}],[\"并定位到创建该对象的业务代码位置\",{\"1\":{\"86\":1}}],[\"并快速定位和解决问题\",{\"1\":{\"70\":1}}],[\"确实是一种常见的方式\",{\"1\":{\"475\":1}}],[\"确定从哪个表或视图中选择数据\",{\"1\":{\"616\":1}}],[\"确定合适的线程池配置\",{\"1\":{\"476\":1}}],[\"确定应用的堆内存大小\",{\"1\":{\"160\":1}}],[\"确定应用对停顿时间和吞吐量的要求\",{\"1\":{\"160\":1}}],[\"确定哪个方法或代码段导致了oom异常\",{\"1\":{\"90\":1}}],[\"确定对象是否可以在栈上分配\",{\"1\":{\"87\":1}}],[\"确定调优重点\",{\"1\":{\"80\":1}}],[\"确保数据库连接的可用性和性能\",{\"1\":{\"656\":1}}],[\"确保任务操作是原子性的\",{\"1\":{\"478\":1}}],[\"确保程序的稳定运行\",{\"1\":{\"467\":1}}],[\"确保cpu在长期被工作线程使用的情况下\",{\"1\":{\"457\":1}}],[\"确保所有任务得到正确处理\",{\"1\":{\"452\":1}}],[\"确保所有可达对象都被正确标记\",{\"1\":{\"139\":1}}],[\"确保交换操作是同步和线程安全的\",{\"1\":{\"363\":1}}],[\"确保系统资源的有效利用和安全性\",{\"1\":{\"359\":1}}],[\"确保线程安全\",{\"1\":{\"521\":1}}],[\"确保线程安全和性能的平衡\",{\"1\":{\"120\":1}}],[\"确保线程按请求顺序获取许可\",{\"1\":{\"359\":1}}],[\"确保不会出现资源争用\",{\"1\":{\"357\":1}}],[\"确保不会破坏java语言的安全性和类型系统\",{\"1\":{\"185\":1}}],[\"确保子线程能够正确获取父线程最新的值\",{\"1\":{\"337\":1}}],[\"确保在屏障前的所有读操作都完成之后\",{\"1\":{\"324\":2}}],[\"确保在屏障前的所有写操作在屏障后的所有读操作\",{\"1\":{\"324\":1}}],[\"确保在屏障前的所有写操作\",{\"1\":{\"324\":1}}],[\"确保操作是不可分割的\",{\"1\":{\"318\":1}}],[\"确保类的唯一性和一致性\",{\"0\":{\"209\":1}}],[\"确保类在使用前完成所有初始化工作\",{\"1\":{\"188\":1}}],[\"确保了java运行环境的安全性和稳定性\",{\"1\":{\"211\":1}}],[\"确保了java运行环境的稳定性\",{\"1\":{\"207\":1}}],[\"确保了类加载过程的安全性\",{\"1\":{\"207\":1}}],[\"确保一致性\",{\"1\":{\"207\":1}}],[\"确保jvm运行环境的安全和稳定\",{\"1\":{\"207\":1}}],[\"确保其符合java虚拟机规范\",{\"1\":{\"185\":1}}],[\"确保字节码文件的正确性和一致性\",{\"1\":{\"180\":1}}],[\"确保代码不会进行非法操作\",{\"1\":{\"178\":1}}],[\"确保相同的字符串字面值在内存中只有一个副本\",{\"1\":{\"105\":1,\"110\":1}}],[\"确保对象不会逃逸出方法范围并且可以安全地进行替换\",{\"1\":{\"175\":1}}],[\"确保对象在内存中被正确地创建和初始化\",{\"1\":{\"117\":1}}],[\"确保对象在不再需要时被垃圾回收\",{\"1\":{\"90\":1}}],[\"确保对象的引用关系正确\",{\"1\":{\"87\":1}}],[\"确保这是你正在使用的分支名称\",{\"1\":{\"16\":1}}],[\"识别性能瓶颈和问题\",{\"1\":{\"80\":1}}],[\"识别性能问题\",{\"1\":{\"80\":1}}],[\"吞吐量和内存使用情况\",{\"1\":{\"160\":1}}],[\"吞吐量\",{\"1\":{\"79\":1}}],[\"堆栈指针等信息\",{\"1\":{\"348\":1}}],[\"堆栈等\",{\"1\":{\"56\":1}}],[\"堆会发生抢占吗\",{\"0\":{\"120\":1}}],[\"堆中的对象也会拷贝一份\",{\"1\":{\"307\":1}}],[\"堆中的内存不规整的情况\",{\"1\":{\"118\":1}}],[\"堆中内存是绝对规整的情况\",{\"1\":{\"118\":1}}],[\"堆是垃圾回收的主要区域\",{\"1\":{\"92\":1}}],[\"堆\",{\"1\":{\"92\":2,\"94\":1,\"96\":1,\"179\":1}}],[\"堆空间各个区域的大小设置\",{\"1\":{\"88\":1}}],[\"堆dump文件进行分析\",{\"1\":{\"84\":1}}],[\"堆内存\",{\"1\":{\"163\":1}}],[\"堆内存大小和并发能力\",{\"1\":{\"161\":1}}],[\"堆内存大小和停顿时间要求来确定\",{\"1\":{\"156\":1}}],[\"堆内存大小\",{\"1\":{\"158\":1}}],[\"堆内存被划分为多个大小相等的区域\",{\"1\":{\"141\":1}}],[\"堆内存会逐渐耗尽\",{\"1\":{\"124\":1}}],[\"堆内存的分配是线程共享的\",{\"1\":{\"120\":1}}],[\"堆内存产生了大量的订单对象和excel对象\",{\"1\":{\"84\":1}}],[\"堆内存溢出\",{\"1\":{\"84\":1}}],[\"堆内存使用情况等\",{\"1\":{\"78\":1}}],[\"调度线程池\",{\"0\":{\"397\":1}}],[\"调用\",{\"1\":{\"480\":2}}],[\"调用设置超时时间\",{\"1\":{\"479\":1}}],[\"调用进行限流\",{\"1\":{\"479\":1}}],[\"调用改为异步调用\",{\"1\":{\"479\":1}}],[\"调用shutdownnow\",{\"1\":{\"452\":1}}],[\"调用shutdown\",{\"1\":{\"452\":1}}],[\"调用start\",{\"1\":{\"341\":1}}],[\"调用future对象的get\",{\"1\":{\"451\":1}}],[\"调用者运行策略\",{\"1\":{\"449\":1}}],[\"调用await方法等待其他线程\",{\"1\":{\"355\":1}}],[\"调用方法不同\",{\"1\":{\"296\":1}}],[\"调用类方法这时候就要用到反射\",{\"1\":{\"254\":1}}],[\"调用类的方法\",{\"1\":{\"215\":1}}],[\"调用类的方法等\",{\"1\":{\"189\":1}}],[\"调用时机\",{\"1\":{\"129\":1}}],[\"调优参数\",{\"1\":{\"160\":1}}],[\"调优复杂\",{\"1\":{\"147\":1,\"151\":1}}],[\"调整gc参数以优化性能\",{\"1\":{\"160\":1}}],[\"调整新生代的比例\",{\"1\":{\"87\":1}}],[\"调整堆内存大小\",{\"1\":{\"87\":1}}],[\"调整配置\",{\"1\":{\"82\":1}}],[\"调整内存参数\",{\"1\":{\"81\":1}}],[\"调整时需要通过实际的测试和监控来确定最佳配置\",{\"1\":{\"76\":1}}],[\"调试和监控参数\",{\"0\":{\"75\":1}}],[\"以供给不同的二次设备使用\",{\"1\":{\"640\":1}}],[\"以实现复杂的查询需求\",{\"1\":{\"656\":1}}],[\"以实现对mybatis的功能扩展或定制\",{\"1\":{\"656\":1}}],[\"以实现互操作性\",{\"1\":{\"624\":1}}],[\"以实现类的隔离和资源的共享\",{\"1\":{\"234\":1}}],[\"以在全网范围内提高系统的整体运行水平为目标\",{\"1\":{\"624\":1}}],[\"以全站信息数字化\",{\"1\":{\"623\":1}}],[\"以一个ubuntu操作系统为例\",{\"1\":{\"561\":1}}],[\"以平衡性能和空间的消耗\",{\"1\":{\"543\":1}}],[\"以atomicinteger的添加方法为例\",{\"1\":{\"511\":1}}],[\"以apache\",{\"1\":{\"428\":1}}],[\"以上代码示例演示了如何使用fork\",{\"1\":{\"480\":1}}],[\"以上是一些常见的垃圾收集算法\",{\"1\":{\"131\":1}}],[\"以适应系统的动态变化和优化性能\",{\"1\":{\"476\":1}}],[\"以满足不同的查询需求\",{\"1\":{\"656\":1}}],[\"以满足不同应用场景的需求\",{\"1\":{\"409\":1}}],[\"以满足系统的性能需求和稳定性要求\",{\"1\":{\"476\":1}}],[\"以避免任务被拒绝\",{\"1\":{\"453\":1}}],[\"以避免任务等待时间过长\",{\"1\":{\"453\":1}}],[\"以避免内存泄漏问题的发生\",{\"1\":{\"125\":1}}],[\"以优化线程池的性能和资源利用率\",{\"1\":{\"448\":1}}],[\"以优化jvm的性能和资源利用率\",{\"1\":{\"76\":1}}],[\"以更灵活地控制线程池的行为\",{\"1\":{\"409\":1}}],[\"以前\",{\"1\":{\"262\":1}}],[\"以接口的全限定名命名\",{\"1\":{\"252\":1}}],[\"以备后续操作\",{\"1\":{\"238\":1}}],[\"以解决应用程序之间的类冲突和实现资源的共享\",{\"1\":{\"234\":1}}],[\"以解决permgen空间不足的问题\",{\"1\":{\"95\":1}}],[\"以及它的应用场景\",{\"0\":{\"688\":1}}],[\"以及进行参数绑定和结果映射\",{\"1\":{\"656\":1}}],[\"以及设置缓存的策略和失效机制\",{\"1\":{\"656\":1}}],[\"以及采用电子式互感器等数字化互感器\",{\"1\":{\"631\":1}}],[\"以及同步相量采集\",{\"1\":{\"628\":1}}],[\"以及自动故障诊断\",{\"1\":{\"622\":1}}],[\"以及一级缓存\",{\"1\":{\"315\":1}}],[\"以及确保线程安全\",{\"1\":{\"313\":1}}],[\"以及不写\",{\"0\":{\"297\":1}}],[\"以及无法使用基本类型作为泛型参数等\",{\"1\":{\"287\":1}}],[\"以及\",{\"1\":{\"234\":1}}],[\"以及更新已加载类的实例\",{\"1\":{\"225\":1}}],[\"以支持应用程序的独立部署和隔离\",{\"1\":{\"219\":1}}],[\"以尽量满足这个目标\",{\"1\":{\"148\":1}}],[\"以减少对数据库的访问次数\",{\"1\":{\"656\":1}}],[\"以减少停顿时间\",{\"1\":{\"142\":1}}],[\"以减少应用停顿时间\",{\"1\":{\"141\":1}}],[\"以确保任务的一致性和可靠性\",{\"1\":{\"478\":1}}],[\"以确保线程安全\",{\"1\":{\"521\":1}}],[\"以确保线程池能够始终保持良好的性能和稳定性\",{\"1\":{\"476\":1}}],[\"以确保线程状态的一致性\",{\"1\":{\"416\":1}}],[\"以确保功能的正确性和稳定性\",{\"1\":{\"232\":1}}],[\"以确保系统的稳定性和可靠性\",{\"1\":{\"231\":1}}],[\"以确保在不同工作负载下的良好表现\",{\"1\":{\"147\":1}}],[\"以确保内存的正确回收和整理\",{\"1\":{\"138\":1}}],[\"以确保持续稳定的性能表现\",{\"1\":{\"83\":1}}],[\"以保证任务的一致性和可靠性\",{\"1\":{\"478\":1}}],[\"以保证线程池的性能和稳定性\",{\"1\":{\"453\":1}}],[\"以保证系统的稳定性和可靠性\",{\"1\":{\"449\":1}}],[\"以保证合理的使用公共资源\",{\"1\":{\"357\":1}}],[\"以保证整个堆的空间利用率\",{\"1\":{\"133\":1}}],[\"以保证对象在内存中的起始地址是按照要求对齐的\",{\"1\":{\"121\":1}}],[\"以提高查找\",{\"1\":{\"525\":1,\"543\":1}}],[\"以提高系统的性能和效率\",{\"1\":{\"348\":1}}],[\"以提高性能和节省内存\",{\"1\":{\"267\":1}}],[\"以提高性能\",{\"1\":{\"164\":1}}],[\"以提高整体的垃圾回收效率\",{\"1\":{\"133\":1}}],[\"以提高垃圾回收的效率和内存利用率\",{\"1\":{\"130\":1}}],[\"以提高执行效率\",{\"1\":{\"122\":1}}],[\"以下简称iec61850或iec61850标准\",{\"1\":{\"647\":1}}],[\"以下简称光学电流互感器\",{\"1\":{\"633\":1}}],[\"以下示例展示如何并行获取多个远程数据源的数据\",{\"1\":{\"385\":1}}],[\"以下对象可以作为gc\",{\"1\":{\"127\":1}}],[\"以下是处理单机线程池断电情况的一般策略\",{\"1\":{\"478\":1}}],[\"以下是线程池状态的转换图\",{\"1\":{\"474\":1}}],[\"以下是线程池在各种工作场景中的一些典型应用\",{\"1\":{\"420\":1}}],[\"以下是详细的线程池状态\",{\"1\":{\"468\":1}}],[\"以下是常见的线程池拒绝策略\",{\"1\":{\"449\":1}}],[\"以下是如何设置和使用自定义线程池的详细指南\",{\"1\":{\"387\":1}}],[\"以下是对每个阶段的详细解释\",{\"1\":{\"183\":1}}],[\"以下是一个使用调度线程池执行定时任务的示例\",{\"1\":{\"440\":1}}],[\"以下是一个使用线程池执行异步任务的示例\",{\"1\":{\"436\":1}}],[\"以下是一个使用线程池并行处理数据块的示例\",{\"1\":{\"432\":1}}],[\"以下是一个使用线程池处理http请求的简单示例\",{\"1\":{\"424\":1}}],[\"以下是一个使用固定大小线程池执行多个任务的示例\",{\"1\":{\"407\":1}}],[\"以下是一个完整的示例\",{\"1\":{\"392\":1}}],[\"以下是一个简单的线程池的设计和实现\",{\"1\":{\"477\":1}}],[\"以下是一个简单的\",{\"1\":{\"361\":1}}],[\"以下是一个简单的示例代码\",{\"1\":{\"220\":1}}],[\"以下是一个简单的代码示例\",{\"1\":{\"215\":1}}],[\"以下是一个示例\",{\"1\":{\"171\":1,\"207\":1}}],[\"以下是一些处理线程池异常的常见方法和技巧\",{\"1\":{\"461\":1}}],[\"以下是一些可能破坏双亲委派机制的方式\",{\"1\":{\"214\":1}}],[\"以下是一些大公司和常见应用场景中使用的垃圾收集器及其原因\",{\"1\":{\"150\":1}}],[\"以下是一些应对频繁minor\",{\"1\":{\"87\":1}}],[\"以下是一些常用的可视化性能监控和故障处理工具\",{\"1\":{\"57\":1}}],[\"以下是选择gc时需要考虑的几个关键因素和常见的垃圾收集器选项\",{\"1\":{\"157\":1}}],[\"以下是引入g1垃圾收集器的主要原因\",{\"1\":{\"146\":1}}],[\"以下是它们的主要区别\",{\"1\":{\"102\":1}}],[\"以下是jdk\",{\"1\":{\"93\":1}}],[\"以下是使用visualvm的一般步骤\",{\"1\":{\"90\":1}}],[\"以节省内存\",{\"1\":{\"105\":1}}],[\"以查找包含oom异常信息的记录\",{\"1\":{\"90\":1}}],[\"以了解出现问题的时间点以及当前fgc的频率\",{\"1\":{\"88\":1}}],[\"以便执行sql语句\",{\"1\":{\"656\":1}}],[\"以便更快地停止线程池\",{\"1\":{\"452\":1}}],[\"以便该线程可以继续执行\",{\"1\":{\"348\":1}}],[\"以便选择器可以监听多个通道的事件\",{\"1\":{\"238\":1}}],[\"以便为新对象的分配提供足够的空间\",{\"1\":{\"134\":1}}],[\"以便进行离线分析\",{\"1\":{\"86\":1}}],[\"以便在后续步骤中查找对应的线程信息\",{\"1\":{\"85\":1}}],[\"以获得更高的性能\",{\"1\":{\"76\":1}}],[\"打包后\",{\"1\":{\"600\":1}}],[\"打包\",{\"0\":{\"600\":1},\"1\":{\"590\":1}}],[\"打包这些应用往往是重复的劳动\",{\"1\":{\"566\":1}}],[\"打印逃逸分析的结果\",{\"1\":{\"174\":1}}],[\"打印详细的垃圾回收日志\",{\"1\":{\"75\":1}}],[\"打开导出的堆内存文件快照\",{\"1\":{\"86\":1}}],[\"打开settings\",{\"1\":{\"20\":1}}],[\"打开仓库my\",{\"1\":{\"20\":1,\"21\":1}}],[\"打开http\",{\"1\":{\"12\":1}}],[\"启用同步消除优化\",{\"1\":{\"166\":1}}],[\"启用标量替换优化\",{\"1\":{\"166\":1,\"174\":1}}],[\"启用逃逸分析\",{\"1\":{\"166\":1,\"174\":1}}],[\"启用方式\",{\"1\":{\"159\":6}}],[\"启用g1垃圾收集器\",{\"1\":{\"144\":1}}],[\"启用服务器模式\",{\"1\":{\"76\":1}}],[\"启用调试模式\",{\"1\":{\"75\":1}}],[\"启用分层编译模式\",{\"1\":{\"74\":1}}],[\"启用字符串连接优化\",{\"1\":{\"74\":1}}],[\"启动脚本是什么\",{\"1\":{\"590\":1}}],[\"启动速度慢\",{\"1\":{\"563\":1}}],[\"启动速度快\",{\"1\":{\"563\":1}}],[\"启动另一个\",{\"1\":{\"373\":1}}],[\"启动时会调用\",{\"1\":{\"350\":1}}],[\"启动\",{\"1\":{\"303\":1,\"562\":1}}],[\"启动线程b\",{\"1\":{\"320\":1}}],[\"启动线程\",{\"1\":{\"220\":1}}],[\"启动类加载器\",{\"0\":{\"199\":1}}],[\"启动visualvm\",{\"1\":{\"90\":1}}],[\"启动命令\",{\"1\":{\"59\":1}}],[\"启动成功后\",{\"1\":{\"11\":1}}],[\"启动开发服务器\",{\"1\":{\"11\":1}}],[\"开出元件的完好性\",{\"1\":{\"639\":1}}],[\"开出需求等信息\",{\"1\":{\"638\":1}}],[\"开入插件\",{\"1\":{\"631\":1}}],[\"开关量采集及跳闸goose网\",{\"1\":{\"627\":1}}],[\"开发的重要性是什么\",{\"0\":{\"730\":1,\"750\":1}}],[\"开发\",{\"1\":{\"559\":1}}],[\"开发者可以实现复杂的结果集映射\",{\"1\":{\"656\":1}}],[\"开发者可以通过配置来启用或禁用缓存\",{\"1\":{\"656\":1}}],[\"开发者可以通过自定义类加载器加载特定的类\",{\"1\":{\"213\":1}}],[\"开发者可以编写自定义的拦截器来实现一些额外的功能\",{\"1\":{\"656\":1}}],[\"开发者可以继承forkjointask类来定义自己的任务\",{\"1\":{\"480\":1}}],[\"开发者可以控制类的加载行为\",{\"1\":{\"204\":1}}],[\"开放地址解决冲突\",{\"1\":{\"334\":1}}],[\"开放定址法就是从冲突的位置再接着往下找\",{\"1\":{\"538\":1}}],[\"开放定址法\",{\"1\":{\"333\":1,\"538\":1}}],[\"开始\",{\"1\":{\"262\":2}}],[\"开始移除永久代\",{\"1\":{\"101\":1}}],[\"开头的\",{\"1\":{\"244\":2}}],[\"开头\",{\"1\":{\"215\":1}}],[\"开启jvm的性能优化选项\",{\"1\":{\"74\":1}}],[\"开源应用程序非常多\",{\"1\":{\"566\":1}}],[\"开源的apm工具\",{\"1\":{\"69\":1,\"70\":1}}],[\"开源的java\",{\"1\":{\"68\":1,\"70\":1}}],[\"开源监控系统和时间序列数据库\",{\"1\":{\"63\":1}}],[\"垃圾对象\",{\"1\":{\"126\":1}}],[\"垃圾回收过程中的\",{\"1\":{\"138\":1}}],[\"垃圾回收时垃圾收集器会遍历整个堆\",{\"1\":{\"131\":1}}],[\"垃圾回收器\",{\"1\":{\"179\":1}}],[\"垃圾回收器调用finalize\",{\"1\":{\"129\":1}}],[\"垃圾回收器在回收对象之前会调用其finalize\",{\"1\":{\"129\":1}}],[\"垃圾回收器会尝试回收软引用指向的对象\",{\"1\":{\"128\":1}}],[\"垃圾回收器不会回收它\",{\"1\":{\"128\":1}}],[\"垃圾回收器从这些对象开始进行可达性分析\",{\"1\":{\"127\":1}}],[\"垃圾回收器日志\",{\"1\":{\"78\":1}}],[\"垃圾回收\",{\"0\":{\"418\":1},\"1\":{\"121\":1,\"178\":1,\"274\":1}}],[\"垃圾回收算法等等\",{\"1\":{\"88\":1}}],[\"垃圾回收停顿时间等\",{\"1\":{\"79\":1}}],[\"垃圾回收参数\",{\"0\":{\"73\":1}}],[\"垃圾收集线程清理那些没有被标记为可达的对象\",{\"1\":{\"139\":1}}],[\"垃圾收集线程从初始标记阶段标记的对象开始\",{\"1\":{\"139\":1}}],[\"垃圾收集器\",{\"1\":{\"163\":1}}],[\"垃圾收集器应该如何选择\",{\"0\":{\"157\":1}}],[\"垃圾收集器在降低垃圾收集停顿时间方面取得了显著成功\",{\"1\":{\"146\":1}}],[\"垃圾收集器可以在这些位置暂停用户程序的执行\",{\"1\":{\"138\":1}}],[\"垃圾收集器可能会选择执行mixed\",{\"1\":{\"133\":1}}],[\"垃圾收集器会遍历整个堆\",{\"1\":{\"131\":1}}],[\"垃圾收集算法是java虚拟机用来回收不再使用的内存空间的一种技术\",{\"1\":{\"131\":1}}],[\"垃圾收集算法了解吗\",{\"0\":{\"131\":1}}],[\"垃圾收集\",{\"1\":{\"55\":1}}],[\"从通信而言\",{\"1\":{\"636\":1}}],[\"从dockerhub中拉取一个nginx镜像并查看\",{\"1\":{\"573\":1}}],[\"从冲突的位置x开始\",{\"1\":{\"538\":1}}],[\"从冲突的位置开始\",{\"1\":{\"538\":1}}],[\"从任一节点到其每个叶子节点的路径上\",{\"1\":{\"527\":1}}],[\"从一个基础镜像来构建\",{\"1\":{\"594\":1}}],[\"从一个线程转而执行另一个线程的过程\",{\"1\":{\"348\":1}}],[\"从一些死锁进程中剥夺资源\",{\"1\":{\"513\":1}}],[\"从队列取任务\",{\"1\":{\"459\":1}}],[\"从父线程中取出inheritablethreadlocals\",{\"1\":{\"336\":1}}],[\"从\",{\"1\":{\"262\":2}}],[\"从根节点出发\",{\"1\":{\"131\":1}}],[\"从jdk6开始hotspot虚拟机开发团队对java中的锁进行优化\",{\"1\":{\"491\":1}}],[\"从jdk6开始\",{\"1\":{\"491\":1}}],[\"从jdk\",{\"1\":{\"103\":1,\"104\":1,\"105\":2,\"299\":1}}],[\"从java\",{\"1\":{\"72\":1,\"92\":1,\"130\":1}}],[\"从永久代移出\",{\"1\":{\"95\":1}}],[\"从菜单\",{\"1\":{\"89\":1}}],[\"从而做到独立分析或解决智能变电站典型故障问题\",{\"1\":{\"644\":1}}],[\"从而保证线程安全\",{\"1\":{\"546\":1}}],[\"从而导致元素的丢失\",{\"1\":{\"545\":1}}],[\"从而导致java\",{\"1\":{\"113\":1}}],[\"从而形成死循环\",{\"1\":{\"545\":1}}],[\"从而形成循环等待\",{\"1\":{\"512\":1}}],[\"从而降低哈希碰撞的概率\",{\"1\":{\"534\":1}}],[\"从而降低系统的性能\",{\"1\":{\"453\":1}}],[\"从而降低系统的性能和稳定性\",{\"1\":{\"453\":1}}],[\"从而使用共享变量时需要从主内存中重新读取最新的值\",{\"1\":{\"487\":1}}],[\"从而避免线程池中的线程因未处理的异常而终止\",{\"1\":{\"462\":1}}],[\"从而避免了这个问题\",{\"1\":{\"309\":1}}],[\"从而避免了重复加载和内存浪费\",{\"1\":{\"207\":1}}],[\"从而让调用者能够捕获和处理异常\",{\"1\":{\"451\":1}}],[\"从而减少了人员误操作的可能性\",{\"1\":{\"630\":1}}],[\"从而减少了线程创建和销毁的开销\",{\"1\":{\"423\":1}}],[\"从而减少堆内存的使用\",{\"1\":{\"87\":1}}],[\"从而影响jit的优化效果\",{\"1\":{\"419\":1}}],[\"从而增加cpu的负担\",{\"1\":{\"415\":1}}],[\"从而增加内存管理的开销\",{\"1\":{\"412\":1}}],[\"从而增加代码的可读性和安全性\",{\"1\":{\"284\":1}}],[\"从而为多线程编程提供了便利和高效的同步与通信机制\",{\"1\":{\"400\":1}}],[\"从而确保操作的原子性和线程安全性\",{\"1\":{\"400\":1}}],[\"从而可能导致内存泄漏\",{\"1\":{\"331\":1}}],[\"从而可以避免permgen空间不足的问题\",{\"1\":{\"96\":1}}],[\"从而起到线程隔离的作用\",{\"1\":{\"326\":1}}],[\"从而实现对象关系映射\",{\"1\":{\"656\":1}}],[\"从而实现对象\",{\"1\":{\"655\":1}}],[\"从而实现线程之间的同步与通信\",{\"1\":{\"400\":1}}],[\"从而实现了面向接口编程的思想\",{\"1\":{\"656\":1}}],[\"从而实现了线程隔离\",{\"1\":{\"328\":1}}],[\"从而实现了代码的热替换\",{\"1\":{\"224\":1}}],[\"从而实现java程序的跨平台性\",{\"1\":{\"249\":1}}],[\"从而改变类加载的委派顺序\",{\"1\":{\"220\":1}}],[\"从而破坏了双亲委派机制\",{\"1\":{\"219\":1}}],[\"从而优化程序性能和内存使用\",{\"1\":{\"190\":1}}],[\"从而提高了程序的并发性能\",{\"1\":{\"510\":1}}],[\"从而提高了系统效率\",{\"1\":{\"402\":1}}],[\"从而提高并发性能\",{\"1\":{\"119\":1}}],[\"从而提升了性能\",{\"1\":{\"309\":1}}],[\"从而提升了程序的性能\",{\"1\":{\"175\":1}}],[\"从而提升程序的运行性能\",{\"1\":{\"169\":1}}],[\"从而提升性能和减少gc的压力\",{\"1\":{\"168\":1}}],[\"从而进行垃圾回收\",{\"1\":{\"127\":1}}],[\"从而找到优化的方向\",{\"1\":{\"87\":1}}],[\"从而触发minor\",{\"1\":{\"87\":1}}],[\"从定位到的代码和业务场景中\",{\"1\":{\"86\":1}}],[\"从master新建分支gh\",{\"0\":{\"19\":1}}],[\"xf\",{\"1\":{\"592\":1}}],[\"xstream等\",{\"1\":{\"277\":1}}],[\"x和y作为局部变量直接在栈上分配\",{\"1\":{\"173\":1}}],[\"x\",{\"1\":{\"85\":1,\"89\":2,\"165\":4,\"172\":5,\"173\":2,\"511\":3}}],[\"xloggc\",{\"1\":{\"75\":2}}],[\"xrunjdwp\",{\"1\":{\"75\":2}}],[\"xdebug\",{\"1\":{\"75\":1}}],[\"xx\",{\"1\":{\"72\":8,\"73\":9,\"74\":5,\"75\":2,\"84\":1,\"87\":3,\"113\":1,\"115\":1,\"136\":2,\"141\":1,\"144\":4,\"148\":1,\"159\":7,\"160\":1,\"166\":6,\"174\":6,\"272\":1,\"574\":1}}],[\"xml配置\",{\"1\":{\"655\":1}}],[\"xml中的打包名称来实现\",{\"1\":{\"600\":1}}],[\"xml\",{\"0\":{\"700\":1,\"711\":1,\"727\":1,\"739\":1,\"747\":1},\"1\":{\"277\":1,\"656\":2}}],[\"xml序列化\",{\"1\":{\"277\":1}}],[\"xml等格式\",{\"1\":{\"277\":1}}],[\"xmn256m\",{\"1\":{\"72\":1}}],[\"xmn\",{\"1\":{\"72\":1}}],[\"xmx参数来增加堆内存大小\",{\"1\":{\"87\":1}}],[\"xmx1024m\",{\"1\":{\"72\":1}}],[\"xmx\",{\"1\":{\"72\":1}}],[\"xms和\",{\"1\":{\"87\":1}}],[\"xms8g\",{\"1\":{\"84\":1}}],[\"xms512m\",{\"1\":{\"72\":1}}],[\"xms\",{\"1\":{\"72\":1}}],[\"xy\",{\"0\":{\"49\":1}}],[\"下面是对代码示例的解释\",{\"1\":{\"480\":1}}],[\"下面是对答案的一些完善和补充\",{\"1\":{\"475\":1}}],[\"下面是对双亲委派机制的详细解释\",{\"1\":{\"205\":1}}],[\"下面是阻塞队列的基本实现原理\",{\"1\":{\"400\":1}}],[\"下面是一个简单的示例代码\",{\"1\":{\"480\":1}}],[\"下面是一个简单的步骤来实现热部署功能\",{\"1\":{\"225\":1}}],[\"下面是一个简单的自定义类加载器示例\",{\"1\":{\"204\":1}}],[\"下面是一个典型的jvm调优流程\",{\"1\":{\"77\":1}}],[\"下面是一些常见的jvm参数配置\",{\"1\":{\"71\":1}}],[\"下面详细说明这些概念\",{\"1\":{\"162\":1}}],[\"下载地址\",{\"1\":{\"9\":1}}],[\"详细描述\",{\"0\":{\"195\":1}}],[\"详细变化对比\",{\"0\":{\"97\":1}}],[\"详细的事务跟踪\",{\"1\":{\"70\":1}}],[\"详细分析应用程序性能\",{\"1\":{\"61\":1}}],[\"与其他\",{\"0\":{\"744\":1}}],[\"与其他orm框架相比\",{\"1\":{\"655\":1}}],[\"与sql的亲和性\",{\"1\":{\"655\":1}}],[\"与电磁电流互感器相比\",{\"1\":{\"633\":1}}],[\"与电磁式电流互感器是完全不同的两种电气设备\",{\"1\":{\"633\":1}}],[\"与电容式电压互感器相比\",{\"1\":{\"632\":1}}],[\"与数字化装置接口连接时不需要二次转换装置\",{\"1\":{\"632\":1}}],[\"与现代电网相比\",{\"1\":{\"621\":1}}],[\"与消费者交换数据\",{\"1\":{\"361\":1}}],[\"与\",{\"0\":{\"711\":1,\"720\":1,\"727\":1,\"739\":1,\"747\":1},\"1\":{\"344\":1}}],[\"与按happens\",{\"1\":{\"320\":1}}],[\"与异常类型更没关系\",{\"1\":{\"296\":1}}],[\"与返回值和修饰符无关\",{\"1\":{\"296\":1}}],[\"与分代垃圾回收协同工作\",{\"1\":{\"115\":1}}],[\"与元空间\",{\"0\":{\"98\":1}}],[\"与线程相同\",{\"1\":{\"92\":3}}],[\"与java栈类似\",{\"1\":{\"92\":1}}],[\"与java\",{\"1\":{\"70\":1}}],[\"与grafana集成效果更佳\",{\"1\":{\"63\":1,\"70\":1}}],[\"易于集成\",{\"1\":{\"655\":1}}],[\"易于部署\",{\"1\":{\"68\":1,\"70\":1}}],[\"易于使用\",{\"1\":{\"59\":1,\"70\":1}}],[\"轻量级锁的获取\",{\"1\":{\"494\":1}}],[\"轻量级锁\",{\"0\":{\"494\":1},\"1\":{\"492\":1}}],[\"轻量级锁和偏向锁等优化策略\",{\"1\":{\"491\":1}}],[\"轻量级\",{\"1\":{\"68\":1,\"70\":1,\"655\":1}}],[\"包含了动态解析后的完整sql语句以及参数值\",{\"1\":{\"656\":1}}],[\"包含以下数据\",{\"1\":{\"610\":1,\"617\":1}}],[\"包含数值常量\",{\"1\":{\"105\":1}}],[\"包含elasticsearch\",{\"1\":{\"64\":1}}],[\"包括了属性名\",{\"1\":{\"656\":1}}],[\"包括了sql语句的id\",{\"1\":{\"656\":1}}],[\"包括了整个智能变电站遥信\",{\"1\":{\"652\":1}}],[\"包括内置的pooleddatasource\",{\"1\":{\"656\":1}}],[\"包括内存使用\",{\"1\":{\"58\":1}}],[\"包括内存\",{\"1\":{\"56\":1}}],[\"包括事务的开启\",{\"1\":{\"656\":1}}],[\"包括命中缓存\",{\"1\":{\"656\":1}}],[\"包括通过rdre逻辑节点实现\",{\"1\":{\"652\":1}}],[\"包括开入\",{\"1\":{\"652\":1}}],[\"包括母差保护启动开入及跳闸方式等有深入了解\",{\"1\":{\"644\":1}}],[\"包括主变压器失灵联跳\",{\"1\":{\"644\":1}}],[\"包括保护电压切换及计量电压切换等\",{\"1\":{\"644\":1}}],[\"包括服务器模型\",{\"1\":{\"636\":1}}],[\"包括站域备自投\",{\"1\":{\"630\":1}}],[\"包括关联的宿主机目录位置\",{\"1\":{\"584\":1}}],[\"包括已经停止的\",{\"1\":{\"580\":1}}],[\"包括我们要修改的html文件\",{\"1\":{\"579\":1}}],[\"包括系统函数库\",{\"1\":{\"562\":1}}],[\"包括线程池的初始化\",{\"1\":{\"477\":2}}],[\"包括线程id\",{\"1\":{\"56\":1}}],[\"包括监控线程池的运行状态\",{\"1\":{\"476\":1}}],[\"包括功能测试\",{\"1\":{\"476\":1}}],[\"包括数据库连接信息\",{\"1\":{\"656\":1}}],[\"包括数据库访问\",{\"1\":{\"422\":1}}],[\"包括数据的格式\",{\"1\":{\"637\":1}}],[\"包括数值常量\",{\"1\":{\"104\":1}}],[\"包括任务的串行执行\",{\"1\":{\"365\":1}}],[\"包括寄存器状态\",{\"1\":{\"348\":1}}],[\"包括类加载器的选择\",{\"1\":{\"232\":1}}],[\"包括类的属性\",{\"1\":{\"56\":1}}],[\"包括常量池\",{\"1\":{\"193\":1}}],[\"包括验证\",{\"1\":{\"180\":1}}],[\"包括解释器\",{\"1\":{\"179\":1}}],[\"包括堆\",{\"1\":{\"178\":1}}],[\"包括对象的移动等\",{\"1\":{\"138\":1}}],[\"包括对象的哈希码\",{\"1\":{\"117\":1}}],[\"包括eden区和survivor区\",{\"1\":{\"134\":1}}],[\"包括无法保证及时执行\",{\"1\":{\"129\":1}}],[\"包括设置初始值或通过参数传递的值\",{\"1\":{\"117\":1}}],[\"包括规避内存溢出问题\",{\"1\":{\"111\":1}}],[\"包括方法区\",{\"1\":{\"179\":1}}],[\"包括方法执行的中间结果\",{\"1\":{\"110\":1}}],[\"包括方法入参\",{\"1\":{\"56\":1}}],[\"包括字面值和符号引用\",{\"1\":{\"110\":1}}],[\"包括字面值\",{\"1\":{\"107\":1}}],[\"包括\",{\"1\":{\"88\":1}}],[\"包括java\",{\"1\":{\"247\":1}}],[\"包括jmap\",{\"1\":{\"88\":1}}],[\"包括jstat\",{\"1\":{\"55\":1}}],[\"包括总内存大小\",{\"1\":{\"88\":1}}],[\"包括自己的代码甚至框架中的代码\",{\"1\":{\"88\":1}}],[\"包括应用程序的内存使用情况\",{\"1\":{\"78\":1}}],[\"包括调用次数\",{\"1\":{\"56\":1}}],[\"包括日志级别\",{\"1\":{\"56\":1}}],[\"包括各种性能指标\",{\"1\":{\"56\":1}}],[\"包括ip地址\",{\"1\":{\"54\":1}}],[\"包括进程id\",{\"1\":{\"54\":1}}],[\"包括cpu核心数\",{\"1\":{\"453\":1}}],[\"包括cpu\",{\"1\":{\"54\":1}}],[\"包括cpu使用率\",{\"1\":{\"54\":1}}],[\"包括磁盘读写速度\",{\"1\":{\"54\":1}}],[\"日志很重要\",{\"0\":{\"674\":1}}],[\"日志是如何启用的\",{\"0\":{\"674\":1}}],[\"日志记录和回滚等机制\",{\"1\":{\"478\":1}}],[\"日志记录和回滚\",{\"1\":{\"478\":1}}],[\"日志记录等\",{\"1\":{\"475\":1}}],[\"日志记录\",{\"1\":{\"434\":1}}],[\"日志框架\",{\"1\":{\"252\":1}}],[\"日志和数据分析平台\",{\"1\":{\"64\":1,\"70\":1}}],[\"日志文件等\",{\"1\":{\"56\":1}}],[\"适用场景\",{\"1\":{\"159\":6,\"457\":1,\"458\":1,\"459\":1,\"460\":1}}],[\"适用于串行执行任务的场景\",{\"1\":{\"459\":1}}],[\"适用于短时任务较多\",{\"1\":{\"455\":1}}],[\"适用于已知线程数固定的场景\",{\"1\":{\"406\":1}}],[\"适用于已知固定数量的并发任务\",{\"1\":{\"394\":1}}],[\"适用于需要执行定时任务和周期性任务的场景\",{\"1\":{\"455\":1}}],[\"适用于需要保证任务按照顺序执行\",{\"1\":{\"455\":1}}],[\"适用于需要限制线程数量的场景\",{\"1\":{\"455\":1}}],[\"适用于需要定期执行任务的场景\",{\"1\":{\"397\":1}}],[\"适用于需要顺序执行任务的场景\",{\"1\":{\"396\":1,\"406\":1}}],[\"适用于需要处理大量数据的应用场景\",{\"1\":{\"154\":1}}],[\"适用于处理cpu密集型的任务\",{\"1\":{\"457\":1}}],[\"适用于处理文本数据\",{\"1\":{\"237\":1}}],[\"适用于处理二进制数据\",{\"1\":{\"237\":1}}],[\"适用于一些特定的加载需求\",{\"1\":{\"233\":1}}],[\"适用于openjdk\",{\"1\":{\"159\":1}}],[\"适用于批处理\",{\"1\":{\"158\":1}}],[\"适用于对响应时间敏感的应用\",{\"1\":{\"158\":1}}],[\"适用于对响应时间有要求的应用\",{\"1\":{\"137\":1}}],[\"适用于大量短生命周期任务\",{\"1\":{\"406\":1}}],[\"适用于大量短生命周期的并发任务\",{\"1\":{\"395\":1}}],[\"适用于大堆内存\",{\"1\":{\"151\":1}}],[\"适用于大规模分布式系统的监控\",{\"1\":{\"69\":1,\"70\":1}}],[\"适用于具有中等堆大小的应用\",{\"1\":{\"151\":1}}],[\"适用于多核服务器上的应用\",{\"1\":{\"137\":1}}],[\"适用于简单的客户端应用或者测试目的\",{\"1\":{\"137\":2}}],[\"适用于老年代的垃圾回收\",{\"1\":{\"131\":1}}],[\"适用于系统和服务的监控\",{\"1\":{\"63\":1}}],[\"适应分布式电源和微电网的接入\",{\"1\":{\"622\":1}}],[\"适应现代应用的需求\",{\"1\":{\"148\":1}}],[\"适应性强\",{\"1\":{\"143\":1}}],[\"适合大堆内存\",{\"1\":{\"153\":1}}],[\"适合大规模监控\",{\"1\":{\"62\":1}}],[\"适合用于缓存的场景\",{\"1\":{\"128\":1}}],[\"适合深度分析\",{\"1\":{\"70\":1}}],[\"适合长期监控和深度分析\",{\"1\":{\"60\":1}}],[\"适合基础监控\",{\"1\":{\"59\":1}}],[\"支持哪些类型的参数映射\",{\"0\":{\"664\":1}}],[\"支持电力市场运营和电力交易的有效开展\",{\"1\":{\"622\":1}}],[\"支持可再生能源的有序\",{\"1\":{\"622\":1}}],[\"支持随机访问\",{\"1\":{\"515\":1}}],[\"支持高并发操作\",{\"1\":{\"291\":1}}],[\"支持多线程\",{\"1\":{\"246\":1}}],[\"支持多种数据源\",{\"1\":{\"62\":1,\"70\":1}}],[\"支持模块化开发和扩展性\",{\"0\":{\"213\":1}}],[\"支持超大堆内存\",{\"1\":{\"159\":1}}],[\"支持超大堆\",{\"1\":{\"151\":1,\"154\":1}}],[\"支持hotspot的未来发展\",{\"1\":{\"116\":1}}],[\"支持更多类加载和卸载\",{\"1\":{\"115\":1}}],[\"支持类和方法的运行\",{\"1\":{\"105\":1}}],[\"支持native方法调用\",{\"1\":{\"92\":1}}],[\"支持大规模环境\",{\"1\":{\"67\":1,\"70\":1}}],[\"支持本地和远程监控\",{\"1\":{\"58\":1,\"70\":1}}],[\"可将光波调制分为强度调制\",{\"1\":{\"635\":1}}],[\"可见数字化微机型继电保护装置的硬件明显少于常规的微机型继电保护装置\",{\"1\":{\"631\":1}}],[\"可见性和有序性\",{\"1\":{\"316\":1}}],[\"可见性保证了共享变量的修改对其他线程是可见的\",{\"1\":{\"316\":1}}],[\"可见性是指当一个线程对共享变量进行修改后\",{\"1\":{\"316\":1}}],[\"可见性是并发编程中非常重要的基础概念\",{\"1\":{\"316\":1}}],[\"可见性\",{\"0\":{\"316\":1,\"318\":1},\"1\":{\"316\":1,\"318\":1}}],[\"可接收来自外部源的数据\",{\"1\":{\"626\":1}}],[\"可靠性更高\",{\"1\":{\"629\":1}}],[\"可靠\",{\"1\":{\"623\":1}}],[\"可实现选择性通知\",{\"1\":{\"495\":1}}],[\"可实现公平锁\",{\"1\":{\"495\":1}}],[\"可重入性怎么实现\",{\"0\":{\"486\":1}}],[\"可控性\",{\"1\":{\"343\":1}}],[\"可变\",{\"1\":{\"268\":2}}],[\"可变性\",{\"1\":{\"268\":1}}],[\"可预测停顿时间和自动调优等特性\",{\"1\":{\"149\":1}}],[\"可预测的低停顿时间\",{\"1\":{\"153\":1}}],[\"可预测的停顿时间\",{\"1\":{\"148\":1,\"151\":1,\"159\":1}}],[\"可预测的特点\",{\"1\":{\"145\":1}}],[\"可预测性\",{\"1\":{\"143\":1}}],[\"可达性分析从一组称为\",{\"1\":{\"126\":1}}],[\"可达性分析\",{\"1\":{\"126\":2}}],[\"可通过\",{\"1\":{\"88\":1}}],[\"可对比正常情况看频率是否正常\",{\"1\":{\"88\":1}}],[\"可视化的堆内存分析工具\",{\"1\":{\"88\":1}}],[\"可全方位监控jvm的各项指标\",{\"1\":{\"88\":1}}],[\"可能有其中几种也可能全部都有\",{\"1\":{\"630\":1}}],[\"可能导致get操作返回null\",{\"1\":{\"545\":1}}],[\"可能导致get为null\",{\"1\":{\"545\":1}}],[\"可能不会执行的情况\",{\"1\":{\"281\":1}}],[\"可能是\",{\"1\":{\"243\":1}}],[\"可能是由于对象的存活时间较长\",{\"1\":{\"87\":1}}],[\"可能需要回滚到之前的状态\",{\"1\":{\"231\":1}}],[\"可能需要卸载旧的类以释放资源并避免内存泄漏\",{\"1\":{\"230\":1}}],[\"可能继续使用cms或转向g1\",{\"1\":{\"155\":1}}],[\"可能抛出异常的位置等\",{\"1\":{\"138\":1}}],[\"可能会影响性能\",{\"1\":{\"613\":1}}],[\"可能会影响到整个线程池的性能和响应速度\",{\"1\":{\"479\":1}}],[\"可能会带来较高的内存开销和延迟\",{\"1\":{\"522\":1}}],[\"可能会因为无限创建线程\",{\"1\":{\"458\":1}}],[\"可能会直接重写\",{\"1\":{\"233\":1}}],[\"可能会存在多个应用程序使用不同的类加载器加载相同的类\",{\"1\":{\"219\":1}}],[\"可能会破坏双亲委派机制对类的唯一性和一致性的要求\",{\"1\":{\"218\":1}}],[\"可能会绕过双亲委派机制\",{\"1\":{\"217\":1}}],[\"可能会有空的内存空间\",{\"1\":{\"515\":1}}],[\"可能会有较长的停顿时间\",{\"1\":{\"159\":1}}],[\"可能会有新创建或删除的对象\",{\"1\":{\"139\":1}}],[\"可能会触发full\",{\"1\":{\"133\":1}}],[\"可能会导致环形链表的出现\",{\"1\":{\"545\":1}}],[\"可能会导致在阻塞队列中的线程长期处于饥饿状态\",{\"1\":{\"501\":1}}],[\"可能会导致oom\",{\"1\":{\"457\":1,\"459\":1}}],[\"可能会导致线程间上下文切换的开销增加\",{\"1\":{\"453\":1}}],[\"可能会导致不再需要的对象一直被保留在内存中\",{\"1\":{\"125\":1}}],[\"可能会导致系统性能下降\",{\"1\":{\"123\":1}}],[\"可能执行效率降低\",{\"1\":{\"131\":1}}],[\"可能存在内存泄漏导致内存无法释放\",{\"1\":{\"86\":1}}],[\"可用来监控各种系统和应用指标\",{\"1\":{\"62\":1}}],[\"可用于cpu和内存分析\",{\"1\":{\"61\":1}}],[\"可以与不同的持久化框架或数据库连接池集成\",{\"1\":{\"656\":1}}],[\"可以与其他接口组合\",{\"1\":{\"343\":1}}],[\"可以拦截sql执行过程中的多个环节\",{\"1\":{\"656\":1}}],[\"可以创建preparedstatement或statement对象\",{\"1\":{\"656\":1}}],[\"可以是直接执行sql\",{\"1\":{\"656\":1}}],[\"可以无饱和\",{\"1\":{\"635\":1}}],[\"可以看到都包含dockerfile文件\",{\"1\":{\"598\":1}}],[\"可以看到其中已经准备好了cloud\",{\"1\":{\"598\":1}}],[\"可以看到\",{\"1\":{\"584\":1,\"598\":1}}],[\"可以看提交记录\",{\"1\":{\"24\":1}}],[\"可以知道nginx的html目录位置在\",{\"1\":{\"579\":1}}],[\"可以输入命令\",{\"1\":{\"574\":1}}],[\"可以迁移到任意linux操作系统\",{\"1\":{\"562\":1}}],[\"可以按照插入顺序或访问顺序进行遍历\",{\"1\":{\"551\":1}}],[\"可以获得较高的读取性能\",{\"1\":{\"522\":1}}],[\"可以直接使用sql语句来执行复杂查询\",{\"1\":{\"655\":1}}],[\"可以直接使用它来替代arraylist\",{\"1\":{\"521\":1}}],[\"可以直接通过数组下标获取\",{\"1\":{\"515\":1}}],[\"可以靠按序申请资源来预防\",{\"1\":{\"512\":1}}],[\"可以主动释放它占有的资源\",{\"1\":{\"512\":1}}],[\"可以一次性请求所有的资源\",{\"1\":{\"512\":1}}],[\"可以保证对变量的操作是线程安全的\",{\"1\":{\"510\":1}}],[\"可以考虑使用\",{\"1\":{\"550\":1}}],[\"可以考虑合并多个变量\",{\"1\":{\"508\":1}}],[\"可以考虑以下几种策略\",{\"1\":{\"479\":1}}],[\"可以确保单机线程池在断电情况下的任务一致性和可靠性\",{\"1\":{\"478\":1}}],[\"可以确定占用cpu资源较多的线程\",{\"1\":{\"85\":1}}],[\"可以有效优化线程池中调用特别耗时的\",{\"1\":{\"479\":1}}],[\"可以有效地管理和调优线程池的配置\",{\"1\":{\"476\":1}}],[\"可以有效控制对资源的并发访问\",{\"1\":{\"359\":1}}],[\"可以提供可视化界面让用户方便地修改线程池的参数\",{\"1\":{\"475\":1}}],[\"可以动态地调整线程池的参数\",{\"1\":{\"475\":1}}],[\"可以动态调整线程数量以适应任务量的变化\",{\"1\":{\"455\":1}}],[\"可以处理队列中的任务\",{\"1\":{\"469\":1}}],[\"可以处理需要返回结果的任务\",{\"1\":{\"451\":1}}],[\"可以接受新任务\",{\"1\":{\"469\":1}}],[\"可以继续活下去\",{\"1\":{\"458\":1}}],[\"可以用来获取任务的执行结果或者监控任务的执行状态\",{\"1\":{\"451\":1}}],[\"可以调度定时任务\",{\"1\":{\"439\":1}}],[\"可以并行处理数据块\",{\"1\":{\"431\":1}}],[\"可以限制并发线程的数量\",{\"1\":{\"404\":1}}],[\"可以不指定线程池\",{\"1\":{\"398\":1}}],[\"可以简化两个线程之间的数据交换逻辑\",{\"1\":{\"363\":1}}],[\"可以指定最大等待时间\",{\"1\":{\"363\":1}}],[\"可以再次使用\",{\"1\":{\"355\":1}}],[\"可以再次进入runnable状态\",{\"1\":{\"347\":1}}],[\"可以重新加载持久化的任务队列\",{\"1\":{\"478\":1}}],[\"可以重新安排语句的执行顺序\",{\"1\":{\"319\":1}}],[\"可以重复使用\",{\"1\":{\"355\":1}}],[\"可以先讲原对象序列化\",{\"1\":{\"307\":1}}],[\"可以快速定位对象\",{\"1\":{\"305\":1}}],[\"可以阻断\",{\"1\":{\"303\":1}}],[\"可以访问类的所有成员变量和方法\",{\"1\":{\"301\":1}}],[\"可以使⽤\",{\"1\":{\"301\":1}}],[\"可以使用如下方式\",{\"1\":{\"614\":1}}],[\"可以使用collections工具类的synchronizedlist方法将arraylist转换为线程安全的list\",{\"1\":{\"521\":1}}],[\"可以使用图算法如找环算法来检测死锁\",{\"1\":{\"513\":1}}],[\"可以使用jdk自带的命令行工具排查\",{\"1\":{\"513\":1}}],[\"可以使用更高效的算法\",{\"1\":{\"479\":1}}],[\"可以使用信号量或者线程池的控制参数来实现并发数的限制\",{\"1\":{\"479\":1}}],[\"可以使用事务管理的机制来实现这一点\",{\"1\":{\"478\":1}}],[\"可以使用优先级队列来根据任务的优先级高低来执行任务\",{\"1\":{\"450\":1}}],[\"可以使用自定义线程池\",{\"1\":{\"388\":1}}],[\"可以使用stringbuilder类以\",{\"1\":{\"268\":1}}],[\"可以使用stringbuffer类\",{\"1\":{\"268\":1}}],[\"可以使用string类\",{\"1\":{\"268\":1}}],[\"可以使用连接池优化\",{\"1\":{\"238\":1}}],[\"可以使用以下jvm参数\",{\"1\":{\"174\":1}}],[\"可以使用\",{\"1\":{\"89\":1,\"226\":1,\"228\":1,\"466\":1,\"475\":1,\"546\":2}}],[\"可以使用工具\",{\"1\":{\"87\":1}}],[\"可以使用printf命令将线程id转换为16进制格式\",{\"1\":{\"85\":1}}],[\"可以修饰类\",{\"1\":{\"297\":1}}],[\"可以修饰变量\",{\"1\":{\"297\":2}}],[\"可以修饰在类\",{\"1\":{\"297\":1}}],[\"可以在已经准备了jdk的基础镜像基础上构建\",{\"1\":{\"593\":1}}],[\"可以在本地或远程向服务端发送指令\",{\"1\":{\"567\":1}}],[\"可以在多线程下并发使用\",{\"1\":{\"520\":1}}],[\"可以在指定的时间点执行任务\",{\"1\":{\"455\":1}}],[\"可以在后台执行\",{\"1\":{\"434\":1}}],[\"可以在编写代码时指定类\",{\"1\":{\"284\":1}}],[\"可以在类中显式地定义serialversionuid字段\",{\"1\":{\"276\":1}}],[\"可以被public\",{\"1\":{\"300\":1}}],[\"可以被继承吗\",{\"0\":{\"267\":1}}],[\"可以被回收\",{\"1\":{\"126\":2}}],[\"可以传递一段代码\",{\"1\":{\"240\":1}}],[\"可以划分为\",{\"1\":{\"236\":1}}],[\"可以分为静态内部类\",{\"1\":{\"309\":1}}],[\"可以分为\",{\"1\":{\"236\":1}}],[\"可以分为新生代\",{\"1\":{\"92\":1}}],[\"可以加载自己的类和库\",{\"1\":{\"234\":1}}],[\"可以实现对象关系映射\",{\"1\":{\"656\":1}}],[\"可以实现一次\",{\"1\":{\"624\":1}}],[\"可以实现一个稳健和可靠的热部署功能\",{\"1\":{\"232\":1}}],[\"可以实现在不修改代码的情况下动态修改线程池的参数\",{\"1\":{\"475\":1}}],[\"可以实现更灵活的控制\",{\"1\":{\"475\":1}}],[\"可以实现自己的类加载逻辑\",{\"1\":{\"202\":1}}],[\"可以将程序及其依赖\",{\"1\":{\"562\":1}}],[\"可以将调用结果缓存起来\",{\"1\":{\"479\":1}}],[\"可以将异步任务提交到线程池中执行\",{\"1\":{\"435\":1}}],[\"可以将数据分割成多个块\",{\"1\":{\"430\":1}}],[\"可以将java对象序列化为二进制格式\",{\"1\":{\"277\":1}}],[\"可以将结构化的数据序列化为紧凑的二进制格式\",{\"1\":{\"277\":1}}],[\"可以将\",{\"1\":{\"224\":1,\"243\":1}}],[\"可以将对象的引用分为以下几种类型\",{\"1\":{\"128\":1}}],[\"可以破坏双亲委派机制\",{\"1\":{\"215\":1}}],[\"可以进行实例化\",{\"1\":{\"189\":1}}],[\"可以进一步分析和优化问题所在\",{\"1\":{\"86\":1}}],[\"可以选择最适合的垃圾收集器来优化java应用的性能和稳定性\",{\"1\":{\"161\":1}}],[\"可以选择合适的工具进行使用\",{\"1\":{\"70\":1}}],[\"可以根据条件动态地生成不同的\",{\"1\":{\"656\":1}}],[\"可以根据具体的需求选择合适的队列类型来优化线程池的性能和行为\",{\"1\":{\"450\":1}}],[\"可以根据具体的业务需求和系统特性选择合适的拒绝策略\",{\"1\":{\"449\":1}}],[\"可以根据具体需求采取适当的措施\",{\"1\":{\"219\":1}}],[\"可以根据通过设置\",{\"1\":{\"272\":1}}],[\"可以根据运行时的表现自动调整垃圾收集策略\",{\"1\":{\"153\":1}}],[\"可以根据需要动态增长\",{\"1\":{\"115\":1}}],[\"可以整理内存\",{\"1\":{\"148\":1}}],[\"可以控制垃圾收集的频率和停顿时间\",{\"1\":{\"139\":1}}],[\"可以采用不同的垃圾回收算法和策略来对各个区域进行回收\",{\"1\":{\"130\":1}}],[\"可以清晰地看出字符串常量池和运行时常量池在用途\",{\"1\":{\"105\":1}}],[\"可以多抓几次做个对比\",{\"1\":{\"89\":1}}],[\"可以了解gc的频率\",{\"1\":{\"87\":1}}],[\"可以利用多线程并行处理\",{\"1\":{\"87\":1}}],[\"可以通过修改pom\",{\"1\":{\"600\":1}}],[\"可以通过\",{\"1\":{\"585\":1}}],[\"可以通过同步机制\",{\"1\":{\"521\":1}}],[\"可以通过自定义\",{\"1\":{\"465\":1}}],[\"可以通过自定义threadfactory来指定线程的名称\",{\"1\":{\"448\":1}}],[\"可以通过向线程池提交任务的方式\",{\"1\":{\"454\":1}}],[\"可以通过监控系统资源的使用情况和线程池的运行状态来动态调整线程数配置\",{\"1\":{\"453\":1}}],[\"可以通过java内置的等待\",{\"1\":{\"351\":1}}],[\"可以通过线程池管理\",{\"1\":{\"343\":1}}],[\"可以通过反射获取注解信息\",{\"1\":{\"289\":1}}],[\"可以通过适当的方式销毁旧类的实例\",{\"1\":{\"230\":1}}],[\"可以通过垃圾回收器来判断对象是否仍然存活\",{\"1\":{\"126\":1}}],[\"可以通过调用awaittermination\",{\"1\":{\"452\":1}}],[\"可以通过调用string类的intern\",{\"1\":{\"103\":1}}],[\"可以通过调整新生代\",{\"1\":{\"87\":1}}],[\"可以通过调整\",{\"1\":{\"87\":3,\"136\":2}}],[\"可以通过启用逃逸分析和标量替换来优化对象的内存分配\",{\"1\":{\"87\":1}}],[\"可以通过合理的对象设计和资源管理来优化对象的生命周期\",{\"1\":{\"87\":1}}],[\"可以减少minor\",{\"1\":{\"87\":1}}],[\"可以初步确定哪些对象占用了大量内存\",{\"1\":{\"86\":1}}],[\"可以初步确定占用cpu资源较多的进程\",{\"1\":{\"85\":1}}],[\"可以初步判断内存飙高的原因\",{\"1\":{\"86\":1}}],[\"可以定位到具体的业务方法\",{\"1\":{\"85\":1}}],[\"可以显著影响java应用程序的性能和行为\",{\"1\":{\"71\":1}}],[\"可以\",{\"1\":{\"54\":1}}],[\"配合使用\",{\"1\":{\"60\":1,\"70\":1}}],[\"配置技术基础\",{\"0\":{\"646\":1}}],[\"配置环境变量\",{\"1\":{\"592\":2}}],[\"配置文件\",{\"1\":{\"589\":1}}],[\"配置\",{\"1\":{\"579\":1,\"589\":1}}],[\"配置打包在一起\",{\"1\":{\"568\":1}}],[\"配置等文件打包在一起\",{\"1\":{\"565\":1}}],[\"配置一起打包\",{\"1\":{\"562\":1}}],[\"配置与应用一起打包\",{\"1\":{\"560\":1}}],[\"配置远程调试参数\",{\"1\":{\"75\":1}}],[\"配置部署分支为gh\",{\"1\":{\"21\":1}}],[\"配置github\",{\"0\":{\"21\":1}}],[\"特性\",{\"1\":{\"656\":1}}],[\"特征\",{\"1\":{\"469\":1,\"470\":1,\"471\":1,\"472\":1,\"473\":1}}],[\"特别适用于需要频繁调整参数的情况\",{\"1\":{\"475\":1}}],[\"特别适用于大内存和多处理器的现代应用环境\",{\"1\":{\"149\":1}}],[\"特别是确定对象是否会逃逸出方法的作用域\",{\"1\":{\"164\":1}}],[\"特别是当需要平衡响应时间和吞吐量时\",{\"1\":{\"155\":1}}],[\"特别是大堆内存环境\",{\"1\":{\"151\":1}}],[\"特别是在高并发或多线程应用程序中\",{\"1\":{\"461\":1}}],[\"特别是在高并发和需要处理大量任务的场景中\",{\"1\":{\"420\":1}}],[\"特别是在生产环境中使用热部署功能时\",{\"1\":{\"232\":1}}],[\"特别是在长时间运行\",{\"1\":{\"123\":1}}],[\"特别是在使用缓存或者集合等数据结构时\",{\"1\":{\"87\":1}}],[\"特别是对于大量动态生成和卸载类的应用\",{\"1\":{\"115\":1}}],[\"特别是与java\",{\"1\":{\"60\":1}}],[\"特点\",{\"1\":{\"58\":1,\"59\":1,\"60\":1,\"61\":1,\"62\":1,\"63\":1,\"64\":1,\"65\":1,\"66\":1,\"67\":1,\"68\":1,\"69\":1,\"70\":1,\"92\":5,\"159\":6,\"199\":1,\"200\":1,\"201\":1,\"202\":1,\"343\":1,\"522\":1}}],[\"官网\",{\"1\":{\"58\":1,\"60\":1,\"61\":1,\"62\":1,\"63\":1,\"64\":1,\"65\":1,\"66\":1,\"67\":1,\"68\":1,\"69\":1,\"70\":1}}],[\"主线程可以继续处理其他工作\",{\"1\":{\"435\":1}}],[\"主线程继续执行其他操作\",{\"1\":{\"383\":1,\"392\":2,\"436\":2}}],[\"主线程使用countdownlatch\",{\"1\":{\"353\":2}}],[\"主线程\",{\"1\":{\"335\":1}}],[\"主内存\",{\"1\":{\"315\":1}}],[\"主观原因\",{\"0\":{\"114\":1}}],[\"主要侧重于网络结构\",{\"1\":{\"628\":1}}],[\"主要侧重于设备构成\",{\"1\":{\"628\":1}}],[\"主要是因为线程的创建和销毁涉及操作系统和jvm层面的多种资源管理和调度\",{\"1\":{\"410\":1}}],[\"主要通过executors工具类来创建\",{\"1\":{\"405\":1}}],[\"主要目的是确保\",{\"1\":{\"305\":1}}],[\"主要负责加载catalina容器相关的类库\",{\"1\":{\"234\":1}}],[\"主要的类加载器有以下几种\",{\"1\":{\"198\":1}}],[\"主要的内存区域包括\",{\"1\":{\"92\":1}}],[\"主要在年轻代gc和混合gc中执行\",{\"1\":{\"142\":1}}],[\"主要标记从根集合\",{\"1\":{\"139\":1}}],[\"主要包括以下几个部分\",{\"1\":{\"130\":1}}],[\"主要用于新生代的收集\",{\"1\":{\"137\":1}}],[\"主要用于存放对象实例\",{\"1\":{\"130\":1}}],[\"主要用于清理前的资源释放工作\",{\"1\":{\"128\":1}}],[\"主要用于实现对象的规范映射\",{\"1\":{\"128\":1}}],[\"主要用途\",{\"1\":{\"58\":1,\"59\":1,\"60\":1,\"61\":1,\"62\":1,\"63\":1,\"64\":1,\"65\":1,\"66\":1,\"67\":1,\"68\":1,\"69\":1,\"70\":1}}],[\"主要变化是永久代\",{\"1\":{\"95\":1}}],[\"主要有以下操作步骤\",{\"1\":{\"89\":1}}],[\"主页\",{\"0\":{\"5\":1}}],[\"使新型互感器抗干扰能力得到增强\",{\"1\":{\"634\":1}}],[\"使线程和队列解耦\",{\"1\":{\"454\":1}}],[\"使线程在屏障点等待\",{\"1\":{\"355\":1}}],[\"使其他被阻塞的线程可以继续执行\",{\"1\":{\"358\":1}}],[\"使其成为监视对象\",{\"1\":{\"238\":1}}],[\"使java程序能够调用本地\",{\"1\":{\"179\":1}}],[\"使用了原理上没有饱和的罗哥夫斯基线圈\",{\"1\":{\"634\":1}}],[\"使用maven打包工具\",{\"1\":{\"597\":1}}],[\"使用docker\",{\"1\":{\"574\":2,\"593\":2}}],[\"使用defineclass方法加载类到内存中\",{\"1\":{\"220\":1}}],[\"使用沙箱机制\",{\"1\":{\"562\":1}}],[\"使用更加方便\",{\"1\":{\"561\":1}}],[\"使用reentrantlock加锁\",{\"1\":{\"548\":1}}],[\"使用线程安全的并发容器\",{\"1\":{\"546\":1}}],[\"使用线程安全的包装类\",{\"1\":{\"546\":1}}],[\"使用随机哈希码\",{\"1\":{\"539\":1}}],[\"使用扰动函数\",{\"1\":{\"532\":1}}],[\"使用链表存储键值对\",{\"1\":{\"525\":1}}],[\"使用copyonwritearraylist代替arraylist\",{\"1\":{\"521\":1}}],[\"使用collections\",{\"1\":{\"521\":1}}],[\"使用countdownlatch时\",{\"1\":{\"356\":1}}],[\"使用自旋+cas实现\",{\"1\":{\"511\":1}}],[\"使用自定义\",{\"0\":{\"465\":1}}],[\"使用自定义线程池\",{\"0\":{\"391\":1}}],[\"使用自定义的类加载器动态加载新的类\",{\"1\":{\"228\":1}}],[\"使用自定义类加载器加载类\",{\"1\":{\"215\":1}}],[\"使用synchronized\",{\"1\":{\"509\":1}}],[\"使用stringbuilder可以获得更好的性能\",{\"1\":{\"268\":1}}],[\"使用stringbuffer可以保证线程安全\",{\"1\":{\"268\":1}}],[\"使用循环原子类\",{\"1\":{\"509\":1}}],[\"使用atomicstampreference类\",{\"1\":{\"505\":1}}],[\"使用一个\",{\"1\":{\"496\":1}}],[\"使用管理平台是一种更高级的方式\",{\"1\":{\"475\":1}}],[\"使用配置文件是一种常见的方式\",{\"1\":{\"475\":1}}],[\"使用动态代理也是一种有效的方式\",{\"1\":{\"475\":1}}],[\"使用可调整的线程池\",{\"1\":{\"475\":1}}],[\"使用可视化工具如visualvm等\",{\"1\":{\"86\":1}}],[\"使用连接池管理数据库连接\",{\"1\":{\"428\":1}}],[\"使用默认线程池\",{\"0\":{\"388\":1}}],[\"使用示例\",{\"1\":{\"361\":1}}],[\"使用完threadlocal后\",{\"1\":{\"330\":1}}],[\"使用完threadlocal一\",{\"1\":{\"125\":1}}],[\"使用volatile关键字或者同步机制\",{\"1\":{\"318\":2}}],[\"使用同步机制控制arraylist的读写\",{\"1\":{\"521\":1}}],[\"使用同步机制\",{\"1\":{\"318\":1,\"546\":1}}],[\"使用静态内部类有助于避免内存泄漏\",{\"1\":{\"313\":1}}],[\"使用的是哈希表的数据结构\",{\"1\":{\"550\":1}}],[\"使用的时候再一个一个的一次调用就可以\",{\"1\":{\"294\":1}}],[\"使用的人员可能发现点击后很久后页面都没反应\",{\"1\":{\"84\":1}}],[\"使用for\",{\"1\":{\"292\":2}}],[\"使用迭代器遍历\",{\"1\":{\"292\":1}}],[\"使用注解作为切点就是运行期注解的应用\",{\"1\":{\"289\":1}}],[\"使用建议\",{\"1\":{\"268\":1}}],[\"使用合适的类加载器\",{\"0\":{\"226\":1}}],[\"使用不同的gc选项运行应用\",{\"1\":{\"160\":1}}],[\"使用不同类型的引用可以更灵活地管理对象的生命周期和内存使用情况\",{\"1\":{\"128\":1}}],[\"使用zgc的理由\",{\"0\":{\"154\":1}}],[\"使用g1的理由\",{\"0\":{\"153\":1}}],[\"使用g1垃圾回收器\",{\"1\":{\"73\":1}}],[\"使用场景\",{\"1\":{\"151\":3}}],[\"使用标记\",{\"1\":{\"137\":3}}],[\"使用指针碰撞或空闲列表实现\",{\"1\":{\"117\":1}}],[\"使用元空间\",{\"1\":{\"116\":1}}],[\"使用元空间替代永久代的原因\",{\"0\":{\"112\":1}}],[\"使用元空间替代\",{\"1\":{\"101\":1}}],[\"使用永久代来存储类元数据\",{\"1\":{\"101\":1}}],[\"使用内存分析工具\",{\"1\":{\"90\":1}}],[\"使用\",{\"0\":{\"189\":1,\"464\":1,\"466\":1,\"467\":1},\"1\":{\"89\":5,\"120\":1,\"183\":1,\"240\":1,\"244\":1,\"268\":2,\"276\":1,\"359\":1,\"387\":1,\"388\":1,\"398\":2,\"480\":2,\"546\":1}}],[\"使用率飙升\",{\"1\":{\"89\":1}}],[\"使用逃逸分析和标量替换\",{\"1\":{\"87\":1}}],[\"使用工具进行离线分析\",{\"1\":{\"86\":1}}],[\"使用jps查找运行的java进程\",{\"1\":{\"513\":1}}],[\"使用juc包下的锁\",{\"1\":{\"509\":1}}],[\"使用java\",{\"1\":{\"292\":1}}],[\"使用jvm提供的工具\",{\"1\":{\"160\":1}}],[\"使用jmap命令将堆内存信息导出到文件中\",{\"1\":{\"86\":1}}],[\"使用jmap命令查看堆内存中占用空间最大的前20个对象类型\",{\"1\":{\"86\":1}}],[\"使用jstack查看线程堆栈信息\",{\"1\":{\"513\":1}}],[\"使用jstack命令打印出进程的所有线程信息\",{\"1\":{\"85\":1}}],[\"使用jstat命令查看垃圾回收的次数\",{\"1\":{\"86\":1}}],[\"使用threadlocal\",{\"1\":{\"351\":1}}],[\"使用thread\",{\"1\":{\"351\":1}}],[\"使用top命令的\",{\"1\":{\"85\":1}}],[\"使用top命令列出系统各个进程的资源占用情况\",{\"1\":{\"85\":1}}],[\"使用typora或者其他markdown软件就能渲染出来\",{\"1\":{\"27\":1}}],[\"使用压缩指针来减少64位环境下的内存占用\",{\"1\":{\"74\":1}}],[\"使用并行gc或者g1\",{\"1\":{\"87\":1}}],[\"使用并行垃圾回收器\",{\"1\":{\"73\":1}}],[\"使用并发标记\",{\"1\":{\"73\":1}}],[\"使用串行垃圾回收器\",{\"1\":{\"73\":1}}],[\"使得每个线程都在等待下一个线程占有的资源\",{\"1\":{\"512\":1}}],[\"使得任务能够动态地分配给空闲的线程\",{\"1\":{\"480\":1}}],[\"使得线程池成为并发编程中重要的工具\",{\"1\":{\"447\":1}}],[\"使得类加载过程更加统一和规范\",{\"1\":{\"212\":1}}],[\"使得java程序能够在各种硬件和操作系统上稳定运行\",{\"1\":{\"181\":1}}],[\"使得垃圾回收器无法回收这些对象\",{\"1\":{\"123\":1}}],[\"使得内存使用更加高效和一致\",{\"1\":{\"115\":1}}],[\"使得开发人员和系统管理员能够更直观地理解系统的运行状况\",{\"1\":{\"70\":1}}],[\"使得分析和诊断性能问题更加直观和方便\",{\"1\":{\"57\":1}}],[\"这意味着查询首先会去除重复的行\",{\"1\":{\"619\":1}}],[\"这意味着在应用\",{\"1\":{\"615\":1}}],[\"这意味着它不能被继承\",{\"1\":{\"267\":1}}],[\"这块结构会随着锁的状态变化而变化\",{\"1\":{\"490\":1}}],[\"这块内存空间包括三个主要部分\",{\"1\":{\"121\":1}}],[\"这包括调整核心线程数\",{\"1\":{\"476\":1}}],[\"这包括确定核心线程数\",{\"1\":{\"476\":1}}],[\"这包括基本类型的零值\",{\"1\":{\"117\":1}}],[\"这可以防止异常传播到线程池外部\",{\"1\":{\"462\":1}}],[\"这可能导致应用程序之间的类冲突\",{\"1\":{\"234\":1}}],[\"这可能导致内存碎片\",{\"1\":{\"139\":1}}],[\"这可能涉及到重新创建实例或者更新现有实例的状态\",{\"1\":{\"229\":1}}],[\"这可能会影响应用程序的性能和响应时间\",{\"1\":{\"87\":1}}],[\"这可能需要数分钟\",{\"1\":{\"11\":1}}],[\"这两种方法都是用来关闭线程池的\",{\"1\":{\"452\":1}}],[\"这两种状态的区别在于阻塞状态是等待获取锁\",{\"1\":{\"346\":1}}],[\"这对于大多数情况已经足够\",{\"1\":{\"388\":1}}],[\"这对于需要保证响应时间的应用非常重要\",{\"1\":{\"153\":1}}],[\"这才起到多线程的效果\",{\"1\":{\"342\":1}}],[\"这就要用到数据卷了\",{\"1\":{\"581\":1}}],[\"这就要求有两个cpu去分别执行两个线程\",{\"1\":{\"339\":1}}],[\"这就是因为容器与数据\",{\"1\":{\"581\":1}}],[\"这就是所谓的工作窃取\",{\"1\":{\"480\":1}}],[\"这就是注解的用处\",{\"1\":{\"289\":1}}],[\"这就是泛型擦除\",{\"1\":{\"287\":1}}],[\"这就是通过字符串常量池来实现的\",{\"1\":{\"267\":1}}],[\"这\",{\"1\":{\"329\":1}}],[\"这使得配置和映射关系更清晰可见\",{\"1\":{\"655\":1}}],[\"这使得submit\",{\"1\":{\"451\":1}}],[\"这使得加载和存储操作看上去可能是在乱序执行\",{\"1\":{\"319\":1}}],[\"这使得字符流在处理文本数据时更方便和高效\",{\"1\":{\"237\":1}}],[\"这提高了类的独立性和可重用性\",{\"1\":{\"309\":1}}],[\"这也是在\",{\"1\":{\"243\":1}}],[\"这取决于不同的加载需求和加载策略\",{\"1\":{\"233\":1}}],[\"这里我们将order\",{\"1\":{\"599\":1}}],[\"这里挂载了mysql的data\",{\"1\":{\"598\":1}}],[\"这里暴露了8848端口\",{\"1\":{\"598\":1}}],[\"这里异常的抛出条件是检测到\",{\"1\":{\"520\":1}}],[\"这里的\",{\"1\":{\"578\":1,\"585\":1}}],[\"这里的mysql就是repository\",{\"1\":{\"571\":1}}],[\"这里的threadlocalhashcode计算有点东西\",{\"1\":{\"332\":1}}],[\"这里的不可变指的是变量的引用不可变\",{\"1\":{\"302\":1}}],[\"这里可能会涉及多层递归\",{\"1\":{\"307\":1}}],[\"这里可以根据实际需求加载类的字节码\",{\"1\":{\"220\":1}}],[\"这里简化为返回一个固定的字节数组\",{\"1\":{\"220\":1}}],[\"这允许不同的jvm实现有自己的优化和设计\",{\"1\":{\"195\":1}}],[\"这减少了堆内存分配和垃圾收集的开销\",{\"1\":{\"173\":1}}],[\"这减少了gc的压力\",{\"1\":{\"164\":1}}],[\"这增加了维护和管理的复杂性\",{\"1\":{\"147\":1}}],[\"这促使了g1垃圾收集器的引入\",{\"1\":{\"146\":1}}],[\"这与传统的分代垃圾收集器不同\",{\"1\":{\"141\":1}}],[\"这一机制保证了java核心类库的安全性和稳定性\",{\"1\":{\"205\":1}}],[\"这一机制的好处是确保了核心java类库的安全性和一致性\",{\"1\":{\"203\":1}}],[\"这一步可以通过各种方式实现\",{\"1\":{\"192\":1}}],[\"这一过程包括以下三个主要步骤\",{\"1\":{\"191\":1}}],[\"这一阶段类已经完全准备好\",{\"1\":{\"189\":1}}],[\"这一阶段检查字节码的正确性\",{\"1\":{\"185\":1}}],[\"这一阶段就是为了重新标记这些对象\",{\"1\":{\"139\":1}}],[\"这一阶段需要再次暂停所有应用线程\",{\"1\":{\"139\":1}}],[\"这一阶段会暂停所有应用线程\",{\"1\":{\"139\":1}}],[\"这一变化有多方面的原因和好处\",{\"1\":{\"111\":1}}],[\"这时候会交换两人的数据\",{\"1\":{\"363\":1}}],[\"这时候要结合gc原理和jvm参数设置\",{\"1\":{\"88\":1}}],[\"这时会触发full\",{\"1\":{\"135\":1}}],[\"这是空心线圈有别于带铁心的电流互感器的一个显著特征\",{\"1\":{\"635\":1}}],[\"这是对\",{\"1\":{\"541\":1}}],[\"这是线程池的最终状态\",{\"1\":{\"473\":1}}],[\"这是线程池的初始状态\",{\"1\":{\"469\":1}}],[\"这是tomcat的共享类加载器\",{\"1\":{\"234\":1}}],[\"这是java的规定\",{\"1\":{\"305\":1}}],[\"这是java虚拟机内置的类加载器\",{\"1\":{\"234\":1}}],[\"这是java垃圾回收器实际使用的方法\",{\"1\":{\"126\":1}}],[\"这是应用程序的主要操作阶段\",{\"1\":{\"189\":1}}],[\"这是垃圾收集的核心操作\",{\"1\":{\"142\":1}}],[\"这是最早的收集器之一\",{\"1\":{\"137\":1}}],[\"这是一个中规中矩的案例\",{\"1\":{\"84\":1}}],[\"这种查找\",{\"1\":{\"515\":1}}],[\"这种锁被称之为重量级锁\",{\"1\":{\"491\":1}}],[\"这种任务可以返回结果\",{\"1\":{\"451\":1}}],[\"这种任务不返回结果\",{\"1\":{\"451\":1}}],[\"这种字节码必须再经过jvm\",{\"1\":{\"250\":1}}],[\"这种机制允许不同应用程序使用相同类名的不同版本\",{\"1\":{\"234\":1}}],[\"这种机制与双亲委派机制有所不同\",{\"1\":{\"218\":1}}],[\"这种灵活的扩展机制使得java系统可以轻松地进行功能扩展和模块化开发\",{\"1\":{\"213\":1}}],[\"这种统一的类加载规则使得java平台的类加载行为更加可预测\",{\"1\":{\"212\":1}}],[\"这种优化可以减少堆内存的分配和垃圾收集的压力\",{\"1\":{\"169\":1}}],[\"这种情况称为可重入锁\",{\"1\":{\"489\":1}}],[\"这种情况通常发生在自定义类加载器已经获取了类的字节码\",{\"1\":{\"233\":1}}],[\"这种情况通常发生在程序需要的内存超过了系统实际可用内存的情况下\",{\"1\":{\"123\":1}}],[\"这种情况下\",{\"1\":{\"219\":1}}],[\"这种情况被称为并发模式失效\",{\"1\":{\"147\":1}}],[\"这种情况也会触发minor\",{\"1\":{\"134\":1}}],[\"这种算法可以减少垃圾回收的停顿时间\",{\"1\":{\"131\":1}}],[\"这种方法通过给对象添加一个引用计数器来跟踪对象的引用数量\",{\"1\":{\"126\":1}}],[\"这种方式使得参数的修改更加便捷\",{\"1\":{\"475\":1}}],[\"这种方式不仅实现简单\",{\"1\":{\"309\":1}}],[\"这种方式可以通过反射机制来实现\",{\"1\":{\"475\":1}}],[\"这种方式可以通过futuretask获取任务执行的返回值\",{\"1\":{\"341\":1}}],[\"这种方式可以在一定程度上实现自定义的类加载逻辑\",{\"1\":{\"220\":1}}],[\"这种方式可以节省大量的执行成本\",{\"1\":{\"122\":1}}],[\"这种方式的优势在于速度更快\",{\"1\":{\"122\":1}}],[\"这种方式的优势在于稳定性\",{\"1\":{\"122\":1}}],[\"这种方式称为\",{\"1\":{\"118\":1}}],[\"这种分配方式称为\",{\"1\":{\"118\":1}}],[\"这样打包好的应用包中\",{\"1\":{\"560\":1}}],[\"这样使得哈希值的分布更加均匀\",{\"1\":{\"534\":1}}],[\"这样的平台称为docker\",{\"1\":{\"566\":1}}],[\"这样的设计增加了哈希值的随机性\",{\"1\":{\"533\":1}}],[\"这样的局部变量的值确实存储在java栈中\",{\"1\":{\"106\":1}}],[\"这样线性化后就不存在环路了\",{\"1\":{\"512\":1}}],[\"这样不可抢占这个条件就破坏掉了\",{\"1\":{\"512\":1}}],[\"这样即使发生断电\",{\"1\":{\"478\":1}}],[\"这样设计的原因\",{\"1\":{\"267\":1}}],[\"这样就实现了电压并列功能\",{\"1\":{\"641\":1}}],[\"这样就能访问到nginx了\",{\"1\":{\"578\":1}}],[\"这样就可以运行任意的ubuntu应用了\",{\"1\":{\"563\":1}}],[\"这样就保证了同一时间只有一个线程能够访问该对象的同步代码块或同步方法\",{\"1\":{\"485\":1}}],[\"这样就允许了父类加载器向子类加载器发出加载请求\",{\"1\":{\"223\":1}}],[\"这样就绕过了双亲委派机制的默认规则\",{\"1\":{\"215\":1}}],[\"这样可以更轻松地理解和调优查询\",{\"1\":{\"655\":1}}],[\"这样可以提高序列化和反序列化的效率\",{\"1\":{\"518\":1}}],[\"这样可以减少对耗时\",{\"1\":{\"479\":1}}],[\"这样可以利用多个线程同时执行任务\",{\"1\":{\"479\":1}}],[\"这样可以防止用户通过自定义类库篡改核心类库\",{\"1\":{\"211\":1}}],[\"这样可以避免线程被长时间阻塞\",{\"1\":{\"479\":1}}],[\"这样可以避免阻塞线程池中的其他任务\",{\"1\":{\"479\":1}}],[\"这样可以避免同一个类被多个类加载器加载导致的类型冲突\",{\"1\":{\"209\":1}}],[\"这样可以避免使用锁\",{\"1\":{\"120\":1}}],[\"这样可以避免了多线程情况下的锁竞争\",{\"1\":{\"119\":1}}],[\"这样做可能会导致调用线程的性能下降\",{\"1\":{\"449\":1}}],[\"这样做可能会导致类加载的混乱和冲突\",{\"1\":{\"214\":1}}],[\"这样做可以减少链表或红黑树的重新排序次数\",{\"1\":{\"543\":1}}],[\"这样做可以减少线程间因为堆内存分配而发生的竞争\",{\"1\":{\"120\":1}}],[\"这样做可以保持类加载的一致性和稳定性\",{\"1\":{\"233\":1}}],[\"这样做的目的是简化内存管理和优化垃圾收集\",{\"1\":{\"141\":1}}],[\"这样\",{\"1\":{\"132\":1,\"234\":1,\"454\":1,\"582\":1}}],[\"这样双管齐下\",{\"1\":{\"84\":1}}],[\"这个查询将对\",{\"1\":{\"614\":1}}],[\"这个查询将返回所有唯一的\",{\"1\":{\"611\":1,\"612\":1}}],[\"这个查询将返回表\",{\"1\":{\"608\":1,\"609\":1}}],[\"这个文件包是只读的\",{\"1\":{\"565\":1}}],[\"这个问题在jdk1\",{\"1\":{\"545\":2}}],[\"这个\",{\"1\":{\"540\":1}}],[\"这个异常只建议用于检测并发修改的bug\",{\"1\":{\"520\":1}}],[\"这个接口只是用来标识是否支持随机访问\",{\"1\":{\"515\":1}}],[\"这个接口是服务的契约\",{\"1\":{\"252\":1}}],[\"这个条件\",{\"1\":{\"512\":3,\"520\":1}}],[\"这个方向基本上是不可逆的\",{\"1\":{\"492\":1}}],[\"这个方法返回一个线程安全的map对象\",{\"1\":{\"546\":1}}],[\"这个方法返回的对象可能是空\",{\"1\":{\"243\":1}}],[\"这个方法相比\",{\"1\":{\"344\":1}}],[\"这个方法在\",{\"1\":{\"303\":1}}],[\"这个方法的存在使得用户编写自己的类加载逻辑时更容易继承并重写这个方法\",{\"1\":{\"222\":1}}],[\"这个标识指明了该方法是一个同步方法\",{\"1\":{\"484\":1}}],[\"这个简单的线程池实现了基本的功能\",{\"1\":{\"477\":1}}],[\"这个流程保证了线程资源的高效利用和任务的有效调度\",{\"1\":{\"447\":1}}],[\"这个结构被附带在线程上\",{\"1\":{\"351\":1}}],[\"这个数字\",{\"1\":{\"332\":1}}],[\"这个值很特殊\",{\"1\":{\"332\":1}}],[\"这个类加载器应该具有动态加载和卸载类的能力\",{\"1\":{\"226\":1}}],[\"这个对象将作为程序访问方法区中的类型数据的外部接口\",{\"1\":{\"196\":1}}],[\"这个对象提供了访问类元数据的接口\",{\"1\":{\"195\":1}}],[\"这个class对象将作为方法区中该类数据的访问入口\",{\"1\":{\"194\":1}}],[\"这个过程也是递归的\",{\"1\":{\"480\":1}}],[\"这个过程是递归的\",{\"1\":{\"480\":1}}],[\"这个过程是自动管理的\",{\"1\":{\"190\":1}}],[\"这个过程确保类的元数据和结构信息可以被程序访问和使用\",{\"1\":{\"197\":1}}],[\"这个过程会导致显著的停顿时间\",{\"1\":{\"147\":1}}],[\"这个过程会产生大量的string对象\",{\"1\":{\"84\":1}}],[\"这个优化依赖于逃逸分析技术\",{\"1\":{\"175\":1}}],[\"这个阶段是类加载的最后一步\",{\"1\":{\"188\":1}}],[\"这个阶段不会执行任何初始化代码\",{\"1\":{\"186\":1}}],[\"这个阶段不会造成显著的停顿\",{\"1\":{\"139\":1}}],[\"这个阶段不需要暂停应用线程\",{\"1\":{\"142\":1}}],[\"这个阶段再次与应用线程并发运行\",{\"1\":{\"139\":1}}],[\"这个阶段也会标记由于并发标记阶段遗漏的对象\",{\"1\":{\"139\":1}}],[\"这个阶段时间较短\",{\"1\":{\"139\":1}}],[\"这个暂停的目的是为了保证对象引用更新的正确性\",{\"1\":{\"138\":1}}],[\"这个机制避免了频繁将存活对象从新生代复制到survivor区\",{\"1\":{\"136\":1}}],[\"这个内存布局在不同的jvm实现中可能会有所不同\",{\"1\":{\"121\":1}}],[\"这个区域在堆内存中是连续的\",{\"1\":{\"119\":1}}],[\"这个局部变量本身存储在java栈中\",{\"1\":{\"110\":1}}],[\"这个局部变量\",{\"1\":{\"108\":1}}],[\"这个字面值\",{\"1\":{\"108\":1}}],[\"这个常量的存储位置和引用机制\",{\"1\":{\"106\":1}}],[\"这个示例中提到的\",{\"1\":{\"106\":1}}],[\"这个计数器的值是未定义的\",{\"1\":{\"92\":1}}],[\"这将指出在哪个方法和代码位置发生了问题\",{\"1\":{\"90\":1}}],[\"这些信息也是调度掌握智能变电站运行情况的重要依据和手段\",{\"1\":{\"652\":1}}],[\"这些函数库是对内核指令的封装\",{\"1\":{\"561\":1}}],[\"这些服务部署时所需要的函数库\",{\"1\":{\"559\":1}}],[\"这些方法都是原子性的\",{\"1\":{\"510\":1}}],[\"这些子问题相互独立且与原问题性质相同\",{\"1\":{\"480\":1}}],[\"这些状态有助于管理线程池的生命周期和行为\",{\"1\":{\"468\":1}}],[\"这些不同类型的工作队列具有不同的特性和适用场景\",{\"1\":{\"450\":1}}],[\"这些参数通常包括核心线程数\",{\"1\":{\"442\":1}}],[\"这些参数可以根据应用场景的需求进行调整和配置\",{\"1\":{\"448\":1}}],[\"这些参数可以根据具体的应用需求进行调整\",{\"1\":{\"76\":1}}],[\"这些参数可以在启动jvm时配置\",{\"1\":{\"166\":1}}],[\"这些任务不需要立即完成\",{\"1\":{\"434\":1}}],[\"这些短生命周期的对象会加大垃圾回收的压力\",{\"1\":{\"418\":1}}],[\"这些同步操作会导致锁的竞争和开销\",{\"1\":{\"416\":1}}],[\"这些结构用于线程调度和管理\",{\"1\":{\"413\":1}}],[\"这些线程会一直相互等待而无法继续运行下去\",{\"1\":{\"512\":1}}],[\"这些线程在处理完一个任务后不会被销毁\",{\"1\":{\"403\":1}}],[\"这些线程必须调用await\",{\"1\":{\"356\":1}}],[\"这些操作就可能被编译器和处理器重排序\",{\"1\":{\"321\":1}}],[\"这些操作可能是\",{\"1\":{\"244\":1}}],[\"这些硬件组件对应着jmm中的工作内存\",{\"1\":{\"315\":1}}],[\"这些破坏都是为了解决特定的问题或实现特定的功能\",{\"1\":{\"224\":1}}],[\"这些实现无法放在核心包中\",{\"1\":{\"223\":1}}],[\"这些类都提供了一些原子操作方法\",{\"1\":{\"510\":1}}],[\"这些类通常是应用程序自定义的类\",{\"1\":{\"201\":1}}],[\"这些类通常位于<java\",{\"1\":{\"200\":1}}],[\"这些类库通常位于<java\",{\"1\":{\"199\":1}}],[\"这些数据结构包括类的元数据\",{\"1\":{\"195\":1}}],[\"这些局部变量会在栈上分配\",{\"1\":{\"170\":1}}],[\"这些优化技术使得java在保持易用性的同时\",{\"1\":{\"168\":1}}],[\"这些安全点通常出现在循环的末尾\",{\"1\":{\"138\":1}}],[\"这些情况都反映了java应用程序在运行过程中内存管理的一些具体场景\",{\"1\":{\"135\":1}}],[\"这些对象就会被晋升到老年代\",{\"1\":{\"134\":1}}],[\"这些对象是垃圾回收器进行可达性分析的起点\",{\"1\":{\"127\":1}}],[\"这些术语都与java堆的垃圾回收相关\",{\"1\":{\"133\":1}}],[\"这些填充字节的大小取决于jvm实现和操作系统的要求\",{\"1\":{\"121\":1}}],[\"这些成员变量按其声明顺序存放在内存中\",{\"1\":{\"121\":1}}],[\"这些改进使得jvm在性能\",{\"1\":{\"116\":1}}],[\"这些常量在类加载时被加载到内存中\",{\"1\":{\"107\":1}}],[\"这些变化主要是为了改进内存管理\",{\"1\":{\"101\":1}}],[\"这些可视化工具可以大大简化性能监控和故障处理的工作\",{\"1\":{\"70\":1}}],[\"这些工具提供了图形界面\",{\"1\":{\"57\":1}}],[\"状态转换图\",{\"0\":{\"474\":1}}],[\"状态下完成终止操作后\",{\"1\":{\"473\":1}}],[\"状态下完成了所有任务\",{\"1\":{\"472\":1}}],[\"状态下中断了所有任务后\",{\"1\":{\"472\":1}}],[\"状态\",{\"1\":{\"56\":1,\"345\":1,\"470\":1,\"471\":1,\"472\":1,\"473\":1}}],[\"状态图\",{\"0\":{\"31\":1}}],[\"执行sql语句并管理缓存\",{\"1\":{\"656\":1}}],[\"执行表的连接操作\",{\"1\":{\"616\":1}}],[\"执行一个命令\",{\"1\":{\"579\":1}}],[\"执行扩容\",{\"1\":{\"549\":1}}],[\"执行同步代码\",{\"1\":{\"493\":1}}],[\"执行完一个\",{\"1\":{\"459\":1}}],[\"执行完任务的线程\",{\"1\":{\"458\":1}}],[\"执行完任务后\",{\"1\":{\"454\":1}}],[\"执行完毕后\",{\"1\":{\"282\":1}}],[\"执行定时任务\",{\"1\":{\"440\":1}}],[\"执行异步任务\",{\"1\":{\"398\":1}}],[\"执行结果\",{\"1\":{\"282\":3}}],[\"执行顺序如下\",{\"1\":{\"618\":1}}],[\"执行顺序\",{\"0\":{\"616\":1},\"1\":{\"282\":1}}],[\"执行java字节码\",{\"1\":{\"181\":1}}],[\"执行\",{\"1\":{\"180\":1,\"249\":1,\"303\":1,\"407\":1,\"409\":1,\"615\":1}}],[\"执行引擎\",{\"1\":{\"179\":1}}],[\"执行代码\",{\"1\":{\"178\":1}}],[\"执行对象的构造函数\",{\"1\":{\"117\":1}}],[\"执行构造函数\",{\"1\":{\"117\":1}}],[\"执行ognl表达式\",{\"1\":{\"56\":1}}],[\"执行各种诊断命令\",{\"1\":{\"55\":1}}],[\"耗时等\",{\"1\":{\"56\":1}}],[\"类似的还有阿里云镜像服务\",{\"1\":{\"568\":1}}],[\"类似于top\",{\"1\":{\"54\":1}}],[\"类加锁\",{\"1\":{\"482\":1}}],[\"类加载的过程是java虚拟机\",{\"1\":{\"191\":1}}],[\"类加载的过程知道吗\",{\"0\":{\"191\":1}}],[\"类加载器不再是双亲委派模型推荐的树状结构\",{\"1\":{\"224\":1}}],[\"类加载器的概念已经存在\",{\"1\":{\"222\":1}}],[\"类加载器的层次结构\",{\"0\":{\"203\":1}}],[\"类加载器在尝试加载一个类时\",{\"1\":{\"205\":1}}],[\"类加载器按照双亲委派模型\",{\"1\":{\"203\":1}}],[\"类加载器之间存在父子关系\",{\"1\":{\"203\":1}}],[\"类加载器有哪些\",{\"0\":{\"198\":1}}],[\"类加载器子系统\",{\"1\":{\"179\":1}}],[\"类加载器会将类文件的常量池中的字面值\",{\"1\":{\"108\":1}}],[\"类加载过程包括加载\",{\"1\":{\"117\":1}}],[\"类加载\",{\"1\":{\"117\":1}}],[\"类加载等信\",{\"1\":{\"55\":1}}],[\"类自身的构造函数创建两个新的任务对象\",{\"1\":{\"480\":1}}],[\"类中\",{\"1\":{\"480\":2}}],[\"类中的\",{\"1\":{\"358\":1}}],[\"类继承了\",{\"1\":{\"480\":1}}],[\"类定义了五种线程池状态\",{\"1\":{\"468\":1}}],[\"类变量\",{\"1\":{\"300\":2}}],[\"类的抽象方法\",{\"1\":{\"480\":1}}],[\"类的常见方法\",{\"0\":{\"274\":1}}],[\"类的字节码数据\",{\"1\":{\"220\":1}}],[\"类名\",{\"1\":{\"268\":1,\"301\":1}}],[\"类可以继承吗\",{\"1\":{\"267\":1}}],[\"类库\",{\"1\":{\"247\":1}}],[\"类型的成员变量\",{\"1\":{\"496\":1}}],[\"类型\",{\"1\":{\"244\":1,\"262\":1,\"286\":2}}],[\"类型数据妥善安置在方法区之后\",{\"1\":{\"196\":1}}],[\"类\",{\"1\":{\"240\":1,\"258\":1,\"362\":2,\"480\":1,\"482\":1,\"520\":1}}],[\"类元数据存储在本地内存中\",{\"1\":{\"115\":1}}],[\"类和接口的符号引用\",{\"1\":{\"104\":1,\"105\":1}}],[\"类图\",{\"0\":{\"30\":1}}],[\"用指令来说明要执行什么操作来构建镜像\",{\"1\":{\"590\":1}}],[\"用vector代替arraylist\",{\"1\":{\"521\":1}}],[\"用\",{\"1\":{\"343\":1,\"356\":1}}],[\"用来保存objectwaiter\",{\"1\":{\"485\":1}}],[\"用来做用户信息上下文的存储\",{\"1\":{\"327\":1}}],[\"用来表示对象的唯一标识\",{\"1\":{\"305\":1}}],[\"用this来区分\",{\"1\":{\"298\":1}}],[\"用最有效率的方法计算2乘以8\",{\"0\":{\"264\":1}}],[\"用尽时才会竞争堆内存\",{\"1\":{\"120\":1}}],[\"用元空间\",{\"1\":{\"111\":1}}],[\"用途\",{\"1\":{\"105\":1}}],[\"用jprofiler\",{\"1\":{\"84\":1}}],[\"用户线程\",{\"1\":{\"350\":1}}],[\"用户程序的状态是可预期的\",{\"1\":{\"138\":1}}],[\"用户体验分析\",{\"1\":{\"70\":1}}],[\"用户体验分析等\",{\"1\":{\"65\":1}}],[\"用户体验等\",{\"1\":{\"67\":1}}],[\"用户旅程图\",{\"0\":{\"33\":1}}],[\"用于构建不同类型的\",{\"1\":{\"656\":1}}],[\"用于构建动态\",{\"1\":{\"656\":1}}],[\"用于编程式地构建\",{\"1\":{\"656\":1}}],[\"用于将java对象的属性值绑定到sql语句的参数位置\",{\"1\":{\"656\":1}}],[\"用于将两个独立的\",{\"1\":{\"374\":1}}],[\"用于对mybatis核心功能进行增强\",{\"1\":{\"656\":2}}],[\"用于定义sql语句\",{\"1\":{\"656\":1}}],[\"用于定义sql映射\",{\"1\":{\"656\":1}}],[\"用于创建sqlsession实例\",{\"1\":{\"656\":1}}],[\"用于创建sqlsessionfactory\",{\"1\":{\"656\":1}}],[\"用于创建sqlsessionfactory实例\",{\"1\":{\"656\":1}}],[\"用于创建新线程的工厂\",{\"1\":{\"448\":1}}],[\"用于操作计算机硬件\",{\"1\":{\"561\":1}}],[\"用于实现多线程环境下的同步操作\",{\"1\":{\"502\":1}}],[\"用于实现热部署\",{\"1\":{\"56\":1}}],[\"用于计算斐波那契数列的值\",{\"1\":{\"480\":1}}],[\"用于并发执行大量短期的小任务\",{\"1\":{\"458\":1}}],[\"用于指定keepalivetime的时间单位\",{\"1\":{\"448\":1}}],[\"用于获取任务的执行结果\",{\"1\":{\"443\":1}}],[\"用于其堆栈空间和线程本地存储\",{\"1\":{\"412\":1}}],[\"用于保存等待执行的任务\",{\"1\":{\"408\":1}}],[\"用于为异步操作设定超时\",{\"1\":{\"380\":1}}],[\"用于等待所有给定的\",{\"1\":{\"375\":1}}],[\"用于在多线程环境下保证共享变量的操作是原子性的\",{\"1\":{\"510\":1}}],[\"用于在超时时返回默认值\",{\"1\":{\"381\":1}}],[\"用于在异步任务完成或发生异常时对结果进行处理\",{\"1\":{\"378\":1}}],[\"用于在异步任务发生异常时提供一个默认值\",{\"1\":{\"377\":1}}],[\"用于在一个\",{\"1\":{\"373\":1}}],[\"用于在任务完成后执行一个没有返回值的操作\",{\"1\":{\"371\":1}}],[\"用于在任务完成后\",{\"1\":{\"369\":1,\"370\":1}}],[\"用于在编译时期提供类型安全的参数化类型\",{\"1\":{\"284\":1}}],[\"用于执行sql语句并进行参数绑定\",{\"1\":{\"656\":1}}],[\"用于执行sql语句和管理事务\",{\"1\":{\"656\":1}}],[\"用于执行fork\",{\"1\":{\"480\":1}}],[\"用于执行没有返回值的异步任务\",{\"1\":{\"367\":1}}],[\"用于执行有返回值的异步任务\",{\"1\":{\"367\":1}}],[\"用于处理异步任务的结果和执行流程\",{\"1\":{\"365\":1}}],[\"用于描述多线程环境下的内存访问行为\",{\"1\":{\"316\":1}}],[\"用于修饰变量\",{\"1\":{\"303\":1}}],[\"用于标识类可以被序列化\",{\"1\":{\"276\":1}}],[\"用于表示一个值可能存在或不存在\",{\"1\":{\"240\":1}}],[\"用于表示和访问方法区中的类信息\",{\"1\":{\"195\":1}}],[\"用于加载tomcat本身的类库\",{\"1\":{\"234\":1}}],[\"用于加载特定线程上下文中所需的类\",{\"1\":{\"223\":1}}],[\"用于加载特定来源或特定方式的类\",{\"1\":{\"202\":1}}],[\"用于初始化静态变量和执行静态代码块\",{\"1\":{\"188\":1}}],[\"用于调试\",{\"1\":{\"174\":1}}],[\"用于确定对象的作用域\",{\"1\":{\"164\":1}}],[\"用于记录元素的插入顺序或访问顺序\",{\"1\":{\"551\":1}}],[\"用于记录对象内的偏移量上存储的数据类型\",{\"1\":{\"138\":1}}],[\"用于记录当前线程执行的字节码行号\",{\"1\":{\"94\":1}}],[\"用于存放类的元数据\",{\"1\":{\"130\":1}}],[\"用于存放新创建的对象\",{\"1\":{\"130\":1,\"132\":1}}],[\"用于存储等待执行的任务的队列\",{\"1\":{\"448\":1}}],[\"用于存储元素\",{\"1\":{\"400\":1}}],[\"用于存储线程局部变量的值\",{\"1\":{\"331\":1}}],[\"用于存储类加载后所需的各种常量和符号引用\",{\"1\":{\"105\":1}}],[\"用于存储类元数据\",{\"1\":{\"101\":1}}],[\"用于存储类结构\",{\"1\":{\"94\":1}}],[\"用于存储局部变量\",{\"1\":{\"94\":1}}],[\"用于存储对象实例\",{\"1\":{\"94\":1}}],[\"用于线程独立地分配对象\",{\"1\":{\"119\":1}}],[\"用于替代永久代\",{\"1\":{\"96\":1}}],[\"用于支持native方法的执行\",{\"1\":{\"94\":1}}],[\"用于监控和优化应用性能\",{\"1\":{\"65\":1}}],[\"用于动态修改变量值等\",{\"1\":{\"56\":1}}],[\"用于查看进程使用的文件和网络资源\",{\"1\":{\"54\":1}}],[\"用于网络故障排查和分析\",{\"1\":{\"54\":1}}],[\"网易云镜像服务\",{\"1\":{\"566\":1}}],[\"网络方式的智能变电站网络示意图\",{\"1\":{\"637\":1}}],[\"网络方式的智能变电站网络中\",{\"1\":{\"637\":1}}],[\"网络独立性\",{\"1\":{\"636\":1}}],[\"网络监测\",{\"1\":{\"630\":1}}],[\"网络结构示意图\",{\"1\":{\"627\":1}}],[\"网络结构模式有两种\",{\"1\":{\"627\":1}}],[\"网络结构模式有几种\",{\"0\":{\"627\":1}}],[\"网络采样跳闸模式和\",{\"1\":{\"627\":1}}],[\"网络\",{\"1\":{\"192\":1}}],[\"网络连接等资源后\",{\"1\":{\"125\":1}}],[\"网络等指标\",{\"1\":{\"54\":1}}],[\"网关等\",{\"1\":{\"54\":1}}],[\"等待队列中除第一个线程以外的所有线程都会阻塞\",{\"1\":{\"498\":1}}],[\"等待队列状态改变的线程会进入等待状态\",{\"1\":{\"400\":1}}],[\"等待次数达到阈值仍未获取到锁\",{\"1\":{\"494\":1}}],[\"等待被唤醒\",{\"1\":{\"485\":1}}],[\"等待已提交任务完成或立即终止\",{\"1\":{\"447\":1}}],[\"等待所有任务完成\",{\"1\":{\"383\":1,\"385\":1}}],[\"等待所有子线程运行结束\",{\"1\":{\"353\":1}}],[\"等待其他线程\",{\"1\":{\"355\":13}}],[\"等待latch降为0\",{\"1\":{\"353\":2}}],[\"等待主线程完成\",{\"1\":{\"353\":1}}],[\"等待子线程完成\",{\"1\":{\"353\":1}}],[\"等待\",{\"1\":{\"351\":1,\"549\":1}}],[\"等待状态\",{\"1\":{\"345\":1}}],[\"等价于通过\",{\"1\":{\"304\":1}}],[\"等等框架中都大量使用了反射机制\",{\"1\":{\"255\":1}}],[\"等命令触发\",{\"1\":{\"135\":1}}],[\"等方法来确保资源的释放\",{\"1\":{\"129\":1}}],[\"等原子性操作来确保对共享数据的原子性访问\",{\"1\":{\"120\":1}}],[\"等后端响应之后按钮才可以进行点击\",{\"1\":{\"84\":1}}],[\"等\",{\"1\":{\"54\":1,\"199\":1,\"305\":1,\"400\":1,\"442\":1,\"490\":1,\"510\":1,\"636\":1,\"656\":2}}],[\"息\",{\"1\":{\"54\":1,\"55\":1}}],[\"监视器锁规则\",{\"1\":{\"320\":1}}],[\"监视器的实现\",{\"1\":{\"232\":1}}],[\"监视器应该能够检测到\",{\"1\":{\"227\":1}}],[\"监视目标类文件的变化\",{\"1\":{\"227\":1}}],[\"监视类文件的变化\",{\"0\":{\"227\":1}}],[\"监听器和回调\",{\"1\":{\"125\":1}}],[\"监听端口等信\",{\"1\":{\"54\":1}}],[\"监控机制可以帮助及时发现线程池的问题\",{\"1\":{\"476\":1}}],[\"监控机制\",{\"1\":{\"476\":1}}],[\"监控和分析gc性能\",{\"1\":{\"160\":1}}],[\"监控和分析gc日志\",{\"1\":{\"87\":1}}],[\"监控和分析java应用的性能和运行时行为\",{\"1\":{\"60\":1}}],[\"监控和分析jvm性能\",{\"1\":{\"58\":1}}],[\"监控和优化\",{\"0\":{\"83\":1}}],[\"监控和诊断java应用的性能问题\",{\"1\":{\"68\":1}}],[\"监控jvm性能和资源使用情况\",{\"1\":{\"59\":1}}],[\"监控java虚拟机的运行情况\",{\"1\":{\"55\":1}}],[\"监控方法的调用情况\",{\"1\":{\"56\":1}}],[\"监控网络连接和网络接口的状态\",{\"1\":{\"54\":1}}],[\"监控系统的磁盘i\",{\"1\":{\"54\":1}}],[\"监控系统的虚拟内存\",{\"1\":{\"54\":1}}],[\"标度转换等工作\",{\"1\":{\"636\":1}}],[\"标志是否等于预期标志\",{\"1\":{\"505\":1}}],[\"标量替换通过将对象的成员变量分解为局部变量并在栈上分配\",{\"1\":{\"175\":1}}],[\"标量替换效果\",{\"0\":{\"173\":1}}],[\"标量替换的工作原理\",{\"0\":{\"170\":1}}],[\"标量替换\",{\"1\":{\"164\":1,\"169\":1}}],[\"标量替换可以将一个对象拆分为多个独立的标量\",{\"1\":{\"87\":1}}],[\"标记不支持随机访问\",{\"1\":{\"515\":1}}],[\"标记字段\",{\"1\":{\"490\":1}}],[\"标记字段记录着锁的状态\",{\"1\":{\"490\":1}}],[\"标记符来实现同步\",{\"1\":{\"484\":1}}],[\"标记自身也可以设置一些值\",{\"1\":{\"289\":1}}],[\"标记从根对象直接可达的对象\",{\"1\":{\"142\":1}}],[\"标记所有可达对象\",{\"1\":{\"142\":1}}],[\"标记所有可达的对象\",{\"1\":{\"139\":1}}],[\"标记所有存活的对象\",{\"1\":{\"131\":1}}],[\"标记所有能够被访问到的对象\",{\"1\":{\"131\":1}}],[\"标记阶段和清除阶段\",{\"1\":{\"131\":1}}],[\"标记\",{\"1\":{\"131\":5}}],[\"标\",{\"1\":{\"54\":1}}],[\"实体类属性名和表中字段名不一样\",{\"0\":{\"764\":1}}],[\"实体关系图\",{\"0\":{\"32\":1}}],[\"实时监测电网的运行参数并进行调节\",{\"1\":{\"630\":1}}],[\"实时查看和管理jmx\",{\"1\":{\"59\":1}}],[\"实时查看系统的整体性能情况\",{\"1\":{\"54\":1}}],[\"实际上就是相当于每个segment都是一个hashmap\",{\"1\":{\"548\":1}}],[\"实际上是存储在栈中的\",{\"1\":{\"108\":1}}],[\"实际直接使用两个流\",{\"1\":{\"519\":1}}],[\"实际就是在暗示线程调度器当前线程请求让出自己的cpu\",{\"1\":{\"344\":1}}],[\"实际是操作自己本地内存里面的变量\",{\"1\":{\"326\":1}}],[\"实际的线程工作模型如下图所示\",{\"1\":{\"315\":1}}],[\"实例编号和数据类名建立对象名的命名规则\",{\"1\":{\"636\":1}}],[\"实例⽅法\",{\"1\":{\"301\":1}}],[\"实例方法呢\",{\"0\":{\"301\":1}}],[\"实例变量即对象变量\",{\"1\":{\"300\":1}}],[\"实例变量存储在堆内存中\",{\"1\":{\"300\":1}}],[\"实例变量是每个对象独有的\",{\"1\":{\"300\":1}}],[\"实例变量\",{\"1\":{\"300\":1,\"301\":1}}],[\"实例化对应的服务提供者对象\",{\"1\":{\"252\":1}}],[\"实例的更新\",{\"1\":{\"232\":1}}],[\"实例数据存储了对象的成员变量值\",{\"1\":{\"121\":1}}],[\"实例数据\",{\"1\":{\"121\":2}}],[\"实现面向全站设备的监视\",{\"1\":{\"628\":1}}],[\"实现站内一次\",{\"1\":{\"624\":1}}],[\"实现与相邻变电站\",{\"1\":{\"623\":1}}],[\"实现标准化\",{\"1\":{\"622\":1}}],[\"实现电网信息的高度集成和共享\",{\"1\":{\"622\":1}}],[\"实现电网的可靠\",{\"1\":{\"621\":1}}],[\"实现资源的优化配置\",{\"1\":{\"622\":1}}],[\"实现思路\",{\"1\":{\"597\":1}}],[\"实现思路如下\",{\"1\":{\"587\":1,\"593\":1}}],[\"实现各种功能\",{\"1\":{\"561\":1}}],[\"实现的\",{\"1\":{\"554\":1}}],[\"实现的原理是int\",{\"1\":{\"272\":1}}],[\"实现arraylist线程安全有哪几种方法\",{\"0\":{\"521\":1}}],[\"实现i++原子操作\",{\"1\":{\"509\":1}}],[\"实现重复利用\",{\"1\":{\"356\":1}}],[\"实现一个线程修改一个对象的值\",{\"1\":{\"351\":1}}],[\"实现一个监视器\",{\"1\":{\"227\":1}}],[\"实现callable接口\",{\"1\":{\"341\":2}}],[\"实现runnable接口\",{\"1\":{\"341\":1}}],[\"实现类和实例不能调用静态方法\",{\"1\":{\"299\":1}}],[\"实现接⼝并覆盖接⼝中同⼀⽅法\",{\"1\":{\"295\":1}}],[\"实现数据的持久化和\",{\"1\":{\"276\":1}}],[\"实现serializable接口的类可以将对象转换为字节流进行传输和存储\",{\"1\":{\"276\":1}}],[\"实现服务接口\",{\"1\":{\"252\":1}}],[\"实现原理\",{\"1\":{\"248\":1}}],[\"实现了一次\",{\"1\":{\"624\":1}}],[\"实现了多线程环境下的线程安全\",{\"1\":{\"400\":1}}],[\"实现了服务接口的具体类\",{\"1\":{\"252\":1}}],[\"实现了类的隔离和资源的共享\",{\"1\":{\"234\":1}}],[\"实现了自己的加载逻辑\",{\"1\":{\"215\":1}}],[\"实现热部署功能需要考虑到多个方面\",{\"1\":{\"232\":1}}],[\"实现热部署功能涉及到动态加载和卸载类\",{\"1\":{\"225\":1}}],[\"实现自己的加载逻辑\",{\"1\":{\"215\":1}}],[\"实现和管理机制上的不同\",{\"1\":{\"105\":1}}],[\"实现\",{\"1\":{\"94\":1,\"103\":1,\"104\":1,\"223\":1,\"299\":1,\"341\":1,\"547\":2}}],[\"实施调优和测试\",{\"0\":{\"82\":1}}],[\"描述了服务提供者需要实现的接口或抽象类\",{\"1\":{\"252\":1}}],[\"描述\",{\"1\":{\"54\":1,\"55\":1,\"56\":1,\"184\":1,\"185\":1,\"186\":1,\"187\":1,\"188\":1,\"189\":1,\"190\":1,\"199\":1,\"200\":1,\"201\":1,\"202\":1}}],[\"称为镜像\",{\"1\":{\"565\":1}}],[\"称为\",{\"1\":{\"224\":1}}],[\"称为混合回收\",{\"1\":{\"141\":1}}],[\"称\",{\"1\":{\"54\":1,\"55\":1}}],[\"有何区别\",{\"0\":{\"686\":1}}],[\"有几种通信规约\",{\"0\":{\"637\":1}}],[\"有效地抑制了因直流偏置使积分值飞快增大的问题\",{\"1\":{\"634\":1}}],[\"有别于网络采集网络跳闸\",{\"1\":{\"629\":1}}],[\"有其它线程写入数据怎么办\",{\"0\":{\"523\":1}}],[\"有\",{\"1\":{\"493\":1}}],[\"有一块结构\",{\"1\":{\"490\":1}}],[\"有一个私有的成员变量\",{\"1\":{\"480\":1}}],[\"有的线程干活慢\",{\"1\":{\"480\":1}}],[\"有的线程干活块\",{\"1\":{\"480\":1}}],[\"有个调用特别耗时\",{\"0\":{\"479\":1}}],[\"有个方法引起了我的注意\",{\"1\":{\"84\":1}}],[\"有哪几种常见的线程池\",{\"0\":{\"455\":1}}],[\"有哪些优势和劣势\",{\"0\":{\"744\":1}}],[\"有哪些工具和技术是你常用的\",{\"0\":{\"735\":1}}],[\"有哪些常用的标签和元素\",{\"0\":{\"731\":1,\"751\":1}}],[\"有哪些常用的命令行性能监控和故障处理工具\",{\"0\":{\"53\":1}}],[\"有哪些常见的分页插件\",{\"0\":{\"690\":1}}],[\"有哪些方式可以调用存储过程\",{\"0\":{\"679\":1}}],[\"有哪些方式可以传递参数\",{\"0\":{\"663\":1}}],[\"有哪些配置选项\",{\"0\":{\"675\":1}}],[\"有哪些原因导致fgc\",{\"1\":{\"88\":1}}],[\"有界队列可以有效地控制线程池中任务的数量\",{\"1\":{\"450\":1}}],[\"有界队列有限制存储的任务数量\",{\"1\":{\"450\":1}}],[\"有界队列\",{\"1\":{\"450\":1}}],[\"有以下几个原因\",{\"1\":{\"410\":1}}],[\"有多种重载形式\",{\"1\":{\"359\":1}}],[\"有两个主要的子类\",{\"1\":{\"480\":1}}],[\"有两个常见的应用场景\",{\"1\":{\"353\":1}}],[\"有两个规则\",{\"1\":{\"320\":1}}],[\"有序性都应该怎么保证呢\",{\"0\":{\"318\":1}}],[\"有序性\",{\"0\":{\"486\":1},\"1\":{\"316\":2,\"318\":1}}],[\"有序性的理解\",{\"0\":{\"316\":1}}],[\"有序性和原子性\",{\"1\":{\"315\":1}}],[\"有可能调用\",{\"1\":{\"303\":1}}],[\"有可能在对象被回收时调用\",{\"1\":{\"129\":1}}],[\"有了标记之后\",{\"1\":{\"289\":1}}],[\"有了cms\",{\"0\":{\"146\":1}}],[\"有什么需要注意的地方\",{\"0\":{\"720\":1}}],[\"有什么用处\",{\"0\":{\"638\":1}}],[\"有什么优点\",{\"0\":{\"632\":1}}],[\"有什么优缺点\",{\"0\":{\"627\":1,\"633\":1}}],[\"有什么特点\",{\"0\":{\"630\":1,\"636\":1}}],[\"有什么办法能解决hashmap线程不安全的问题呢\",{\"0\":{\"546\":1}}],[\"有什么问题\",{\"0\":{\"503\":1}}],[\"有什么区别\",{\"0\":{\"247\":1,\"261\":1,\"299\":1,\"672\":1,\"759\":1}}],[\"有什么作用\",{\"0\":{\"129\":1}}],[\"有读或写事件时\",{\"1\":{\"238\":1}}],[\"有时候会重写\",{\"1\":{\"233\":3}}],[\"有时是重写defineclass方法\",{\"0\":{\"233\":1}}],[\"有时是重写findclass方法\",{\"0\":{\"233\":1}}],[\"有时是重写loadclass方法\",{\"0\":{\"233\":1}}],[\"有时可能会出现比预期更长的停顿\",{\"1\":{\"139\":1}}],[\"有些架构还有一个共享的二级缓存\",{\"1\":{\"315\":1}}],[\"有些情况下\",{\"1\":{\"162\":1}}],[\"有些图渲染不出来\",{\"1\":{\"27\":1}}],[\"有没有遇到过懒加载导致的性能问题\",{\"0\":{\"741\":1}}],[\"有没有遇到过文件过多或难以维护的情况\",{\"0\":{\"726\":1,\"746\":1}}],[\"有没有遇到过\",{\"0\":{\"721\":1}}],[\"有没有了解逃逸分析技术\",{\"0\":{\"162\":1}}],[\"有没有处理过oom问题\",{\"0\":{\"90\":1}}],[\"有没有处理过内存泄漏问题\",{\"0\":{\"89\":1}}],[\"有实际调优过吗\",{\"0\":{\"84\":1}}],[\"有做过jvm调优吗\",{\"0\":{\"77\":1}}],[\"渲染失败了\",{\"1\":{\"51\":1}}],[\"uv\",{\"1\":{\"649\":1}}],[\"update\",{\"1\":{\"656\":1}}],[\"up\",{\"1\":{\"597\":1,\"602\":1}}],[\"utf\",{\"1\":{\"579\":1}}],[\"util包下的集合类都是快速失败的\",{\"1\":{\"520\":1}}],[\"util包等\",{\"1\":{\"234\":1}}],[\"util\",{\"1\":{\"124\":2,\"199\":1,\"206\":1,\"244\":1,\"361\":1,\"383\":4,\"385\":4,\"390\":2,\"392\":4,\"405\":1,\"407\":3,\"409\":3,\"424\":2,\"432\":5,\"436\":2,\"440\":3,\"467\":1,\"477\":2,\"480\":1,\"520\":1}}],[\"ubuntu和centospringboot都是基于linux内核\",{\"1\":{\"561\":1}}],[\"ubuntu\",{\"1\":{\"561\":1,\"563\":1,\"592\":1}}],[\"u\",{\"1\":{\"511\":1,\"549\":2}}],[\"unpooleddatasource等\",{\"1\":{\"656\":1}}],[\"unpause\",{\"1\":{\"577\":1}}],[\"unpark\",{\"1\":{\"496\":1}}],[\"under\",{\"1\":{\"649\":1}}],[\"unbuffered\",{\"1\":{\"649\":1}}],[\"unbounded\",{\"1\":{\"450\":1}}],[\"unchecked\",{\"1\":{\"549\":1}}],[\"uncaughtexceptionhandler\",{\"0\":{\"464\":1},\"1\":{\"464\":1}}],[\"unit\",{\"1\":{\"353\":1,\"463\":2}}],[\"unloading\",{\"0\":{\"190\":1},\"1\":{\"183\":1}}],[\"uffff\",{\"1\":{\"258\":1}}],[\"u0000\",{\"1\":{\"258\":2}}],[\"urcb\",{\"1\":{\"649\":1}}],[\"url\",{\"1\":{\"599\":1}}],[\"urlclassloader\",{\"1\":{\"226\":1}}],[\"urgent\",{\"1\":{\"51\":1}}],[\"urg\",{\"1\":{\"51\":1}}],[\"usr\",{\"1\":{\"579\":3,\"582\":1,\"586\":2,\"592\":1}}],[\"using\",{\"0\":{\"189\":1},\"1\":{\"183\":1}}],[\"usessl=false\",{\"1\":{\"599\":1}}],[\"user表\",{\"1\":{\"598\":1}}],[\"username\",{\"1\":{\"428\":1,\"599\":1}}],[\"user\",{\"1\":{\"350\":1,\"436\":1,\"598\":1,\"599\":1,\"601\":1}}],[\"userservice\",{\"1\":{\"598\":2}}],[\"users\",{\"1\":{\"11\":2}}],[\"use\",{\"1\":{\"165\":1,\"334\":1}}],[\"桑基图\",{\"0\":{\"48\":1}}],[\"图1\",{\"1\":{\"627\":3,\"631\":5,\"632\":3,\"633\":4,\"634\":1,\"637\":1,\"640\":4,\"641\":2,\"650\":2}}],[\"图\",{\"0\":{\"39\":1}}],[\"图表\",{\"0\":{\"38\":1,\"49\":1}}],[\"需求\",{\"1\":{\"573\":1,\"574\":1,\"575\":1,\"579\":1,\"584\":1,\"586\":1,\"587\":1,\"592\":1,\"593\":1,\"597\":1}}],[\"需求图\",{\"0\":{\"37\":1}}],[\"需要对多个字段进行去重\",{\"1\":{\"614\":1}}],[\"需要放到dockerfile的同级目录中\",{\"1\":{\"601\":1}}],[\"需要安装什么依赖\",{\"1\":{\"590\":1}}],[\"需要拷贝什么文件\",{\"1\":{\"590\":1}}],[\"需要哪些baseimage\",{\"1\":{\"590\":1}}],[\"需要我们自己管理目录\",{\"1\":{\"588\":1}}],[\"需要进入nginx内部\",{\"1\":{\"581\":1}}],[\"需要进行充分的测试和验证\",{\"1\":{\"232\":1}}],[\"需要更多的旋转操作来保持平衡\",{\"1\":{\"529\":1}}],[\"需要更新这些实例以反映新加载类的变化\",{\"1\":{\"229\":1}}],[\"需要存储前驱和后继\",{\"1\":{\"515\":1}}],[\"需要遍历链表\",{\"1\":{\"515\":1}}],[\"需要一定的阻塞等待唤醒机制来保证锁的分配\",{\"1\":{\"496\":1}}],[\"需要子类自行实现\",{\"1\":{\"496\":2}}],[\"需要子类来实现\",{\"1\":{\"480\":1}}],[\"需要仔细观察线程池的运行情况\",{\"1\":{\"476\":1}}],[\"需要及时调整配置并重新测试\",{\"1\":{\"476\":1}}],[\"需要限制线程数量的场景\",{\"1\":{\"460\":1}}],[\"需要考虑以下几个因素\",{\"1\":{\"453\":1}}],[\"需要考虑到可能出现的错误情况\",{\"1\":{\"231\":1}}],[\"需要定期执行一些任务\",{\"1\":{\"438\":1}}],[\"需要执行一些异步任务\",{\"1\":{\"434\":1}}],[\"需要消耗较多的时间\",{\"1\":{\"426\":1}}],[\"需要保存当前线程的状态\",{\"1\":{\"415\":1}}],[\"需要保证线程安全\",{\"1\":{\"268\":1}}],[\"需要处理可能的\",{\"1\":{\"355\":1}}],[\"需要手动管理线程\",{\"1\":{\"343\":1}}],[\"需要使用锁来保护对队列数据结构的访问\",{\"1\":{\"400\":1}}],[\"需要使用\",{\"1\":{\"301\":1}}],[\"需要使用自定义的类加载器来加载类\",{\"1\":{\"226\":1}}],[\"需要自行保证线程安全\",{\"1\":{\"268\":1}}],[\"需要强制转换\",{\"1\":{\"259\":1}}],[\"需要格外小心\",{\"1\":{\"232\":1}}],[\"需要继承java\",{\"1\":{\"202\":1}}],[\"需要逃逸分析\",{\"1\":{\"166\":2}}],[\"需要低停顿时间的应用\",{\"1\":{\"159\":1}}],[\"需要极低停顿时间\",{\"1\":{\"159\":1}}],[\"需要极低停顿时间的应用\",{\"1\":{\"151\":1}}],[\"需要可预测的低停顿时间\",{\"1\":{\"159\":1}}],[\"需要stw\",{\"1\":{\"142\":2}}],[\"需要在使用时根据具体应用场景进行调优\",{\"1\":{\"139\":1}}],[\"需要暂停所有的用户线程\",{\"1\":{\"138\":1}}],[\"需要注意的是value是volatile的\",{\"1\":{\"548\":1}}],[\"需要注意的是\",{\"1\":{\"121\":1}}],[\"需要注意及时清理不再使用的对象\",{\"1\":{\"87\":1}}],[\"需要维护一个列表\",{\"1\":{\"118\":1}}],[\"需要先创建对象然后通过对象才能访问到它\",{\"1\":{\"301\":1}}],[\"需要先定位到可疑对象\",{\"1\":{\"88\":1}}],[\"需要先进入项目目录\",{\"1\":{\"14\":1}}],[\"需要综合考虑应用程序的特性\",{\"1\":{\"83\":1}}],[\"需要经过多个步骤来确保最佳结果\",{\"1\":{\"77\":1}}],[\"需要build成html文件和js才行\",{\"1\":{\"22\":1}}],[\"象限图\",{\"0\":{\"36\":1}}],[\"9所示\",{\"1\":{\"633\":1}}],[\"9允许在接口中定义私有方法\",{\"1\":{\"299\":1}}],[\"9e\",{\"1\":{\"258\":1}}],[\"99\",{\"1\":{\"51\":1}}],[\"96\",{\"1\":{\"51\":1}}],[\"95\",{\"1\":{\"51\":1}}],[\"9\",{\"0\":{\"36\":1,\"66\":1,\"386\":1},\"1\":{\"432\":1,\"631\":2,\"633\":1,\"640\":1,\"649\":1}}],[\"饼图\",{\"0\":{\"35\":1}}],[\"甘特图\",{\"0\":{\"34\":1}}],[\"5中\",{\"1\":{\"631\":1}}],[\"5所示分别为wxh\",{\"1\":{\"631\":1}}],[\"5倍\",{\"1\":{\"516\":1}}],[\"5引入的一个特性\",{\"1\":{\"284\":1}}],[\"5000\",{\"1\":{\"89\":2}}],[\"5\",{\"0\":{\"32\":1,\"62\":1,\"82\":1,\"188\":1,\"213\":1,\"219\":1,\"230\":1,\"376\":1,\"377\":1,\"378\":1,\"398\":1,\"408\":1,\"437\":1,\"446\":1,\"466\":1,\"473\":1,\"575\":1,\"586\":1,\"602\":1,\"603\":1,\"604\":1},\"1\":{\"89\":1,\"262\":1,\"353\":1,\"377\":1,\"378\":1,\"397\":1,\"398\":1,\"406\":1,\"407\":1,\"409\":1,\"428\":1,\"432\":1,\"436\":1,\"440\":1,\"442\":1,\"477\":1,\"493\":2,\"494\":1,\"571\":1,\"575\":1,\"595\":2,\"598\":3,\"622\":1,\"631\":2,\"649\":1}}],[\"在选择使用\",{\"0\":{\"744\":1}}],[\"在选择\",{\"0\":{\"734\":1,\"754\":1}}],[\"在选择垃圾收集器时\",{\"1\":{\"156\":1}}],[\"在未来的发展中有哪些可以改进的地方\",{\"0\":{\"724\":1}}],[\"在未来的发展方向是什么\",{\"0\":{\"714\":1}}],[\"在面对连接异常时\",{\"0\":{\"723\":1}}],[\"在你的项目中\",{\"0\":{\"726\":1,\"730\":1,\"735\":1,\"741\":1,\"746\":1,\"750\":1}}],[\"在你的开发经验中\",{\"0\":{\"714\":1,\"721\":1,\"728\":1,\"744\":1,\"748\":1}}],[\"在你看来\",{\"0\":{\"704\":1}}],[\"在什么情况下你会选择禁用缓存\",{\"0\":{\"740\":1}}],[\"在什么情况下你会选择使用乐观锁\",{\"0\":{\"732\":1,\"752\":1}}],[\"在什么情况下你会选择启用二级缓存\",{\"0\":{\"687\":1}}],[\"在什么场景下你会选择使用批量更新操作\",{\"0\":{\"729\":1,\"749\":1}}],[\"在什么场景下你会选择使用批量操作\",{\"0\":{\"717\":1}}],[\"在什么场景下会需要自定义\",{\"0\":{\"719\":1}}],[\"在什么时候触发取决于新生代的内存分配情况\",{\"1\":{\"134\":1}}],[\"在工程建设期间便于调试和传动智能电子设备\",{\"1\":{\"645\":1}}],[\"在工程建设前期便于审核和验证智能变电站虚端子回路\",{\"1\":{\"645\":1}}],[\"在常规变电站中\",{\"1\":{\"641\":1}}],[\"在系统配置完成后\",{\"1\":{\"638\":1}}],[\"在iec\",{\"1\":{\"636\":1}}],[\"在非常高的一次电流下\",{\"1\":{\"635\":1}}],[\"在二次回路中\",{\"1\":{\"634\":1}}],[\"在其光学电流传感器内部就会产生与其大小及相位有关联的磁场\",{\"1\":{\"633\":1}}],[\"在电网发生大扰动和故障时\",{\"1\":{\"622\":1}}],[\"在查询中使用\",{\"0\":{\"614\":1}}],[\"在大数据集上使用\",{\"1\":{\"613\":1}}],[\"在大数据处理和计算任务中\",{\"1\":{\"430\":1}}],[\"在将课前资料中的mysql\",{\"1\":{\"587\":1}}],[\"在之前的nginx案例中\",{\"1\":{\"581\":1}}],[\"在浏览器访问自己的虚拟机地址\",{\"1\":{\"579\":1}}],[\"在没有指定tag时\",{\"1\":{\"571\":1}}],[\"在没有多线程竞争时\",{\"1\":{\"491\":1}}],[\"在数百上千台服务中重复部署\",{\"1\":{\"558\":1}}],[\"在冲突的位置拉一个链表\",{\"1\":{\"538\":1}}],[\"在扩容时保持链表元素原本的顺序\",{\"1\":{\"545\":1}}],[\"在扩容时\",{\"1\":{\"535\":1,\"543\":1}}],[\"在遍历期间原集合发生的修改迭代器是不知道的\",{\"1\":{\"520\":1}}],[\"在遍历时不是直接在集合内容上访问的\",{\"1\":{\"520\":1}}],[\"在拷贝的集合上进行遍历\",{\"1\":{\"520\":1}}],[\"在用迭代器遍历一个集合对象时\",{\"1\":{\"520\":1}}],[\"在获取资源时设置超时\",{\"1\":{\"512\":1}}],[\"在无外力作用的情况下\",{\"1\":{\"512\":1}}],[\"在无竞争的情况下\",{\"1\":{\"491\":1}}],[\"在轻量级锁升级为重量级锁时\",{\"1\":{\"491\":1}}],[\"在判断拥有同步标识\",{\"1\":{\"485\":1}}],[\"在上线之后建立完善的线程池监控机制\",{\"1\":{\"476\":1}}],[\"在上线之前进行充分的测试\",{\"1\":{\"476\":1}}],[\"在上线之前\",{\"1\":{\"476\":1}}],[\"在上述代码中\",{\"1\":{\"207\":1}}],[\"在上述示例中\",{\"1\":{\"110\":1}}],[\"在该状态下\",{\"1\":{\"469\":1,\"470\":1,\"471\":1,\"472\":1}}],[\"在任务内部使用\",{\"1\":{\"467\":1}}],[\"在任务\",{\"1\":{\"462\":1}}],[\"在调用了shutdown\",{\"1\":{\"452\":1}}],[\"在指定时间或周期性执行\",{\"1\":{\"439\":1}}],[\"在许多应用中\",{\"1\":{\"434\":1}}],[\"在典型的jvm中\",{\"1\":{\"412\":1}}],[\"在对队列进行添加或移除元素的操作时\",{\"1\":{\"400\":1}}],[\"在对象经过多次minor\",{\"1\":{\"132\":1}}],[\"在队列为空或已满时\",{\"1\":{\"400\":1}}],[\"在多线程编程中起着重要作用\",{\"1\":{\"400\":1}}],[\"在多线程环境下使用stringbuilder\",{\"1\":{\"268\":1}}],[\"在多线程环境下\",{\"1\":{\"268\":1,\"316\":3}}],[\"在所有任务完成后处理结果\",{\"1\":{\"383\":1}}],[\"在compute\",{\"1\":{\"480\":1}}],[\"在countdownlatch中\",{\"1\":{\"356\":1}}],[\"在cyclicbarrier中\",{\"1\":{\"356\":1}}],[\"在使用arraylist时\",{\"1\":{\"521\":1}}],[\"在使用cyclicbarrier时\",{\"1\":{\"356\":1}}],[\"在使用时\",{\"1\":{\"204\":1}}],[\"在它们结束后都可以执行特定动作\",{\"1\":{\"354\":1}}],[\"在此等待信号再继续\",{\"1\":{\"353\":1}}],[\"在编写多线程应用程序时\",{\"1\":{\"348\":1}}],[\"在编译时候就确定了类型信息\",{\"1\":{\"254\":1}}],[\"在等待时间内没有其他线程调用相同对象的\",{\"1\":{\"344\":1}}],[\"在子线程中就可以拿到了\",{\"1\":{\"335\":1}}],[\"在主线程的inheritablethreadlocal实例设置值\",{\"1\":{\"335\":1}}],[\"在get的时候\",{\"1\":{\"333\":1}}],[\"在tryacquire\",{\"1\":{\"501\":1}}],[\"在try块中发生了线程死锁\",{\"1\":{\"281\":1}}],[\"在try块中发生了死循环或无限递归\",{\"1\":{\"281\":1}}],[\"在try块中调用了system\",{\"1\":{\"281\":1}}],[\"在thread的构造函数中\",{\"1\":{\"336\":1}}],[\"在thread类里还有另外一个变量\",{\"1\":{\"336\":1}}],[\"在threadlocalmap\",{\"1\":{\"334\":1}}],[\"在threadlocal中\",{\"1\":{\"331\":1}}],[\"在自然灾害\",{\"1\":{\"622\":1}}],[\"在自己的map里找对应的key\",{\"1\":{\"328\":1}}],[\"在自动装箱的时候会调用integer\",{\"1\":{\"272\":1}}],[\"在每个volatile读操作的后面插入一个\",{\"1\":{\"324\":2}}],[\"在每个volatile写操作的后面插入一个\",{\"1\":{\"324\":1}}],[\"在每个volatile写操作的前面插入一个\",{\"1\":{\"324\":1}}],[\"在设计模式中\",{\"1\":{\"313\":1}}],[\"在外部调⽤静态⽅法时\",{\"1\":{\"301\":1}}],[\"在同一类内可见\",{\"1\":{\"297\":1}}],[\"在同一包内可见\",{\"1\":{\"297\":1}}],[\"在执行完对应的代码块之后\",{\"1\":{\"489\":1}}],[\"在执行第二个子任务的过程中\",{\"1\":{\"480\":1}}],[\"在执行任务之前和之后\",{\"1\":{\"478\":1}}],[\"在执行任务时\",{\"1\":{\"478\":1}}],[\"在执行过程中会经历多个状态\",{\"1\":{\"468\":1}}],[\"在执行程序时\",{\"1\":{\"319\":1}}],[\"在执行\",{\"1\":{\"282\":1}}],[\"在执行young\",{\"1\":{\"135\":1}}],[\"在序列化时不需要保存\",{\"1\":{\"276\":1}}],[\"在静态块中会初始化好缓存值\",{\"1\":{\"272\":1}}],[\"在堆里创建一个\",{\"1\":{\"269\":1}}],[\"在堆内存中为对象分配内存空间\",{\"1\":{\"117\":1}}],[\"在单线程环境下\",{\"1\":{\"268\":1}}],[\"在单次gc中同时处理年轻代和老年代的对象\",{\"1\":{\"148\":1}}],[\"在目前所有的版本中都是不可以的\",{\"1\":{\"262\":1}}],[\"在应用程序运行时\",{\"1\":{\"252\":1}}],[\"在默认的双亲委派模型下\",{\"1\":{\"234\":1}}],[\"在部署热部署功能之前\",{\"1\":{\"232\":1}}],[\"在新线程中\",{\"1\":{\"220\":1}}],[\"在新生代中\",{\"1\":{\"132\":1,\"134\":1}}],[\"在合适的情况下\",{\"1\":{\"219\":1}}],[\"在实现热部署功能时\",{\"1\":{\"231\":1}}],[\"在实现中采用了自定义的类加载器策略\",{\"1\":{\"219\":1}}],[\"在实际开发中\",{\"1\":{\"224\":1}}],[\"在实际应用中\",{\"1\":{\"137\":1}}],[\"在测试方法中\",{\"1\":{\"215\":1}}],[\"在测试环境下运行调优后的应用程序并收集性能数据\",{\"1\":{\"82\":1}}],[\"在加载新的类之前\",{\"1\":{\"230\":1}}],[\"在加载类时\",{\"1\":{\"215\":1}}],[\"在加载阶段结束后\",{\"1\":{\"196\":1}}],[\"在整个jvm中\",{\"1\":{\"207\":1}}],[\"在整理阶段\",{\"1\":{\"131\":1}}],[\"在内存中生成一个代表这个类的java\",{\"1\":{\"194\":1}}],[\"在类加载阶段丢弃\",{\"1\":{\"289\":1}}],[\"在类加载时从类文件常量池中提取\",{\"1\":{\"105\":1}}],[\"在类被加载和初始化之后\",{\"1\":{\"189\":1}}],[\"在解析阶段\",{\"1\":{\"187\":1}}],[\"在线监测等一次\",{\"1\":{\"625\":1}}],[\"在线监测等全面集成\",{\"1\":{\"625\":1}}],[\"在线分析决策\",{\"1\":{\"623\":1}}],[\"在线和连续的安全评估和分析能力\",{\"1\":{\"622\":1}}],[\"在线程池上线之后\",{\"1\":{\"476\":1}}],[\"在线程池中\",{\"1\":{\"450\":1,\"454\":1}}],[\"在线程栈信息中找到对应线程号的\",{\"1\":{\"89\":1}}],[\"在线游戏\",{\"1\":{\"158\":1}}],[\"在线游戏等\",{\"1\":{\"158\":1}}],[\"在生产环境中\",{\"1\":{\"150\":1}}],[\"在即时编译过程中\",{\"1\":{\"138\":1}}],[\"在hotspot虚拟机中\",{\"1\":{\"138\":1}}],[\"在young\",{\"1\":{\"136\":1}}],[\"在某些情况下\",{\"1\":{\"133\":2}}],[\"在mapper中如何传递多个参数\",{\"0\":{\"763\":1}}],[\"在markdown中使用mermaid画图\",{\"0\":{\"27\":1}}],[\"在mybatis中\",{\"1\":{\"656\":1}}],[\"在minor\",{\"1\":{\"132\":1,\"133\":1}}],[\"在垃圾回收时\",{\"1\":{\"131\":1}}],[\"在垃圾回收日志中包含时间戳\",{\"1\":{\"75\":1}}],[\"在清除阶段\",{\"1\":{\"131\":1}}],[\"在标记阶段\",{\"1\":{\"131\":2}}],[\"在并发场景下的性能表现\",{\"1\":{\"119\":1}}],[\"在分配内存时\",{\"1\":{\"118\":1}}],[\"在这一阶段\",{\"1\":{\"186\":1}}],[\"在这些特定位置上\",{\"1\":{\"138\":1}}],[\"在这个过程中\",{\"1\":{\"348\":1}}],[\"在这个优化后的版本中\",{\"1\":{\"173\":1}}],[\"在这个例子中\",{\"1\":{\"165\":1,\"311\":1,\"312\":1,\"358\":1}}],[\"在这个阶段\",{\"1\":{\"139\":1}}],[\"在这个暂停期间\",{\"1\":{\"138\":1}}],[\"在这个示例中\",{\"1\":{\"124\":2,\"172\":1,\"204\":1,\"215\":1,\"220\":1,\"480\":1}}],[\"在这种方式下\",{\"1\":{\"122\":2}}],[\"在这种情况下\",{\"1\":{\"118\":2,\"224\":1,\"233\":2}}],[\"在这段代码中\",{\"1\":{\"108\":1}}],[\"在运行时获取泛型类型信息\",{\"1\":{\"287\":1}}],[\"在运行时动态地获取类信息\",{\"1\":{\"254\":1}}],[\"在运行时\",{\"1\":{\"108\":1}}],[\"在运行时的表示形式\",{\"1\":{\"104\":1}}],[\"在代码\",{\"1\":{\"108\":1}}],[\"在不同版本的java开发工具包\",{\"1\":{\"93\":1}}],[\"在jdk1\",{\"1\":{\"270\":1,\"491\":2,\"495\":1,\"545\":1,\"547\":1}}],[\"在jdk\",{\"1\":{\"94\":1,\"95\":1,\"96\":1,\"103\":1,\"104\":1,\"105\":2,\"111\":1,\"114\":2,\"117\":2,\"299\":1,\"543\":2}}],[\"在jvm\",{\"1\":{\"350\":1}}],[\"在jvm退出时销毁\",{\"1\":{\"92\":2}}],[\"在jvm启动时创建\",{\"1\":{\"92\":2}}],[\"在java的线程池中\",{\"1\":{\"451\":1}}],[\"在java8时jdk对\",{\"1\":{\"270\":1}}],[\"在java程序中\",{\"1\":{\"122\":1}}],[\"在java中\",{\"1\":{\"106\":1,\"121\":1,\"126\":1,\"127\":1,\"128\":2,\"162\":1,\"216\":1,\"256\":1,\"309\":1,\"507\":1}}],[\"在java\",{\"1\":{\"72\":2,\"133\":2,\"240\":1}}],[\"在java开发和运维过程中\",{\"1\":{\"57\":1}}],[\"在visualvm的\",{\"1\":{\"90\":1}}],[\"在错误日志中找到oom异常的堆栈跟踪信息\",{\"1\":{\"90\":1}}],[\"在\",{\"0\":{\"685\":1,\"689\":1,\"699\":1,\"707\":1,\"710\":1,\"713\":1,\"718\":1,\"733\":1,\"739\":1,\"753\":1},\"1\":{\"89\":1,\"118\":1,\"120\":1,\"222\":1,\"223\":1,\"282\":1,\"295\":1,\"303\":1,\"480\":4,\"552\":1,\"615\":1,\"619\":1}}],[\"在前端的导出订单按钮上加上了置灰状态\",{\"1\":{\"84\":1}}],[\"在当前配置下运行应用程序并收集性能数据\",{\"1\":{\"79\":1}}],[\"在命令行输入\",{\"1\":{\"59\":1}}],[\"在actions菜单栏中应该会触发自动发布\",{\"1\":{\"21\":1}}],[\"john\",{\"1\":{\"610\":3,\"611\":1,\"612\":2,\"617\":3,\"618\":5}}],[\"join任务\",{\"1\":{\"480\":1}}],[\"join框架来计算斐波那契数列的值\",{\"1\":{\"480\":2}}],[\"join框架中表示任务的抽象类\",{\"1\":{\"480\":1}}],[\"join框架会将这个大任务拆分成若干个小任务\",{\"1\":{\"480\":1}}],[\"join框架的线程池实现\",{\"1\":{\"480\":1}}],[\"join框架的关键组件包括\",{\"1\":{\"480\":1}}],[\"join框架的工作原理如下\",{\"1\":{\"480\":1}}],[\"join框架的定义\",{\"1\":{\"480\":1}}],[\"join框架\",{\"1\":{\"480\":1}}],[\"join框架是java7提供的一个用于并行执行任务的框架\",{\"1\":{\"480\":1}}],[\"join框架了解吗\",{\"0\":{\"480\":1}}],[\"join\",{\"1\":{\"320\":3,\"344\":3,\"346\":1,\"351\":3,\"383\":1,\"385\":1,\"480\":3,\"616\":1}}],[\"josh\",{\"1\":{\"240\":1}}],[\"j\",{\"0\":{\"776\":1},\"1\":{\"317\":1}}],[\"jre包含jvm\",{\"1\":{\"247\":1}}],[\"jre\",{\"0\":{\"247\":1},\"1\":{\"247\":2}}],[\"jdb\",{\"1\":{\"247\":1}}],[\"jdbc编程有哪些不足之处\",{\"0\":{\"758\":1}}],[\"jdbc\",{\"1\":{\"223\":2,\"428\":1,\"599\":2}}],[\"jdk8\",{\"1\":{\"592\":2}}],[\"jdk的安装目录\",{\"1\":{\"592\":1}}],[\"jdk的自带工具\",{\"1\":{\"88\":1}}],[\"jdk5之前是没有泛型\",{\"1\":{\"287\":1}}],[\"jdk包含jre\",{\"1\":{\"247\":1}}],[\"jdk11使用byte\",{\"1\":{\"268\":1}}],[\"jdk1\",{\"0\":{\"239\":1,\"240\":1,\"543\":1,\"548\":1,\"549\":1},\"1\":{\"238\":1,\"525\":2,\"545\":1,\"548\":1,\"592\":1}}],[\"jdk\",{\"0\":{\"94\":1,\"95\":1,\"96\":1,\"247\":1},\"1\":{\"89\":1,\"93\":1,\"98\":2,\"99\":2,\"100\":2,\"101\":3,\"222\":2,\"247\":1,\"299\":1,\"543\":3}}],[\"jdk工具\",{\"0\":{\"55\":1}}],[\"jit优化\",{\"0\":{\"419\":1}}],[\"jit\",{\"1\":{\"179\":1,\"419\":1}}],[\"jinfo\",{\"1\":{\"55\":2}}],[\"just\",{\"1\":{\"179\":1,\"549\":1}}],[\"jni引用的对象\",{\"1\":{\"127\":1}}],[\"jprofiler\",{\"1\":{\"89\":1}}],[\"jps\",{\"1\":{\"55\":1,\"89\":1,\"513\":1}}],[\"jvisualvm\",{\"1\":{\"88\":1,\"89\":1}}],[\"jvm先检查对象markword是否指向当前线程栈帧中的锁记录\",{\"1\":{\"494\":1}}],[\"jvm使用cas操作将对象头markword更新为指向锁记录的指针\",{\"1\":{\"494\":1}}],[\"jvm采用\",{\"1\":{\"484\":2}}],[\"jvm中的即时编译器\",{\"1\":{\"419\":1}}],[\"jvm退出\",{\"1\":{\"350\":1}}],[\"jvm执行start方法\",{\"1\":{\"342\":1}}],[\"jvm在堆内存中实例化一个java\",{\"1\":{\"195\":1}}],[\"jvm将字节流解析成方法区的运行时数据结构\",{\"1\":{\"195\":1}}],[\"jvm将字节码解释或编译成本地机器码\",{\"1\":{\"178\":1}}],[\"jvm将这些符号引用转换为内存地址等直接引用\",{\"1\":{\"187\":1}}],[\"jvm为类变量分配内存\",{\"1\":{\"186\":1}}],[\"jvm通过类加载器\",{\"1\":{\"184\":1,\"195\":1}}],[\"jvm负责将字节码转换为对应平台的机器码\",{\"1\":{\"181\":1}}],[\"jvm负责分配和管理程序运行时所需的内存\",{\"1\":{\"178\":1}}],[\"jvm有一套安全管理机制\",{\"1\":{\"178\":1}}],[\"jvm自动管理内存\",{\"1\":{\"178\":1}}],[\"jvm从文件系统中加载java字节码文件\",{\"1\":{\"178\":1}}],[\"jvm是java语言实现跨平台特性\",{\"1\":{\"181\":1}}],[\"jvm是java技术的核心部分\",{\"1\":{\"177\":1}}],[\"jvm是怎么设计来保证线程安全的\",{\"0\":{\"120\":1}}],[\"jvm编译器可以将对象的成员变量直接分配在栈上\",{\"1\":{\"169\":1}}],[\"jvm支持逃逸分析的参数包括\",{\"1\":{\"166\":1}}],[\"jvm可能会优化\",{\"1\":{\"165\":1}}],[\"jvm可以将point对象的成员变量直接分解为局部变量\",{\"1\":{\"172\":1}}],[\"jvm可以进行一系列优化\",{\"1\":{\"168\":1}}],[\"jvm可以进行一些优化\",{\"1\":{\"164\":1}}],[\"jvm可以消除不必要的同步代码\",{\"1\":{\"164\":1}}],[\"jvm会判断是否已经是重量级锁\",{\"1\":{\"494\":1}}],[\"jvm会正常退出\",{\"1\":{\"350\":1}}],[\"jvm会在合适的时机通过垃圾回收机制回收不再使用的类的class对象和相关资源\",{\"1\":{\"190\":1}}],[\"jvm会为对象设置对象头信息\",{\"1\":{\"117\":1}}],[\"jvm会将分配的内存空间初始化为零值\",{\"1\":{\"117\":1}}],[\"jvm会先检查字符串常量池中是否已经存在相同的字符串\",{\"1\":{\"103\":1}}],[\"jvm的开销\",{\"0\":{\"417\":1}}],[\"jvm的跨平台特性\",{\"0\":{\"181\":1}}],[\"jvm的工作过程\",{\"0\":{\"180\":1}}],[\"jvm的结构大致可以分为以下几个部分\",{\"1\":{\"179\":1}}],[\"jvm的结构\",{\"0\":{\"179\":1}}],[\"jvm的主要功能\",{\"0\":{\"178\":1}}],[\"jvm的内存区域主要包括\",{\"1\":{\"94\":1}}],[\"jvm的内存区域分为方法区\",{\"1\":{\"92\":1}}],[\"jvm的内存区域分为多个部分\",{\"1\":{\"92\":1}}],[\"jvm的常见参数配置知道哪些\",{\"0\":{\"71\":1}}],[\"jvm参数\",{\"0\":{\"174\":1}}],[\"jvm参数和逃逸分析\",{\"0\":{\"166\":1}}],[\"jvm参数设置问题\",{\"1\":{\"88\":1}}],[\"jvm参数等\",{\"1\":{\"56\":1}}],[\"jvm性能和运行时行为分析\",{\"1\":{\"70\":1}}],[\"jvm性能和资源使用监控\",{\"1\":{\"70\":1}}],[\"jvm性能监控和分析\",{\"1\":{\"70\":1}}],[\"jvm\",{\"0\":{\"120\":1,\"247\":1},\"1\":{\"56\":1,\"71\":1,\"92\":1,\"93\":1,\"102\":1,\"111\":1,\"117\":1,\"118\":5,\"119\":4,\"120\":4,\"139\":1,\"140\":1,\"177\":1,\"183\":1,\"191\":1,\"247\":2,\"256\":1,\"272\":1,\"282\":1}}],[\"jvm调优是一个迭代和持续改进的过程\",{\"1\":{\"83\":1}}],[\"jvm调优是一个系统性的过程\",{\"1\":{\"77\":1}}],[\"jvm调优\",{\"0\":{\"52\":1}}],[\"jfr\",{\"1\":{\"60\":1,\"70\":1}}],[\"jmm属于语言级的内存模型\",{\"1\":{\"319\":1}}],[\"jmm的很多技术都是围绕着这三大特性展开\",{\"1\":{\"316\":1}}],[\"jmm定义了线程和主内存之间的抽象关系\",{\"1\":{\"315\":1}}],[\"jmm\",{\"0\":{\"315\":1},\"1\":{\"315\":1}}],[\"jmc\",{\"0\":{\"60\":1},\"1\":{\"70\":1}}],[\"jmap\",{\"1\":{\"55\":2,\"86\":2,\"88\":3,\"89\":4}}],[\"jconsole\",{\"0\":{\"59\":1},\"1\":{\"59\":1,\"70\":1}}],[\"jcmd\",{\"1\":{\"55\":1}}],[\"jane\",{\"1\":{\"610\":1,\"611\":1,\"612\":1,\"617\":1,\"618\":3}}],[\"jar放到与服务名称对应的目录\",{\"1\":{\"601\":1}}],[\"jar文件\",{\"1\":{\"601\":1}}],[\"jar文件到docker\",{\"1\":{\"592\":1}}],[\"jar拷贝到cloud\",{\"1\":{\"597\":1}}],[\"jar拷贝到镜像中\",{\"1\":{\"593\":1}}],[\"jar到这个目录中\",{\"1\":{\"593\":1}}],[\"jar\",{\"1\":{\"592\":4,\"593\":4,\"597\":1,\"598\":4,\"600\":1}}],[\"jar等\",{\"1\":{\"234\":2}}],[\"javaweb\",{\"1\":{\"592\":1}}],[\"java项目的启动命令\",{\"1\":{\"592\":1}}],[\"java8\",{\"1\":{\"592\":2}}],[\"java8有哪些内置函数式接口\",{\"0\":{\"242\":1}}],[\"java有哪些保证原子性的方法\",{\"0\":{\"509\":1}}],[\"java有哪些数据类型\",{\"0\":{\"258\":1}}],[\"java提供了atomicstampreference类\",{\"1\":{\"505\":1}}],[\"java提供了字符流\",{\"1\":{\"237\":1}}],[\"java对象头里\",{\"1\":{\"490\":1}}],[\"java对象流序列化是java标准库提供的一种序列化方式\",{\"1\":{\"277\":1}}],[\"java对象流序列化\",{\"1\":{\"277\":1}}],[\"java通过java\",{\"1\":{\"405\":1}}],[\"java线程将操作系统中的就绪和运行两种状态笼\",{\"1\":{\"345\":1}}],[\"java内存模型通过定义内存间的交互操作规则\",{\"1\":{\"315\":1}}],[\"java内存模型的抽象图\",{\"1\":{\"315\":1}}],[\"java内存模型\",{\"0\":{\"314\":1},\"1\":{\"315\":1}}],[\"java内部类为什么推荐用静态类\",{\"0\":{\"309\":1}}],[\"java语言是值传递\",{\"1\":{\"306\":1}}],[\"java语言有哪些特点\",{\"0\":{\"246\":1}}],[\"java是值传递\",{\"0\":{\"306\":1}}],[\"java注解本质上是一个标记\",{\"1\":{\"289\":1}}],[\"java泛型是java\",{\"1\":{\"284\":1}}],[\"java库\",{\"1\":{\"277\":1}}],[\"java序列化可以将对象序列化为字节流\",{\"1\":{\"277\":1}}],[\"java序列化只会保存对象的非静态成员变量\",{\"1\":{\"276\":1}}],[\"java可以对字符串进行缓存和共享\",{\"1\":{\"267\":1}}],[\"java5\",{\"1\":{\"262\":1}}],[\"java的spi机制会使用服务加载器加载这些配置文件\",{\"1\":{\"252\":1}}],[\"java的spi\",{\"1\":{\"252\":1}}],[\"java的垃圾回收器不使用引用计数算法\",{\"1\":{\"126\":1}}],[\"java的垃圾回收器使用了\",{\"1\":{\"126\":1}}],[\"javadoc\",{\"1\":{\"247\":1}}],[\"javac\",{\"1\":{\"247\":1}}],[\"java程序运行在java虚拟机上\",{\"1\":{\"247\":1}}],[\"java程序在不同平台上运行时\",{\"1\":{\"181\":1}}],[\"java概述\",{\"0\":{\"245\":1}}],[\"java中提供了多种原子操作类\",{\"1\":{\"510\":1}}],[\"java中的forkjoinpool使用工作窃取队列来实现任务的并行执行\",{\"1\":{\"450\":1}}],[\"java中的delayed接口和delayedworkqueue类用于实现延迟队列\",{\"1\":{\"450\":1}}],[\"java中的priorityblockingqueue是一个线程安全的优先级队列实现\",{\"1\":{\"450\":1}}],[\"java中的线程池实现\",{\"0\":{\"405\":1}}],[\"java中的线程分为两类\",{\"1\":{\"350\":1}}],[\"java中的类加载器\",{\"1\":{\"198\":1}}],[\"java中序列化可以通过实现externalizable或者serializable来实现\",{\"1\":{\"308\":1}}],[\"java中实现map接口的有哪些类\",{\"0\":{\"291\":1}}],[\"java中可以使用google提供的protobuf\",{\"1\":{\"277\":1}}],[\"java中可以使用第三方库\",{\"1\":{\"277\":3}}],[\"java中可作为gc\",{\"0\":{\"127\":1}}],[\"java堆的内存分区主要是为了优化内存的使用和垃圾回收效率\",{\"1\":{\"130\":1}}],[\"java堆的内存分区了解吗\",{\"0\":{\"130\":1}}],[\"java堆可以根据内存分配的策略划分为不同的区域\",{\"1\":{\"130\":1}}],[\"java堆是java虚拟机管理的最大的一块内存区域\",{\"1\":{\"130\":1}}],[\"java堆是否规整是由选择的垃圾收集器是否具有压缩整理能力决定的\",{\"1\":{\"118\":1}}],[\"java堆内存溢出\",{\"1\":{\"124\":2}}],[\"java堆中可能会划分出一块内存作为句柄池\",{\"1\":{\"122\":1}}],[\"java栈\",{\"1\":{\"92\":2,\"94\":1,\"96\":1,\"107\":1,\"110\":1,\"127\":1,\"179\":1}}],[\"java虚拟机外部的二进制字节流就按照虚拟机设定的格式存储在方法区中\",{\"1\":{\"196\":1}}],[\"java虚拟机规范\",{\"1\":{\"195\":1,\"196\":1}}],[\"java虚拟机规范中只规定了reference是一个指向对象的引用\",{\"1\":{\"122\":1}}],[\"java虚拟机会卸载该类\",{\"1\":{\"190\":1}}],[\"java虚拟机中常见的垃圾收集算法包括以下几种\",{\"1\":{\"131\":1}}],[\"java虚拟机\",{\"1\":{\"71\":1,\"93\":1,\"111\":1,\"117\":1,\"247\":1}}],[\"java自带工具\",{\"1\":{\"59\":1,\"70\":1}}],[\"java\",{\"0\":{\"60\":1,\"236\":1,\"250\":1,\"267\":1,\"279\":1,\"308\":1,\"694\":1,\"777\":1},\"1\":{\"59\":1,\"60\":1,\"70\":1,\"89\":2,\"90\":3,\"92\":1,\"94\":1,\"118\":2,\"119\":1,\"124\":2,\"127\":1,\"137\":1,\"166\":1,\"174\":1,\"177\":1,\"179\":1,\"199\":1,\"204\":1,\"206\":1,\"215\":2,\"222\":3,\"223\":1,\"234\":2,\"238\":1,\"240\":3,\"243\":1,\"244\":1,\"247\":7,\"249\":2,\"250\":2,\"262\":3,\"276\":1,\"286\":3,\"287\":1,\"295\":1,\"303\":1,\"305\":1,\"315\":1,\"344\":1,\"360\":1,\"361\":1,\"383\":4,\"385\":4,\"390\":2,\"392\":4,\"407\":3,\"409\":3,\"424\":5,\"428\":4,\"432\":5,\"436\":2,\"440\":3,\"467\":1,\"468\":1,\"477\":2,\"480\":1,\"520\":2,\"592\":3,\"593\":2,\"594\":1,\"598\":2,\"656\":1}}],[\"javascript\",{\"2\":{\"26\":1}}],[\"jad\",{\"1\":{\"56\":1}}],[\"jhat服务\",{\"1\":{\"89\":1}}],[\"jhat\",{\"1\":{\"55\":1,\"89\":2}}],[\"js\",{\"1\":{\"559\":1}}],[\"jstack等\",{\"1\":{\"55\":1}}],[\"jstack\",{\"1\":{\"55\":1,\"85\":1,\"89\":1,\"513\":1}}],[\"jstat等常用命令\",{\"1\":{\"88\":1}}],[\"jstat\",{\"1\":{\"55\":1,\"86\":1,\"88\":1,\"89\":2}}],[\"json序列化\",{\"1\":{\"277\":1}}],[\"json\",{\"1\":{\"11\":1}}],[\"踩了一些坑\",{\"1\":{\"24\":1}}],[\"踩坑\",{\"0\":{\"24\":1}}],[\"默认是latest\",{\"1\":{\"571\":1}}],[\"默认的segment长度是16\",{\"1\":{\"548\":1}}],[\"默认的拒绝策略\",{\"1\":{\"449\":1}}],[\"默认10次\",{\"1\":{\"494\":1}}],[\"默认策略\",{\"1\":{\"449\":1}}],[\"默认情况下\",{\"1\":{\"388\":1,\"412\":1,\"578\":1}}],[\"默认情况类没有覆盖\",{\"1\":{\"304\":1}}],[\"默认\",{\"0\":{\"297\":1}}],[\"默认范围是\",{\"1\":{\"272\":1}}],[\"默认开启\",{\"1\":{\"166\":1,\"174\":1}}],[\"默认值\",{\"1\":{\"23\":1,\"258\":1,\"300\":1,\"377\":1}}],[\"默认为15\",{\"1\":{\"136\":1}}],[\"默认为客户端模式\",{\"1\":{\"76\":1}}],[\"默认为\",{\"1\":{\"11\":1}}],[\"修饰存储元素的\",{\"1\":{\"517\":1}}],[\"修饰代码块\",{\"1\":{\"482\":1}}],[\"修饰静态方法\",{\"1\":{\"482\":1}}],[\"修饰实例方法\",{\"1\":{\"482\":1}}],[\"修饰的\",{\"1\":{\"496\":1}}],[\"修饰的变量不可变\",{\"1\":{\"303\":1}}],[\"修饰的变量值不会被持久化和恢复\",{\"1\":{\"276\":1}}],[\"修饰的方法不可被重写\",{\"1\":{\"303\":1}}],[\"修饰符修饰的变量\",{\"1\":{\"301\":1}}],[\"修正后的解释和示例代码\",{\"0\":{\"109\":1}}],[\"修复\",{\"0\":{\"23\":1}}],[\"修改版本号等内容\",{\"1\":{\"638\":1}}],[\"修改微服务配置\",{\"0\":{\"599\":1}}],[\"修改自己的cloud\",{\"1\":{\"597\":1}}],[\"修改容器内的html目录内的index\",{\"1\":{\"586\":1}}],[\"修改nginx的html页面时\",{\"1\":{\"581\":1}}],[\"修改index\",{\"1\":{\"579\":1}}],[\"修改html文件内容\",{\"1\":{\"579\":1}}],[\"修改文件也很麻烦\",{\"1\":{\"581\":1}}],[\"修改文件\",{\"0\":{\"579\":1},\"1\":{\"586\":1}}],[\"修改同步状态成功即为获得锁\",{\"1\":{\"496\":1}}],[\"修改是无效的\",{\"1\":{\"282\":1}}],[\"修改classloader类的defineclass方法\",{\"0\":{\"217\":1}}],[\"修改theme\",{\"1\":{\"23\":1}}],[\"修改\",{\"0\":{\"16\":1,\"17\":1},\"1\":{\"496\":1,\"520\":1,\"652\":1}}],[\"goose\",{\"1\":{\"649\":1}}],[\"goose报文\",{\"1\":{\"644\":1}}],[\"goals\",{\"1\":{\"141\":1,\"148\":1}}],[\"gateway服务的mysql\",{\"1\":{\"599\":1}}],[\"gateway\",{\"1\":{\"598\":3,\"601\":1}}],[\"garbage\",{\"1\":{\"131\":1,\"135\":1,\"137\":2,\"140\":2,\"151\":2,\"159\":2,\"179\":1}}],[\"gz\",{\"1\":{\"592\":2}}],[\"gz文件到docker\",{\"1\":{\"592\":1}}],[\"g\",{\"1\":{\"579\":2,\"631\":1}}],[\"gson等\",{\"1\":{\"277\":1}}],[\"generator\",{\"0\":{\"675\":1}}],[\"generational\",{\"1\":{\"131\":1}}],[\"generation\",{\"1\":{\"87\":1,\"92\":2,\"94\":1,\"130\":3,\"139\":1,\"141\":2}}],[\"generic\",{\"1\":{\"649\":1}}],[\"get查询\",{\"1\":{\"549\":1}}],[\"get流程\",{\"1\":{\"548\":1}}],[\"gettreenode\",{\"1\":{\"532\":1}}],[\"getnode\",{\"1\":{\"532\":2}}],[\"getname\",{\"1\":{\"204\":1,\"355\":3,\"357\":3,\"361\":4,\"407\":1,\"409\":1,\"432\":1,\"477\":1}}],[\"getintvolatile\",{\"1\":{\"511\":1}}],[\"getanddecrement\",{\"1\":{\"511\":1}}],[\"getandset\",{\"1\":{\"510\":1}}],[\"getandaddint\",{\"1\":{\"511\":2}}],[\"getandadd\",{\"1\":{\"332\":1}}],[\"getruntime\",{\"1\":{\"440\":1}}],[\"getresourceasstream\",{\"1\":{\"215\":1}}],[\"getstring\",{\"1\":{\"428\":1}}],[\"getsystemclassloader\",{\"1\":{\"201\":1,\"336\":1}}],[\"get\",{\"1\":{\"243\":1,\"326\":1,\"334\":1,\"335\":1,\"375\":3,\"383\":1,\"385\":3,\"463\":1,\"467\":1,\"515\":3,\"532\":1}}],[\"getcause\",{\"1\":{\"463\":1,\"467\":1}}],[\"getconnection\",{\"1\":{\"428\":1}}],[\"getcontextclassloader\",{\"1\":{\"220\":1}}],[\"getcount\",{\"1\":{\"353\":1}}],[\"getclassloader\",{\"1\":{\"207\":1,\"215\":1}}],[\"getclass\",{\"1\":{\"204\":1,\"215\":1,\"274\":1}}],[\"getmethod\",{\"1\":{\"215\":1,\"220\":1}}],[\"getparent\",{\"1\":{\"207\":3}}],[\"g1适用于大多数现代应用\",{\"1\":{\"156\":1}}],[\"g1适用于多核处理器和大内存的环境\",{\"1\":{\"143\":1}}],[\"g1具有自适应调优能力\",{\"1\":{\"153\":1}}],[\"g1具有自适应调优功能\",{\"1\":{\"148\":1}}],[\"g1通过标记\",{\"1\":{\"153\":1}}],[\"g1通过分区管理和并发回收机制\",{\"1\":{\"153\":1}}],[\"g1通过混合回收\",{\"1\":{\"148\":1}}],[\"g1的设计目标之一就是提供可预测的低停顿时间\",{\"1\":{\"153\":1}}],[\"g1的引入旨在克服cms的局限性\",{\"1\":{\"149\":1}}],[\"g1和zgc是首选\",{\"1\":{\"156\":1}}],[\"g1和zgc\",{\"1\":{\"150\":1}}],[\"g1设计之初即考虑了大内存环境\",{\"1\":{\"148\":1}}],[\"g1除了支持并发标记外\",{\"1\":{\"148\":1}}],[\"g1会动态调整垃圾收集过程\",{\"1\":{\"148\":1}}],[\"g1会根据设置的暂停时间来调整其行为\",{\"1\":{\"141\":1}}],[\"g1引入了目标停顿时间设置\",{\"1\":{\"148\":1}}],[\"g1采用了分区\",{\"1\":{\"148\":1}}],[\"g1heapregionsize=<size>\",{\"1\":{\"144\":1}}],[\"g1可以根据用户设定的停顿时间目标自动调整其行为\",{\"1\":{\"143\":1}}],[\"g1可以通过参数配置目标暂停时间\",{\"1\":{\"141\":1}}],[\"g1在处理大堆内存时能有效控制垃圾收集的停顿时间\",{\"1\":{\"143\":1}}],[\"g1在回收过程中会同时处理年轻代和老年代的垃圾收集\",{\"1\":{\"141\":1}}],[\"g1收集器和cms一样\",{\"1\":{\"141\":1}}],[\"g1收集器专为多处理器和大内存的环境设计\",{\"1\":{\"140\":1}}],[\"g1收集器是一种面向服务端应用的垃圾收集器\",{\"1\":{\"137\":1}}],[\"g1垃圾收集器通过分区管理\",{\"1\":{\"145\":1,\"149\":1}}],[\"g1垃圾收集器的配置参数\",{\"0\":{\"144\":1}}],[\"g1垃圾收集器的优势\",{\"0\":{\"143\":1,\"148\":1}}],[\"g1垃圾收集器的工作阶段\",{\"0\":{\"142\":1}}],[\"g1垃圾收集器的关键特点\",{\"0\":{\"141\":1}}],[\"g1垃圾收集器\",{\"1\":{\"140\":1}}],[\"g1垃圾收集器了解吗\",{\"0\":{\"140\":1}}],[\"g1\",{\"1\":{\"137\":1,\"151\":1,\"159\":1,\"160\":1}}],[\"grids\",{\"1\":{\"621\":1}}],[\"group\",{\"1\":{\"616\":1}}],[\"groupid>\",{\"1\":{\"600\":1}}],[\"grandparent\",{\"1\":{\"207\":2}}],[\"grafana\",{\"0\":{\"62\":1},\"1\":{\"62\":1,\"70\":2}}],[\"grep\",{\"1\":{\"85\":1}}],[\"glowroot\",{\"0\":{\"68\":1},\"1\":{\"68\":1,\"70\":2}}],[\"gc分代年龄\",{\"1\":{\"490\":1}}],[\"gc分代信息\",{\"1\":{\"117\":1}}],[\"gc可以通过调整\",{\"1\":{\"160\":1}}],[\"gc停顿时间长和调优复杂等问题限制了其进一步的应用和发展\",{\"1\":{\"149\":1}}],[\"gc停顿时间长\",{\"1\":{\"147\":1,\"151\":1}}],[\"gc之前检查老年代\",{\"1\":{\"135\":1}}],[\"gc之后的对象移动操作中增加\",{\"1\":{\"136\":1}}],[\"gc之后\",{\"1\":{\"135\":1,\"136\":1}}],[\"gc之后老年代空间不足\",{\"1\":{\"135\":1}}],[\"gc通常在eden区满或者存活对象晋升到老年代时触发\",{\"1\":{\"134\":1}}],[\"gc通常会在新生代和老年代之间进行对象的晋升和迁移\",{\"1\":{\"133\":1}}],[\"gc实际上是对新生代进行垃圾回收\",{\"1\":{\"134\":1}}],[\"gc什么时候触发\",{\"0\":{\"134\":1}}],[\"gc会对新生代和老年代以及永久代\",{\"1\":{\"133\":1}}],[\"gc是一种完全的垃圾回收操作\",{\"1\":{\"133\":1}}],[\"gc是一种混合型的垃圾回收操作\",{\"1\":{\"133\":1}}],[\"gc中\",{\"1\":{\"133\":1}}],[\"gc都是什么意思\",{\"0\":{\"133\":1}}],[\"gc后可能升入老年代的对象大小可能超过了老年代当前可用内存空间\",{\"1\":{\"135\":1}}],[\"gc后升入老年代的对象总和的平均大小\",{\"1\":{\"135\":1}}],[\"gc后仍然存活时\",{\"1\":{\"132\":1}}],[\"gc后仍然存活的对象\",{\"1\":{\"132\":1}}],[\"gc后仍然存活的对象会被晋升到老年代\",{\"1\":{\"130\":1,\"134\":1}}],[\"gc后\",{\"1\":{\"130\":1}}],[\"gceasy\",{\"1\":{\"89\":1}}],[\"gceasy等\",{\"1\":{\"87\":1}}],[\"gcviewer\",{\"1\":{\"89\":1}}],[\"gccause\",{\"1\":{\"89\":1}}],[\"gc增加很快\",{\"1\":{\"89\":1}}],[\"gcutil\",{\"1\":{\"88\":1,\"89\":1}}],[\"gc怎么办\",{\"0\":{\"88\":1}}],[\"gc时\",{\"1\":{\"87\":1,\"132\":1,\"135\":1}}],[\"gc在处理minor\",{\"1\":{\"87\":1}}],[\"gc的时机有两个主要条件\",{\"1\":{\"134\":1}}],[\"gc的目标是清理老年代中的垃圾对象\",{\"1\":{\"133\":1}}],[\"gc的目标是清理新生代中的垃圾对象\",{\"1\":{\"133\":1}}],[\"gc的排查思路大概如下\",{\"1\":{\"88\":1}}],[\"gc的频率和停顿时间\",{\"1\":{\"115\":1,\"116\":1}}],[\"gc的频率\",{\"1\":{\"87\":2}}],[\"gc的建议\",{\"1\":{\"87\":1}}],[\"gc日志\",{\"1\":{\"78\":1,\"160\":1}}],[\"gc\",{\"0\":{\"87\":1,\"133\":5,\"134\":1,\"135\":1},\"1\":{\"75\":1,\"86\":1,\"87\":5,\"89\":8,\"121\":1,\"126\":1,\"132\":1,\"133\":14,\"134\":5,\"135\":9,\"139\":1,\"142\":1,\"147\":3,\"157\":1,\"159\":6,\"163\":1,\"303\":1,\"334\":1}}],[\"gc活动\",{\"1\":{\"58\":1}}],[\"gc等\",{\"1\":{\"56\":1}}],[\"gh\",{\"1\":{\"22\":1}}],[\"gitgraph\",{\"0\":{\"38\":1}}],[\"git\",{\"0\":{\"38\":1},\"1\":{\"11\":1}}],[\"gitee\",{\"1\":{\"1\":1}}],[\"github上开源\",{\"0\":{\"20\":1}}],[\"github\",{\"1\":{\"1\":1,\"8\":1,\"11\":1}}],[\"是如何定义和使用的\",{\"0\":{\"708\":1}}],[\"是如何定位的\",{\"0\":{\"89\":1}}],[\"是如何实现的\",{\"0\":{\"703\":1,\"715\":1,\"736\":1}}],[\"是如何工作的\",{\"0\":{\"695\":1}}],[\"是什么\",{\"0\":{\"659\":1,\"669\":1,\"676\":1,\"696\":1,\"719\":1}}],[\"是mybatis与数据库之间的桥梁\",{\"1\":{\"656\":1}}],[\"是站控层信息交换的基础体现方式和平台\",{\"1\":{\"652\":1}}],[\"是scd文件一部分\",{\"1\":{\"638\":1}}],[\"是施工调试人员及运行检修人员进行传动调试必备的配置文件\",{\"1\":{\"638\":1}}],[\"是智能变电站满足智能电网坚强\",{\"1\":{\"630\":1}}],[\"是智能变电站\",{\"1\":{\"629\":1}}],[\"是智能变电站的初级阶段\",{\"1\":{\"624\":1}}],[\"是对智能变电站设备及网络架构的综合描述\",{\"1\":{\"628\":1}}],[\"是将容器端口映射到宿主机端口\",{\"1\":{\"578\":1}}],[\"是基于红黑树实现的\",{\"1\":{\"552\":1}}],[\"是线程安全的吗\",{\"0\":{\"545\":1}}],[\"是因为如果这个阈值也设置成8\",{\"1\":{\"539\":1}}],[\"是因为当前版本没支持\",{\"1\":{\"27\":1}}],[\"是则向树中插入节点\",{\"1\":{\"531\":1}}],[\"是黑色的\",{\"1\":{\"527\":1}}],[\"是可重入锁\",{\"1\":{\"489\":1}}],[\"是类成员\",{\"1\":{\"482\":1}}],[\"是为保证数据通信系统中通信双方能有效和可靠地通信而规定的双方应共同遵守的一系列约定\",{\"1\":{\"637\":1}}],[\"是为成对线程设计的\",{\"1\":{\"363\":1}}],[\"是为每个线程分配的一块私有的内存区域\",{\"1\":{\"119\":1}}],[\"是当最后一个非守护线程束时\",{\"1\":{\"350\":1}}],[\"是系统进行资源分配和调度的基本单位\",{\"1\":{\"340\":1}}],[\"是阿里巴巴开源的基于\",{\"1\":{\"337\":1}}],[\"是原子性操作\",{\"1\":{\"317\":1}}],[\"是指采用光学器件作为被测电流传感器\",{\"1\":{\"635\":1}}],[\"是指包含一个或多个处理器\",{\"1\":{\"626\":1}}],[\"是指资源是有线性顺序的\",{\"1\":{\"512\":1}}],[\"是指程序执行的顺序与代码的顺序一致\",{\"1\":{\"316\":1}}],[\"是指在程序执行过程中的特定位置\",{\"1\":{\"138\":1}}],[\"是在操作系统中模拟硬件设备\",{\"1\":{\"563\":1}}],[\"是在\",{\"1\":{\"303\":1}}],[\"是被\",{\"1\":{\"301\":1}}],[\"是程序无法处理的\",{\"1\":{\"279\":1}}],[\"是google开发的一种高效的序列化协议\",{\"1\":{\"277\":1}}],[\"是用来控制同时访问特定资源的线程数量\",{\"1\":{\"357\":1}}],[\"是用到了integer自动装箱的机制\",{\"1\":{\"272\":1}}],[\"是用于加载和实例化服务提供者的api\",{\"1\":{\"252\":1}}],[\"是用于防范\",{\"1\":{\"243\":1}}],[\"是a和b相等\",{\"1\":{\"272\":1}}],[\"是parentdelegationexample类的类加载器\",{\"1\":{\"207\":1}}],[\"是默认的类加载器\",{\"1\":{\"201\":1}}],[\"是java提供的线程安全的哈希表实现\",{\"1\":{\"546\":1}}],[\"是java并发面试的高频题目\",{\"1\":{\"496\":1}}],[\"是java类加载器的一种工作模式\",{\"1\":{\"205\":1}}],[\"是java\",{\"1\":{\"200\":1,\"201\":1,\"365\":1}}],[\"是java虚拟机\",{\"1\":{\"140\":1}}],[\"是最顶层的类加载器\",{\"1\":{\"199\":1}}],[\"是的话就返回遍历\",{\"1\":{\"520\":1}}],[\"是的\",{\"1\":{\"183\":1}}],[\"是逃逸分析的一种优化技术\",{\"1\":{\"169\":1}}],[\"是确保java应用程序性能和稳定性的关键\",{\"1\":{\"157\":1}}],[\"是一块连续的内存空间\",{\"1\":{\"515\":1}}],[\"是一种有序的的集合\",{\"1\":{\"552\":1}}],[\"是一种原子操作\",{\"1\":{\"502\":1}}],[\"是一种抽象的模型\",{\"1\":{\"315\":1}}],[\"是一种行为规范\",{\"1\":{\"299\":1}}],[\"是一种模板设计\",{\"1\":{\"299\":1}}],[\"是一种标记语言\",{\"1\":{\"277\":1}}],[\"是一种轻量级的数据交换格式\",{\"1\":{\"277\":1}}],[\"是一种元数据文件\",{\"1\":{\"252\":1}}],[\"是一种数据结构\",{\"1\":{\"138\":1}}],[\"是一个虚拟目录\",{\"1\":{\"582\":1}}],[\"是一个虚拟的计算机\",{\"1\":{\"177\":1}}],[\"是一个把大任务分割成若干个小任务\",{\"1\":{\"480\":1}}],[\"是一个以threadlocal对象为键\",{\"1\":{\"351\":1}}],[\"是一个接口\",{\"1\":{\"343\":1}}],[\"是一个类\",{\"1\":{\"343\":1}}],[\"是一个终端操作\",{\"1\":{\"244\":1}}],[\"是一个典型的例子\",{\"1\":{\"223\":1,\"224\":1}}],[\"是一个局部变量\",{\"1\":{\"108\":1}}],[\"是一个专门用于存储字符串字面值\",{\"1\":{\"103\":1}}],[\"是针对老年代的垃圾回收操作\",{\"1\":{\"133\":1}}],[\"是针对新生代的垃圾回收操作\",{\"1\":{\"133\":1}}],[\"是两种不同的内存管理问题\",{\"1\":{\"123\":1}}],[\"是\",{\"0\":{\"267\":1},\"1\":{\"119\":1,\"360\":1,\"490\":1,\"554\":1,\"656\":2}}],[\"是每个类文件中的常量池\",{\"1\":{\"104\":1}}],[\"是源码分支\",{\"1\":{\"22\":1}}],[\"是否为树节点\",{\"1\":{\"531\":1}}],[\"是否支持随机访问\",{\"1\":{\"515\":1}}],[\"是否小于等于1\",{\"1\":{\"480\":1}}],[\"是否能够满足系统的性能和稳定性要求\",{\"1\":{\"476\":1}}],[\"是否能作用在\",{\"0\":{\"262\":1}}],[\"是否都不是以\",{\"1\":{\"244\":1}}],[\"是否有以\",{\"1\":{\"244\":1}}],[\"是否想要现在启动\",{\"1\":{\"11\":1}}],[\"是否初始化\",{\"1\":{\"11\":1}}],[\"是否需要一个自动部署文档到\",{\"1\":{\"11\":1}}],[\"点击jconsole线程面板的\",{\"1\":{\"513\":1}}],[\"点击访问即可\",{\"1\":{\"21\":1}}],[\"点击save\",{\"1\":{\"21\":1}}],[\"选项卡下\",{\"1\":{\"90\":1}}],[\"选中侧边栏pages\",{\"1\":{\"21\":1}}],[\"选择\",{\"1\":{\"618\":1}}],[\"选择要返回的列\",{\"1\":{\"616\":1}}],[\"选择器\",{\"1\":{\"238\":4}}],[\"选择重写哪个方法取决于具体的加载需求和加载策略\",{\"1\":{\"233\":1}}],[\"选择合适的方法取决于您的具体需求和应用场景\",{\"1\":{\"467\":1}}],[\"选择合适的加载策略和模型\",{\"1\":{\"224\":1}}],[\"选择合适的垃圾收集器是一个平衡应用需求\",{\"1\":{\"161\":1}}],[\"选择合适的垃圾收集器\",{\"1\":{\"157\":1}}],[\"选择合适的垃圾收集器取决于应用程序的需求\",{\"1\":{\"150\":1}}],[\"选择合适的垃圾收集器取决于应用程序的性能需求和特点\",{\"1\":{\"137\":1}}],[\"选择合适的垃圾收集算法可以提高垃圾回收的效率和系统的性能\",{\"1\":{\"131\":1}}],[\"选择能适应未来需求的gc\",{\"1\":{\"160\":1}}],[\"选择垃圾收集器的步骤\",{\"0\":{\"160\":1}}],[\"选择垃圾回收器\",{\"1\":{\"81\":1}}],[\"选择使用指针碰撞还是空闲列表取决于堆内存的布局情况以及\",{\"1\":{\"118\":1}}],[\"选择包管理器\",{\"1\":{\"11\":1}}],[\"选择显示语言\",{\"1\":{\"11\":1}}],[\"fst\",{\"1\":{\"649\":1}}],[\"fcda\",{\"1\":{\"649\":1}}],[\"fc\",{\"1\":{\"649\":1}}],[\"fedora等\",{\"1\":{\"561\":1}}],[\"fetchdatafromservice3\",{\"1\":{\"385\":2}}],[\"fetchdatafromservice2\",{\"1\":{\"385\":2}}],[\"fetchdatafromservice1\",{\"1\":{\"385\":2}}],[\"frame\",{\"0\":{\"790\":1}}],[\"freenext\",{\"1\":{\"485\":1}}],[\"from\",{\"1\":{\"252\":1,\"428\":1,\"592\":1,\"593\":1,\"598\":1,\"608\":1,\"609\":1,\"611\":1,\"612\":1,\"614\":1,\"616\":1,\"618\":2}}],[\"from区和to区之间会进行对象的交换\",{\"1\":{\"130\":1}}],[\"from区和to区\",{\"1\":{\"130\":1,\"131\":1,\"132\":1}}],[\"float\",{\"1\":{\"258\":2,\"306\":1}}],[\"flight\",{\"1\":{\"60\":1,\"70\":1}}],[\"futureexceptionhandling\",{\"1\":{\"467\":1}}],[\"future<integer>\",{\"1\":{\"467\":1}}],[\"future<\",{\"1\":{\"463\":3}}],[\"future<string>\",{\"1\":{\"443\":1}}],[\"future3\",{\"1\":{\"375\":3,\"383\":3,\"385\":3}}],[\"future2\",{\"1\":{\"374\":2,\"375\":3,\"383\":3,\"385\":3}}],[\"future1\",{\"1\":{\"374\":2,\"375\":3,\"383\":3,\"385\":3}}],[\"future\",{\"0\":{\"467\":1},\"1\":{\"367\":2,\"369\":1,\"373\":1,\"377\":1,\"378\":1,\"380\":1,\"381\":1,\"383\":2,\"388\":1,\"391\":1,\"392\":2,\"443\":1,\"463\":3,\"467\":3}}],[\"functionally\",{\"1\":{\"649\":1}}],[\"functional\",{\"1\":{\"649\":1}}],[\"functionalinterface\",{\"1\":{\"241\":1,\"242\":1}}],[\"functionname\",{\"1\":{\"285\":2}}],[\"function\",{\"1\":{\"242\":1,\"244\":1}}],[\"full\",{\"0\":{\"133\":1},\"1\":{\"88\":1,\"89\":7,\"133\":3,\"135\":2,\"147\":1,\"149\":1,\"151\":1}}],[\"f\",{\"1\":{\"238\":1,\"549\":4,\"580\":1,\"631\":1}}],[\"fast\",{\"0\":{\"520\":1},\"1\":{\"520\":1}}],[\"fail\",{\"0\":{\"520\":2},\"1\":{\"520\":2}}],[\"failure断路器失灵\",{\"1\":{\"649\":1}}],[\"failure\",{\"1\":{\"135\":1,\"147\":1}}],[\"fair\",{\"1\":{\"501\":2}}],[\"fairsync\",{\"0\":{\"498\":1},\"1\":{\"501\":3}}],[\"fallback\",{\"1\":{\"243\":1}}],[\"false\",{\"1\":{\"17\":1,\"244\":1,\"258\":1,\"477\":2,\"501\":1,\"502\":1}}],[\"fibonacci\",{\"1\":{\"480\":1}}],[\"fibonaccitask\",{\"1\":{\"480\":13}}],[\"fixedthreadpool\",{\"0\":{\"457\":1},\"1\":{\"394\":1,\"406\":2,\"455\":1,\"457\":1}}],[\"fifo\",{\"1\":{\"359\":1}}],[\"field\",{\"1\":{\"254\":1,\"289\":1,\"311\":1,\"312\":1}}],[\"filter\",{\"1\":{\"244\":4}}],[\"fileinputstream\",{\"1\":{\"204\":1}}],[\"filename\",{\"1\":{\"204\":2,\"215\":2}}],[\"file\",{\"1\":{\"89\":1,\"104\":1,\"252\":1,\"595\":1}}],[\"file=29471\",{\"1\":{\"89\":1}}],[\"file=heap\",{\"1\":{\"88\":1}}],[\"file=\",{\"1\":{\"86\":1}}],[\"first第一个\",{\"1\":{\"649\":1}}],[\"first\",{\"1\":{\"137\":1,\"140\":1,\"151\":1,\"159\":1,\"532\":9,\"610\":1,\"611\":3,\"612\":3,\"617\":1,\"618\":6}}],[\"finalname>\",{\"1\":{\"600\":1}}],[\"finalizabledelegatedexecutorservice\",{\"1\":{\"459\":1}}],[\"finalize的区别\",{\"0\":{\"303\":1}}],[\"finalize\",{\"0\":{\"129\":1},\"1\":{\"129\":5,\"274\":1,\"303\":6}}],[\"finalresult\",{\"1\":{\"385\":2}}],[\"final修饰的类不可被继承\",{\"1\":{\"303\":1}}],[\"final关键字有什么作用\",{\"0\":{\"302\":1}}],[\"finally中修改try中return的值\",{\"1\":{\"282\":1}}],[\"finally中return\",{\"1\":{\"282\":1}}],[\"finally中正常执行\",{\"1\":{\"282\":1}}],[\"finally\",{\"0\":{\"303\":1},\"1\":{\"282\":10,\"303\":1,\"495\":1,\"549\":1}}],[\"finally块中的代码也无法执行\",{\"1\":{\"281\":2}}],[\"finally一定会执行吗\",{\"0\":{\"281\":1}}],[\"final\",{\"0\":{\"303\":1},\"1\":{\"268\":1,\"299\":1,\"303\":1,\"332\":1,\"335\":1,\"407\":1,\"409\":1,\"424\":1,\"477\":4,\"480\":1,\"505\":1,\"511\":4,\"532\":1,\"549\":2}}],[\"findclass\",{\"1\":{\"204\":1,\"220\":2,\"222\":1,\"233\":5}}],[\"fin\",{\"1\":{\"51\":1}}],[\"forwardingnode<k\",{\"1\":{\"549\":1}}],[\"forwardingnode\",{\"1\":{\"549\":1}}],[\"forkjointask是fork\",{\"1\":{\"480\":1}}],[\"forkjointask\",{\"1\":{\"480\":1}}],[\"forkjoinpool实现了工作窃取算法\",{\"1\":{\"480\":1}}],[\"forkjoinpool是fork\",{\"1\":{\"480\":1}}],[\"forkjoinpool\",{\"1\":{\"387\":1,\"388\":1,\"398\":1,\"480\":1}}],[\"fork\",{\"0\":{\"480\":1},\"1\":{\"480\":8}}],[\"for\",{\"1\":{\"252\":1,\"334\":2,\"355\":1,\"357\":1,\"407\":1,\"409\":1,\"432\":1,\"477\":3,\"531\":3,\"554\":1}}],[\"foreach\",{\"1\":{\"244\":3,\"383\":1,\"656\":1}}],[\"forname\",{\"1\":{\"228\":1}}],[\"format=b\",{\"1\":{\"86\":1,\"88\":1,\"89\":1}}],[\"found\",{\"1\":{\"11\":1}}],[\"wxh\",{\"1\":{\"631\":2}}],[\"where\",{\"1\":{\"614\":1,\"616\":1}}],[\"when\",{\"1\":{\"336\":1,\"549\":1}}],[\"whether\",{\"1\":{\"289\":1}}],[\"while\",{\"1\":{\"124\":1,\"204\":1,\"334\":1,\"355\":1,\"424\":1,\"428\":1,\"477\":1,\"511\":1,\"532\":1,\"549\":2}}],[\"welcome\",{\"1\":{\"579\":1}}],[\"web\",{\"1\":{\"595\":2}}],[\"web服务器可以预先创建一组线程来处理请求\",{\"1\":{\"423\":1}}],[\"web服务器需要处理大量的客户端请求\",{\"1\":{\"422\":1}}],[\"web服务器\",{\"0\":{\"421\":1}}],[\"webappclassloader\",{\"1\":{\"234\":1}}],[\"weakcompareandsetint\",{\"1\":{\"511\":2}}],[\"weak\",{\"1\":{\"128\":1}}],[\"word的锁对象\",{\"1\":{\"494\":1}}],[\"word里存储当前线程指针\",{\"1\":{\"491\":1}}],[\"word存储对象自身的运行数据\",{\"1\":{\"490\":1}}],[\"word\",{\"1\":{\"490\":3,\"494\":1}}],[\"worker\",{\"1\":{\"477\":2}}],[\"workers\",{\"1\":{\"477\":5}}],[\"workerthread\",{\"1\":{\"477\":5}}],[\"work\",{\"1\":{\"450\":1}}],[\"workqueue\",{\"1\":{\"408\":1,\"409\":1,\"442\":1,\"448\":1,\"463\":2}}],[\"wora\",{\"1\":{\"177\":1}}],[\"world\",{\"0\":{\"138\":1},\"1\":{\"138\":1,\"139\":1,\"369\":1,\"373\":1,\"374\":1}}],[\"writeobject\",{\"1\":{\"554\":1}}],[\"writeobject自定义序列化和反序列化策略\",{\"1\":{\"519\":1}}],[\"writer\",{\"1\":{\"236\":1}}],[\"write\",{\"1\":{\"177\":1,\"204\":1}}],[\"windows\",{\"1\":{\"247\":1,\"563\":1}}],[\"window\",{\"1\":{\"51\":1}}],[\"with\",{\"1\":{\"17\":1,\"129\":1}}],[\"waiters\",{\"1\":{\"485\":1}}],[\"waitsetlock\",{\"1\":{\"485\":1}}],[\"waitset\",{\"1\":{\"485\":4}}],[\"waittofight\",{\"1\":{\"353\":6}}],[\"waitind\",{\"1\":{\"345\":1}}],[\"waiting状态是暂时的\",{\"1\":{\"347\":1}}],[\"waiting状态表示线程在等待其他线程的通知或中断\",{\"1\":{\"347\":1}}],[\"waiting状态表示线程正在等待其他线程的通知\",{\"1\":{\"346\":1}}],[\"waiting和terminated有什么区别\",{\"0\":{\"347\":1}}],[\"waiting\",{\"1\":{\"345\":2}}],[\"wait\",{\"1\":{\"274\":3,\"344\":8,\"351\":1,\"485\":1}}],[\"want\",{\"1\":{\"11\":1}}],[\"was\",{\"1\":{\"11\":1}}],[\"warn\",{\"1\":{\"11\":1}}],[\"的连接池配置吗\",{\"0\":{\"743\":1}}],[\"的缓存机制是如何工作的\",{\"0\":{\"740\":1}}],[\"的拼接和参数传递\",{\"0\":{\"733\":1,\"753\":1}}],[\"的拼接操作\",{\"1\":{\"270\":1}}],[\"的乐观锁功能吗\",{\"0\":{\"732\":1,\"752\":1}}],[\"的乐观锁和悲观锁\",{\"0\":{\"692\":1}}],[\"的单元测试的\",{\"0\":{\"730\":1,\"750\":1}}],[\"的异常处理机制来处理业务异常吗\",{\"0\":{\"728\":1,\"748\":1}}],[\"的异常处理是如何应用的\",{\"0\":{\"728\":1,\"748\":1}}],[\"的异常的\",{\"0\":{\"667\":1}}],[\"的未来发展有什么预期\",{\"0\":{\"724\":1}}],[\"的局限性\",{\"0\":{\"721\":1}}],[\"的哪些功能给你带来了便利\",{\"0\":{\"721\":1}}],[\"的哪些特性给你留下了深刻的印象\",{\"0\":{\"714\":1}}],[\"的批量操作功能吗\",{\"0\":{\"717\":1}}],[\"的批量更新功能吗\",{\"0\":{\"683\":1}}],[\"的动态\",{\"0\":{\"715\":1}}],[\"的注解方式进行\",{\"0\":{\"711\":1}}],[\"的优势是什么\",{\"0\":{\"704\":1}}],[\"的多表查询\",{\"0\":{\"701\":1}}],[\"的性能监控和调优的\",{\"0\":{\"735\":1}}],[\"的性能的\",{\"0\":{\"697\":1}}],[\"的性能调优有什么经验\",{\"0\":{\"697\":1}}],[\"的二级缓存吗\",{\"0\":{\"687\":1}}],[\"的拦截器\",{\"0\":{\"681\":1}}],[\"的高级特性\",{\"0\":{\"673\":1}}],[\"的插件\",{\"0\":{\"665\":1}}],[\"的核心组件是什么\",{\"0\":{\"656\":1}}],[\"的划分\",{\"1\":{\"644\":1}}],[\"的组网方式\",{\"1\":{\"644\":1}}],[\"的组合\",{\"1\":{\"612\":1}}],[\"的电压合并器\",{\"1\":{\"641\":1}}],[\"的电子式电流互感器主要有以下3种\",{\"1\":{\"635\":1}}],[\"的电子式电流互感器有哪几种类型\",{\"0\":{\"635\":1}}],[\"的采集及转换设备\",{\"1\":{\"639\":1}}],[\"的设计产生深刻的影响\",{\"1\":{\"636\":1}}],[\"的一级缓存和二级缓\",{\"0\":{\"662\":1}}],[\"的一种网络结构模式\",{\"1\":{\"629\":1}}],[\"的一部分\",{\"1\":{\"141\":1}}],[\"的缩写\",{\"1\":{\"626\":1}}],[\"的表\",{\"1\":{\"610\":1,\"617\":1}}],[\"的公开服务\",{\"1\":{\"566\":1}}],[\"的源码⾮常⾮常少\",{\"1\":{\"554\":1}}],[\"的顺序进行排序\",{\"1\":{\"552\":1}}],[\"的自然顺序或者\",{\"1\":{\"552\":1}}],[\"的基础上维护了一个双向链表\",{\"1\":{\"551\":1}}],[\"的基础用法\",{\"1\":{\"282\":1}}],[\"的策略\",{\"1\":{\"543\":1}}],[\"的概念\",{\"1\":{\"543\":1}}],[\"的某些数字\",{\"1\":{\"537\":1}}],[\"的低位的余数部分\",{\"1\":{\"535\":1}}],[\"的同时并不释放自己已经获取的资源\",{\"1\":{\"512\":1}}],[\"的原理\",{\"0\":{\"511\":1}}],[\"的当前值是否等于预期值\",{\"1\":{\"502\":1}}],[\"的操作过程如下\",{\"1\":{\"502\":1}}],[\"的状态值加1后返回\",{\"1\":{\"500\":1}}],[\"的状态值为1\",{\"1\":{\"500\":1}}],[\"的执行过程\",{\"0\":{\"500\":1}}],[\"的锁\",{\"1\":{\"482\":2}}],[\"的调用次数\",{\"1\":{\"479\":1}}],[\"的调度\",{\"1\":{\"344\":1}}],[\"的构造函数或者提供的方法\",{\"1\":{\"475\":1}}],[\"的并发行为\",{\"1\":{\"398\":1}}],[\"的结果进行合并\",{\"1\":{\"374\":1}}],[\"的结果暂存起来\",{\"1\":{\"282\":1}}],[\"的屏障\",{\"1\":{\"354\":1}}],[\"的时间自行返回的\",{\"1\":{\"345\":1}}],[\"的方法和使用特定的数据结构\",{\"1\":{\"337\":1}}],[\"的增强版\",{\"1\":{\"337\":1}}],[\"的大小为老数组的两倍\",{\"1\":{\"334\":1}}],[\"的数组\",{\"1\":{\"517\":1}}],[\"的数量已经达到了列表的扩容阈值\",{\"1\":{\"334\":1}}],[\"的数据反序列化为java对象\",{\"1\":{\"277\":1}}],[\"的弱引用\",{\"1\":{\"329\":1}}],[\"的理解\",{\"0\":{\"315\":1}}],[\"的两个对象⽆论如何都不会相等\",{\"1\":{\"305\":1}}],[\"的默认⾏为是对堆上的对象产⽣独特值\",{\"1\":{\"305\":1}}],[\"的⽅式调用\",{\"1\":{\"301\":1}}],[\"的⽅式\",{\"1\":{\"301\":2}}],[\"的静态存储区\",{\"1\":{\"300\":1}}],[\"的兼容性\",{\"1\":{\"287\":1}}],[\"的区别\",{\"0\":{\"296\":1,\"304\":1,\"766\":1}}],[\"的区别及作用\",{\"0\":{\"263\":1}}],[\"的区域\",{\"1\":{\"103\":1}}],[\"的类加载机制和类对象模型\",{\"1\":{\"256\":1}}],[\"的类加载策略\",{\"0\":{\"219\":1}}],[\"的容器\",{\"1\":{\"243\":1}}],[\"的\",{\"0\":{\"670\":1,\"696\":1,\"726\":1,\"731\":1,\"742\":1,\"746\":1,\"751\":1},\"1\":{\"238\":1,\"282\":1,\"336\":1,\"468\":1,\"485\":1}}],[\"的早期版本中\",{\"1\":{\"223\":1}}],[\"的垃圾收集\",{\"1\":{\"139\":1}}],[\"的内存不足时\",{\"1\":{\"133\":1}}],[\"的内存区域有一些重要的变化\",{\"1\":{\"93\":1}}],[\"的初始对象开始\",{\"1\":{\"126\":1}}],[\"的工作原理是什么\",{\"0\":{\"657\":1}}],[\"的工作原理如下\",{\"1\":{\"119\":1}}],[\"的工作流\",{\"1\":{\"11\":1}}],[\"的具体实现\",{\"1\":{\"118\":1}}],[\"的影响\",{\"1\":{\"113\":1}}],[\"的值更新为新值\",{\"1\":{\"502\":1}}],[\"的值更新为新值b\",{\"1\":{\"502\":1}}],[\"的值已经被其他线程改变\",{\"1\":{\"502\":1}}],[\"的值没有被其他线程改变\",{\"1\":{\"502\":1}}],[\"的值相同时\",{\"1\":{\"502\":1}}],[\"的值传递问题\",{\"1\":{\"337\":1}}],[\"的值\",{\"1\":{\"108\":1}}],[\"的逐步移除\",{\"1\":{\"95\":1}}],[\"的情况\",{\"1\":{\"89\":2}}],[\"的比例来减少minor\",{\"1\":{\"87\":1}}],[\"的参数配置非常重要\",{\"1\":{\"71\":1}}],[\"的博客演示\",{\"1\":{\"17\":1}}],[\"博客演示\",{\"1\":{\"17\":1}}],[\"eager\",{\"0\":{\"686\":1}}],[\"each循环遍历键值对\",{\"1\":{\"292\":1}}],[\"each循环遍历键集合或值集合\",{\"1\":{\"292\":1}}],[\"events面向通用对象的变电站事件\",{\"1\":{\"649\":1}}],[\"evacuation\",{\"1\":{\"142\":1}}],[\"employees\",{\"1\":{\"610\":1,\"611\":1,\"612\":1,\"617\":1,\"618\":2}}],[\"empty\",{\"1\":{\"516\":1,\"549\":1}}],[\"etc\",{\"1\":{\"595\":1,\"598\":1}}],[\"epoch\",{\"1\":{\"490\":1}}],[\"err\",{\"1\":{\"465\":1,\"649\":1}}],[\"error错误\",{\"1\":{\"649\":1}}],[\"error\",{\"1\":{\"279\":1}}],[\"ee\",{\"1\":{\"463\":2}}],[\"effective\",{\"1\":{\"240\":1}}],[\"equals\",{\"0\":{\"304\":1,\"305\":1},\"1\":{\"220\":1,\"274\":1,\"304\":2,\"305\":1,\"531\":2,\"532\":2}}],[\"escapeanalysisexample\",{\"1\":{\"165\":1}}],[\"escape\",{\"0\":{\"164\":1}}],[\"esbuild\",{\"1\":{\"11\":2}}],[\"e\",{\"1\":{\"124\":2,\"204\":2,\"215\":2,\"220\":2,\"238\":1,\"282\":1,\"286\":1,\"334\":5,\"353\":2,\"355\":2,\"357\":2,\"361\":4,\"375\":2,\"380\":2,\"381\":2,\"383\":8,\"385\":8,\"392\":3,\"407\":2,\"409\":2,\"428\":2,\"432\":2,\"436\":1,\"440\":1,\"446\":1,\"452\":1,\"462\":2,\"464\":2,\"466\":2,\"467\":4,\"477\":3,\"515\":1,\"531\":7,\"532\":10,\"554\":7,\"579\":2,\"631\":1}}],[\"eden区满\",{\"1\":{\"134\":1}}],[\"eden区和survivor区\",{\"1\":{\"132\":1}}],[\"eden区和s区的大小\",{\"1\":{\"88\":1}}],[\"eden区是新创建对象的初始分配区域\",{\"1\":{\"132\":1}}],[\"eden区\",{\"1\":{\"130\":1,\"132\":2}}],[\"eden\",{\"1\":{\"92\":1}}],[\"eclipse\",{\"1\":{\"89\":1}}],[\"environment用于定义mybatis的运行环境\",{\"1\":{\"656\":1}}],[\"environment\",{\"1\":{\"595\":1,\"598\":4,\"656\":1}}],[\"env\",{\"1\":{\"592\":3}}],[\"entrypoint\",{\"1\":{\"592\":1,\"593\":1,\"598\":1}}],[\"entrylist\",{\"1\":{\"485\":2}}],[\"entry为\",{\"1\":{\"333\":1}}],[\"entry数据\",{\"1\":{\"333\":1}}],[\"entry\",{\"1\":{\"332\":1,\"334\":6,\"525\":2}}],[\"entry是threalocal弱引用作为key\",{\"1\":{\"332\":1}}],[\"enum\",{\"1\":{\"262\":1}}],[\"engine\",{\"1\":{\"179\":1,\"590\":1}}],[\"encoding=utf\",{\"1\":{\"76\":1}}],[\"enable\",{\"1\":{\"17\":1}}],[\"electric\",{\"0\":{\"787\":1}}],[\"electro\",{\"1\":{\"636\":1}}],[\"electronic\",{\"1\":{\"626\":1,\"649\":1}}],[\"elementdata\",{\"1\":{\"516\":3,\"517\":1}}],[\"elementtype\",{\"1\":{\"289\":6}}],[\"element\",{\"1\":{\"286\":2,\"515\":1}}],[\"else\",{\"1\":{\"220\":1,\"334\":1,\"336\":1,\"480\":1,\"531\":3,\"549\":2}}],[\"elimination\",{\"1\":{\"164\":1}}],[\"elk\",{\"0\":{\"64\":1}}],[\"elastic\",{\"0\":{\"64\":1},\"1\":{\"64\":1,\"70\":2}}],[\"exec\",{\"1\":{\"579\":2}}],[\"exec命令\",{\"1\":{\"579\":1}}],[\"execute\",{\"1\":{\"443\":2,\"451\":5}}],[\"executequery\",{\"1\":{\"428\":1}}],[\"executor还负责缓存的管理\",{\"1\":{\"656\":1}}],[\"executor负责执行sql语句\",{\"1\":{\"656\":1}}],[\"executor\",{\"1\":{\"407\":6,\"409\":6,\"432\":6,\"436\":3,\"442\":1,\"443\":2,\"446\":4,\"452\":5,\"462\":2,\"464\":1,\"465\":2,\"467\":3,\"656\":1}}],[\"executorservice\",{\"1\":{\"390\":2,\"392\":2,\"394\":1,\"395\":1,\"396\":1,\"398\":2,\"406\":3,\"407\":2,\"424\":2,\"432\":2,\"436\":2,\"442\":1,\"457\":1,\"458\":1,\"459\":1,\"462\":1,\"464\":1,\"465\":1,\"467\":1}}],[\"executors\",{\"1\":{\"390\":3,\"392\":2,\"394\":1,\"395\":1,\"396\":1,\"397\":1,\"398\":2,\"406\":4,\"407\":2,\"424\":2,\"432\":2,\"436\":2,\"440\":2,\"462\":1,\"464\":1,\"467\":1}}],[\"executionexception\",{\"1\":{\"375\":1,\"383\":2,\"385\":2,\"463\":1,\"467\":1}}],[\"execution\",{\"1\":{\"179\":1}}],[\"existing\",{\"1\":{\"554\":1}}],[\"exit\",{\"1\":{\"281\":2,\"303\":1}}],[\"ex\",{\"1\":{\"377\":1,\"378\":2}}],[\"exclusive表示是获取独占资源时被挂起后放入aqs队列的\",{\"1\":{\"496\":1}}],[\"exchange\",{\"1\":{\"361\":2,\"362\":3,\"363\":2}}],[\"exchanger也可以用于校对工作\",{\"1\":{\"363\":1}}],[\"exchanger可以用于遗传算法\",{\"1\":{\"363\":1}}],[\"exchanger<>\",{\"1\":{\"361\":1}}],[\"exchanger<string>\",{\"1\":{\"361\":5}}],[\"exchangerexample\",{\"1\":{\"361\":1}}],[\"exchanger\",{\"0\":{\"360\":1},\"1\":{\"360\":1,\"361\":15,\"362\":1,\"363\":3}}],[\"exceptionally\",{\"0\":{\"377\":1},\"1\":{\"377\":1,\"466\":1}}],[\"exception\",{\"1\":{\"90\":1,\"204\":1,\"215\":1,\"220\":1,\"279\":2,\"282\":1,\"462\":1,\"467\":2,\"520\":3}}],[\"expose\",{\"1\":{\"592\":1,\"593\":1}}],[\"export\",{\"1\":{\"17\":1}}],[\"expected\",{\"1\":{\"511\":3}}],[\"expungestaleentries\",{\"1\":{\"334\":1}}],[\"expr还可以是字符串\",{\"1\":{\"262\":1}}],[\"expr\",{\"1\":{\"262\":3}}],[\"extclassloader的父加载器是引导类加载器\",{\"1\":{\"207\":1}}],[\"extclassloader\",{\"1\":{\"207\":1,\"234\":1}}],[\"extensible\",{\"1\":{\"277\":1}}],[\"extension\",{\"0\":{\"200\":1}}],[\"extensions\",{\"1\":{\"59\":1}}],[\"extends\",{\"1\":{\"204\":1,\"215\":1,\"220\":1,\"463\":1,\"477\":1,\"480\":1}}],[\"ext\",{\"1\":{\"200\":1}}],[\"ext目录或者由系统变量java\",{\"1\":{\"200\":1}}],[\"examplemethod\",{\"1\":{\"165\":1,\"172\":2,\"173\":2}}],[\"example\",{\"1\":{\"90\":1,\"104\":1,\"109\":1,\"172\":2,\"173\":2,\"192\":1,\"204\":1,\"215\":1,\"220\":2,\"252\":2,\"436\":1}}],[\"访问修饰符public\",{\"0\":{\"297\":1}}],[\"访问控制是否正确等\",{\"1\":{\"185\":1}}],[\"访问\",{\"0\":{\"12\":1},\"1\":{\"12\":1}}],[\"nginx的环境\",{\"1\":{\"579\":1}}],[\"nginx\",{\"1\":{\"573\":1,\"574\":4,\"578\":2,\"579\":4,\"582\":1,\"585\":1,\"586\":3,\"604\":4}}],[\"nt\",{\"1\":{\"549\":2}}],[\"nthreads\",{\"1\":{\"457\":3}}],[\"nil节点\",{\"1\":{\"527\":1}}],[\"nio工作原理\",{\"1\":{\"238\":1}}],[\"nio\",{\"0\":{\"238\":1},\"1\":{\"238\":2}}],[\"nid=0x731f\",{\"1\":{\"89\":1}}],[\"nid\",{\"1\":{\"89\":1}}],[\"null的槽位才会停止查找\",{\"1\":{\"333\":1}}],[\"nullpointerexception\",{\"1\":{\"243\":1}}],[\"null\",{\"0\":{\"678\":1},\"1\":{\"204\":2,\"215\":1,\"243\":2,\"334\":4,\"336\":2,\"378\":1,\"463\":2,\"466\":1,\"485\":9,\"531\":8,\"532\":9,\"549\":7,\"554\":2}}],[\"number\",{\"1\":{\"51\":2}}],[\"nacos服务地址\",{\"1\":{\"599\":1}}],[\"nacos地址都修改为基于容器名的访问\",{\"1\":{\"599\":1}}],[\"nacos地址都命名为docker\",{\"1\":{\"597\":1}}],[\"nacos\",{\"1\":{\"598\":7,\"599\":2}}],[\"nanos\",{\"1\":{\"274\":1,\"344\":1,\"351\":1}}],[\"name\",{\"1\":{\"204\":3,\"215\":7,\"220\":4,\"578\":2,\"580\":1,\"585\":1,\"586\":1,\"599\":2,\"608\":2,\"609\":2,\"610\":2,\"611\":3,\"612\":6,\"614\":1,\"617\":2,\"618\":14}}],[\"native\",{\"1\":{\"92\":1,\"94\":1,\"114\":1,\"127\":1,\"179\":2,\"505\":1,\"511\":1}}],[\"n20\",{\"1\":{\"88\":1}}],[\"n\",{\"1\":{\"70\":1,\"85\":1,\"89\":2,\"480\":15,\"515\":2,\"528\":2,\"531\":3,\"532\":3,\"543\":2,\"549\":6}}],[\"nexttable\",{\"1\":{\"549\":2}}],[\"nexttab\",{\"1\":{\"549\":5}}],[\"next\",{\"1\":{\"428\":1,\"520\":1,\"531\":2,\"532\":2}}],[\"nextindex\",{\"1\":{\"334\":1}}],[\"nexthashcode\",{\"1\":{\"332\":2}}],[\"nextvalue\",{\"1\":{\"204\":3}}],[\"new一个object作为value\",{\"1\":{\"554\":1}}],[\"newnode\",{\"1\":{\"531\":2}}],[\"newcapacity\",{\"1\":{\"516\":6}}],[\"newcachedthreadpool\",{\"1\":{\"395\":1,\"398\":1,\"406\":1,\"458\":1}}],[\"newthread\",{\"1\":{\"464\":1}}],[\"newtab\",{\"1\":{\"334\":7}}],[\"newscheduledthreadpool\",{\"1\":{\"397\":1,\"406\":1,\"440\":1}}],[\"newsinglethreadexecutor\",{\"1\":{\"396\":1,\"406\":1,\"459\":1}}],[\"newfixedthreadpool\",{\"1\":{\"390\":1,\"392\":1,\"394\":1,\"398\":1,\"406\":1,\"407\":1,\"424\":1,\"432\":1,\"436\":1,\"457\":1,\"462\":1,\"464\":1,\"467\":1}}],[\"newlen\",{\"1\":{\"334\":5}}],[\"new创建新对象\",{\"1\":{\"308\":1}}],[\"newinstance\",{\"1\":{\"204\":1,\"215\":1,\"220\":1}}],[\"newratio参数来改变新生代和老年代的比例\",{\"1\":{\"87\":1}}],[\"new\",{\"0\":{\"65\":1,\"120\":1,\"269\":1,\"536\":1},\"1\":{\"65\":1,\"70\":2,\"120\":1,\"124\":2,\"128\":1,\"165\":1,\"172\":2,\"173\":1,\"190\":1,\"204\":4,\"215\":3,\"220\":5,\"244\":1,\"254\":1,\"269\":3,\"311\":2,\"312\":1,\"326\":1,\"334\":1,\"335\":2,\"345\":1,\"353\":12,\"355\":4,\"357\":3,\"359\":1,\"361\":5,\"377\":1,\"378\":1,\"380\":1,\"381\":1,\"383\":4,\"385\":3,\"392\":1,\"409\":2,\"424\":2,\"428\":1,\"440\":1,\"442\":2,\"457\":2,\"458\":2,\"459\":3,\"460\":1,\"464\":2,\"465\":3,\"467\":1,\"477\":4,\"480\":3,\"482\":1,\"497\":1,\"501\":5,\"516\":1,\"549\":2}}],[\"net\",{\"1\":{\"424\":2}}],[\"netflix\",{\"1\":{\"155\":1}}],[\"netstat\",{\"1\":{\"54\":1}}],[\"networks\",{\"1\":{\"647\":1}}],[\"network\",{\"1\":{\"11\":1,\"644\":1}}],[\"npm\",{\"1\":{\"14\":1}}],[\"not\",{\"1\":{\"336\":1}}],[\"notifyall\",{\"1\":{\"274\":1,\"344\":5,\"495\":1}}],[\"notify\",{\"1\":{\"274\":1,\"344\":6,\"351\":1}}],[\"nonfairsync\",{\"0\":{\"499\":1},\"1\":{\"497\":1,\"501\":4}}],[\"non\",{\"1\":{\"309\":1}}],[\"nonematch\",{\"1\":{\"244\":1}}],[\"nonestartswithz\",{\"1\":{\"244\":1}}],[\"nosuchmethodexception\",{\"1\":{\"220\":1}}],[\"node逻辑节点\",{\"1\":{\"649\":1}}],[\"node<\",{\"1\":{\"549\":1}}],[\"node<k\",{\"1\":{\"531\":1,\"532\":4,\"549\":9}}],[\"node节点中的thread变量用来存放进入aqs队列里的线程\",{\"1\":{\"496\":1}}],[\"node\",{\"1\":{\"11\":2,\"532\":1}}],[\"no\",{\"1\":{\"11\":1,\"336\":1,\"549\":1}}],[\"hibernate\",{\"0\":{\"759\":1}}],[\"histo\",{\"1\":{\"86\":1,\"88\":2,\"89\":1}}],[\"hr\",{\"1\":{\"610\":2,\"617\":2}}],[\"hmy\",{\"1\":{\"587\":1,\"595\":2}}],[\"hugecapacity\",{\"1\":{\"516\":1}}],[\"hysteresis\",{\"1\":{\"334\":1}}],[\"having\",{\"1\":{\"616\":1}}],[\"handler\",{\"1\":{\"465\":2}}],[\"handlerequest\",{\"1\":{\"424\":2}}],[\"handle\",{\"0\":{\"378\":1},\"1\":{\"378\":1}}],[\"happens\",{\"0\":{\"320\":1},\"1\":{\"320\":11}}],[\"hash一样就覆盖\",{\"1\":{\"549\":1}}],[\"hashentry本身就是一个链表的结构\",{\"1\":{\"548\":1}}],[\"hash值\",{\"1\":{\"535\":3}}],[\"hash计算后应该落入第\",{\"1\":{\"333\":1}}],[\"hash\",{\"1\":{\"332\":4,\"525\":1,\"531\":10,\"532\":8,\"542\":2,\"549\":2}}],[\"hashset的add方法\",{\"1\":{\"554\":1}}],[\"hashset⾃⼰不得不实现之外\",{\"1\":{\"554\":1}}],[\"hashset\",{\"1\":{\"305\":1,\"554\":2}}],[\"hashtable\",{\"1\":{\"291\":1}}],[\"hashmap采用了\",{\"1\":{\"543\":1}}],[\"hashmap采用了尾插法\",{\"1\":{\"543\":1}}],[\"hashmap会使用更加均匀的哈希函数来计算索引位置\",{\"1\":{\"543\":1}}],[\"hashmap会将链表转换为红黑树\",{\"1\":{\"543\":1}}],[\"hashmap会向上寻找\",{\"1\":{\"536\":1}}],[\"hashmap扩容机制了解吗\",{\"0\":{\"542\":1}}],[\"hashmap里进行了优化改造\",{\"1\":{\"537\":1}}],[\"hashmap<>\",{\"0\":{\"536\":1}}],[\"hashmap的putval\",{\"1\":{\"554\":1}}],[\"hashmap的put流程知道吗\",{\"0\":{\"531\":1}}],[\"hashmap的容量必须是2的倍数\",{\"1\":{\"536\":1}}],[\"hashmap的哈希函数是先通过\",{\"1\":{\"533\":1}}],[\"hashmap的哈希\",{\"0\":{\"533\":1}}],[\"hashmap怎么查找元素的呢\",{\"0\":{\"532\":1}}],[\"hashmap使用头插法插入元素\",{\"1\":{\"545\":1}}],[\"hashmap使用链表或红黑树来解决冲突\",{\"1\":{\"525\":1}}],[\"hashmap使用键的哈希码\",{\"1\":{\"525\":1}}],[\"hashmap内部使用一个数组\",{\"1\":{\"525\":1}}],[\"hashmap\",{\"0\":{\"545\":1,\"550\":1},\"1\":{\"291\":1,\"305\":1,\"550\":2,\"551\":1,\"554\":2}}],[\"hashcode方法用于获取对象的哈希码\",{\"1\":{\"305\":1}}],[\"hashcode与\",{\"0\":{\"305\":1}}],[\"hashcode\",{\"1\":{\"274\":1,\"305\":4,\"531\":1,\"533\":1,\"544\":1}}],[\"hp\",{\"1\":{\"89\":1}}],[\"hprof\",{\"1\":{\"86\":1}}],[\"h20\",{\"1\":{\"88\":1}}],[\"hotspot会计算并记录下对象内部各个偏移量上存储的数据类型\",{\"1\":{\"138\":1}}],[\"hotspot虚拟机并不要求对象的年龄必须达到阈值才能晋升到老年代\",{\"1\":{\"136\":1}}],[\"hotspot虚拟机主要采用直接指针访问方式来进行对象访问\",{\"1\":{\"122\":1}}],[\"home=$java\",{\"1\":{\"592\":1}}],[\"home>\",{\"1\":{\"199\":1,\"200\":1}}],[\"home\",{\"1\":{\"86\":1,\"592\":1}}],[\"hope\",{\"1\":{\"8\":1,\"10\":1,\"11\":5,\"17\":1}}],[\"hessian是一种基于http的轻量级二进制序列化协议\",{\"1\":{\"277\":1}}],[\"hessian序列化\",{\"1\":{\"277\":1}}],[\"helloserviceimpl2\",{\"1\":{\"252\":1}}],[\"helloserviceimpl\",{\"1\":{\"252\":3}}],[\"helloservice\",{\"1\":{\"252\":5}}],[\"hello\",{\"1\":{\"103\":2,\"104\":2,\"109\":2,\"215\":2,\"220\":2,\"252\":1,\"369\":1,\"370\":1,\"371\":1,\"373\":1,\"374\":1,\"592\":1}}],[\"help命令查看docker\",{\"1\":{\"574\":1}}],[\"helptransfer\",{\"1\":{\"549\":1}}],[\"help\",{\"1\":{\"56\":1,\"334\":1,\"574\":1}}],[\"heapoverflowexample\",{\"1\":{\"124\":1}}],[\"heap\",{\"1\":{\"89\":3,\"90\":1,\"92\":1,\"94\":1,\"103\":1,\"163\":1,\"178\":1,\"179\":1}}],[\"header\",{\"1\":{\"121\":4,\"485\":1}}],[\"head\",{\"1\":{\"86\":1,\"88\":1}}],[\"h\",{\"1\":{\"85\":1,\"334\":5,\"531\":2}}],[\"h选项\",{\"1\":{\"85\":1}}],[\"htm\",{\"1\":{\"585\":1}}],[\"html内容\",{\"1\":{\"586\":1}}],[\"html这个目录中\",{\"1\":{\"585\":1}}],[\"html目录了\",{\"1\":{\"582\":1}}],[\"html目录\",{\"1\":{\"582\":1}}],[\"html的内容\",{\"1\":{\"579\":1}}],[\"html\",{\"1\":{\"579\":4,\"584\":3,\"585\":3,\"586\":6}}],[\"htop\",{\"1\":{\"54\":1}}],[\"https\",{\"1\":{\"590\":1,\"595\":1}}],[\"http\",{\"1\":{\"11\":2,\"579\":1,\"592\":1}}],[\"➜\",{\"1\":{\"11\":2}}],[\">>>\",{\"1\":{\"531\":1,\"549\":1}}],[\">>\",{\"1\":{\"516\":2}}],[\">a\",{\"1\":{\"504\":1}}],[\">b\",{\"1\":{\"504\":1}}],[\">重量级锁\",{\"1\":{\"492\":1}}],[\">偏向锁\",{\"1\":{\"492\":1}}],[\">达到屏障点\",{\"1\":{\"355\":1}}],[\">放行\",{\"1\":{\"355\":2}}],[\">=\",{\"1\":{\"334\":4,\"531\":2}}],[\">对象指向分配的内存空间\",{\"1\":{\"319\":1}}],[\">初始化对象\",{\"1\":{\"319\":1}}],[\">\",{\"1\":{\"11\":2,\"89\":3,\"124\":1,\"204\":2,\"215\":2,\"220\":3,\"243\":1,\"244\":8,\"249\":1,\"334\":1,\"336\":1,\"353\":6,\"367\":2,\"369\":2,\"370\":2,\"371\":2,\"373\":3,\"374\":3,\"375\":4,\"377\":3,\"378\":3,\"380\":1,\"381\":1,\"383\":6,\"385\":4,\"388\":1,\"391\":1,\"392\":2,\"398\":3,\"407\":1,\"409\":1,\"424\":1,\"432\":1,\"436\":1,\"440\":2,\"443\":2,\"462\":1,\"463\":3,\"464\":1,\"466\":2,\"467\":1,\"477\":1,\"492\":1,\"531\":1,\"532\":1,\"549\":2,\"579\":1,\"587\":3,\"600\":1}}],[\"请详细说明它们的区别和工作原理\",{\"0\":{\"716\":1}}],[\"请分享一下经验\",{\"0\":{\"692\":1}}],[\"请参考官网文档\",{\"1\":{\"590\":1}}],[\"请求并持有\",{\"1\":{\"512\":2}}],[\"请在浏览器输入给出的开发服务器地址\",{\"1\":{\"11\":1}}],[\"请耐心等待\",{\"1\":{\"11\":1}}],[\"ynchronized修饰同步方法时\",{\"1\":{\"484\":1}}],[\"yield\",{\"1\":{\"344\":2,\"349\":1,\"549\":1}}],[\"y\",{\"1\":{\"165\":4,\"172\":5,\"173\":2}}],[\"ygc\",{\"1\":{\"89\":2}}],[\"yml\",{\"0\":{\"16\":1}}],[\"young\",{\"0\":{\"133\":1,\"134\":1},\"1\":{\"87\":2,\"92\":1,\"130\":1,\"133\":1,\"135\":2,\"141\":1}}],[\"you\",{\"1\":{\"11\":1}}],[\"yes\",{\"1\":{\"11\":3}}],[\"icd\",{\"1\":{\"649\":1}}],[\"icd文件没有实际用处\",{\"1\":{\"638\":1}}],[\"icd文件是设计人员进行变电站设计时必需的\",{\"1\":{\"638\":1}}],[\"icd文件是由装置厂商提供给智能变电站系统集成厂商\",{\"1\":{\"638\":1}}],[\"images\",{\"1\":{\"573\":1}}],[\"image\",{\"1\":{\"559\":1,\"560\":1,\"561\":4,\"563\":2,\"565\":2,\"566\":1,\"567\":1,\"569\":1,\"571\":1,\"572\":1,\"573\":3,\"574\":3,\"577\":1,\"578\":1,\"579\":3,\"581\":1,\"582\":1,\"584\":2,\"587\":1,\"589\":1,\"590\":1,\"592\":4,\"594\":1,\"595\":1,\"598\":7,\"600\":1,\"601\":3,\"602\":1}}],[\"implements\",{\"1\":{\"252\":1,\"355\":1,\"357\":1,\"361\":2}}],[\"import\",{\"1\":{\"124\":2,\"204\":1,\"361\":1,\"383\":4,\"385\":4,\"390\":2,\"392\":4,\"407\":3,\"409\":3,\"424\":5,\"428\":5,\"432\":5,\"436\":2,\"440\":3,\"467\":1,\"477\":2,\"480\":1}}],[\"iec61850中的mms服务\",{\"1\":{\"652\":1}}],[\"iec61850提供给用户三大服务\",{\"1\":{\"651\":1}}],[\"iec61850标准规约的三大服务\",{\"0\":{\"651\":1}}],[\"iec61850标准规约的产生背景及新标准的优点\",{\"0\":{\"648\":1}}],[\"iec61850装置数据模型的层次结构如图1\",{\"1\":{\"650\":1}}],[\"iec61850装置数据模型的层次结构\",{\"0\":{\"650\":1},\"1\":{\"650\":1}}],[\"iec61850模型中配置技术相关缩略语\",{\"0\":{\"649\":1}}],[\"iec61850系列标准的全称为变电站通信网络和系统标准\",{\"1\":{\"647\":1}}],[\"iec\",{\"0\":{\"636\":1},\"1\":{\"636\":6,\"637\":1}}],[\"ied能力描述文件\",{\"1\":{\"649\":1}}],[\"ied实例配置文件\",{\"1\":{\"649\":1}}],[\"ied之间的通信配置及变电站一次系统结构配置文件\",{\"1\":{\"638\":1}}],[\"ied同时也扮演客户的角色\",{\"1\":{\"636\":1}}],[\"ied是具有一个或多个特定环境中特定逻辑节点且受制于其接口的装置\",{\"1\":{\"626\":1}}],[\"ied是英文intelligent\",{\"1\":{\"626\":1}}],[\"ied分布安装于站内\",{\"1\":{\"624\":1}}],[\"ied\",{\"1\":{\"624\":1,\"638\":1,\"649\":3}}],[\"ie\",{\"1\":{\"463\":1}}],[\"ignored\",{\"1\":{\"353\":1}}],[\"illegalstateexception\",{\"1\":{\"380\":1,\"381\":1,\"383\":4,\"385\":3,\"392\":1}}],[\"illegalaccessexception\",{\"1\":{\"220\":1}}],[\"ilp\",{\"1\":{\"319\":1}}],[\"i++\",{\"1\":{\"317\":1,\"355\":1,\"357\":1,\"407\":1,\"409\":1,\"477\":2}}],[\"isdone\",{\"1\":{\"463\":1}}],[\"isinterrupted\",{\"1\":{\"344\":2}}],[\"isbooted\",{\"1\":{\"336\":2}}],[\"is\",{\"1\":{\"289\":1,\"477\":2}}],[\"ispresent\",{\"1\":{\"243\":1}}],[\"issame\",{\"1\":{\"103\":1}}],[\"ioexception\",{\"1\":{\"204\":1,\"215\":1,\"424\":3}}],[\"io\",{\"0\":{\"235\":1,\"236\":1},\"1\":{\"204\":1,\"424\":1}}],[\"iostat\",{\"1\":{\"54\":1}}],[\"id\",{\"1\":{\"89\":2,\"610\":1,\"617\":1}}],[\"i\",{\"1\":{\"54\":2,\"124\":2,\"215\":2,\"220\":2,\"282\":7,\"317\":4,\"332\":1,\"334\":1,\"355\":3,\"357\":3,\"407\":3,\"409\":3,\"477\":7,\"531\":3,\"549\":2,\"574\":1,\"579\":1}}],[\"item\",{\"1\":{\"432\":5}}],[\"it\",{\"1\":{\"11\":2,\"17\":1,\"579\":2,\"610\":2,\"617\":2}}],[\"ifpresent\",{\"1\":{\"243\":1}}],[\"ifconfig\",{\"1\":{\"54\":1}}],[\"if\",{\"0\":{\"321\":1},\"1\":{\"11\":1,\"204\":1,\"215\":2,\"220\":1,\"320\":1,\"321\":3,\"334\":4,\"336\":5,\"377\":1,\"378\":2,\"392\":1,\"407\":1,\"409\":1,\"432\":1,\"440\":1,\"446\":1,\"452\":1,\"463\":3,\"467\":1,\"480\":1,\"488\":1,\"516\":3,\"531\":9,\"532\":5,\"549\":9,\"554\":2}}],[\"insert\",{\"1\":{\"656\":1}}],[\"inspect\",{\"1\":{\"583\":1,\"584\":2,\"586\":1}}],[\"instruction\",{\"1\":{\"319\":1,\"590\":1}}],[\"instantiationexception\",{\"1\":{\"220\":1}}],[\"instanceof\",{\"1\":{\"463\":1,\"531\":1,\"532\":1,\"549\":1}}],[\"instance=new\",{\"1\":{\"319\":1}}],[\"instance\",{\"1\":{\"121\":3,\"215\":2,\"220\":2}}],[\"inittable\",{\"1\":{\"549\":2}}],[\"initializestaticvar\",{\"1\":{\"190\":2}}],[\"initialization\",{\"0\":{\"188\":1},\"1\":{\"183\":1,\"549\":1}}],[\"initial\",{\"1\":{\"139\":1,\"141\":1,\"142\":1}}],[\"initiatingheapoccupancypercent=<n>\",{\"1\":{\"144\":1}}],[\"initiatingheapoccupancypercent=45\",{\"1\":{\"73\":1}}],[\"initiatingheapoccupancypercent\",{\"1\":{\"73\":1}}],[\"index\",{\"1\":{\"407\":2,\"409\":2,\"515\":2,\"579\":1,\"586\":1}}],[\"inheriting\",{\"1\":{\"336\":1}}],[\"inherit\",{\"1\":{\"336\":1}}],[\"inheritablethreadlocals\",{\"1\":{\"336\":5}}],[\"inheritablethreadlocal原理是什么呢\",{\"0\":{\"336\":1}}],[\"inheritablethreadlocaltest\",{\"1\":{\"335\":1}}],[\"inheritablethreadlocal\",{\"1\":{\"335\":2,\"337\":1}}],[\"increment\",{\"1\":{\"332\":2}}],[\"incremental\",{\"1\":{\"131\":1}}],[\"innerclass是非静态内部类\",{\"1\":{\"311\":1}}],[\"innerclass\",{\"1\":{\"311\":3}}],[\"inner\",{\"1\":{\"309\":3,\"311\":2,\"312\":2}}],[\"inf\",{\"1\":{\"252\":3}}],[\"invocationtargetexception\",{\"1\":{\"220\":1}}],[\"invoke\",{\"1\":{\"215\":1,\"220\":1}}],[\"inputstream\",{\"1\":{\"204\":3,\"215\":5,\"236\":1}}],[\"intrinsiccandidate\",{\"1\":{\"505\":1}}],[\"intrinsic\",{\"1\":{\"485\":1}}],[\"intelligent\",{\"1\":{\"649\":1}}],[\"integercache是一个静态内部类\",{\"1\":{\"272\":1}}],[\"integer\",{\"0\":{\"272\":4},\"1\":{\"272\":2,\"273\":2,\"432\":2,\"458\":1,\"460\":1,\"467\":1,\"480\":2}}],[\"interceptor负责实际的拦截功能\",{\"1\":{\"656\":1}}],[\"interceptor是mybatis提供的拦截器接口\",{\"1\":{\"656\":1}}],[\"interceptor\",{\"0\":{\"681\":1},\"1\":{\"656\":1}}],[\"interruptedexception\",{\"1\":{\"353\":4,\"355\":2,\"357\":1,\"359\":1,\"361\":2,\"363\":1,\"375\":1,\"380\":1,\"381\":1,\"383\":4,\"385\":4,\"392\":2,\"407\":2,\"409\":2,\"432\":2,\"436\":1,\"440\":1,\"446\":1,\"452\":1,\"463\":1,\"467\":1,\"477\":3}}],[\"interrupted\",{\"1\":{\"344\":1}}],[\"interrupt\",{\"1\":{\"344\":2,\"407\":1,\"409\":1,\"432\":1,\"436\":1,\"463\":1,\"467\":1,\"477\":4}}],[\"interpreter\",{\"1\":{\"179\":1}}],[\"interfacename\",{\"1\":{\"285\":1}}],[\"interface\",{\"0\":{\"299\":1},\"1\":{\"127\":1,\"179\":1,\"252\":3,\"258\":1,\"285\":1,\"289\":2}}],[\"international\",{\"1\":{\"636\":1}}],[\"intern方法有什么作用\",{\"0\":{\"271\":1}}],[\"intern\",{\"1\":{\"105\":1,\"113\":2}}],[\"int\",{\"0\":{\"108\":1},\"1\":{\"104\":1,\"106\":1,\"108\":2,\"109\":1,\"110\":1,\"124\":1,\"165\":4,\"172\":5,\"173\":3,\"190\":2,\"204\":1,\"258\":2,\"262\":1,\"273\":1,\"274\":1,\"282\":4,\"311\":1,\"312\":1,\"317\":2,\"332\":3,\"334\":4,\"344\":1,\"351\":1,\"355\":1,\"357\":1,\"407\":2,\"409\":2,\"424\":2,\"457\":1,\"460\":1,\"463\":2,\"477\":5,\"480\":5,\"496\":1,\"511\":8,\"515\":2,\"516\":5,\"531\":1,\"532\":2,\"549\":4}}],[\"in\",{\"1\":{\"11\":3,\"90\":1,\"179\":1,\"220\":2,\"647\":1}}],[\"30\",{\"1\":{\"649\":1}}],[\"3000\",{\"1\":{\"380\":1,\"381\":1,\"383\":1,\"385\":1}}],[\"3所示\",{\"1\":{\"627\":1}}],[\"3306\",{\"1\":{\"428\":1,\"599\":1}}],[\"324\",{\"1\":{\"258\":1}}],[\"32\",{\"1\":{\"51\":1,\"258\":2}}],[\"31\",{\"1\":{\"51\":1,\"282\":1}}],[\"3s\",{\"1\":{\"11\":1}}],[\"3\",{\"0\":{\"30\":1,\"60\":1,\"80\":1,\"186\":1,\"194\":1,\"201\":1,\"211\":1,\"217\":1,\"228\":1,\"368\":1,\"369\":1,\"370\":1,\"371\":2,\"375\":1,\"392\":1,\"396\":1,\"405\":1,\"406\":1,\"417\":1,\"418\":1,\"419\":1,\"429\":1,\"444\":1,\"459\":1,\"464\":1,\"471\":1,\"561\":1,\"564\":1,\"565\":1,\"566\":1,\"567\":2,\"568\":1,\"573\":1,\"579\":1,\"581\":1,\"582\":1,\"583\":1,\"584\":2,\"585\":1,\"586\":1,\"587\":1,\"588\":1,\"589\":1,\"590\":1,\"591\":2,\"592\":2,\"593\":2,\"594\":1,\"597\":1,\"598\":1,\"599\":1,\"600\":2,\"601\":1,\"602\":1},\"1\":{\"11\":2,\"258\":1,\"264\":1,\"282\":6,\"334\":2,\"355\":13,\"357\":1,\"359\":1,\"432\":1,\"477\":1,\"493\":2,\"494\":1,\"561\":1,\"573\":1,\"574\":1,\"575\":1,\"579\":1,\"587\":1,\"595\":1,\"598\":1,\"610\":1,\"617\":1,\"620\":1,\"622\":1,\"627\":1,\"631\":1,\"635\":1,\"636\":1,\"649\":1}}],[\"6电阻分压式电压互感器原理示意图\",{\"1\":{\"632\":1}}],[\"6和图1\",{\"1\":{\"632\":1}}],[\"6和1\",{\"1\":{\"98\":1}}],[\"6锁优化以前\",{\"1\":{\"495\":1}}],[\"6之前synchronized的实现直接调用objectmonitor的enter和exit\",{\"1\":{\"491\":1}}],[\"6之前\",{\"1\":{\"491\":1}}],[\"60870系列标准和uca的经验\",{\"1\":{\"636\":1}}],[\"60l\",{\"1\":{\"442\":1,\"458\":1}}],[\"60\",{\"1\":{\"407\":1,\"409\":2,\"432\":1,\"440\":1,\"446\":1,\"452\":1}}],[\"606\",{\"1\":{\"11\":1}}],[\"6时就计划放弃永久代\",{\"1\":{\"114\":1}}],[\"6及之前位于永久代\",{\"1\":{\"105\":2}}],[\"6及之前\",{\"1\":{\"103\":1,\"104\":1}}],[\"6中\",{\"1\":{\"94\":1}}],[\"64bit\",{\"1\":{\"490\":1}}],[\"64\",{\"1\":{\"51\":1,\"258\":2,\"490\":1}}],[\"63\",{\"1\":{\"51\":1}}],[\"639\",{\"1\":{\"11\":1}}],[\"6\",{\"0\":{\"33\":1,\"63\":1,\"83\":1,\"93\":1,\"94\":1,\"189\":1,\"220\":1,\"231\":1,\"379\":1,\"380\":1,\"381\":1,\"409\":1,\"467\":1,\"587\":1},\"1\":{\"11\":1,\"93\":1,\"99\":1,\"100\":1,\"101\":1,\"357\":1,\"432\":1,\"575\":1,\"622\":1,\"631\":1,\"649\":1}}],[\"61850规约和ft3规约\",{\"1\":{\"637\":1}}],[\"61850规约\",{\"1\":{\"637\":3}}],[\"61850\",{\"1\":{\"636\":1,\"640\":1}}],[\"61850的特点如下所述\",{\"1\":{\"636\":1}}],[\"61850标准使用acsi和scsm技术\",{\"1\":{\"636\":1}}],[\"61850标准总结了变电站内信息传输所必需的通信服务\",{\"1\":{\"636\":1}}],[\"61850标准采用面向对象的建模技术\",{\"1\":{\"636\":1}}],[\"61850标准吸收了iec\",{\"1\":{\"636\":1}}],[\"61850标准是由国际电工委员会\",{\"1\":{\"636\":1}}],[\"61850标准和数字化互感器为主要特征\",{\"1\":{\"625\":1}}],[\"61850通信规约是什么\",{\"0\":{\"636\":1}}],[\"61850通信规约的相关软件\",{\"1\":{\"631\":1}}],[\"61\",{\"1\":{\"11\":1}}],[\"813电压合并单元工作原理与常规变电站的电压并列原理完全不同\",{\"1\":{\"641\":1}}],[\"813电压合并单元就自动屏蔽ⅱ母电压互感器的输入\",{\"1\":{\"641\":1}}],[\"813电压合并单元就自动屏蔽ⅰ母电压互感器的输入\",{\"1\":{\"641\":1}}],[\"813电压合并单元开入原理图\",{\"1\":{\"641\":2}}],[\"813电压合并单元是许继电气生产的一款适用于智能变电站\",{\"1\":{\"641\":1}}],[\"813电压合并单元的电压并列是如何实现的\",{\"0\":{\"641\":1}}],[\"813电压合并单元背视图\",{\"1\":{\"640\":1}}],[\"813电压合并单元正视图\",{\"1\":{\"640\":1}}],[\"813电压合并单元正视图和背视图\",{\"1\":{\"640\":1}}],[\"8电磁电流互感器工作原理图\",{\"1\":{\"633\":1}}],[\"8所示为电磁式电流互感器的工作原理示意图\",{\"1\":{\"633\":1}}],[\"8848\",{\"1\":{\"598\":2,\"599\":1}}],[\"8是基于cas+synchronized\",{\"1\":{\"547\":1}}],[\"8还引入了\",{\"1\":{\"543\":1}}],[\"8对hashmap的扩容操作进行了优化\",{\"1\":{\"543\":1}}],[\"8对hashmap主要做了哪些优化呢\",{\"0\":{\"543\":1}}],[\"8对哈希碰撞的处理进行了优化\",{\"1\":{\"543\":1}}],[\"8引入的一个异步编程工具类\",{\"1\":{\"365\":1}}],[\"8引入了新的日期和时间api\",{\"1\":{\"240\":1}}],[\"8的stream\",{\"1\":{\"292\":1}}],[\"8之前\",{\"1\":{\"270\":1}}],[\"8之间内存区域的主要变化\",{\"1\":{\"93\":1}}],[\"8都有哪些新特性\",{\"0\":{\"240\":1}}],[\"8新特性\",{\"0\":{\"239\":1}}],[\"8及以后版本\",{\"1\":{\"133\":1}}],[\"8及之后的版本中\",{\"1\":{\"117\":1}}],[\"8及之前使用\",{\"1\":{\"72\":2}}],[\"8中都存在\",{\"1\":{\"545\":2}}],[\"8中的hashmap改为使用尾插法插入元素\",{\"1\":{\"545\":1}}],[\"8中引入了元空间来替代永久代\",{\"1\":{\"116\":1}}],[\"8中\",{\"1\":{\"96\":1,\"111\":1,\"114\":1,\"240\":1,\"299\":1,\"543\":2}}],[\"8内存区域的变化\",{\"0\":{\"93\":1}}],[\"8开始\",{\"1\":{\"130\":1,\"299\":1}}],[\"8开始被移除\",{\"1\":{\"92\":1}}],[\"8开始使用\",{\"1\":{\"72\":1}}],[\"803b数字化微机型继电保护装置背板图\",{\"1\":{\"631\":1}}],[\"803b数字化微机型继电保护装置的背板图\",{\"1\":{\"631\":1}}],[\"803a微机型继电保护装置背板图\",{\"1\":{\"631\":1}}],[\"803a微机型继电保护装置和wxh\",{\"1\":{\"631\":1}}],[\"8090\",{\"1\":{\"592\":2,\"593\":1,\"595\":2}}],[\"80\",{\"1\":{\"578\":2,\"585\":1,\"586\":2}}],[\"800\",{\"1\":{\"392\":1}}],[\"8000\",{\"1\":{\"89\":2}}],[\"8080\",{\"1\":{\"11\":3,\"12\":1,\"424\":1,\"585\":1,\"604\":4}}],[\"84\",{\"1\":{\"11\":1}}],[\"825ms\",{\"1\":{\"11\":1}}],[\"8\",{\"0\":{\"35\":1,\"65\":1,\"96\":1,\"384\":1,\"385\":1,\"549\":1},\"1\":{\"11\":2,\"76\":1,\"98\":1,\"99\":1,\"100\":1,\"101\":1,\"243\":1,\"258\":3,\"432\":1,\"525\":1,\"579\":1,\"592\":1,\"593\":3,\"594\":1,\"595\":1,\"598\":1,\"631\":1,\"649\":1}}],[\"83\",{\"1\":{\"11\":2}}],[\"1表明\",{\"1\":{\"650\":1}}],[\"13\",{\"1\":{\"640\":1,\"649\":1}}],[\"13可见\",{\"1\":{\"640\":1}}],[\"13思维导图\",{\"0\":{\"45\":1}}],[\"1所示\",{\"1\":{\"627\":1,\"650\":1}}],[\"1^2\",{\"1\":{\"538\":1}}],[\"1得任意数\",{\"1\":{\"535\":1}}],[\"1st\",{\"1\":{\"531\":2}}],[\"1b6d3586\",{\"1\":{\"207\":1}}],[\"15所示为dmu\",{\"1\":{\"640\":1}}],[\"150\",{\"1\":{\"579\":1,\"592\":1,\"604\":4}}],[\"1500\",{\"1\":{\"353\":1}}],[\"159\",{\"1\":{\"51\":1}}],[\"15\",{\"1\":{\"51\":1,\"640\":1,\"649\":1}}],[\"15zenuml\",{\"0\":{\"47\":1}}],[\"18b4aac2\",{\"1\":{\"207\":1}}],[\"18\",{\"0\":{\"50\":1},\"1\":{\"649\":1}}],[\"17所示\",{\"1\":{\"641\":1}}],[\"17\",{\"0\":{\"49\":1},\"1\":{\"649\":1}}],[\"16所示为dmu\",{\"1\":{\"641\":1}}],[\"168\",{\"1\":{\"579\":1,\"592\":1,\"604\":4}}],[\"160\",{\"1\":{\"51\":1}}],[\"16\",{\"0\":{\"48\":1},\"1\":{\"51\":1,\"89\":2,\"258\":2,\"531\":1,\"592\":1,\"641\":1,\"649\":1}}],[\"14和图1\",{\"1\":{\"640\":1}}],[\"144\",{\"1\":{\"51\":1,\"592\":1}}],[\"143\",{\"1\":{\"51\":1}}],[\"14\",{\"0\":{\"46\":1},\"1\":{\"640\":1,\"649\":1}}],[\"12所示\",{\"1\":{\"637\":1}}],[\"123\",{\"1\":{\"595\":1,\"598\":2,\"599\":1}}],[\"127这种赋值\",{\"1\":{\"272\":1}}],[\"127\",{\"0\":{\"272\":2},\"1\":{\"51\":1,\"258\":1,\"272\":1}}],[\"12\",{\"0\":{\"39\":1,\"69\":1},\"1\":{\"90\":1,\"637\":1,\"649\":1}}],[\"128到127之间\",{\"1\":{\"272\":1}}],[\"128\",{\"0\":{\"272\":1},\"1\":{\"11\":1,\"51\":1,\"258\":1,\"272\":1}}],[\"11所示\",{\"1\":{\"634\":1}}],[\"112\",{\"1\":{\"51\":1}}],[\"111\",{\"1\":{\"51\":1}}],[\"110kv等级智能变电站\",{\"1\":{\"644\":1}}],[\"110\",{\"1\":{\"51\":1}}],[\"11\",{\"0\":{\"38\":1,\"68\":1},\"1\":{\"634\":1,\"649\":1}}],[\"104规约\",{\"1\":{\"637\":2}}],[\"10所示\",{\"1\":{\"633\":1}}],[\"101规约\",{\"1\":{\"637\":1}}],[\"101\",{\"1\":{\"579\":1,\"592\":1,\"604\":4}}],[\"10毫秒范围内\",{\"1\":{\"151\":1,\"154\":1,\"159\":1}}],[\"10不应该存放在栈中吗\",{\"0\":{\"106\":1}}],[\"109\",{\"1\":{\"51\":1}}],[\"108\",{\"1\":{\"51\":1}}],[\"107\",{\"1\":{\"51\":1}}],[\"106\",{\"1\":{\"51\":1}}],[\"105\",{\"1\":{\"51\":1}}],[\"10010\",{\"1\":{\"598\":2}}],[\"10000\",{\"1\":{\"357\":1}}],[\"1000000\",{\"1\":{\"124\":1}}],[\"1000\",{\"1\":{\"86\":1,\"88\":1,\"353\":1,\"355\":1,\"383\":1,\"385\":1,\"392\":1,\"432\":1,\"477\":1}}],[\"100\",{\"1\":{\"51\":1,\"89\":1,\"409\":1,\"428\":1,\"465\":1}}],[\"10\",{\"0\":{\"37\":1,\"67\":1,\"108\":1},\"1\":{\"11\":2,\"89\":2,\"104\":1,\"106\":2,\"108\":8,\"109\":1,\"110\":2,\"311\":1,\"312\":1,\"390\":1,\"392\":1,\"394\":1,\"406\":1,\"407\":1,\"409\":2,\"424\":1,\"428\":1,\"432\":1,\"442\":1,\"462\":1,\"464\":1,\"465\":2,\"467\":1,\"480\":2,\"614\":2,\"633\":1,\"649\":1}}],[\"192\",{\"1\":{\"51\":1,\"579\":1,\"592\":1,\"604\":4}}],[\"191\",{\"1\":{\"51\":1}}],[\"19\",{\"0\":{\"51\":1},\"1\":{\"11\":1,\"649\":1}}],[\"197\",{\"1\":{\"11\":1}}],[\"1\",{\"0\":{\"28\":1,\"58\":1,\"78\":1,\"93\":2,\"94\":1,\"95\":1,\"96\":1,\"184\":1,\"192\":1,\"199\":1,\"209\":1,\"215\":1,\"226\":1,\"365\":1,\"367\":1,\"369\":1,\"373\":1,\"377\":1,\"380\":1,\"385\":1,\"388\":1,\"390\":1,\"394\":1,\"403\":1,\"406\":1,\"411\":1,\"412\":2,\"413\":1,\"415\":1,\"418\":1,\"421\":1,\"442\":1,\"457\":1,\"462\":1,\"469\":1,\"558\":2,\"559\":3,\"560\":2,\"561\":2,\"562\":2,\"563\":1,\"564\":1,\"565\":2,\"566\":1,\"567\":1,\"568\":1,\"569\":1,\"570\":1,\"571\":2,\"572\":1,\"573\":1,\"574\":1,\"575\":1,\"577\":1,\"582\":1,\"589\":1,\"592\":1,\"595\":1,\"598\":1,\"603\":1,\"643\":2,\"644\":3,\"645\":2,\"646\":1,\"647\":2},\"1\":{\"11\":1,\"93\":2,\"94\":1,\"95\":1,\"96\":1,\"98\":2,\"99\":2,\"100\":2,\"101\":3,\"103\":2,\"104\":2,\"105\":4,\"111\":1,\"116\":1,\"117\":2,\"124\":1,\"165\":1,\"172\":1,\"173\":1,\"190\":1,\"204\":1,\"222\":2,\"258\":7,\"282\":2,\"317\":1,\"332\":1,\"334\":1,\"353\":1,\"355\":12,\"357\":1,\"359\":1,\"363\":1,\"428\":2,\"432\":1,\"440\":1,\"459\":2,\"480\":3,\"485\":3,\"489\":1,\"493\":1,\"511\":1,\"515\":1,\"516\":2,\"531\":5,\"532\":1,\"534\":1,\"535\":6,\"543\":5,\"549\":4,\"561\":1,\"573\":1,\"574\":1,\"575\":1,\"579\":1,\"587\":1,\"592\":1,\"604\":3,\"610\":1,\"617\":1,\"622\":1,\"624\":1,\"627\":2,\"631\":1,\"635\":1,\"636\":1,\"649\":1,\"650\":1}}],[\"rm\",{\"1\":{\"577\":1,\"583\":1,\"584\":1}}],[\"rmi\",{\"1\":{\"574\":1,\"575\":1}}],[\"r\",{\"1\":{\"463\":4,\"464\":2,\"465\":2}}],[\"rs\",{\"1\":{\"428\":3,\"549\":3}}],[\"rst\",{\"1\":{\"51\":1}}],[\"rabbitmq\",{\"1\":{\"559\":1}}],[\"race\",{\"1\":{\"549\":1}}],[\"random\",{\"1\":{\"355\":1,\"357\":1,\"377\":1,\"378\":1}}],[\"radix\",{\"1\":{\"273\":1}}],[\"roots的对象有哪几种\",{\"0\":{\"127\":1}}],[\"roots到该对象的引用链\",{\"1\":{\"126\":1}}],[\"roots相连\",{\"1\":{\"126\":1}}],[\"roots\",{\"1\":{\"126\":1,\"127\":1,\"139\":2}}],[\"root\",{\"1\":{\"89\":1,\"141\":1,\"142\":1,\"585\":3,\"595\":1,\"598\":2,\"599\":1}}],[\"rollup\",{\"1\":{\"11\":1}}],[\"run命令写到一个文件\",{\"1\":{\"595\":1}}],[\"run命令的常见参数有哪些\",{\"1\":{\"580\":1}}],[\"run创建容器并运行\",{\"1\":{\"593\":1}}],[\"run的命令中通过\",{\"1\":{\"588\":1}}],[\"runasync\",{\"1\":{\"367\":2,\"389\":1,\"466\":1}}],[\"runtime和处理器都必须遵守as\",{\"1\":{\"321\":1}}],[\"runtimeexception\",{\"1\":{\"279\":1,\"377\":1,\"378\":1}}],[\"runtime\",{\"1\":{\"95\":1,\"104\":1,\"179\":1,\"289\":2,\"440\":1}}],[\"runnable\",{\"1\":{\"89\":2,\"242\":1,\"341\":1,\"343\":1,\"345\":1,\"355\":2,\"357\":1,\"361\":2,\"462\":1,\"463\":1,\"464\":1,\"465\":1,\"477\":2}}],[\"running\",{\"0\":{\"469\":1},\"1\":{\"11\":2,\"469\":1,\"477\":5}}],[\"run\",{\"1\":{\"14\":1,\"177\":1,\"335\":2,\"355\":2,\"357\":1,\"358\":1,\"361\":2,\"477\":2,\"577\":1,\"578\":2,\"585\":1,\"586\":1,\"592\":1}}],[\"rc\",{\"1\":{\"11\":3}}],[\"report\",{\"1\":{\"649\":2}}],[\"repository\",{\"1\":{\"571\":1}}],[\"replace\",{\"1\":{\"204\":1,\"215\":1}}],[\"replacement\",{\"1\":{\"164\":1,\"169\":1}}],[\"reentrantlock怎么实现公平锁的\",{\"0\":{\"501\":1}}],[\"reentrantlock通过sync类\",{\"1\":{\"497\":1}}],[\"reentrantlock实现原理\",{\"0\":{\"497\":1}}],[\"reentrantlock需要手工声明来加锁和释放锁\",{\"1\":{\"495\":1}}],[\"reentrantlock类借助condition接口与newcondition\",{\"1\":{\"495\":1}}],[\"reentrantlock可以指定是公平锁还是非公平锁\",{\"1\":{\"495\":1}}],[\"reentrantlock提供了一种能够中断等待锁的线程的机制\",{\"1\":{\"495\":1}}],[\"reentrantlock\",{\"1\":{\"495\":1,\"497\":1,\"501\":7}}],[\"reentrantlock是基于jdk的api层面实现的\",{\"1\":{\"495\":1}}],[\"rejected\",{\"1\":{\"465\":1}}],[\"rejectedexecution\",{\"1\":{\"465\":1}}],[\"rejectedexecutionhandler\",{\"0\":{\"465\":1},\"1\":{\"448\":1,\"465\":3}}],[\"release\",{\"1\":{\"357\":1,\"358\":1}}],[\"relic\",{\"0\":{\"65\":1},\"1\":{\"65\":1,\"70\":2}}],[\"rehash\",{\"1\":{\"334\":5}}],[\"required\",{\"1\":{\"289\":2}}],[\"retention\",{\"1\":{\"289\":2}}],[\"retentionpolicy\",{\"1\":{\"289\":5}}],[\"returntype\",{\"1\":{\"285\":2}}],[\"return\",{\"0\":{\"263\":1},\"1\":{\"190\":1,\"204\":3,\"215\":3,\"220\":3,\"263\":1,\"282\":9,\"332\":1,\"367\":1,\"377\":1,\"378\":3,\"380\":1,\"381\":1,\"383\":4,\"385\":6,\"388\":1,\"391\":1,\"392\":1,\"398\":2,\"443\":1,\"457\":1,\"458\":1,\"459\":1,\"464\":1,\"466\":1,\"467\":1,\"480\":2,\"505\":1,\"511\":3,\"516\":3,\"532\":5,\"549\":3,\"554\":2}}],[\"redis\",{\"0\":{\"785\":1},\"1\":{\"559\":1,\"575\":2}}],[\"reduce\",{\"1\":{\"244\":2}}],[\"reduced\",{\"1\":{\"244\":1}}],[\"reduce归约\",{\"1\":{\"244\":1}}],[\"redefine\",{\"1\":{\"56\":1}}],[\"reactor\",{\"1\":{\"238\":1}}],[\"readobject\",{\"1\":{\"554\":1}}],[\"reader\",{\"1\":{\"236\":1}}],[\"read\",{\"1\":{\"204\":1,\"215\":1}}],[\"registry\",{\"1\":{\"566\":1}}],[\"register\",{\"1\":{\"92\":1,\"94\":1,\"179\":1}}],[\"region\",{\"1\":{\"141\":3,\"142\":1,\"148\":1}}],[\"remarking\",{\"1\":{\"141\":1}}],[\"remark\",{\"1\":{\"139\":1,\"142\":1}}],[\"reference\",{\"1\":{\"128\":4,\"590\":1}}],[\"reference中存储的直接是对象地址\",{\"1\":{\"122\":1}}],[\"reference中存储的是对象的句柄地址\",{\"1\":{\"122\":1}}],[\"recursions\",{\"1\":{\"485\":1}}],[\"recursivetask<integer>\",{\"1\":{\"480\":2}}],[\"recursivetask\",{\"1\":{\"480\":2}}],[\"recursivetask用于表示有返回值的任务\",{\"1\":{\"480\":1}}],[\"recursivemethod\",{\"1\":{\"124\":4}}],[\"recipient\",{\"1\":{\"436\":2}}],[\"received\",{\"1\":{\"361\":2}}],[\"recorder\",{\"1\":{\"60\":1,\"70\":1}}],[\"responsible\",{\"1\":{\"485\":1}}],[\"response\",{\"1\":{\"361\":2,\"363\":1}}],[\"resulttype\",{\"0\":{\"672\":1}}],[\"resultmap是mybatis中用于定义查询结果集与java对象之间映射关系的组件\",{\"1\":{\"656\":1}}],[\"resultmap\",{\"0\":{\"669\":1,\"672\":1,\"673\":1,\"708\":3},\"1\":{\"656\":1}}],[\"resultsethandler根据映射文件中定义的结果映射\",{\"1\":{\"656\":1}}],[\"resultsethandler负责处理sql语句执行后返回的结果集\",{\"1\":{\"656\":1}}],[\"resultsethandler\",{\"1\":{\"656\":1}}],[\"resultset\",{\"1\":{\"428\":2}}],[\"results\",{\"1\":{\"383\":2}}],[\"result3\",{\"1\":{\"375\":2,\"385\":2}}],[\"result2\",{\"1\":{\"374\":2,\"375\":2,\"385\":2,\"480\":2}}],[\"result1\",{\"1\":{\"374\":2,\"375\":2,\"385\":2,\"480\":2}}],[\"resultfuture\",{\"1\":{\"374\":1}}],[\"result\",{\"1\":{\"369\":2,\"370\":2,\"373\":2,\"378\":2,\"383\":2,\"392\":2,\"398\":4,\"467\":3,\"480\":2}}],[\"resizers\",{\"1\":{\"549\":1}}],[\"resizestamp\",{\"1\":{\"549\":1}}],[\"resize\",{\"1\":{\"334\":3,\"531\":2,\"549\":1}}],[\"resolution\",{\"0\":{\"187\":1},\"1\":{\"183\":1}}],[\"resolved\",{\"1\":{\"11\":2}}],[\"resources语句或显式地调用close\",{\"1\":{\"129\":1}}],[\"reserved\",{\"1\":{\"51\":1}}],[\"reused\",{\"1\":{\"11\":2}}],[\"仓库\",{\"1\":{\"11\":1}}],[\"项目启动命令\",{\"0\":{\"14\":1}}],[\"项目需要用到多语言么\",{\"1\":{\"11\":1}}],[\"项目介绍\",{\"1\":{\"1\":1}}],[\"mu\",{\"0\":{\"640\":1},\"1\":{\"640\":5}}],[\"mms具备信号上送功能\",{\"1\":{\"652\":1}}],[\"mms报文\",{\"1\":{\"644\":1}}],[\"mms\",{\"1\":{\"636\":1,\"649\":1}}],[\"md\",{\"1\":{\"603\":1}}],[\"mv\",{\"1\":{\"592\":1}}],[\"mn\",{\"1\":{\"579\":2,\"585\":1,\"586\":1}}],[\"m\",{\"0\":{\"776\":1},\"1\":{\"215\":2,\"220\":2}}],[\"message\",{\"1\":{\"649\":1}}],[\"meta\",{\"1\":{\"252\":1}}],[\"metaspace\",{\"0\":{\"98\":1},\"1\":{\"92\":1,\"96\":2,\"111\":1,\"116\":1,\"130\":2}}],[\"metaspacesize=128m\",{\"1\":{\"72\":1}}],[\"metaspacesize\",{\"1\":{\"72\":1}}],[\"methodhandle\",{\"1\":{\"505\":1}}],[\"method\",{\"1\":{\"92\":2,\"94\":2,\"179\":2,\"254\":1,\"289\":2,\"482\":2}}],[\"memory\",{\"1\":{\"114\":1,\"123\":4,\"163\":2,\"315\":3}}],[\"mem\",{\"1\":{\"89\":2}}],[\"microservices\",{\"0\":{\"782\":1}}],[\"mincapacity\",{\"1\":{\"516\":6}}],[\"minor\",{\"0\":{\"87\":1,\"133\":1,\"134\":1},\"1\":{\"133\":3,\"134\":2,\"142\":1}}],[\"milliseconds\",{\"1\":{\"392\":1,\"457\":1,\"459\":1,\"460\":1,\"465\":1}}],[\"millis\",{\"1\":{\"344\":1,\"351\":2,\"460\":1}}],[\"misc\",{\"1\":{\"207\":2}}],[\"mission\",{\"0\":{\"60\":1},\"1\":{\"60\":1,\"70\":1,\"114\":1}}],[\"mixed\",{\"0\":{\"133\":1},\"1\":{\"133\":3,\"141\":2,\"148\":1}}],[\"mit\",{\"1\":{\"11\":1}}],[\"mbean\",{\"1\":{\"59\":1}}],[\"maven\",{\"1\":{\"600\":1}}],[\"macos\",{\"1\":{\"247\":1}}],[\"machine\",{\"1\":{\"177\":1,\"247\":1,\"563\":1}}],[\"mappedstatement与mapper接口中的方法一一对应\",{\"1\":{\"656\":1}}],[\"mappedstatement是mybatis中的一个关键组件\",{\"1\":{\"656\":1}}],[\"mappedstatement\",{\"1\":{\"656\":1}}],[\"mapper\",{\"0\":{\"658\":1,\"727\":2,\"747\":2},\"1\":{\"656\":1}}],[\"mapper接口的实现类由mybatis框架在运行时自动生成\",{\"1\":{\"656\":1}}],[\"mapper接口是用于定义数据库操作的接口\",{\"1\":{\"656\":1}}],[\"mapper接口\",{\"1\":{\"656\":1}}],[\"mapping\",{\"1\":{\"554\":1}}],[\"map\",{\"0\":{\"524\":1},\"1\":{\"138\":1,\"244\":2,\"383\":1,\"554\":1,\"556\":1}}],[\"major\",{\"0\":{\"133\":1},\"1\":{\"133\":3}}],[\"markword中锁标志是否为\",{\"1\":{\"493\":1}}],[\"markup\",{\"1\":{\"277\":1}}],[\"marking\",{\"1\":{\"141\":3,\"142\":1}}],[\"mark\",{\"1\":{\"131\":2,\"137\":1,\"139\":4,\"140\":1,\"142\":1,\"146\":1,\"147\":1,\"148\":1,\"151\":1,\"159\":1,\"490\":4,\"494\":1}}],[\"math\",{\"1\":{\"355\":1,\"357\":1,\"377\":1,\"378\":1,\"516\":1}}],[\"match\",{\"1\":{\"244\":1}}],[\"mat\",{\"1\":{\"89\":1}}],[\"mat等\",{\"1\":{\"88\":1}}],[\"max\",{\"1\":{\"458\":2,\"460\":2,\"516\":2,\"549\":1}}],[\"maximumpoolsize\",{\"1\":{\"408\":1,\"409\":1,\"442\":2,\"448\":1,\"463\":2}}],[\"maxinlinesize\",{\"1\":{\"74\":1}}],[\"maxgcpausemillis来优化停顿时间\",{\"1\":{\"160\":1}}],[\"maxgcpausemillis指定目标停顿时间\",{\"1\":{\"148\":1}}],[\"maxgcpausemillis=<n>\",{\"1\":{\"144\":1,\"159\":1}}],[\"maxgcpausemillis参数设置\",{\"1\":{\"141\":1}}],[\"maxtenuringthreshold参数来设置这个阈值\",{\"1\":{\"136\":1}}],[\"maxmetaspacesize=256m\",{\"1\":{\"72\":1}}],[\"maxmetaspacesize\",{\"1\":{\"72\":1}}],[\"maxpermsize参数\",{\"1\":{\"115\":1}}],[\"maxpermsize参数调整其大小\",{\"1\":{\"113\":1}}],[\"maxpermsize=256m\",{\"1\":{\"72\":1}}],[\"maxpermsize\",{\"1\":{\"72\":1}}],[\"manufacturing\",{\"1\":{\"649\":1}}],[\"manually\",{\"1\":{\"11\":1}}],[\"management\",{\"1\":{\"59\":1}}],[\"main函数所在的钱程就是一个用户线程\",{\"1\":{\"350\":1}}],[\"main方法执行\",{\"1\":{\"190\":2}}],[\"main\",{\"1\":{\"23\":1,\"90\":1,\"104\":1,\"109\":1,\"124\":2,\"172\":1,\"173\":1,\"190\":1,\"204\":1,\"207\":1,\"215\":1,\"220\":1,\"282\":3,\"311\":1,\"312\":1,\"315\":1,\"335\":1,\"350\":1,\"353\":2,\"355\":1,\"357\":1,\"361\":1,\"383\":1,\"385\":1,\"392\":1,\"407\":1,\"409\":1,\"424\":1,\"428\":1,\"432\":1,\"436\":1,\"440\":1,\"467\":1,\"477\":1,\"480\":2}}],[\"master的代码都是ts和一些markdown文件\",{\"1\":{\"22\":1}}],[\"master\",{\"1\":{\"16\":1,\"22\":1}}],[\"make\",{\"1\":{\"11\":1}}],[\"modcount\",{\"1\":{\"520\":1}}],[\"modcount变量是否为expectedmodcount值\",{\"1\":{\"520\":1}}],[\"modcount的值\",{\"1\":{\"520\":1}}],[\"modification\",{\"1\":{\"520\":3}}],[\"model\",{\"1\":{\"203\":1,\"205\":1,\"315\":1}}],[\"mode\",{\"1\":{\"147\":1,\"598\":2}}],[\"modules\",{\"1\":{\"11\":2}}],[\"monitorexit或者acc\",{\"1\":{\"485\":1}}],[\"monitorexit\",{\"1\":{\"484\":2,\"485\":1}}],[\"monitorenter\",{\"1\":{\"484\":2,\"485\":2}}],[\"monitor\",{\"1\":{\"56\":1,\"485\":4}}],[\"move\",{\"1\":{\"11\":1}}],[\"mytable\",{\"1\":{\"428\":1}}],[\"mydatabase\",{\"1\":{\"428\":1}}],[\"mysql镜像放到网络上\",{\"1\":{\"566\":1}}],[\"mysql在调用ubuntu函数库时\",{\"1\":{\"561\":1}}],[\"mysql等\",{\"1\":{\"559\":1}}],[\"mysql\",{\"1\":{\"428\":1,\"587\":5,\"595\":8,\"598\":10,\"599\":3}}],[\"mybatis如何执行批量操作\",{\"0\":{\"772\":1}}],[\"mybatis支持动态sql吗\",{\"0\":{\"771\":1}}],[\"mybatis支持多种datasource实现\",{\"1\":{\"656\":1}}],[\"mybatis能执行一对一\",{\"0\":{\"768\":1}}],[\"mybatis生命周期\",{\"0\":{\"762\":1}}],[\"mybatis使用过程\",{\"0\":{\"761\":1}}],[\"mybatis和hibernate的适用场景\",{\"0\":{\"760\":1}}],[\"mybatis是否支持延迟加载\",{\"0\":{\"769\":1}}],[\"mybatis是否可以映射enum枚举类\",{\"0\":{\"765\":1}}],[\"mybatis是如何解决的\",{\"0\":{\"758\":1}}],[\"mybatis是一个java持久层框架\",{\"1\":{\"655\":1}}],[\"mybatis中的缓存分为一级缓存和二级缓存两种\",{\"1\":{\"656\":1}}],[\"mybatis提供了多种事务管理器实现\",{\"1\":{\"656\":1}}],[\"mybatis提供了一系列内置的typehandler\",{\"1\":{\"656\":1}}],[\"mybatis提供了更接近sql的编程模型\",{\"1\":{\"655\":1}}],[\"mybatis通过mapper接口的动态代理方式将方法与对应的sql语句绑定在一起\",{\"1\":{\"656\":1}}],[\"mybatis通常使用xml文件进行配置\",{\"1\":{\"655\":1}}],[\"mybatis的核心组件包括\",{\"1\":{\"656\":1}}],[\"mybatis相对于其他orm框架来说比较轻量级\",{\"1\":{\"655\":1}}],[\"mybatis相对于其他orm框架更加灵活\",{\"1\":{\"655\":1}}],[\"mybatis可以很容易地集成到已有的项目中\",{\"1\":{\"655\":1}}],[\"mybatis允许开发人员直接编写和控制sql查询\",{\"1\":{\"655\":1}}],[\"mybatis有几个不同之处\",{\"1\":{\"655\":1}}],[\"mybatis大全\",{\"0\":{\"654\":1}}],[\"mybatis\",{\"0\":{\"655\":1,\"656\":1,\"657\":1,\"658\":1,\"659\":1,\"660\":1,\"661\":1,\"662\":1,\"663\":1,\"664\":1,\"665\":1,\"666\":1,\"667\":1,\"668\":1,\"669\":1,\"670\":2,\"671\":1,\"672\":1,\"673\":1,\"674\":1,\"675\":1,\"676\":1,\"677\":1,\"678\":1,\"679\":1,\"680\":1,\"681\":1,\"682\":1,\"683\":1,\"684\":1,\"685\":1,\"686\":1,\"687\":1,\"688\":1,\"689\":1,\"690\":1,\"691\":1,\"692\":1,\"693\":1,\"694\":1,\"695\":1,\"696\":2,\"697\":2,\"698\":1,\"699\":2,\"700\":1,\"701\":1,\"702\":1,\"703\":1,\"704\":1,\"705\":1,\"706\":1,\"707\":1,\"708\":1,\"709\":1,\"710\":1,\"711\":1,\"712\":1,\"713\":2,\"714\":2,\"715\":1,\"716\":1,\"717\":1,\"718\":2,\"719\":1,\"720\":1,\"721\":2,\"722\":1,\"723\":1,\"724\":2,\"725\":1,\"726\":1,\"727\":1,\"728\":2,\"729\":1,\"730\":2,\"731\":1,\"732\":1,\"733\":1,\"734\":1,\"735\":1,\"736\":1,\"737\":1,\"738\":1,\"739\":1,\"740\":1,\"741\":1,\"742\":1,\"743\":1,\"744\":1,\"745\":1,\"746\":1,\"747\":1,\"748\":2,\"749\":1,\"750\":2,\"751\":1,\"752\":1,\"753\":1,\"754\":1,\"759\":1,\"789\":1},\"1\":{\"255\":1,\"656\":2}}],[\"myapplication\",{\"1\":{\"166\":1}}],[\"mymethod\",{\"1\":{\"90\":1}}],[\"myclassloader是一个自定义类加载器\",{\"1\":{\"204\":1}}],[\"myclassloader\",{\"1\":{\"204\":4}}],[\"myclass\",{\"1\":{\"90\":2,\"190\":3,\"192\":1,\"204\":1}}],[\"myheapdump\",{\"1\":{\"86\":1}}],[\"my\",{\"0\":{\"783\":1},\"1\":{\"10\":1,\"11\":2,\"14\":1,\"17\":1}}],[\"o\",{\"1\":{\"511\":6,\"574\":2}}],[\"owneristhread\",{\"1\":{\"485\":1}}],[\"owner\",{\"1\":{\"485\":5}}],[\"o密集型的\",{\"1\":{\"453\":1}}],[\"o操作的完成\",{\"1\":{\"453\":1}}],[\"o操作\",{\"1\":{\"349\":1}}],[\"optional<string>\",{\"1\":{\"243\":1,\"244\":1}}],[\"optional了解吗\",{\"0\":{\"243\":1}}],[\"optional类是一个容器类\",{\"1\":{\"240\":1}}],[\"optional\",{\"1\":{\"240\":1,\"243\":9,\"244\":1}}],[\"options\",{\"1\":{\"51\":1}}],[\"overload\",{\"0\":{\"296\":1}}],[\"override\",{\"0\":{\"296\":1},\"1\":{\"204\":1,\"215\":1,\"220\":1,\"252\":1,\"289\":1,\"335\":1,\"355\":2,\"357\":1,\"361\":2,\"463\":1,\"464\":1,\"465\":1,\"477\":1,\"480\":1}}],[\"overflow\",{\"1\":{\"123\":2,\"516\":2}}],[\"orm\",{\"0\":{\"655\":1,\"734\":1,\"744\":2,\"754\":1},\"1\":{\"655\":1,\"656\":2}}],[\"order\",{\"1\":{\"598\":2,\"599\":1,\"601\":1,\"614\":1,\"616\":1,\"618\":2}}],[\"orderservice\",{\"1\":{\"598\":2,\"599\":1}}],[\"ordering\",{\"1\":{\"316\":1}}],[\"org\",{\"1\":{\"428\":1}}],[\"ortimeout\",{\"0\":{\"380\":1},\"1\":{\"380\":1}}],[\"orelse\",{\"1\":{\"243\":1}}],[\"oriented\",{\"1\":{\"138\":1,\"649\":1}}],[\"oracle在jdk\",{\"1\":{\"114\":1}}],[\"oracle收购bea后\",{\"1\":{\"114\":1}}],[\"oracle收购bea后的整合\",{\"1\":{\"114\":1}}],[\"oopmap\",{\"0\":{\"138\":1},\"1\":{\"138\":1}}],[\"oom异常会被明确标记\",{\"1\":{\"90\":1}}],[\"outer\",{\"1\":{\"311\":3,\"312\":1}}],[\"outerfield\",{\"1\":{\"311\":2,\"312\":2}}],[\"outerclass\",{\"1\":{\"311\":3,\"312\":1}}],[\"outputstream\",{\"1\":{\"236\":1}}],[\"out\",{\"1\":{\"124\":2,\"172\":1,\"173\":1,\"190\":3,\"204\":1,\"207\":2,\"215\":1,\"220\":1,\"243\":1,\"244\":4,\"252\":1,\"282\":4,\"311\":1,\"312\":1,\"335\":1,\"353\":3,\"355\":4,\"357\":3,\"361\":4,\"370\":1,\"371\":1,\"375\":1,\"383\":2,\"385\":1,\"392\":2,\"398\":1,\"407\":1,\"409\":1,\"428\":1,\"432\":1,\"436\":3,\"440\":1,\"467\":1,\"477\":2,\"480\":1}}],[\"outofmemoryerror\",{\"1\":{\"89\":1,\"90\":2,\"113\":1,\"124\":2,\"516\":1}}],[\"oldvalue\",{\"1\":{\"554\":3}}],[\"oldcapacity\",{\"1\":{\"516\":5}}],[\"oldlen\",{\"1\":{\"334\":2}}],[\"oldtab\",{\"1\":{\"334\":4}}],[\"old是parallel\",{\"1\":{\"137\":1}}],[\"old是serial收集器的老年代版本\",{\"1\":{\"137\":1}}],[\"old收集器\",{\"1\":{\"137\":2}}],[\"old\",{\"0\":{\"133\":1},\"1\":{\"92\":1,\"130\":1,\"133\":1,\"141\":1}}],[\"oldgeneration\",{\"1\":{\"87\":1}}],[\"osgi\",{\"1\":{\"224\":1}}],[\"osgi等框架\",{\"0\":{\"218\":1}}],[\"os\",{\"1\":{\"89\":1}}],[\"ognl\",{\"1\":{\"56\":1}}],[\"o等待时间等\",{\"1\":{\"54\":1}}],[\"o等信息\",{\"1\":{\"54\":1}}],[\"o性能\",{\"1\":{\"54\":1}}],[\"onlyifabsent\",{\"1\":{\"554\":1}}],[\"once\",{\"1\":{\"177\":1}}],[\"on\",{\"1\":{\"16\":1,\"477\":1}}],[\"offset\",{\"1\":{\"51\":1,\"511\":6}}],[\"of\",{\"1\":{\"11\":1,\"243\":1,\"383\":1}}],[\"obj\",{\"1\":{\"128\":1,\"190\":1,\"204\":2,\"274\":1}}],[\"object数据对象\",{\"1\":{\"649\":1}}],[\"objectinputstream\",{\"1\":{\"519\":1}}],[\"objectoutputstream\",{\"1\":{\"519\":1}}],[\"objectmonitor\",{\"1\":{\"485\":1}}],[\"objectmonitor有两个队列\",{\"1\":{\"485\":1}}],[\"objectmonitor的工作原理\",{\"1\":{\"485\":1}}],[\"object类方法\",{\"1\":{\"344\":1}}],[\"object类提供的clone\",{\"1\":{\"307\":1}}],[\"object作为value的结构\",{\"1\":{\"332\":1}}],[\"object\",{\"0\":{\"274\":1},\"1\":{\"121\":1,\"128\":2,\"138\":1,\"204\":1,\"207\":1,\"215\":1,\"220\":1,\"274\":1,\"303\":1,\"485\":1,\"505\":1,\"511\":3,\"532\":2,\"649\":1}}],[\"ob\",{\"1\":{\"11\":4}}],[\"29\",{\"1\":{\"649\":1}}],[\"29452\",{\"1\":{\"89\":2}}],[\"29471\",{\"1\":{\"89\":3}}],[\"28\",{\"1\":{\"649\":1}}],[\"27\",{\"1\":{\"649\":1}}],[\"26\",{\"1\":{\"649\":1}}],[\"24\",{\"1\":{\"649\":1}}],[\"246\",{\"1\":{\"11\":1}}],[\"23\",{\"1\":{\"649\":1}}],[\"21\",{\"1\":{\"649\":1}}],[\"2规约\",{\"1\":{\"640\":1}}],[\"2中\",{\"1\":{\"636\":1}}],[\"2和图1\",{\"1\":{\"627\":1}}],[\"2^63\",{\"1\":{\"258\":2}}],[\"2^15\",{\"1\":{\"258\":2}}],[\"2^31\",{\"1\":{\"258\":2}}],[\"20210801100955653\",{\"1\":{\"602\":1}}],[\"20210801100308102\",{\"1\":{\"601\":1}}],[\"20210801100231495\",{\"1\":{\"601\":1}}],[\"20210801100201253\",{\"1\":{\"601\":1}}],[\"20210801101455590\",{\"1\":{\"592\":1}}],[\"20210801101410200\",{\"1\":{\"592\":1}}],[\"20210801101314816\",{\"1\":{\"592\":1}}],[\"20210801101207444\",{\"1\":{\"592\":1}}],[\"20210801095951030\",{\"1\":{\"600\":1}}],[\"20210801095320586\",{\"1\":{\"598\":1}}],[\"20210801095205034\",{\"1\":{\"598\":1}}],[\"20210731181341330\",{\"1\":{\"598\":1}}],[\"20210731180921742\",{\"1\":{\"594\":1}}],[\"20210731180321133\",{\"1\":{\"590\":1}}],[\"20210731175806273\",{\"1\":{\"589\":1}}],[\"20210731175155453\",{\"1\":{\"587\":1}}],[\"20210731173809877\",{\"1\":{\"584\":1}}],[\"20210731173746910\",{\"1\":{\"584\":1}}],[\"20210731173541846\",{\"1\":{\"582\":1}}],[\"20210731172440275\",{\"1\":{\"581\":1}}],[\"20210731164717604\",{\"1\":{\"579\":1}}],[\"20210731164455818\",{\"1\":{\"579\":1}}],[\"20210731164159811\",{\"1\":{\"579\":1}}],[\"20210731163255863\",{\"1\":{\"578\":1}}],[\"20210731161950495\",{\"1\":{\"577\":1}}],[\"20210731161746245\",{\"1\":{\"574\":1}}],[\"20210731161354344\",{\"1\":{\"574\":1}}],[\"20210731161104732\",{\"1\":{\"574\":1}}],[\"20210731155903037\",{\"1\":{\"573\":1}}],[\"20210731155856199\",{\"1\":{\"573\":1}}],[\"20210731155844368\",{\"1\":{\"573\":1}}],[\"20210731155649535\",{\"1\":{\"572\":1}}],[\"20210731155141362\",{\"1\":{\"571\":1}}],[\"20210731155002425\",{\"1\":{\"569\":1}}],[\"20210731154257653\",{\"1\":{\"567\":1}}],[\"20210731153743354\",{\"1\":{\"566\":1}}],[\"20210731153059464\",{\"1\":{\"565\":1}}],[\"20210731152243765\",{\"1\":{\"563\":1}}],[\"20210731145914960\",{\"1\":{\"563\":1}}],[\"20210731144820638\",{\"1\":{\"561\":1}}],[\"20210731144458680\",{\"1\":{\"561\":1}}],[\"20210731144304990\",{\"1\":{\"561\":1}}],[\"20210731143401460\",{\"1\":{\"561\":1}}],[\"20210731142219735\",{\"1\":{\"560\":1}}],[\"20210731141907366\",{\"1\":{\"559\":1}}],[\"2000\",{\"1\":{\"383\":1,\"385\":1,\"407\":1,\"409\":1,\"436\":1}}],[\"20\",{\"1\":{\"86\":1,\"649\":1}}],[\"25镜像构建的容器\",{\"1\":{\"595\":1}}],[\"255\",{\"1\":{\"51\":1}}],[\"25\",{\"1\":{\"11\":1,\"595\":1,\"598\":3,\"649\":1}}],[\"2\",{\"0\":{\"29\":1,\"59\":1,\"79\":1,\"185\":1,\"193\":1,\"200\":1,\"210\":1,\"216\":1,\"227\":1,\"366\":1,\"367\":1,\"370\":1,\"374\":1,\"378\":1,\"381\":1,\"389\":1,\"390\":1,\"391\":2,\"395\":1,\"404\":1,\"413\":1,\"414\":1,\"415\":1,\"416\":2,\"419\":1,\"425\":1,\"443\":1,\"458\":1,\"463\":1,\"470\":1,\"560\":1,\"563\":1,\"566\":1,\"570\":1,\"571\":1,\"572\":2,\"573\":1,\"574\":1,\"575\":1,\"576\":2,\"577\":2,\"578\":3,\"579\":2,\"580\":2,\"581\":1,\"582\":1,\"583\":2,\"584\":1,\"585\":1,\"586\":1,\"587\":1,\"588\":1,\"590\":1,\"593\":1,\"596\":1,\"599\":1,\"604\":1,\"645\":1,\"646\":1,\"647\":1},\"1\":{\"11\":8,\"165\":1,\"172\":1,\"173\":1,\"222\":2,\"258\":2,\"264\":1,\"282\":5,\"317\":1,\"334\":2,\"355\":11,\"380\":1,\"381\":1,\"432\":1,\"480\":2,\"493\":1,\"549\":1,\"561\":1,\"573\":1,\"574\":1,\"575\":1,\"579\":1,\"587\":1,\"598\":1,\"610\":1,\"617\":1,\"618\":2,\"622\":1,\"624\":1,\"627\":1,\"631\":1,\"635\":1,\"636\":1,\"649\":1}}],[\"220kv及以上等级智能变电站\",{\"1\":{\"644\":1}}],[\"22\",{\"1\":{\"11\":1,\"649\":1}}],[\"ln\",{\"1\":{\"649\":1}}],[\"ld\",{\"1\":{\"649\":1}}],[\"lpct\",{\"1\":{\"635\":1}}],[\"ls\",{\"1\":{\"583\":1,\"584\":2}}],[\"lsof\",{\"1\":{\"54\":1}}],[\"l\",{\"1\":{\"513\":2}}],[\"lazy\",{\"0\":{\"666\":1,\"686\":1}}],[\"last\",{\"1\":{\"610\":1,\"612\":3,\"617\":1,\"618\":8}}],[\"latest打包为一个redis\",{\"1\":{\"575\":1}}],[\"latest\",{\"1\":{\"574\":2,\"575\":1,\"604\":1}}],[\"latch数量减1\",{\"1\":{\"353\":1}}],[\"lambda\",{\"0\":{\"241\":1},\"1\":{\"240\":5,\"241\":2}}],[\"launcher$extclassloader\",{\"1\":{\"207\":1}}],[\"launcher$appclassloader\",{\"1\":{\"207\":1}}],[\"lang包\",{\"1\":{\"234\":1}}],[\"lang\",{\"1\":{\"17\":1,\"89\":1,\"90\":1,\"113\":1,\"194\":1,\"195\":1,\"196\":1,\"199\":2,\"200\":1,\"201\":1,\"202\":1,\"206\":1,\"207\":1,\"222\":1,\"303\":1}}],[\"language\",{\"1\":{\"11\":1,\"277\":1}}],[\"len\",{\"1\":{\"334\":1}}],[\"length\",{\"1\":{\"51\":1,\"204\":1,\"215\":1,\"220\":1,\"332\":1,\"334\":1,\"516\":1,\"531\":2,\"532\":1,\"549\":4}}],[\"level\",{\"1\":{\"319\":1}}],[\"leak\",{\"1\":{\"123\":2}}],[\"limit\",{\"0\":{\"615\":1},\"1\":{\"614\":1,\"615\":2,\"616\":1,\"618\":2,\"619\":2}}],[\"linkedlist每个节点\",{\"1\":{\"515\":1}}],[\"linkedlist基于链表\",{\"1\":{\"515\":2}}],[\"linkedlist基于链表实现\",{\"1\":{\"515\":1}}],[\"linkedlist基于双向链表实现\",{\"1\":{\"515\":1}}],[\"linkedlist更利于增删\",{\"1\":{\"515\":1}}],[\"linkedblockingqueue<>\",{\"1\":{\"465\":1,\"477\":1}}],[\"linkedblockingqueue<runnable>\",{\"1\":{\"442\":1,\"457\":1,\"459\":1}}],[\"linkedblockingqueue\",{\"1\":{\"400\":1,\"477\":1}}],[\"linkedhashmap在\",{\"1\":{\"551\":1}}],[\"linkedhashmap\",{\"0\":{\"551\":1},\"1\":{\"291\":1,\"550\":1,\"551\":1}}],[\"linking\",{\"1\":{\"183\":1}}],[\"linux\",{\"1\":{\"247\":1}}],[\"lib\",{\"1\":{\"200\":1,\"582\":1,\"584\":1,\"586\":1,\"595\":1,\"598\":1}}],[\"lib目录下\",{\"1\":{\"199\":1}}],[\"list归约成一个值\",{\"1\":{\"244\":1}}],[\"list<integer>\",{\"1\":{\"432\":1}}],[\"list<string>\",{\"1\":{\"244\":1,\"383\":1}}],[\"list<byte\",{\"1\":{\"124\":1}}],[\"list\",{\"0\":{\"514\":1},\"1\":{\"124\":3,\"244\":3,\"383\":2,\"385\":1,\"432\":1,\"556\":1}}],[\"listed\",{\"1\":{\"11\":1}}],[\"literals\",{\"1\":{\"103\":1}}],[\"live\",{\"1\":{\"86\":1,\"89\":2}}],[\"lost\",{\"1\":{\"549\":1}}],[\"lower\",{\"1\":{\"334\":1}}],[\"lockinterruptibly\",{\"1\":{\"495\":1}}],[\"lock\",{\"0\":{\"500\":1},\"1\":{\"485\":2,\"501\":2,\"509\":1,\"549\":1}}],[\"lock接口等\",{\"1\":{\"318\":2}}],[\"lock接口\",{\"1\":{\"318\":1}}],[\"localarea\",{\"1\":{\"644\":1}}],[\"locals\",{\"1\":{\"336\":2}}],[\"localvariable\",{\"1\":{\"326\":3}}],[\"localhost\",{\"1\":{\"11\":2,\"12\":1,\"428\":1}}],[\"local\",{\"0\":{\"119\":1},\"1\":{\"11\":3,\"117\":1,\"119\":1,\"315\":1,\"412\":1,\"592\":1}}],[\"lombok\",{\"1\":{\"289\":1}}],[\"long长期的\",{\"1\":{\"649\":1}}],[\"long类型\",{\"1\":{\"244\":1}}],[\"long\",{\"0\":{\"262\":1},\"1\":{\"244\":1,\"258\":2,\"262\":1,\"274\":2,\"344\":4,\"351\":2,\"353\":1,\"355\":1,\"357\":1,\"463\":1,\"511\":3,\"649\":1}}],[\"load加载镜像\",{\"1\":{\"574\":1}}],[\"load的语法\",{\"1\":{\"574\":1}}],[\"loadstore\",{\"1\":{\"324\":1}}],[\"loadload\",{\"1\":{\"324\":1}}],[\"load\",{\"1\":{\"252\":2,\"574\":1,\"575\":1}}],[\"loaded\",{\"1\":{\"215\":2,\"220\":2}}],[\"loader\",{\"1\":{\"179\":1,\"252\":4,\"336\":1}}],[\"loadclassbytes\",{\"1\":{\"220\":2}}],[\"loadclass方法\",{\"0\":{\"216\":1},\"1\":{\"216\":1}}],[\"loadclass\",{\"1\":{\"204\":1,\"215\":4,\"220\":1,\"222\":1,\"233\":6}}],[\"loadclassdata\",{\"1\":{\"204\":2}}],[\"loading\",{\"0\":{\"184\":1,\"666\":1,\"686\":2},\"1\":{\"183\":1}}],[\"logical\",{\"1\":{\"649\":2}}],[\"logs\",{\"1\":{\"580\":1}}],[\"logstash和kibana\",{\"1\":{\"64\":1}}],[\"log\",{\"1\":{\"75\":1,\"528\":1,\"543\":1}}],[\"logger\",{\"1\":{\"56\":1}}],[\"afternodeaccess\",{\"1\":{\"554\":1}}],[\"afterexecute\",{\"1\":{\"463\":3}}],[\"aqs是一个一个fifo的双向队列\",{\"1\":{\"496\":1}}],[\"aqs\",{\"1\":{\"496\":3,\"500\":2}}],[\"aqs了解多少\",{\"0\":{\"496\":1}}],[\"acsi\",{\"1\":{\"636\":1}}],[\"accelerate加速\",{\"1\":{\"649\":1}}],[\"accept\",{\"1\":{\"424\":1}}],[\"acc\",{\"1\":{\"484\":1,\"485\":1,\"649\":1}}],[\"acquiredwithtimeout\",{\"1\":{\"359\":1}}],[\"acquired\",{\"1\":{\"359\":1}}],[\"acquire\",{\"1\":{\"357\":1,\"358\":1,\"359\":1}}],[\"ack\",{\"1\":{\"51\":1}}],[\"acknowledgment\",{\"1\":{\"51\":1}}],[\"awaittermination\",{\"1\":{\"392\":1,\"407\":1,\"409\":1,\"432\":1,\"440\":1,\"446\":1,\"452\":1}}],[\"await\",{\"1\":{\"353\":6,\"355\":2}}],[\"avoid\",{\"1\":{\"334\":1}}],[\"available\",{\"1\":{\"215\":1}}],[\"asci\",{\"1\":{\"636\":1}}],[\"asynctaskexample\",{\"1\":{\"436\":1}}],[\"aslist\",{\"1\":{\"432\":1}}],[\"as\",{\"0\":{\"321\":1},\"1\":{\"320\":1,\"321\":1}}],[\"aba\",{\"0\":{\"504\":1},\"1\":{\"503\":1}}],[\"abortpolicy\",{\"1\":{\"449\":1}}],[\"abstractqueuedsynchronizer\",{\"1\":{\"496\":1}}],[\"abstract\",{\"0\":{\"299\":1}}],[\"abc\",{\"0\":{\"269\":2},\"1\":{\"269\":6}}],[\"autowired\",{\"1\":{\"289\":1}}],[\"autoboxcachemax=来修改缓存的最大值\",{\"1\":{\"272\":1}}],[\"aop\",{\"1\":{\"289\":1}}],[\"a1==b1的结果是false\",{\"1\":{\"272\":1}}],[\"a=\",{\"0\":{\"272\":1},\"1\":{\"272\":1}}],[\"a+b拼接后的对象位于堆中\",{\"1\":{\"270\":1}}],[\"a和b初始化时位于字符串常量池\",{\"1\":{\"270\":1}}],[\"aaa1\",{\"1\":{\"244\":1}}],[\"aaa2\",{\"1\":{\"244\":1}}],[\"aio\",{\"0\":{\"238\":1},\"1\":{\"238\":1}}],[\"annotated\",{\"1\":{\"289\":1}}],[\"annotation\",{\"1\":{\"289\":1}}],[\"anymatch\",{\"1\":{\"244\":1}}],[\"anystartswitha\",{\"1\":{\"244\":1}}],[\"anywhere\",{\"1\":{\"177\":1}}],[\"analysis\",{\"0\":{\"164\":1}}],[\"and\",{\"1\":{\"51\":1,\"120\":1,\"131\":2,\"502\":1,\"510\":1,\"647\":1}}],[\"alpine\",{\"1\":{\"593\":1,\"594\":1,\"598\":1}}],[\"alpine作为基础镜像\",{\"1\":{\"593\":1}}],[\"alpine镜像\",{\"1\":{\"593\":1}}],[\"always\",{\"1\":{\"532\":1}}],[\"allof\",{\"0\":{\"375\":1},\"1\":{\"375\":3,\"383\":3,\"385\":3}}],[\"allocation\",{\"0\":{\"119\":1},\"1\":{\"117\":1,\"119\":1,\"164\":1}}],[\"allmatch\",{\"1\":{\"244\":1}}],[\"allstartswitha\",{\"1\":{\"244\":2}}],[\"already\",{\"1\":{\"11\":1}}],[\"artifactid>\",{\"1\":{\"600\":1}}],[\"arthas工具\",{\"0\":{\"56\":1}}],[\"array\",{\"1\":{\"516\":1}}],[\"arrays\",{\"1\":{\"432\":2}}],[\"arrayblockingqueue<>\",{\"1\":{\"409\":1}}],[\"arrayblockingqueue\",{\"1\":{\"400\":1,\"409\":1}}],[\"arraylist通过两个方法readobject\",{\"1\":{\"519\":1}}],[\"arraylist的序列化不太一样\",{\"1\":{\"517\":1}}],[\"arraylist的扩容机制了解吗\",{\"0\":{\"516\":1}}],[\"arraylist怎么序列化的知道吗\",{\"0\":{\"517\":1}}],[\"arraylist是预先定义好的数组\",{\"1\":{\"515\":1}}],[\"arraylist基于数组\",{\"1\":{\"515\":2}}],[\"arraylist基于数组实现\",{\"1\":{\"515\":2}}],[\"arraylist增删如果是数组末尾的位置\",{\"1\":{\"515\":1}}],[\"arraylist更利于查找\",{\"1\":{\"515\":1}}],[\"arraylist和linkedlist有什么区别\",{\"0\":{\"515\":1}}],[\"arraylist<>\",{\"1\":{\"124\":1,\"244\":1}}],[\"arraylist\",{\"1\":{\"124\":1}}],[\"arg\",{\"1\":{\"285\":1}}],[\"args\",{\"1\":{\"104\":1,\"109\":1,\"124\":2,\"172\":1,\"173\":1,\"190\":1,\"204\":1,\"207\":1,\"215\":1,\"220\":1,\"282\":3,\"311\":1,\"312\":1,\"335\":1,\"353\":2,\"355\":1,\"357\":1,\"361\":1,\"383\":1,\"385\":1,\"392\":1,\"407\":1,\"409\":1,\"424\":1,\"428\":1,\"432\":1,\"436\":1,\"440\":1,\"467\":1,\"477\":1,\"480\":1,\"505\":1}}],[\"area\",{\"1\":{\"92\":1,\"94\":1,\"179\":2}}],[\"addr\",{\"1\":{\"599\":1}}],[\"address=8000\",{\"1\":{\"75\":1}}],[\"adding\",{\"1\":{\"549\":1}}],[\"add方法有锁\",{\"1\":{\"523\":1}}],[\"addshutdownhook\",{\"1\":{\"440\":1}}],[\"add\",{\"1\":{\"124\":1,\"244\":8,\"554\":1}}],[\"added\",{\"1\":{\"11\":2}}],[\"apache\",{\"1\":{\"428\":1}}],[\"api遍历\",{\"1\":{\"292\":1}}],[\"api提供了一种更简洁\",{\"1\":{\"240\":1}}],[\"api\",{\"1\":{\"234\":1,\"240\":2,\"479\":7,\"656\":1}}],[\"app\",{\"1\":{\"592\":2,\"593\":3,\"598\":3}}],[\"appclassloader的父加载器是扩展类加载器\",{\"1\":{\"207\":1}}],[\"appclassloader\",{\"1\":{\"207\":1,\"234\":1}}],[\"application\",{\"0\":{\"201\":1},\"1\":{\"195\":1,\"599\":1}}],[\"appdynamics\",{\"0\":{\"66\":1},\"1\":{\"66\":1,\"70\":2}}],[\"apm工具\",{\"1\":{\"68\":1,\"70\":1}}],[\"apm\",{\"1\":{\"65\":1,\"70\":1}}],[\"attribute数据属性\",{\"1\":{\"649\":1}}],[\"attribute功能约束数据属性\",{\"1\":{\"649\":1}}],[\"attached\",{\"1\":{\"336\":1}}],[\"atomicreference等\",{\"1\":{\"510\":1}}],[\"atomiclong\",{\"1\":{\"510\":1}}],[\"atomicinteger\",{\"0\":{\"511\":1},\"1\":{\"510\":1}}],[\"atomicity\",{\"1\":{\"316\":1}}],[\"atomic类等\",{\"1\":{\"318\":1}}],[\"at\",{\"1\":{\"11\":1,\"90\":1}}],[\"a\",{\"0\":{\"106\":1,\"108\":1},\"1\":{\"11\":3,\"70\":1,\"104\":1,\"106\":1,\"108\":7,\"109\":1,\"110\":2,\"220\":2,\"238\":1,\"244\":7,\"502\":3,\"504\":1,\"580\":1,\"593\":1,\"631\":1,\"634\":2}}],[\"ssd\",{\"1\":{\"649\":1}}],[\"sv\",{\"1\":{\"644\":1,\"649\":1}}],[\"sv采样需求及goose开入\",{\"1\":{\"638\":1}}],[\"smart\",{\"1\":{\"621\":1}}],[\"smith\",{\"1\":{\"610\":1,\"612\":1,\"617\":1,\"618\":2}}],[\"sqlsession是与数据库交互的主要接口\",{\"1\":{\"656\":1}}],[\"sqlsession\",{\"1\":{\"656\":1}}],[\"sqlsessionfactory的主要功能是加载映射文件以及配置信息\",{\"1\":{\"656\":1}}],[\"sqlsessionfactory是一个工厂类\",{\"1\":{\"656\":1}}],[\"sqlsessionfactory\",{\"1\":{\"656\":1}}],[\"sqlsessionfactorybuilder负责读取mybatis的配置信息\",{\"1\":{\"656\":1}}],[\"sqlsessionfactorybuilder\",{\"1\":{\"656\":1}}],[\"sql控制\",{\"1\":{\"655\":1}}],[\"sqlexception\",{\"1\":{\"428\":2}}],[\"sql\",{\"0\":{\"659\":2,\"670\":2,\"674\":2,\"678\":1,\"688\":1,\"691\":1,\"695\":3,\"696\":3,\"700\":2,\"703\":2,\"710\":3,\"711\":1,\"715\":2,\"726\":1,\"731\":1,\"733\":3,\"736\":2,\"739\":1,\"742\":2,\"746\":1,\"751\":1,\"753\":3,\"783\":1},\"1\":{\"428\":4,\"606\":1,\"613\":1,\"615\":1,\"619\":1,\"656\":15}}],[\"sleep\",{\"1\":{\"344\":1,\"353\":2,\"355\":1,\"357\":1,\"380\":1,\"381\":1,\"383\":3,\"385\":3,\"392\":1,\"407\":1,\"409\":1,\"432\":1,\"436\":1,\"477\":1}}],[\"signal信号\",{\"1\":{\"649\":1}}],[\"sig\",{\"1\":{\"649\":1}}],[\"simplewebserver\",{\"1\":{\"424\":3}}],[\"singlethreadexecutor\",{\"0\":{\"459\":1},\"1\":{\"406\":2,\"455\":1}}],[\"singlethreadpool\",{\"1\":{\"396\":1}}],[\"singleton\",{\"1\":{\"319\":2}}],[\"sizectl\",{\"1\":{\"549\":5}}],[\"size\",{\"1\":{\"334\":3,\"336\":1,\"516\":1}}],[\"sz\",{\"1\":{\"334\":2}}],[\"specification\",{\"1\":{\"649\":1}}],[\"specification制造报文规范\",{\"1\":{\"649\":1}}],[\"spring事务等\",{\"1\":{\"656\":1}}],[\"springframework\",{\"1\":{\"600\":1}}],[\"spring里的很多注解\",{\"1\":{\"255\":1}}],[\"spring\",{\"0\":{\"684\":1,\"720\":1,\"791\":1},\"1\":{\"255\":2,\"599\":1}}],[\"spin\",{\"1\":{\"549\":1}}],[\"spinclock\",{\"1\":{\"485\":1}}],[\"spinfreq\",{\"1\":{\"485\":1}}],[\"spi机制的应用场景\",{\"1\":{\"252\":1}}],[\"spi机制的优势\",{\"1\":{\"252\":1}}],[\"spi机制的工作原理如下\",{\"1\":{\"252\":1}}],[\"spi中的几个关键元素\",{\"1\":{\"252\":1}}],[\"space错误\",{\"1\":{\"113\":1}}],[\"space\",{\"1\":{\"90\":1,\"92\":2}}],[\"sdk\",{\"1\":{\"247\":1}}],[\"s2\",{\"1\":{\"244\":2}}],[\"s1\",{\"1\":{\"244\":2}}],[\"s\",{\"1\":{\"243\":2,\"244\":12,\"269\":1,\"273\":3,\"579\":2}}],[\"sampled\",{\"1\":{\"649\":1}}],[\"sampling\",{\"1\":{\"644\":1}}],[\"sas\",{\"1\":{\"636\":1}}],[\"save命令将\",{\"1\":{\"575\":1}}],[\"save导出镜像到磁盘\",{\"1\":{\"574\":1}}],[\"save\",{\"1\":{\"574\":3}}],[\"save和docker\",{\"1\":{\"574\":1}}],[\"save将nginx镜像导出磁盘\",{\"1\":{\"574\":1}}],[\"sayhello\",{\"1\":{\"215\":2,\"220\":2,\"252\":3}}],[\"safe\",{\"0\":{\"520\":1},\"1\":{\"138\":1,\"520\":1}}],[\"sar\",{\"1\":{\"54\":1}}],[\"share\",{\"1\":{\"579\":3,\"582\":1,\"586\":2}}],[\"shared表示是获取共享资源时被阻塞挂起后放入aqs队列的\",{\"1\":{\"496\":1}}],[\"sharedclassloader\",{\"1\":{\"234\":1}}],[\"shift\",{\"1\":{\"549\":1}}],[\"shutdownnow\",{\"1\":{\"392\":2,\"407\":2,\"409\":2,\"432\":2,\"440\":2,\"446\":3,\"452\":6,\"471\":1}}],[\"shutdown\",{\"0\":{\"470\":1},\"1\":{\"392\":1,\"407\":1,\"409\":1,\"432\":1,\"436\":1,\"440\":1,\"446\":2,\"452\":4,\"467\":1,\"470\":3,\"472\":1,\"477\":2}}],[\"short\",{\"1\":{\"258\":2,\"262\":1}}],[\"shouldprefetch\",{\"1\":{\"17\":1}}],[\"shenandoah\",{\"1\":{\"159\":1}}],[\"shenandoah是一种低延迟的垃圾收集器\",{\"1\":{\"137\":1}}],[\"shenandoah收集器\",{\"1\":{\"137\":1}}],[\"switch\",{\"0\":{\"262\":1},\"1\":{\"262\":1}}],[\"sweep\",{\"1\":{\"131\":1,\"137\":1,\"139\":3,\"140\":1,\"146\":1,\"151\":1,\"159\":1}}],[\"swap\",{\"1\":{\"120\":1,\"502\":1,\"510\":1}}],[\"systems\",{\"1\":{\"647\":1}}],[\"system\",{\"1\":{\"124\":2,\"135\":1,\"172\":1,\"173\":1,\"190\":3,\"204\":1,\"207\":2,\"215\":1,\"220\":1,\"243\":1,\"244\":4,\"252\":1,\"281\":1,\"282\":4,\"303\":1,\"311\":1,\"312\":1,\"335\":1,\"336\":1,\"353\":3,\"355\":4,\"357\":3,\"361\":4,\"370\":1,\"371\":1,\"375\":1,\"383\":2,\"385\":1,\"392\":2,\"398\":1,\"407\":1,\"409\":1,\"428\":1,\"432\":1,\"436\":3,\"440\":2,\"465\":1,\"467\":1,\"477\":2,\"480\":1,\"649\":1}}],[\"sync\",{\"1\":{\"501\":2}}],[\"synchronous\",{\"1\":{\"450\":1}}],[\"synchronousqueue<runnable>\",{\"1\":{\"458\":1}}],[\"synchronousqueue\",{\"1\":{\"448\":1}}],[\"synchronizedmap\",{\"1\":{\"546\":1}}],[\"synchronizedlist包装arraylist\",{\"1\":{\"521\":1}}],[\"synchronized与wait\",{\"1\":{\"495\":1}}],[\"synchronized的性能比reentrantlock差很多\",{\"1\":{\"495\":1}}],[\"synchronized的实现原理\",{\"0\":{\"483\":1}}],[\"synchronized是java语言的关键字\",{\"1\":{\"495\":1}}],[\"synchronized是怎么加锁的呢\",{\"0\":{\"484\":1}}],[\"synchronized做了哪些优化\",{\"0\":{\"491\":1}}],[\"synchronized优化了解吗\",{\"0\":{\"490\":1}}],[\"synchronized怎么实现可重入的呢\",{\"0\":{\"489\":1}}],[\"synchronized怎么保证有序性\",{\"0\":{\"488\":1}}],[\"synchronized怎么保证可见性\",{\"0\":{\"487\":1}}],[\"synchronized同步的代码块\",{\"1\":{\"488\":1}}],[\"synchronized可见性\",{\"0\":{\"486\":1}}],[\"synchronized锁住的是什么呢\",{\"0\":{\"485\":1}}],[\"synchronized修饰代码块时\",{\"1\":{\"484\":1}}],[\"synchronized\",{\"1\":{\"482\":5,\"484\":1,\"485\":2,\"489\":2,\"495\":1,\"546\":1}}],[\"synchronized用过吗\",{\"0\":{\"482\":1}}],[\"synchronized关键字等\",{\"1\":{\"316\":1}}],[\"synchronization\",{\"1\":{\"164\":1}}],[\"syn\",{\"1\":{\"51\":1}}],[\"succ\",{\"1\":{\"485\":1}}],[\"suppresswarnings\",{\"1\":{\"549\":1}}],[\"supplyasync\",{\"1\":{\"367\":2,\"369\":1,\"370\":1,\"371\":1,\"373\":2,\"374\":2,\"375\":3,\"377\":1,\"378\":1,\"380\":1,\"381\":1,\"383\":3,\"385\":3,\"388\":1,\"389\":1,\"391\":1,\"392\":1,\"398\":1}}],[\"supplier\",{\"1\":{\"242\":1}}],[\"super\",{\"1\":{\"215\":2,\"220\":1,\"335\":1,\"460\":1,\"463\":2}}],[\"sun\",{\"1\":{\"207\":2}}],[\"substations\",{\"1\":{\"647\":1}}],[\"substation\",{\"1\":{\"644\":1,\"649\":2}}],[\"subsystem\",{\"1\":{\"179\":1}}],[\"submit\",{\"1\":{\"407\":1,\"409\":1,\"424\":1,\"432\":1,\"436\":1,\"443\":1,\"451\":3,\"462\":1,\"467\":1,\"477\":2}}],[\"subdependencies\",{\"1\":{\"11\":1}}],[\"sum\",{\"1\":{\"172\":2,\"173\":2}}],[\"survivor区不足\",{\"1\":{\"134\":1}}],[\"survivor区通常有两个\",{\"1\":{\"132\":1}}],[\"survivor区是用于存放经过一次minor\",{\"1\":{\"132\":1}}],[\"survivor区用来保存经过一次gc后仍然存活的对象\",{\"1\":{\"130\":1}}],[\"survivor区\",{\"1\":{\"130\":1,\"132\":2}}],[\"survivor\",{\"1\":{\"92\":1}}],[\"suspend=n\",{\"1\":{\"75\":1}}],[\"some\",{\"1\":{\"614\":1}}],[\"sorted\",{\"1\":{\"244\":4}}],[\"soft\",{\"1\":{\"128\":1}}],[\"socket\",{\"1\":{\"75\":1,\"424\":3}}],[\"source\",{\"1\":{\"51\":1,\"289\":2}}],[\"sourcemap\",{\"1\":{\"11\":1}}],[\"scd\",{\"1\":{\"644\":1,\"649\":1}}],[\"scd文件是设计人员经过综合变电站的各种功能需求进行完善的设计后\",{\"1\":{\"638\":1}}],[\"scd文件应包含版本修改信息\",{\"1\":{\"638\":1}}],[\"scd文件由系统集成厂商根据变电站设计图纸\",{\"1\":{\"638\":1}}],[\"scd文件指的是什么\",{\"0\":{\"638\":1}}],[\"scsm\",{\"1\":{\"636\":1}}],[\"scheduleatfixedrate\",{\"1\":{\"440\":1}}],[\"scheduler\",{\"1\":{\"440\":6}}],[\"scheduledtaskexample\",{\"1\":{\"440\":1}}],[\"scheduledthreadpoolexecutor\",{\"1\":{\"460\":1}}],[\"scheduledthreadpool\",{\"0\":{\"460\":1},\"1\":{\"397\":1,\"406\":2,\"455\":1}}],[\"scheduledexecutorservice\",{\"1\":{\"397\":1,\"406\":1,\"440\":2}}],[\"scada\",{\"1\":{\"628\":1}}],[\"scalarreplacementexample\",{\"1\":{\"172\":3,\"173\":3,\"174\":1}}],[\"scalar\",{\"1\":{\"164\":1,\"169\":1}}],[\"scanning\",{\"1\":{\"141\":1,\"142\":1}}],[\"scavenge收集器的老年代版本\",{\"1\":{\"137\":1}}],[\"scavenge收集器也是针对新生代的收集器\",{\"1\":{\"137\":1}}],[\"scavenge收集器\",{\"1\":{\"137\":1}}],[\"sc\",{\"1\":{\"56\":1,\"549\":13}}],[\"scripting\",{\"0\":{\"688\":1},\"1\":{\"656\":3}}],[\"script\",{\"1\":{\"11\":1}}],[\"sed\",{\"1\":{\"579\":1}}],[\"segment如果是空就先初始化\",{\"1\":{\"548\":1}}],[\"segment之间相互不会受到影响\",{\"1\":{\"548\":1}}],[\"segment则包含hashentry的数组\",{\"1\":{\"548\":1}}],[\"segment继承于reentrantlock\",{\"1\":{\"548\":1}}],[\"sendemail\",{\"1\":{\"436\":2}}],[\"seconds\",{\"1\":{\"359\":1,\"363\":1,\"380\":1,\"381\":1,\"407\":1,\"409\":2,\"432\":1,\"440\":2,\"442\":1,\"446\":1,\"452\":1,\"458\":1}}],[\"semaphore可以设置为公平模式\",{\"1\":{\"359\":1}}],[\"semaphoreexample\",{\"1\":{\"357\":1}}],[\"semaphore\",{\"0\":{\"357\":1},\"1\":{\"357\":5,\"358\":1,\"359\":3}}],[\"setqueue\",{\"1\":{\"475\":1}}],[\"setcorepoolsize\",{\"1\":{\"475\":1}}],[\"setcontextclassloader方法可以设置当前线程的上下文类加载器\",{\"1\":{\"220\":1}}],[\"setcontextclassloader\",{\"0\":{\"220\":1},\"1\":{\"220\":1}}],[\"setmaximumpoolsize\",{\"1\":{\"475\":1}}],[\"setmaxidle\",{\"1\":{\"428\":1}}],[\"setmaxopenpreparedstatements\",{\"1\":{\"428\":1}}],[\"setminidle\",{\"1\":{\"428\":1}}],[\"setpassword\",{\"1\":{\"428\":1}}],[\"setuncaughtexceptionhandler\",{\"1\":{\"464\":1}}],[\"setusername\",{\"1\":{\"428\":1}}],[\"seturl\",{\"1\":{\"428\":1}}],[\"setthreshold\",{\"1\":{\"334\":1}}],[\"set\",{\"0\":{\"553\":1},\"1\":{\"326\":1,\"334\":1,\"335\":1,\"556\":1}}],[\"serial语义的存在\",{\"1\":{\"488\":1}}],[\"serial语义的意思是\",{\"1\":{\"321\":1}}],[\"serial语义\",{\"1\":{\"321\":2}}],[\"serial又是什么\",{\"0\":{\"321\":1}}],[\"serialversionuid的值保持不变\",{\"1\":{\"276\":1}}],[\"serialversionuid\",{\"1\":{\"276\":1}}],[\"serializable接口有什么用\",{\"1\":{\"276\":1}}],[\"serial\",{\"1\":{\"137\":2,\"159\":1,\"320\":1}}],[\"serial收集器\",{\"1\":{\"137\":1}}],[\"service3数据\",{\"1\":{\"385\":1}}],[\"service2数据\",{\"1\":{\"385\":1}}],[\"service1数据\",{\"1\":{\"385\":1}}],[\"serviceloader<helloservice>\",{\"1\":{\"252\":2}}],[\"services\",{\"1\":{\"252\":3,\"595\":1,\"598\":1}}],[\"service\",{\"1\":{\"89\":1,\"252\":9,\"598\":2,\"599\":2,\"601\":2}}],[\"server镜像构建\",{\"1\":{\"598\":1}}],[\"serversocket\",{\"1\":{\"424\":5}}],[\"server=y\",{\"1\":{\"75\":1}}],[\"server\",{\"1\":{\"11\":1,\"76\":1,\"567\":1,\"598\":2,\"599\":1}}],[\"sequence\",{\"1\":{\"51\":1}}],[\"select\",{\"1\":{\"11\":1,\"428\":1,\"608\":1,\"609\":1,\"611\":1,\"612\":1,\"614\":1,\"616\":1,\"618\":2,\"656\":1}}],[\"src\",{\"1\":{\"11\":1}}],[\"st6\",{\"1\":{\"633\":1}}],[\"st2两个光口分别向互感器的光学电流传感元件1及光学电流传感元件2发送两束标准光\",{\"1\":{\"633\":1}}],[\"stealing\",{\"1\":{\"450\":1}}],[\"stmt\",{\"1\":{\"428\":2}}],[\"stw\",{\"1\":{\"139\":2}}],[\"storage\",{\"1\":{\"412\":1}}],[\"storeload\",{\"1\":{\"324\":1}}],[\"storestore\",{\"1\":{\"324\":1}}],[\"store\",{\"1\":{\"11\":2}}],[\"stopworker\",{\"1\":{\"477\":2}}],[\"stop\",{\"0\":{\"471\":1},\"1\":{\"138\":1,\"139\":1,\"471\":2,\"472\":1,\"577\":1}}],[\"strap压板\",{\"1\":{\"649\":1}}],[\"strp\",{\"1\":{\"649\":1}}],[\"stream的常用api\",{\"1\":{\"244\":1}}],[\"stream的常用操作有\",{\"1\":{\"244\":1}}],[\"stream流一般用于集合\",{\"1\":{\"244\":1}}],[\"stream\",{\"0\":{\"244\":1},\"1\":{\"240\":2,\"244\":12,\"383\":2,\"385\":1}}],[\"strong\",{\"1\":{\"128\":1}}],[\"str\",{\"1\":{\"104\":1,\"109\":1}}],[\"str2\",{\"0\":{\"269\":1},\"1\":{\"103\":2}}],[\"str1\",{\"0\":{\"269\":1},\"1\":{\"103\":2,\"269\":1}}],[\"string怎么转成integer的\",{\"0\":{\"273\":1}}],[\"string的确是不可变的\",{\"1\":{\"270\":1}}],[\"string不是不可变类吗\",{\"0\":{\"270\":1}}],[\"string是不可变的\",{\"1\":{\"268\":1}}],[\"string是java基本数据类型吗\",{\"1\":{\"267\":1}}],[\"stringbuilder是stringbuffer的非线程安全版本\",{\"1\":{\"268\":1}}],[\"stringbuilder类\",{\"1\":{\"268\":1}}],[\"stringbuilder\",{\"1\":{\"268\":1}}],[\"stringbuffer的性能相对较低\",{\"1\":{\"268\":1}}],[\"stringbuffer的方法都使用synchronized关键字进行同步\",{\"1\":{\"268\":1}}],[\"stringbuffer是可变的\",{\"1\":{\"268\":1}}],[\"stringbuffer类\",{\"1\":{\"268\":1}}],[\"stringbuffer\",{\"0\":{\"268\":1},\"1\":{\"268\":1}}],[\"string和stringbuilder\",{\"0\":{\"268\":1}}],[\"string类是线程安全的\",{\"1\":{\"268\":1}}],[\"string类\",{\"1\":{\"268\":1}}],[\"string类的不可变性使得它在安全性和可靠性方面更加可靠\",{\"1\":{\"267\":1}}],[\"string类的不可变性使得它可以被安全地用于多线程环境下\",{\"1\":{\"267\":1}}],[\"string类在java中被声明为final类\",{\"1\":{\"267\":1}}],[\"string上\",{\"0\":{\"262\":1}}],[\"stringcollection\",{\"1\":{\"244\":17}}],[\"string\",{\"0\":{\"267\":1,\"269\":2},\"1\":{\"103\":4,\"104\":2,\"109\":2,\"113\":1,\"124\":2,\"172\":1,\"173\":1,\"190\":1,\"204\":6,\"207\":1,\"215\":3,\"220\":2,\"244\":3,\"262\":1,\"267\":3,\"268\":1,\"269\":5,\"273\":3,\"282\":3,\"311\":1,\"312\":1,\"335\":1,\"353\":2,\"355\":1,\"357\":1,\"361\":5,\"363\":1,\"375\":3,\"383\":1,\"385\":5,\"392\":1,\"407\":1,\"409\":1,\"424\":1,\"428\":1,\"432\":1,\"436\":2,\"440\":1,\"467\":1,\"477\":1,\"480\":1}}],[\"standalone\",{\"1\":{\"598\":2}}],[\"stamp\",{\"1\":{\"505\":1,\"549\":1}}],[\"staic\",{\"1\":{\"482\":1}}],[\"staticinnerclass是静态内部类\",{\"1\":{\"312\":1}}],[\"staticinnerclass\",{\"1\":{\"312\":3}}],[\"static修饰的方法\",{\"1\":{\"301\":1}}],[\"static等修饰符所修饰\",{\"1\":{\"300\":1}}],[\"staticvar\",{\"1\":{\"190\":1}}],[\"static\",{\"1\":{\"104\":1,\"109\":1,\"124\":3,\"172\":1,\"173\":1,\"190\":4,\"204\":1,\"207\":1,\"215\":1,\"220\":1,\"282\":6,\"285\":1,\"299\":1,\"301\":1,\"309\":2,\"311\":1,\"312\":3,\"326\":1,\"332\":2,\"335\":1,\"353\":3,\"355\":2,\"357\":2,\"361\":3,\"383\":1,\"385\":4,\"392\":1,\"407\":1,\"409\":1,\"424\":1,\"428\":1,\"432\":2,\"436\":2,\"440\":1,\"457\":1,\"458\":1,\"459\":1,\"467\":1,\"477\":1,\"480\":1,\"482\":1}}],[\"statementhandler通常与parameterhandler和resultsethandler一起工作\",{\"1\":{\"656\":1}}],[\"statementhandler负责处理sql语句的创建和执行过程\",{\"1\":{\"656\":1}}],[\"statementhandler\",{\"1\":{\"656\":1}}],[\"state+1\",{\"1\":{\"496\":1}}],[\"state值时通过\",{\"1\":{\"496\":1}}],[\"state\",{\"1\":{\"89\":1,\"496\":1,\"501\":1}}],[\"stackoverflowexample\",{\"1\":{\"124\":1}}],[\"stackoverflowerror\",{\"1\":{\"124\":2}}],[\"stack\",{\"0\":{\"64\":2},\"1\":{\"64\":1,\"70\":2,\"92\":2,\"94\":2,\"163\":1,\"164\":1,\"178\":1,\"179\":2}}],[\"start\",{\"1\":{\"220\":1,\"320\":3,\"335\":1,\"353\":10,\"355\":1,\"357\":1,\"361\":2,\"477\":1,\"577\":1}}],[\"startswithb\",{\"1\":{\"244\":1}}],[\"startswith\",{\"1\":{\"215\":1,\"244\":6}}],[\"stars\",{\"1\":{\"4\":1}}],[\"star\",{\"0\":{\"4\":1}}],[\"+除留余数法\",{\"1\":{\"544\":1}}],[\"+1\",{\"1\":{\"485\":1}}],[\"++size\",{\"1\":{\"531\":1}}],[\"++bincount\",{\"1\":{\"531\":1}}],[\"++和\",{\"1\":{\"265\":1}}],[\"++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\",{\"1\":{\"11\":1}}],[\"++++++++\",{\"1\":{\"11\":1}}],[\"+printescapeanalysis\",{\"1\":{\"174\":2}}],[\"+printgcdatestamps\",{\"1\":{\"75\":1}}],[\"+printgcdetails\",{\"1\":{\"75\":1}}],[\"+eliminatelocks\",{\"1\":{\"166\":2}}],[\"+eliminateallocations\",{\"1\":{\"166\":2,\"174\":2}}],[\"+doescapeanalysis\",{\"1\":{\"166\":2,\"174\":2}}],[\"+heapdumponoutofmemoryerror参数\",{\"1\":{\"84\":1}}],[\"+tieredcompilation\",{\"1\":{\"74\":1}}],[\"+optimizestringconcat\",{\"1\":{\"74\":1}}],[\"+aggressiveopts\",{\"1\":{\"74\":1}}],[\"+useshenandoahgc\",{\"1\":{\"159\":1}}],[\"+useserialgc\",{\"1\":{\"73\":1,\"159\":1}}],[\"+usezgc\",{\"1\":{\"159\":1}}],[\"+usecompressedoops\",{\"1\":{\"74\":1}}],[\"+useconcmarksweepgc\",{\"1\":{\"73\":1,\"159\":1}}],[\"+useg1gc参数来选择使用并行gc或者g1\",{\"1\":{\"87\":1}}],[\"+useg1gc\",{\"1\":{\"73\":1,\"144\":1,\"159\":1}}],[\"+useparallelgc或者\",{\"1\":{\"87\":1}}],[\"+useparallelgc\",{\"1\":{\"73\":1,\"159\":1}}],[\"+\",{\"1\":{\"11\":4,\"124\":1,\"172\":1,\"173\":1,\"204\":2,\"207\":2,\"215\":1,\"244\":2,\"270\":2,\"300\":1,\"311\":1,\"312\":1,\"317\":1,\"335\":1,\"355\":4,\"357\":4,\"361\":8,\"369\":1,\"373\":1,\"374\":1,\"375\":4,\"383\":1,\"385\":5,\"392\":1,\"398\":2,\"407\":4,\"409\":4,\"428\":1,\"432\":3,\"436\":1,\"440\":1,\"465\":1,\"467\":1,\"477\":5,\"480\":2,\"485\":1,\"511\":1,\"516\":2,\"525\":3,\"549\":3}}],[\"+606\",{\"1\":{\"11\":1}}],[\"+83\",{\"1\":{\"11\":1}}],[\"t线程还在同步代码块中\",{\"1\":{\"493\":1}}],[\"t线程已经退出同步代码块\",{\"1\":{\"493\":1}}],[\"ttl通过重写\",{\"1\":{\"337\":1}}],[\"ttl\",{\"0\":{\"337\":1},\"1\":{\"337\":1}}],[\"tar文件上传到虚拟机\",{\"1\":{\"587\":1}}],[\"tar文件\",{\"1\":{\"575\":1}}],[\"tar包\",{\"1\":{\"575\":1}}],[\"tar\",{\"1\":{\"574\":2,\"592\":4}}],[\"target\",{\"1\":{\"289\":2}}],[\"tag\",{\"1\":{\"571\":1,\"604\":1}}],[\"tabat\",{\"1\":{\"549\":1}}],[\"tab\",{\"1\":{\"531\":8,\"532\":4,\"549\":17}}],[\"table\",{\"1\":{\"332\":2,\"334\":2,\"531\":1,\"532\":1,\"549\":5,\"608\":2,\"609\":2,\"614\":1}}],[\"take\",{\"1\":{\"460\":1,\"477\":1}}],[\"task2\",{\"1\":{\"480\":2}}],[\"task1\",{\"1\":{\"480\":3}}],[\"taskid\",{\"1\":{\"477\":3}}],[\"taskqueue\",{\"1\":{\"477\":4}}],[\"task\",{\"1\":{\"355\":3,\"465\":1,\"467\":3,\"477\":6,\"480\":2}}],[\"typehandler将java对象的属性值转换为数据库字段的值\",{\"1\":{\"656\":1}}],[\"typehandler将数据库字段的值转换为java对象的属性值\",{\"1\":{\"656\":1}}],[\"typehandler负责处理java对象与数据库类型之间的转换\",{\"1\":{\"656\":1}}],[\"typehandler\",{\"0\":{\"676\":2,\"719\":3},\"1\":{\"656\":1}}],[\"type\",{\"1\":{\"286\":1,\"289\":1}}],[\"t\",{\"1\":{\"285\":1,\"286\":1,\"335\":2,\"463\":7,\"464\":1,\"493\":1,\"592\":1}}],[\"tlab\",{\"1\":{\"119\":11,\"120\":3}}],[\"treeifybin\",{\"1\":{\"531\":2}}],[\"treeify\",{\"1\":{\"531\":2}}],[\"treenode<k\",{\"1\":{\"531\":1,\"532\":1}}],[\"treenode\",{\"1\":{\"531\":1,\"532\":1}}],[\"treemap\",{\"0\":{\"552\":1},\"1\":{\"291\":1,\"550\":1,\"552\":2}}],[\"tryacquire\",{\"1\":{\"359\":3,\"496\":1,\"501\":1}}],[\"try\",{\"1\":{\"124\":2,\"204\":1,\"215\":1,\"220\":1,\"280\":1,\"282\":6,\"303\":1,\"353\":2,\"355\":1,\"357\":1,\"361\":2,\"375\":1,\"380\":1,\"381\":1,\"383\":4,\"385\":4,\"392\":2,\"407\":2,\"409\":2,\"428\":1,\"432\":2,\"436\":1,\"440\":1,\"446\":1,\"452\":1,\"462\":1,\"463\":1,\"467\":1,\"477\":3,\"549\":1}}],[\"true\",{\"1\":{\"103\":1,\"124\":1,\"243\":1,\"244\":1,\"289\":2,\"355\":1,\"359\":2,\"424\":1,\"467\":1,\"477\":1,\"501\":2,\"502\":1}}],[\"transactionmanager负责管理数据库事务的生命周期\",{\"1\":{\"656\":1}}],[\"transactionmanager\",{\"1\":{\"656\":1}}],[\"transformer电流互感器\",{\"1\":{\"649\":1}}],[\"transferindex\",{\"1\":{\"549\":1}}],[\"transfer\",{\"1\":{\"450\":1,\"549\":1}}],[\"transmittablethreadlocal\",{\"1\":{\"337\":1}}],[\"transient\",{\"1\":{\"276\":4,\"517\":2}}],[\"transport=dt\",{\"1\":{\"75\":1}}],[\"trace\",{\"1\":{\"56\":1}}],[\"txt\",{\"1\":{\"89\":1}}],[\"tidying\",{\"0\":{\"472\":1},\"1\":{\"472\":2,\"473\":1}}],[\"tid=0x00007fbe2c164000\",{\"1\":{\"89\":1}}],[\"timout\",{\"1\":{\"344\":1}}],[\"timeunit\",{\"1\":{\"353\":1,\"359\":1,\"363\":1,\"380\":1,\"381\":1,\"392\":2,\"407\":2,\"409\":3,\"432\":2,\"440\":3,\"442\":1,\"446\":1,\"448\":1,\"452\":1,\"457\":1,\"458\":1,\"459\":1,\"463\":1,\"465\":1}}],[\"timeoutexception\",{\"1\":{\"355\":1}}],[\"timeout\",{\"1\":{\"274\":2,\"344\":2,\"353\":1}}],[\"time包\",{\"1\":{\"240\":1}}],[\"time\",{\"1\":{\"141\":2,\"148\":1,\"179\":1,\"345\":1}}],[\"title\",{\"1\":{\"17\":1,\"51\":1}}],[\"tda\",{\"1\":{\"89\":1}}],[\"this|object\",{\"1\":{\"482\":1}}],[\"this相当于是指向当前对象本身\",{\"1\":{\"298\":1}}],[\"this的用法在java中大体可以分为3种\",{\"1\":{\"298\":1}}],[\"this关键字有什么作用\",{\"0\":{\"298\":1}}],[\"this\",{\"1\":{\"165\":2,\"172\":2,\"204\":1,\"336\":3,\"355\":1,\"357\":1,\"361\":2,\"477\":1,\"480\":1,\"482\":1,\"505\":1,\"511\":1,\"531\":1,\"549\":2}}],[\"threshold\",{\"1\":{\"334\":7,\"531\":4}}],[\"threadfactory\",{\"1\":{\"448\":1,\"464\":4}}],[\"threadpool\",{\"1\":{\"424\":3,\"477\":3}}],[\"threadpoolexecutor\",{\"1\":{\"409\":3,\"442\":1,\"457\":1,\"458\":1,\"459\":1,\"463\":1,\"465\":2,\"468\":1,\"475\":2}}],[\"threadpoolexample\",{\"1\":{\"407\":1}}],[\"thread类中的静态方法\",{\"1\":{\"344\":2}}],[\"thread类的方法\",{\"1\":{\"344\":1}}],[\"thread类适合直接创建新线程\",{\"1\":{\"343\":1}}],[\"thread类有一个类型为threadlocal\",{\"1\":{\"328\":1}}],[\"thread和runnable有什么区别\",{\"0\":{\"343\":1}}],[\"threadlocalhashcode\",{\"1\":{\"332\":1,\"334\":1}}],[\"threadlocal本身不存储值\",{\"1\":{\"328\":1}}],[\"threadlocalmap\",{\"1\":{\"336\":2}}],[\"threadlocalmap扩容机制了解吗\",{\"0\":{\"334\":1}}],[\"threadlocalmap怎么解决hash冲突的\",{\"0\":{\"333\":1}}],[\"threadlocalmap用的是哈希取余法\",{\"1\":{\"332\":1}}],[\"threadlocalmap的结构了解吗\",{\"0\":{\"332\":1}}],[\"threadlocalmap的key没了\",{\"1\":{\"329\":1}}],[\"threadlocalmap的key\",{\"1\":{\"329\":1}}],[\"threadlocalmap的实例变量threadlocals\",{\"1\":{\"328\":1}}],[\"threadlocalmap中使用的\",{\"1\":{\"329\":1}}],[\"threadlocalmap内部维护着entry数组\",{\"1\":{\"328\":1}}],[\"threadlocal怎么实现的呢\",{\"0\":{\"328\":1}}],[\"threadlocal<\",{\"1\":{\"334\":1}}],[\"threadlocal<>\",{\"1\":{\"326\":1}}],[\"threadlocal<string>\",{\"1\":{\"326\":1}}],[\"threadlocal是什么\",{\"0\":{\"326\":1}}],[\"threadlocal\",{\"0\":{\"325\":1,\"329\":1},\"1\":{\"326\":1,\"329\":1,\"335\":4,\"336\":3,\"337\":1,\"351\":1}}],[\"threadlocal的弱引用导致内存泄漏也是个老生常谈的话题了\",{\"1\":{\"125\":1}}],[\"threadlocal使用不当\",{\"1\":{\"125\":1}}],[\"thread\",{\"0\":{\"119\":1,\"220\":1},\"1\":{\"56\":1,\"89\":2,\"90\":1,\"117\":1,\"119\":1,\"220\":8,\"335\":2,\"336\":2,\"343\":1,\"353\":22,\"355\":5,\"357\":5,\"361\":6,\"380\":1,\"381\":1,\"383\":3,\"385\":3,\"392\":1,\"407\":3,\"409\":3,\"412\":1,\"432\":3,\"436\":2,\"440\":1,\"463\":1,\"464\":6,\"467\":1,\"468\":1,\"477\":7,\"549\":1}}],[\"throw\",{\"1\":{\"204\":1,\"215\":1,\"280\":1,\"377\":1,\"378\":1,\"380\":1,\"381\":1,\"383\":4,\"385\":3,\"392\":1,\"467\":1,\"516\":1}}],[\"throwable\",{\"1\":{\"129\":1,\"279\":1,\"463\":1}}],[\"throws\",{\"1\":{\"129\":1,\"204\":2,\"207\":1,\"215\":2,\"220\":2,\"280\":1,\"353\":2,\"424\":2}}],[\"thencombine\",{\"0\":{\"374\":1},\"1\":{\"374\":1}}],[\"thencompose\",{\"0\":{\"373\":1},\"1\":{\"373\":1}}],[\"thenrun\",{\"0\":{\"371\":1},\"1\":{\"371\":1}}],[\"thenacceptasync\",{\"1\":{\"398\":1}}],[\"thenaccept\",{\"0\":{\"370\":1},\"1\":{\"370\":1,\"375\":1,\"383\":1,\"385\":1,\"392\":1}}],[\"thenapplyasync\",{\"1\":{\"398\":1}}],[\"thenapply\",{\"0\":{\"369\":1},\"1\":{\"369\":1}}],[\"then\",{\"1\":{\"11\":1}}],[\"the\",{\"0\":{\"138\":1},\"1\":{\"11\":1,\"138\":1,\"139\":1,\"165\":1,\"289\":1,\"334\":1,\"336\":1}}],[\"theme\",{\"1\":{\"8\":1,\"10\":1,\"11\":5,\"17\":2}}],[\"tcpdump\",{\"1\":{\"54\":1}}],[\"tcp\",{\"1\":{\"51\":1}}],[\"ts\",{\"0\":{\"17\":1},\"1\":{\"23\":1}}],[\"technicalcommission\",{\"1\":{\"636\":1}}],[\"terminated\",{\"0\":{\"473\":1},\"1\":{\"345\":1,\"473\":2}}],[\"terser\",{\"1\":{\"11\":1}}],[\"test\",{\"1\":{\"282\":6}}],[\"testclass类会被自定义类加载器加载\",{\"1\":{\"220\":1}}],[\"testclass\",{\"1\":{\"215\":2,\"220\":3}}],[\"tenured\",{\"1\":{\"139\":1}}],[\"template\",{\"1\":{\"11\":2}}],[\"tolist\",{\"1\":{\"383\":1}}],[\"tostring\",{\"1\":{\"274\":1,\"465\":1}}],[\"touppercase\",{\"1\":{\"244\":1}}],[\"tomcat提供了隔离的机制\",{\"1\":{\"234\":1}}],[\"tomcat在类加载机制上破坏了传统的双亲委派模型\",{\"1\":{\"234\":1}}],[\"tomcat的公共类加载器\",{\"1\":{\"234\":1}}],[\"tomcat的类加载机制了解吗\",{\"0\":{\"234\":1}}],[\"tomcat采用了一种特殊的类加载器体系\",{\"1\":{\"234\":1}}],[\"tomcat\",{\"1\":{\"234\":1}}],[\"tobytearray\",{\"1\":{\"204\":1}}],[\"top\",{\"1\":{\"54\":1,\"85\":2,\"89\":2}}],[\"to\",{\"1\":{\"11\":2,\"20\":1,\"75\":1,\"89\":1,\"204\":1,\"289\":1,\"334\":1,\"336\":1,\"549\":1,\"579\":1}}],[\"tmp\",{\"1\":{\"11\":2,\"587\":5,\"592\":2,\"593\":2,\"595\":2,\"598\":2}}],[\"vlan\",{\"1\":{\"644\":1}}],[\"v就是挂载数据卷的命令\",{\"1\":{\"585\":1}}],[\"v>\",{\"1\":{\"531\":2,\"532\":5,\"549\":10}}],[\"version\",{\"1\":{\"595\":1,\"598\":1}}],[\"verification\",{\"0\":{\"185\":1},\"1\":{\"183\":1}}],[\"vector的所有方法都是同步的\",{\"1\":{\"521\":1}}],[\"vector是一个线程安全的动态数组类\",{\"1\":{\"521\":1}}],[\"vm\",{\"1\":{\"336\":2}}],[\"vmstat\",{\"1\":{\"54\":1}}],[\"voltage欠电压\",{\"1\":{\"649\":1}}],[\"volume名称\",{\"1\":{\"588\":1}}],[\"volume命令是数据卷操作\",{\"1\":{\"583\":1}}],[\"volumes\",{\"1\":{\"582\":1,\"584\":1,\"586\":1,\"595\":1,\"598\":2}}],[\"volume\",{\"1\":{\"582\":1,\"583\":1,\"584\":8,\"586\":1}}],[\"volatile修饰原数组array\",{\"1\":{\"522\":1}}],[\"volatile\",{\"1\":{\"477\":1,\"496\":2}}],[\"volatile和synchronized关键字\",{\"1\":{\"351\":1}}],[\"volatile怎么保证有序性的呢\",{\"0\":{\"324\":1}}],[\"volatile怎么保证可见性的呢\",{\"0\":{\"323\":1}}],[\"volatile可以确保对某个变量的更新对其他线程马上可见\",{\"1\":{\"323\":1}}],[\"volatile就是更轻量的选择\",{\"1\":{\"323\":1}}],[\"volatile有两个作用\",{\"1\":{\"322\":1}}],[\"volatile实现原理了解吗\",{\"0\":{\"322\":1}}],[\"volatile变量规则\",{\"1\":{\"320\":1}}],[\"volatile关键字\",{\"1\":{\"316\":1}}],[\"void\",{\"1\":{\"104\":1,\"109\":1,\"124\":3,\"129\":1,\"165\":1,\"172\":2,\"173\":2,\"190\":1,\"204\":1,\"207\":1,\"215\":2,\"220\":2,\"252\":2,\"282\":3,\"311\":2,\"312\":2,\"334\":2,\"335\":2,\"344\":1,\"353\":3,\"355\":3,\"357\":2,\"361\":3,\"383\":1,\"385\":1,\"392\":1,\"407\":1,\"409\":1,\"424\":2,\"428\":1,\"432\":2,\"436\":2,\"440\":1,\"463\":1,\"465\":1,\"467\":1,\"477\":5,\"480\":1,\"482\":2}}],[\"v\",{\"0\":{\"776\":1},\"1\":{\"286\":1,\"375\":1,\"383\":1,\"385\":1,\"502\":7,\"511\":5,\"532\":1,\"554\":1,\"585\":3,\"586\":2,\"587\":2,\"588\":4}}],[\"var\",{\"1\":{\"582\":1,\"584\":1,\"586\":1,\"595\":1,\"598\":1}}],[\"variable\",{\"1\":{\"51\":1}}],[\"val\",{\"1\":{\"505\":2}}],[\"valatile保证有序性\",{\"1\":{\"324\":1}}],[\"value采样值\",{\"1\":{\"649\":1}}],[\"value的能力能指向下一个节点的指针\",{\"1\":{\"548\":1}}],[\"value还在\",{\"1\":{\"329\":1}}],[\"value是threadlocal的泛型值\",{\"1\":{\"328\":1}}],[\"valueof\",{\"1\":{\"272\":1,\"273\":1}}],[\"value\",{\"1\":{\"255\":1,\"268\":2,\"286\":2,\"334\":1,\"458\":2,\"460\":2,\"511\":1,\"531\":3,\"532\":1,\"549\":1,\"554\":3,\"644\":1}}],[\"vi\",{\"1\":{\"586\":1}}],[\"virtual\",{\"1\":{\"177\":1,\"247\":1,\"563\":1,\"644\":1}}],[\"visualvm等\",{\"1\":{\"90\":1}}],[\"visualvm\",{\"0\":{\"58\":1,\"61\":1},\"1\":{\"58\":1,\"61\":1,\"70\":2,\"89\":1}}],[\"visibility\",{\"1\":{\"20\":1,\"316\":1}}],[\"vite\",{\"1\":{\"11\":1}}],[\"v5\",{\"1\":{\"11\":1}}],[\"vue\",{\"1\":{\"11\":1}}],[\"vuepress\",{\"1\":{\"10\":1,\"11\":8,\"17\":1}}],[\"v3\",{\"1\":{\"11\":2}}],[\"bf\",{\"1\":{\"649\":1}}],[\"bin\",{\"1\":{\"549\":1,\"592\":1}}],[\"bincount\",{\"1\":{\"531\":3}}],[\"bio\",{\"0\":{\"238\":1},\"1\":{\"238\":1}}],[\"b又变回a的情况\",{\"1\":{\"504\":1}}],[\"boundsql可以方便地被executor和statementhandler使用\",{\"1\":{\"656\":1}}],[\"boundsql封装了一个完整的sql语句以及与之对应的参数信息\",{\"1\":{\"656\":1}}],[\"boundsql\",{\"1\":{\"656\":1}}],[\"bounded\",{\"1\":{\"450\":1}}],[\"books\",{\"0\":{\"788\":1}}],[\"book\",{\"0\":{\"774\":1}}],[\"boot<\",{\"1\":{\"600\":1}}],[\"boot\",{\"1\":{\"255\":1,\"600\":1}}],[\"bootstrapclassloader\",{\"1\":{\"234\":2}}],[\"bootstrap\",{\"0\":{\"199\":1},\"1\":{\"195\":1,\"206\":1,\"207\":1}}],[\"boolean等\",{\"1\":{\"306\":1}}],[\"boolean\",{\"1\":{\"103\":1,\"244\":3,\"258\":2,\"289\":1,\"344\":2,\"353\":1,\"359\":2,\"477\":1,\"501\":1,\"505\":2,\"511\":2,\"554\":1}}],[\"beforec\",{\"1\":{\"320\":1}}],[\"before于线程a从threadb\",{\"1\":{\"320\":1}}],[\"before于线程b中的任意操作\",{\"1\":{\"320\":1}}],[\"before于任意后续对这个volatile域的读\",{\"1\":{\"320\":1}}],[\"before于随后对这个锁的加锁\",{\"1\":{\"320\":1}}],[\"before于该线程中的任意后续操作\",{\"1\":{\"320\":1}}],[\"before和我们息息相关的有六大规则\",{\"1\":{\"320\":1}}],[\"before关系来执行的结果一致\",{\"1\":{\"320\":1}}],[\"before关系指定的顺序来执行\",{\"1\":{\"320\":1}}],[\"before关系\",{\"1\":{\"320\":1}}],[\"before另一个操作\",{\"1\":{\"320\":1}}],[\"before的定义\",{\"1\":{\"320\":1}}],[\"before\",{\"1\":{\"320\":3}}],[\"before了解吗\",{\"0\":{\"320\":1}}],[\"beta\",{\"1\":{\"51\":1}}],[\"brcb\",{\"1\":{\"649\":1}}],[\"brokenbarrierexception\",{\"1\":{\"355\":3}}],[\"breaker\",{\"1\":{\"649\":1}}],[\"break\",{\"0\":{\"263\":1},\"1\":{\"263\":1,\"531\":2,\"549\":4}}],[\"branches\",{\"1\":{\"16\":1}}],[\"bbb2\",{\"1\":{\"244\":1}}],[\"bbb3\",{\"1\":{\"244\":1}}],[\"bbb1\",{\"1\":{\"244\":1}}],[\"block无缓存报告控制块\",{\"1\":{\"649\":1}}],[\"block有缓存报告控制块\",{\"1\":{\"649\":1}}],[\"blockingqueue\",{\"1\":{\"477\":1}}],[\"blockingqueue<runnable>\",{\"1\":{\"463\":1,\"477\":1}}],[\"blocked状态表示线程被阻塞\",{\"1\":{\"346\":1}}],[\"blocked和waiting有什么区别\",{\"0\":{\"346\":1}}],[\"blocked\",{\"1\":{\"345\":1}}],[\"bloch\",{\"1\":{\"240\":1}}],[\"blogs\",{\"1\":{\"11\":1}}],[\"blogs>\",{\"1\":{\"11\":1}}],[\"blog\",{\"1\":{\"11\":1}}],[\"b\",{\"0\":{\"272\":1},\"1\":{\"238\":5,\"244\":4,\"320\":1,\"502\":2,\"593\":1,\"631\":2}}],[\"build>\",{\"1\":{\"600\":1}}],[\"build临时构建的镜像容器\",{\"1\":{\"595\":1}}],[\"build命令构建镜像\",{\"1\":{\"593\":1}}],[\"build\",{\"1\":{\"592\":1,\"595\":1,\"598\":3}}],[\"builder\",{\"0\":{\"696\":1},\"1\":{\"590\":1,\"656\":3}}],[\"bucket\",{\"1\":{\"525\":1,\"550\":1}}],[\"bundle\",{\"1\":{\"224\":3}}],[\"buffered\",{\"1\":{\"649\":1}}],[\"buffers\",{\"1\":{\"277\":1}}],[\"buffer\",{\"0\":{\"119\":1},\"1\":{\"117\":1,\"119\":1}}],[\"bypassclassloader\",{\"1\":{\"220\":1}}],[\"by\",{\"1\":{\"215\":2,\"220\":2,\"432\":1,\"614\":1,\"616\":2,\"618\":2}}],[\"bytes\",{\"1\":{\"215\":4,\"220\":3}}],[\"bytestream\",{\"1\":{\"204\":3}}],[\"bytearrayoutputstream\",{\"1\":{\"204\":2}}],[\"bytecode\",{\"1\":{\"177\":1}}],[\"byte\",{\"0\":{\"262\":1},\"1\":{\"124\":1,\"204\":2,\"215\":2,\"220\":3,\"258\":2,\"262\":1}}],[\"basic\",{\"0\":{\"778\":1,\"786\":1}}],[\"basicdatasource\",{\"1\":{\"428\":3}}],[\"bash是一个linux终端交互命令\",{\"1\":{\"579\":1}}],[\"bash\",{\"1\":{\"579\":2}}],[\"base\",{\"1\":{\"17\":1}}],[\"barrier\",{\"1\":{\"354\":1,\"355\":8}}],[\"bam\",{\"1\":{\"243\":3}}],[\"baidusyncdisk\",{\"1\":{\"11\":2}}],[\"dmu\",{\"0\":{\"641\":1},\"1\":{\"640\":2,\"641\":5}}],[\"d转换等单元组成\",{\"1\":{\"634\":1}}],[\"d转换器组成\",{\"1\":{\"634\":1}}],[\"driver\",{\"1\":{\"599\":2}}],[\"dbcp2\",{\"1\":{\"428\":1}}],[\"dbcp为例\",{\"1\":{\"428\":1}}],[\"dubbo等\",{\"1\":{\"277\":1}}],[\"dump等命令也会触发full\",{\"1\":{\"135\":1}}],[\"dumping\",{\"1\":{\"89\":1}}],[\"dump堆内存文件\",{\"1\":{\"88\":1}}],[\"dump\",{\"1\":{\"86\":1,\"88\":1,\"89\":10}}],[\"ddd1\",{\"1\":{\"244\":1}}],[\"ddd2\",{\"1\":{\"244\":1}}],[\"d\",{\"0\":{\"272\":1},\"1\":{\"238\":2,\"578\":2,\"580\":1,\"586\":1,\"593\":1,\"595\":1,\"597\":1,\"598\":1,\"602\":1,\"631\":1}}],[\"dir\",{\"1\":{\"592\":3}}],[\"dir=\",{\"1\":{\"592\":1}}],[\"dirs指定的目录中\",{\"1\":{\"200\":1}}],[\"disa规约\",{\"1\":{\"637\":2}}],[\"distinct\",{\"0\":{\"614\":1},\"1\":{\"606\":1,\"608\":1,\"609\":1,\"611\":1,\"612\":1,\"613\":3,\"614\":1,\"615\":2,\"616\":2,\"618\":2,\"619\":1}}],[\"displaced\",{\"1\":{\"494\":1}}],[\"display\",{\"1\":{\"11\":1}}],[\"discardoldestpolicy\",{\"1\":{\"449\":1}}],[\"discardpolicy\",{\"1\":{\"449\":1}}],[\"dfile\",{\"1\":{\"76\":1}}],[\"dproperty=value\",{\"1\":{\"76\":1}}],[\"dynatrace\",{\"0\":{\"67\":1},\"1\":{\"67\":1,\"70\":2}}],[\"da\",{\"1\":{\"649\":1}}],[\"daemon\",{\"1\":{\"89\":1,\"350\":1}}],[\"dashboard\",{\"1\":{\"56\":1}}],[\"database\",{\"0\":{\"784\":1}}],[\"databaseconnectionpoolexample\",{\"1\":{\"428\":1}}],[\"data到mysql容器内数据存储目录\",{\"1\":{\"587\":1}}],[\"data目录\",{\"1\":{\"584\":1}}],[\"datasource负责管理数据库连接的创建\",{\"1\":{\"656\":1}}],[\"datasource用于提供数据库连接\",{\"1\":{\"656\":1}}],[\"datasource\",{\"1\":{\"428\":8,\"599\":1,\"656\":1}}],[\"data\",{\"1\":{\"51\":2,\"121\":3,\"179\":1,\"361\":6,\"363\":1,\"432\":2,\"586\":1,\"587\":1,\"595\":1,\"598\":1,\"649\":4}}],[\"daiwencheng\",{\"1\":{\"11\":2}}],[\"delete\",{\"1\":{\"656\":1}}],[\"delegation\",{\"1\":{\"203\":1,\"205\":1}}],[\"delta\",{\"1\":{\"511\":2}}],[\"delayqueue\",{\"1\":{\"460\":1}}],[\"delayedworkqueue\",{\"1\":{\"460\":1}}],[\"delay\",{\"1\":{\"450\":1}}],[\"declares\",{\"1\":{\"289\":1}}],[\"destination\",{\"1\":{\"51\":1}}],[\"description系统规格文件\",{\"1\":{\"649\":1}}],[\"description全站系统配置文件\",{\"1\":{\"649\":1}}],[\"description\",{\"1\":{\"17\":1,\"644\":1,\"649\":2}}],[\"defineclass\",{\"1\":{\"204\":1,\"215\":1,\"220\":1,\"228\":1,\"233\":6}}],[\"defineuserconfig\",{\"1\":{\"17\":1}}],[\"defaultcapacity\",{\"1\":{\"516\":1}}],[\"default\",{\"1\":{\"17\":1,\"289\":1,\"297\":1,\"336\":1,\"460\":1,\"516\":1,\"549\":1}}],[\"device设备\",{\"1\":{\"649\":1}}],[\"device物理设备\",{\"1\":{\"649\":1}}],[\"device逻辑设备\",{\"1\":{\"649\":1}}],[\"device智能电子设备\",{\"1\":{\"649\":1}}],[\"device\",{\"1\":{\"626\":1}}],[\"development\",{\"1\":{\"247\":1}}],[\"dev\",{\"1\":{\"11\":3,\"14\":1,\"649\":1}}],[\"devdependencies\",{\"1\":{\"11\":2}}],[\"demo目录\",{\"1\":{\"602\":1}}],[\"demo目录下\",{\"1\":{\"592\":1}}],[\"demo上传至虚拟机\",{\"1\":{\"597\":1}}],[\"demo上传到虚拟机任意目录\",{\"1\":{\"592\":1}}],[\"demo中的每一个对应的子目录中\",{\"1\":{\"597\":1}}],[\"demo项目\",{\"1\":{\"597\":1}}],[\"demo文件夹上传到虚拟机中\",{\"1\":{\"602\":1}}],[\"demo文件夹\",{\"1\":{\"597\":1,\"598\":1}}],[\"demo微服务集群利用dockercompose部署\",{\"1\":{\"597\":1}}],[\"demo这个目录\",{\"1\":{\"592\":3}}],[\"demo\",{\"1\":{\"11\":1,\"592\":4,\"593\":1}}],[\"department\",{\"1\":{\"610\":1,\"617\":1}}],[\"deps\",{\"1\":{\"560\":2}}],[\"deploy\",{\"0\":{\"16\":1}}],[\"dependency\",{\"1\":{\"11\":2,\"289\":1}}],[\"deprecated\",{\"1\":{\"11\":1}}],[\"doe\",{\"1\":{\"610\":3,\"612\":2,\"617\":3,\"618\":6}}],[\"do\",{\"1\":{\"511\":1,\"532\":1,\"649\":1}}],[\"doubling\",{\"1\":{\"334\":1}}],[\"double\",{\"1\":{\"258\":2}}],[\"done\",{\"1\":{\"11\":4}}],[\"downloaded\",{\"1\":{\"11\":2}}],[\"dockercompose的详细语法参考官网\",{\"1\":{\"595\":1}}],[\"dockerfile的第一行必须是from\",{\"1\":{\"594\":1}}],[\"dockerfile的本质是一个文件\",{\"1\":{\"594\":1}}],[\"dockerfile就是一个文本文件\",{\"1\":{\"590\":1}}],[\"dockerfile语法\",{\"0\":{\"590\":1}}],[\"docker\",{\"0\":{\"781\":1},\"1\":{\"573\":2,\"574\":5,\"577\":6,\"578\":2,\"579\":2,\"580\":4,\"582\":1,\"583\":2,\"584\":9,\"585\":1,\"586\":3,\"588\":1,\"590\":1,\"592\":2,\"594\":1,\"595\":1,\"597\":1,\"602\":1,\"604\":3}}],[\"docker结构\",{\"1\":{\"568\":1}}],[\"docker守护进程\",{\"1\":{\"567\":1}}],[\"dockerhub是一个官方的docker镜像的托管平台\",{\"1\":{\"566\":1}}],[\"dockerhub\",{\"0\":{\"566\":1},\"1\":{\"566\":1,\"568\":1}}],[\"docker将应用程序及其所需的依赖\",{\"1\":{\"565\":1}}],[\"docker将用户程序与所需要调用的系统\",{\"1\":{\"561\":1}}],[\"docker中有几个重要的概念\",{\"1\":{\"565\":1}}],[\"docker架构\",{\"0\":{\"564\":1,\"567\":1}}],[\"docker体积小\",{\"1\":{\"563\":1}}],[\"docker和虚拟机的差异\",{\"1\":{\"563\":1}}],[\"docker和虚拟机的区别\",{\"0\":{\"563\":1}}],[\"docker仅仅是封装函数库\",{\"1\":{\"563\":1}}],[\"docker可以让一个应用在任何操作系统中非常方便的运行\",{\"1\":{\"563\":1}}],[\"docker是一个cs架构的程序\",{\"1\":{\"567\":1}}],[\"docker是一个系统进程\",{\"1\":{\"563\":1}}],[\"docker是一个快速交付应用\",{\"1\":{\"562\":1}}],[\"docker是如何实现的呢\",{\"1\":{\"560\":1}}],[\"docker镜像中包含完整运行环境\",{\"1\":{\"562\":1}}],[\"docker应用运行在容器中\",{\"1\":{\"562\":1}}],[\"docker允许开发中将应用\",{\"1\":{\"562\":1}}],[\"docker如何解决开发\",{\"1\":{\"562\":1}}],[\"docker如何解决大型项目依赖关系复杂\",{\"1\":{\"562\":1}}],[\"docker如何解决不同系统环境的问题\",{\"1\":{\"561\":1}}],[\"docker运行到不同操作系统时\",{\"1\":{\"561\":1}}],[\"docker解决操作系统环境差异\",{\"0\":{\"561\":1}}],[\"docker解决依赖兼容问题\",{\"0\":{\"560\":1}}],[\"docker为了解决依赖的兼容问题的\",{\"1\":{\"560\":1}}],[\"docker实用篇\",{\"0\":{\"557\":1}}],[\"documented\",{\"1\":{\"289\":1}}],[\"documents\",{\"1\":{\"11\":2}}],[\"docsbranch\",{\"1\":{\"23\":1}}],[\"docs的settings项\",{\"1\":{\"21\":1}}],[\"docs\",{\"0\":{\"16\":1},\"1\":{\"10\":1,\"11\":3,\"14\":2,\"17\":1,\"20\":1,\"590\":1,\"595\":1}}],[\"dlx\",{\"1\":{\"11\":2}}],[\"ct\",{\"1\":{\"649\":1}}],[\"cid文件对于特定的某个智能组件来说与scd文件完全相同\",{\"1\":{\"638\":1}}],[\"cid文件\",{\"1\":{\"638\":1}}],[\"cid\",{\"0\":{\"638\":1},\"1\":{\"649\":1}}],[\"cdc\",{\"1\":{\"649\":1}}],[\"cdt规约及dnp规约等\",{\"1\":{\"637\":2}}],[\"cd\",{\"1\":{\"579\":1,\"586\":1,\"592\":1}}],[\"cmp\",{\"1\":{\"505\":2}}],[\"cms需要对许多参数进行调优\",{\"1\":{\"147\":1}}],[\"cms会触发一次full\",{\"1\":{\"147\":1}}],[\"cms的局限性\",{\"0\":{\"147\":1}}],[\"cms也有其缺点\",{\"1\":{\"139\":1}}],[\"cms开始进行垃圾收集\",{\"1\":{\"139\":1}}],[\"cmsinitiatingoccupancyfraction\",{\"1\":{\"139\":1}}],[\"cms使用标记\",{\"1\":{\"139\":1,\"147\":1}}],[\"cms收集器通过初始标记\",{\"1\":{\"139\":1}}],[\"cms收集器还有一个重要的参数\",{\"1\":{\"139\":1}}],[\"cms收集器提供了并发压缩\",{\"1\":{\"139\":1}}],[\"cms收集器设计的主要目的是降低垃圾收集对应用程序的停顿时间\",{\"1\":{\"139\":1}}],[\"cms收集器有以下几个特点\",{\"1\":{\"139\":1}}],[\"cms收集器主要用于老年代\",{\"1\":{\"139\":1}}],[\"cms收集器是一种以减少停顿时间为目标的收集器\",{\"1\":{\"137\":1}}],[\"cms\",{\"1\":{\"73\":1,\"137\":1,\"139\":1,\"151\":1,\"159\":1}}],[\"cxq\",{\"1\":{\"485\":1}}],[\"centos7安装docker\",{\"1\":{\"603\":1}}],[\"ce\",{\"1\":{\"463\":2}}],[\"cyclic\",{\"1\":{\"354\":1}}],[\"cyclicbarrier可以在所有的线程释放后重新使\",{\"1\":{\"356\":1}}],[\"cyclicbarrier面向的是线程数\",{\"1\":{\"356\":1}}],[\"cyclicbarrier是可重用的\",{\"1\":{\"356\":1}}],[\"cyclicbarrier和countdownlatch有什么区别\",{\"0\":{\"356\":1}}],[\"cyclicbarrierexample\",{\"1\":{\"355\":1}}],[\"cyclicbarrier的字面意思是可循环使用\",{\"1\":{\"354\":1}}],[\"cyclicbarrier\",{\"0\":{\"354\":1},\"1\":{\"355\":5,\"356\":1}}],[\"ccl\",{\"1\":{\"336\":1}}],[\"ccc\",{\"1\":{\"244\":1}}],[\"c和d不相等\",{\"1\":{\"272\":1}}],[\"c=\",{\"0\":{\"272\":1}}],[\"choose\",{\"1\":{\"656\":1}}],[\"check\",{\"1\":{\"532\":1}}],[\"checkedexception\",{\"1\":{\"279\":1}}],[\"checksum\",{\"1\":{\"51\":1}}],[\"charset=\",{\"1\":{\"579\":1}}],[\"characteristics\",{\"1\":{\"336\":1}}],[\"charat\",{\"1\":{\"243\":1}}],[\"char\",{\"1\":{\"258\":2,\"262\":1,\"268\":2}}],[\"channel代表了服务端与客户端的连接\",{\"1\":{\"238\":1}}],[\"current\",{\"1\":{\"649\":1}}],[\"currenttimemillis\",{\"1\":{\"440\":1}}],[\"currentthread\",{\"0\":{\"220\":1},\"1\":{\"220\":3,\"355\":3,\"357\":3,\"361\":4,\"407\":2,\"409\":2,\"432\":2,\"436\":1,\"463\":1,\"467\":1,\"477\":4}}],[\"customthreadpoolexample\",{\"1\":{\"392\":1,\"409\":1}}],[\"customthreadpool\",{\"1\":{\"390\":1,\"391\":1,\"392\":6,\"463\":2,\"477\":4}}],[\"customclassloader\",{\"1\":{\"215\":6,\"220\":6}}],[\"custom\",{\"0\":{\"202\":1}}],[\"capability\",{\"1\":{\"649\":1}}],[\"capacity\",{\"1\":{\"516\":1,\"549\":1}}],[\"cancellationexception\",{\"1\":{\"463\":1}}],[\"callerrunspolicy\",{\"1\":{\"449\":1}}],[\"callable<integer>\",{\"1\":{\"467\":1}}],[\"callable\",{\"0\":{\"467\":1},\"1\":{\"242\":1,\"462\":1,\"467\":2}}],[\"car\",{\"1\":{\"357\":3,\"358\":1}}],[\"catalinaclassloader\",{\"1\":{\"234\":1}}],[\"catch\",{\"1\":{\"124\":2,\"204\":1,\"215\":1,\"220\":1,\"280\":1,\"282\":2,\"303\":1,\"353\":2,\"355\":1,\"357\":1,\"361\":2,\"375\":1,\"380\":1,\"381\":1,\"383\":4,\"385\":4,\"392\":2,\"407\":2,\"409\":2,\"428\":1,\"432\":2,\"436\":1,\"440\":1,\"446\":1,\"452\":1,\"462\":1,\"463\":3,\"467\":2,\"477\":3}}],[\"cache用于缓存查询结果\",{\"1\":{\"656\":1}}],[\"cachedthreadpool\",{\"0\":{\"458\":1},\"1\":{\"395\":1,\"406\":2,\"455\":1}}],[\"cache\",{\"1\":{\"130\":1,\"656\":1}}],[\"cass公共数据类\",{\"1\":{\"649\":1}}],[\"castabat\",{\"1\":{\"549\":1}}],[\"cas操作\",{\"1\":{\"549\":1}}],[\"cas操作都不做\",{\"1\":{\"491\":1}}],[\"cas+synchronized\",{\"0\":{\"549\":1}}],[\"caspair\",{\"1\":{\"505\":1}}],[\"cas获取偏向锁失败表示有竞争\",{\"1\":{\"493\":1}}],[\"cas\",{\"0\":{\"503\":1},\"1\":{\"120\":2,\"496\":1,\"501\":3,\"502\":6,\"508\":2}}],[\"cloud\",{\"1\":{\"598\":1,\"599\":2}}],[\"clone\",{\"1\":{\"274\":1}}],[\"cleansomeslots\",{\"1\":{\"334\":1}}],[\"cleanup\",{\"1\":{\"141\":1,\"142\":1}}],[\"clazz\",{\"1\":{\"204\":2,\"215\":3,\"220\":3}}],[\"classes\",{\"1\":{\"204\":1}}],[\"classname\",{\"1\":{\"204\":2,\"285\":1}}],[\"classnotfoundexception\",{\"1\":{\"204\":2,\"207\":1,\"215\":2,\"220\":2}}],[\"classdata\",{\"1\":{\"204\":4}}],[\"class<\",{\"1\":{\"204\":2,\"215\":2,\"220\":2}}],[\"classpath\",{\"1\":{\"201\":1,\"204\":5}}],[\"class类的对象\",{\"1\":{\"196\":1}}],[\"class对象\",{\"1\":{\"194\":1,\"195\":1}}],[\"classloader类的defineclass方法用于定义类并加载类的字节码\",{\"1\":{\"217\":1}}],[\"classloader类提供了loadclass方法用于加载类\",{\"1\":{\"216\":1}}],[\"classloader类并重写findclass方法\",{\"1\":{\"202\":1}}],[\"classloader是用本地代码实现的\",{\"1\":{\"207\":1}}],[\"classloader的子类\",{\"1\":{\"199\":1,\"200\":1,\"201\":1}}],[\"classloader从应用的classpath加载类\",{\"1\":{\"195\":1}}],[\"classloader从jre的lib目录加载类\",{\"1\":{\"195\":1}}],[\"classloader\",{\"0\":{\"199\":1,\"200\":1,\"201\":1,\"202\":1},\"1\":{\"184\":1,\"195\":1,\"198\":1,\"204\":3,\"206\":1,\"207\":9,\"215\":2,\"220\":2,\"222\":1,\"228\":1,\"336\":1}}],[\"class文件内容\",{\"1\":{\"193\":1}}],[\"class文件加载到内存中\",{\"1\":{\"180\":1}}],[\"class文件\",{\"1\":{\"178\":1,\"179\":1,\"184\":1,\"191\":1,\"249\":1}}],[\"class\",{\"0\":{\"299\":1},\"1\":{\"104\":2,\"109\":1,\"124\":2,\"165\":2,\"172\":2,\"173\":1,\"179\":1,\"190\":1,\"204\":2,\"207\":2,\"215\":3,\"220\":3,\"228\":1,\"249\":2,\"250\":1,\"252\":3,\"254\":1,\"258\":1,\"285\":1,\"289\":4,\"309\":3,\"311\":2,\"312\":2,\"335\":1,\"336\":1,\"355\":2,\"357\":2,\"361\":3,\"383\":1,\"385\":1,\"392\":1,\"407\":1,\"409\":1,\"424\":1,\"428\":1,\"432\":1,\"436\":1,\"440\":1,\"463\":1,\"467\":1,\"477\":2,\"480\":1,\"482\":3,\"599\":1}}],[\"clientsocket\",{\"1\":{\"424\":3}}],[\"client\",{\"1\":{\"11\":1,\"567\":1}}],[\"cpu等资源\",{\"1\":{\"577\":1}}],[\"cpu不再运行\",{\"1\":{\"577\":1}}],[\"cpu消耗\",{\"0\":{\"414\":1}}],[\"cpu占用率等\",{\"1\":{\"78\":1}}],[\"cpu使用率\",{\"1\":{\"54\":1}}],[\"cpu\",{\"1\":{\"54\":1,\"89\":3,\"344\":2,\"348\":1,\"349\":4,\"498\":1,\"499\":1}}],[\"c4deployment\",{\"0\":{\"44\":1}}],[\"c4dynamic\",{\"0\":{\"43\":1}}],[\"c4component\",{\"0\":{\"42\":1}}],[\"c4container\",{\"0\":{\"41\":1}}],[\"c4context\",{\"0\":{\"40\":1}}],[\"c4\",{\"0\":{\"39\":1,\"40\":1,\"41\":1,\"42\":1,\"43\":1,\"44\":1}}],[\"cnf\",{\"1\":{\"595\":2}}],[\"cnf到mysql容器的配置文件\",{\"1\":{\"587\":1}}],[\"cnf文件上传到\",{\"1\":{\"587\":1}}],[\"cn\",{\"1\":{\"17\":1}}],[\"column2\",{\"1\":{\"609\":2,\"614\":3}}],[\"column1\",{\"1\":{\"608\":2,\"609\":2,\"614\":3}}],[\"column\",{\"1\":{\"428\":1}}],[\"collect\",{\"1\":{\"383\":1}}],[\"collectors\",{\"1\":{\"383\":2,\"385\":1}}],[\"collector\",{\"1\":{\"137\":1,\"140\":1,\"151\":1,\"159\":1,\"179\":1}}],[\"collections\",{\"1\":{\"141\":2,\"148\":1,\"546\":1}}],[\"collection\",{\"1\":{\"131\":1,\"135\":1}}],[\"corepoolsize\",{\"1\":{\"408\":1,\"409\":1,\"442\":2,\"448\":1,\"460\":2,\"463\":2}}],[\"countdown\",{\"1\":{\"353\":9}}],[\"countdownlatch在计数器为0\",{\"1\":{\"356\":1}}],[\"countdownlatch面向的是任务\",{\"1\":{\"356\":1}}],[\"countdownlatch中的各个子线程不可以等待其他线程\",{\"1\":{\"356\":1}}],[\"countdownlatch是一次性的\",{\"1\":{\"356\":2}}],[\"countdownlatch的核心方法\",{\"1\":{\"353\":1}}],[\"countdownlatch\",{\"0\":{\"353\":1},\"1\":{\"353\":22,\"356\":1}}],[\"count++\",{\"1\":{\"334\":1}}],[\"count\",{\"1\":{\"244\":3,\"334\":2,\"485\":3,\"592\":1}}],[\"counter\",{\"1\":{\"92\":1,\"94\":1,\"179\":1}}],[\"copyonwrite\",{\"1\":{\"522\":1}}],[\"copyonwritearraylist适合在读多写少的场景中使用\",{\"1\":{\"522\":1}}],[\"copyonwritearraylist通过创建副本的方式实现线程安全\",{\"1\":{\"522\":1}}],[\"copyonwritearraylist就是线程安全版本的arraylist\",{\"1\":{\"522\":1}}],[\"copyonwritearraylist了解多少\",{\"0\":{\"522\":1}}],[\"copyonwritearraylist具有较高的性能\",{\"1\":{\"521\":1}}],[\"copyonwritearraylist是一种线程安全的并发list\",{\"1\":{\"521\":1}}],[\"copy\",{\"1\":{\"148\":1,\"592\":2,\"593\":1,\"598\":1}}],[\"copying\",{\"1\":{\"131\":1}}],[\"code\",{\"1\":{\"130\":1,\"289\":1,\"516\":1,\"525\":1}}],[\"codec\",{\"1\":{\"11\":1}}],[\"communication\",{\"1\":{\"647\":1}}],[\"command\",{\"1\":{\"583\":1}}],[\"common\",{\"1\":{\"649\":1}}],[\"commons\",{\"1\":{\"428\":2}}],[\"commonpool\",{\"1\":{\"387\":1,\"388\":1,\"398\":1}}],[\"commonclassloader\",{\"1\":{\"234\":1}}],[\"compose中的服务名\",{\"1\":{\"597\":1}}],[\"compose文件\",{\"0\":{\"598\":1},\"1\":{\"597\":1,\"598\":1}}],[\"compose文件是一个文本文件\",{\"1\":{\"595\":1}}],[\"compose\",{\"1\":{\"595\":2,\"597\":1,\"602\":1}}],[\"compose可以基于compose文件帮我们快速的部署分布式应用\",{\"1\":{\"594\":1}}],[\"component\",{\"1\":{\"255\":1}}],[\"comprator\",{\"1\":{\"552\":1}}],[\"compute\",{\"1\":{\"480\":9}}],[\"completed\",{\"1\":{\"477\":1}}],[\"completeontimeout\",{\"0\":{\"381\":1},\"1\":{\"381\":1}}],[\"completablefuture的线程池设置\",{\"0\":{\"387\":1}}],[\"completablefuturerealworldexample\",{\"1\":{\"385\":1}}],[\"completablefutureparallelexample\",{\"1\":{\"383\":1}}],[\"completablefuture<void>\",{\"1\":{\"367\":1,\"375\":1,\"383\":1,\"385\":1}}],[\"completablefuture<string>\",{\"1\":{\"367\":1,\"369\":1,\"373\":1,\"374\":3,\"375\":3,\"377\":1,\"378\":1,\"380\":1,\"381\":1,\"383\":3,\"385\":6,\"388\":1,\"391\":1,\"392\":1}}],[\"completablefuture\",{\"0\":{\"367\":1,\"372\":1,\"466\":1},\"1\":{\"365\":1,\"367\":3,\"369\":1,\"370\":1,\"371\":1,\"373\":4,\"374\":3,\"375\":5,\"377\":1,\"378\":1,\"380\":1,\"381\":1,\"383\":5,\"385\":5,\"386\":1,\"387\":1,\"388\":2,\"389\":2,\"391\":2,\"392\":2,\"398\":2,\"466\":2}}],[\"compiler\",{\"1\":{\"179\":1}}],[\"comparator\",{\"1\":{\"242\":1}}],[\"compareandsetint是个native方法\",{\"1\":{\"511\":1}}],[\"compareandsetint\",{\"1\":{\"511\":2,\"549\":2}}],[\"compareandset\",{\"1\":{\"505\":2,\"510\":1}}],[\"compareto\",{\"1\":{\"244\":1}}],[\"compare\",{\"1\":{\"120\":1,\"502\":1,\"510\":1}}],[\"compacting\",{\"1\":{\"139\":1}}],[\"compact\",{\"1\":{\"131\":1,\"147\":1}}],[\"com\",{\"1\":{\"90\":1,\"204\":1,\"215\":1,\"220\":2,\"252\":2,\"436\":1,\"590\":1,\"595\":1,\"599\":1}}],[\"congregation\",{\"0\":{\"780\":1}}],[\"condition\",{\"1\":{\"614\":1}}],[\"conf目录\",{\"1\":{\"598\":1}}],[\"conf\",{\"1\":{\"587\":3,\"595\":2,\"598\":2}}],[\"configured\",{\"1\":{\"649\":1}}],[\"configuration\",{\"1\":{\"252\":1,\"644\":1,\"649\":1}}],[\"config\",{\"0\":{\"17\":1}}],[\"conn\",{\"1\":{\"428\":2}}],[\"connection\",{\"1\":{\"428\":2}}],[\"containername\",{\"1\":{\"578\":1}}],[\"container\",{\"1\":{\"565\":1}}],[\"contextclassloader\",{\"1\":{\"336\":3}}],[\"continue\",{\"0\":{\"263\":1},\"1\":{\"263\":1}}],[\"control管理工具\",{\"1\":{\"114\":1}}],[\"control\",{\"0\":{\"60\":1},\"1\":{\"60\":1,\"70\":1,\"141\":1,\"649\":2}}],[\"conscious\",{\"1\":{\"516\":1}}],[\"constrained\",{\"1\":{\"649\":1}}],[\"constraint功能约束\",{\"1\":{\"649\":1}}],[\"constructor\",{\"1\":{\"254\":1,\"289\":1}}],[\"constant\",{\"1\":{\"95\":1,\"103\":1,\"104\":2}}],[\"consumer\",{\"1\":{\"242\":1,\"361\":3,\"362\":1}}],[\"concurrent包下的容器都是安全失败\",{\"1\":{\"520\":1}}],[\"concurrent包提供了多种线程池实现\",{\"1\":{\"405\":1}}],[\"concurrenthashmap线程安全在jdk1\",{\"1\":{\"547\":1}}],[\"concurrenthashmap\",{\"1\":{\"291\":1,\"546\":2}}],[\"concurrent\",{\"0\":{\"779\":1},\"1\":{\"137\":1,\"139\":3,\"140\":1,\"141\":2,\"142\":1,\"146\":1,\"147\":1,\"151\":1,\"159\":1,\"361\":1,\"383\":2,\"385\":2,\"390\":2,\"392\":4,\"407\":3,\"409\":3,\"424\":2,\"432\":3,\"436\":2,\"440\":3,\"467\":1,\"477\":2,\"480\":1}}],[\"concgcthreads\",{\"1\":{\"73\":1}}],[\"c\",{\"1\":{\"11\":2,\"238\":1,\"320\":1,\"593\":1,\"631\":2}}],[\"createinheritedmap\",{\"1\":{\"336\":1}}],[\"created\",{\"1\":{\"89\":1}}],[\"create\",{\"1\":{\"10\":1,\"11\":1,\"583\":1,\"584\":2}}],[\"04\",{\"1\":{\"592\":1}}],[\"0得0\",{\"1\":{\"535\":1}}],[\"00000006\",{\"1\":{\"539\":1}}],[\"00\",{\"1\":{\"494\":1}}],[\"01\",{\"1\":{\"493\":1}}],[\"0x61c88647\",{\"1\":{\"332\":2}}],[\"0x0000000000000000\",{\"1\":{\"89\":1}}],[\"0d\",{\"1\":{\"258\":1}}],[\"0f\",{\"1\":{\"258\":1}}],[\"0l\",{\"1\":{\"258\":1,\"457\":1,\"459\":1,\"465\":1}}],[\"0\",{\"1\":{\"11\":16,\"51\":1,\"124\":1,\"204\":2,\"215\":1,\"220\":1,\"243\":1,\"258\":5,\"282\":1,\"303\":1,\"334\":1,\"336\":2,\"377\":1,\"378\":1,\"407\":1,\"409\":1,\"440\":1,\"458\":1,\"477\":2,\"485\":8,\"501\":1,\"516\":3,\"531\":3,\"532\":1,\"549\":7,\"592\":2,\"604\":3,\"621\":1}}],[\"4中\",{\"1\":{\"631\":1}}],[\"4和图1\",{\"1\":{\"631\":1}}],[\"42\",{\"1\":{\"467\":1}}],[\"4028235e38\",{\"1\":{\"258\":1}}],[\"409\",{\"1\":{\"11\":1}}],[\"45\",{\"1\":{\"258\":1}}],[\"4e\",{\"1\":{\"258\":1}}],[\"4之前的选择\",{\"1\":{\"238\":1}}],[\"4\",{\"0\":{\"31\":1,\"61\":1,\"81\":1,\"187\":1,\"202\":1,\"212\":1,\"218\":1,\"229\":1,\"372\":1,\"373\":1,\"374\":1,\"375\":1,\"393\":1,\"394\":1,\"395\":1,\"396\":1,\"397\":2,\"407\":1,\"433\":1,\"445\":1,\"460\":1,\"465\":1,\"472\":1,\"562\":1,\"568\":1,\"569\":1,\"574\":1,\"580\":1,\"585\":1,\"594\":1,\"595\":1,\"596\":1,\"597\":1,\"598\":1,\"599\":1,\"600\":1,\"601\":2,\"602\":1},\"1\":{\"11\":2,\"258\":3,\"333\":2,\"334\":3,\"432\":2,\"493\":1,\"494\":1,\"575\":1,\"587\":1,\"610\":1,\"617\":1,\"622\":1,\"631\":2,\"636\":1,\"649\":1}}],[\"7电容式电压互感器原理示意图\",{\"1\":{\"632\":1}}],[\"7所示分别为电阻分压式电压互感器和电容式电压互感器的原理示意图\",{\"1\":{\"632\":1}}],[\"7就是tag\",{\"1\":{\"571\":1}}],[\"7版本的mysql镜像\",{\"1\":{\"571\":1}}],[\"7版本的concurrenthashmap采用分段锁机制\",{\"1\":{\"548\":1}}],[\"7版本是基于\",{\"1\":{\"547\":1}}],[\"7和jdk1\",{\"1\":{\"545\":2}}],[\"7和1\",{\"1\":{\"93\":1,\"99\":1,\"100\":1}}],[\"75作为hashmap的默认加载因子呢\",{\"0\":{\"541\":1}}],[\"75\",{\"0\":{\"540\":1}}],[\"7976931348623157e308\",{\"1\":{\"258\":1}}],[\"7及以前版本\",{\"1\":{\"133\":1}}],[\"7及以前版本的概念\",{\"1\":{\"130\":1}}],[\"7及之前的版本中\",{\"1\":{\"117\":1}}],[\"7开始位于堆中\",{\"1\":{\"105\":2}}],[\"7开始\",{\"1\":{\"103\":1,\"104\":1}}],[\"7中\",{\"1\":{\"95\":1,\"114\":1,\"545\":1}}],[\"731f\",{\"1\":{\"89\":2}}],[\"7428\",{\"1\":{\"11\":2}}],[\"7\",{\"0\":{\"34\":1,\"64\":1,\"93\":1,\"95\":1,\"190\":1,\"232\":1,\"382\":1,\"548\":1,\"588\":1},\"1\":{\"11\":2,\"89\":1,\"98\":1,\"101\":1,\"262\":1,\"432\":1,\"525\":1,\"595\":2,\"598\":3,\"631\":2,\"636\":1,\"649\":1}}],[\"创建目录\",{\"1\":{\"587\":2}}],[\"创建容器并挂载数据卷到容器内的html目录\",{\"1\":{\"586\":1}}],[\"创建数据卷\",{\"1\":{\"584\":2}}],[\"创建和查看数据卷\",{\"0\":{\"584\":1}}],[\"创建并运行mysql容器\",{\"1\":{\"587\":1}}],[\"创建并运行一个mysql容器\",{\"1\":{\"587\":1}}],[\"创建并运行一个容器\",{\"0\":{\"578\":1},\"1\":{\"577\":1,\"578\":1}}],[\"创建并运行nginx容器的命令\",{\"1\":{\"578\":1}}],[\"创建并启动两个线程\",{\"1\":{\"361\":1}}],[\"创建并启动六个线程模拟汽车\",{\"1\":{\"357\":1}}],[\"创建并启动三个线程\",{\"1\":{\"355\":1}}],[\"创建定时任务线程池\",{\"1\":{\"460\":1}}],[\"创建单线程线程池\",{\"1\":{\"459\":1}}],[\"创建缓存线程池\",{\"1\":{\"458\":1}}],[\"创建核心线程执行任务\",{\"1\":{\"457\":1}}],[\"创建核心线程和任务队列\",{\"1\":{\"447\":1}}],[\"创建固定大小线程池\",{\"1\":{\"457\":1}}],[\"创建新线程执行任务\",{\"1\":{\"444\":1}}],[\"创建自定义线程池\",{\"0\":{\"390\":1},\"1\":{\"392\":1,\"409\":1}}],[\"创建cyclicbarrier实例\",{\"1\":{\"355\":1}}],[\"创建class对象\",{\"0\":{\"194\":1},\"1\":{\"195\":1}}],[\"创建\",{\"0\":{\"367\":1},\"1\":{\"326\":1}}],[\"创建了一个threadloca变量localvariable\",{\"1\":{\"326\":1}}],[\"创建了一个threadlocal变量\",{\"1\":{\"326\":1}}],[\"创建了几个对象\",{\"1\":{\"269\":1}}],[\"创建对象有哪几种方式\",{\"0\":{\"308\":1}}],[\"创建对象实例的方式\",{\"1\":{\"254\":1}}],[\"创建类实例\",{\"1\":{\"254\":1}}],[\"创建类的实例\",{\"1\":{\"215\":1}}],[\"创建一个nginx容器\",{\"1\":{\"586\":1}}],[\"创建一个数据卷\",{\"1\":{\"584\":1}}],[\"创建一个volume\",{\"1\":{\"583\":1}}],[\"创建一个\",{\"1\":{\"480\":1}}],[\"创建一个固定大小的线程池\",{\"1\":{\"390\":1,\"407\":1}}],[\"创建一个自定义的线程池\",{\"1\":{\"463\":1}}],[\"创建一个自定义的类加载器\",{\"1\":{\"220\":1}}],[\"创建一个自定义线程池\",{\"1\":{\"390\":1}}],[\"创建一个包含所有异步任务的completablefuture\",{\"1\":{\"383\":1}}],[\"创建一个exchanger实例\",{\"1\":{\"361\":1}}],[\"创建一个semaphore实例\",{\"1\":{\"357\":1}}],[\"创建一个threadlocal变量\",{\"1\":{\"326\":1}}],[\"创建一个线程\",{\"1\":{\"220\":1}}],[\"创建一个1mb大小的字节数组对象\",{\"1\":{\"124\":1}}],[\"创建myclassloader对象并指定类文件路径\",{\"1\":{\"204\":1}}],[\"创建过程\",{\"0\":{\"11\":1}}],[\"创建项目模板\",{\"0\":{\"10\":1}}],[\"pmt\",{\"1\":{\"649\":1}}],[\"persistent\",{\"1\":{\"649\":1}}],[\"persist\",{\"1\":{\"649\":1}}],[\"pers\",{\"1\":{\"649\":1}}],[\"permitted许可\",{\"1\":{\"649\":1}}],[\"permit\",{\"1\":{\"649\":1}}],[\"permanent\",{\"1\":{\"94\":1,\"130\":1}}],[\"permgen\",{\"0\":{\"98\":1},\"1\":{\"92\":1,\"94\":1,\"95\":1,\"103\":1,\"111\":1,\"113\":1,\"116\":1}}],[\"permsize=128m\",{\"1\":{\"72\":1}}],[\"permsize\",{\"1\":{\"72\":1}}],[\"physical\",{\"1\":{\"649\":1}}],[\"phantom\",{\"1\":{\"128\":1}}],[\"pd\",{\"1\":{\"649\":1}}],[\"p参数\",{\"1\":{\"578\":1}}],[\"pipedreader和pipedwriter\",{\"1\":{\"351\":1}}],[\"pipedinputstream\",{\"1\":{\"351\":1}}],[\"pipedoutputstream\",{\"1\":{\"351\":1}}],[\"pid\",{\"1\":{\"88\":3,\"89\":7}}],[\"pinpoint\",{\"0\":{\"69\":1},\"1\":{\"69\":1,\"70\":2}}],[\"prune\",{\"1\":{\"583\":1,\"584\":1}}],[\"present\",{\"1\":{\"554\":1}}],[\"preparestatement\",{\"1\":{\"428\":1}}],[\"preparedstatement\",{\"1\":{\"428\":2}}],[\"preparation\",{\"0\":{\"186\":1},\"1\":{\"183\":1}}],[\"predicate\",{\"1\":{\"242\":1}}],[\"pretenuresizethreshold参数来设置大对象的大小阈值\",{\"1\":{\"136\":1}}],[\"priority\",{\"1\":{\"450\":1}}],[\"prio=0\",{\"1\":{\"89\":1}}],[\"prio=9\",{\"1\":{\"89\":1}}],[\"private\",{\"0\":{\"297\":1},\"1\":{\"204\":2,\"220\":1,\"268\":1,\"297\":1,\"300\":1,\"311\":1,\"312\":1,\"332\":3,\"334\":2,\"353\":1,\"355\":1,\"357\":1,\"361\":2,\"385\":3,\"424\":2,\"432\":1,\"436\":1,\"477\":5,\"480\":1,\"505\":1,\"516\":1,\"549\":1}}],[\"print\",{\"1\":{\"282\":1,\"311\":2,\"312\":2}}],[\"printstacktrace\",{\"1\":{\"204\":1,\"220\":1,\"353\":1,\"355\":1,\"357\":1,\"361\":2,\"375\":1,\"385\":1,\"428\":1,\"462\":1,\"463\":1,\"464\":1,\"466\":1,\"467\":2}}],[\"println\",{\"1\":{\"124\":2,\"172\":1,\"173\":1,\"190\":3,\"204\":1,\"207\":2,\"215\":1,\"220\":1,\"243\":1,\"244\":4,\"252\":1,\"282\":3,\"311\":1,\"312\":1,\"335\":1,\"353\":3,\"355\":4,\"357\":3,\"361\":4,\"370\":1,\"371\":1,\"375\":1,\"383\":2,\"385\":1,\"392\":2,\"398\":1,\"407\":1,\"409\":1,\"428\":1,\"432\":1,\"436\":3,\"440\":1,\"465\":1,\"467\":1,\"477\":2,\"480\":1}}],[\"printf\",{\"1\":{\"85\":1,\"89\":2}}],[\"processing\",{\"1\":{\"432\":1}}],[\"process\",{\"1\":{\"432\":2}}],[\"protocol\",{\"1\":{\"277\":1}}],[\"protobuf\",{\"1\":{\"277\":1}}],[\"protobuf序列化\",{\"1\":{\"277\":1}}],[\"protected和default修饰符\",{\"1\":{\"299\":1}}],[\"protected\",{\"0\":{\"297\":1},\"1\":{\"129\":1,\"204\":1,\"222\":1,\"297\":1,\"463\":1,\"480\":1}}],[\"provider\",{\"1\":{\"252\":3}}],[\"promotion\",{\"1\":{\"135\":1}}],[\"prometheus\",{\"0\":{\"63\":1},\"1\":{\"63\":1,\"70\":2}}],[\"programming\",{\"1\":{\"138\":1}}],[\"program\",{\"1\":{\"92\":1,\"94\":1,\"179\":1}}],[\"progress\",{\"1\":{\"11\":2}}],[\"profiler\",{\"0\":{\"61\":1}}],[\"producer\",{\"1\":{\"361\":3,\"362\":1}}],[\"prod\",{\"1\":{\"11\":1}}],[\"project\",{\"1\":{\"11\":1}}],[\"p\",{\"1\":{\"85\":1,\"89\":1,\"165\":2,\"172\":3,\"531\":9,\"578\":2,\"580\":1,\"585\":1,\"586\":1}}],[\"pull命令拉取镜像\",{\"1\":{\"575\":1}}],[\"pull\",{\"1\":{\"573\":1,\"604\":1}}],[\"put流程\",{\"1\":{\"548\":1,\"549\":1}}],[\"put和get并发时\",{\"1\":{\"545\":1}}],[\"puttreeval\",{\"1\":{\"531\":1}}],[\"put\",{\"1\":{\"477\":1,\"554\":1}}],[\"public\",{\"1\":{\"20\":1,\"104\":2,\"109\":2,\"124\":5,\"165\":2,\"172\":3,\"173\":3,\"190\":2,\"204\":3,\"207\":2,\"215\":5,\"220\":4,\"252\":3,\"282\":6,\"285\":4,\"289\":2,\"297\":1,\"299\":1,\"311\":3,\"312\":3,\"326\":1,\"335\":3,\"353\":2,\"355\":5,\"357\":4,\"361\":6,\"383\":2,\"385\":2,\"392\":2,\"407\":2,\"409\":2,\"424\":3,\"428\":2,\"432\":2,\"436\":2,\"440\":2,\"457\":1,\"458\":1,\"459\":1,\"460\":1,\"463\":2,\"464\":1,\"465\":1,\"467\":2,\"477\":7,\"480\":3,\"501\":2,\"505\":1,\"511\":4,\"532\":1,\"554\":1}}],[\"push\",{\"1\":{\"16\":1,\"604\":1}}],[\"pwa\",{\"1\":{\"17\":1}}],[\"posts\",{\"0\":{\"775\":1}}],[\"postinstall\",{\"1\":{\"11\":1}}],[\"power\",{\"1\":{\"621\":1}}],[\"powershell\",{\"1\":{\"11\":1}}],[\"polymorphicsignature\",{\"1\":{\"505\":1}}],[\"point对象的分配被消除了\",{\"1\":{\"173\":1}}],[\"point对象在examplemethod方法中创建\",{\"1\":{\"172\":1}}],[\"point对象只在examplemethod方法内部使用\",{\"1\":{\"165\":1}}],[\"point\",{\"1\":{\"138\":1,\"165\":5,\"172\":4,\"173\":1}}],[\"pointer\",{\"1\":{\"51\":1}}],[\"poolsize\",{\"1\":{\"424\":2,\"477\":6}}],[\"pool2\",{\"1\":{\"398\":3}}],[\"pool1\",{\"1\":{\"398\":3}}],[\"pool\",{\"1\":{\"95\":1,\"103\":1,\"104\":2,\"468\":1}}],[\"ports\",{\"1\":{\"595\":1,\"598\":3}}],[\"port\",{\"1\":{\"51\":2,\"89\":1,\"424\":2}}],[\"plugin通常与interceptor结合使用\",{\"1\":{\"656\":1}}],[\"plugin可以在mybatis的各个执行阶段插入自定义的逻辑\",{\"1\":{\"656\":1}}],[\"plugin是mybatis提供的插件接口\",{\"1\":{\"656\":1}}],[\"plugins>\",{\"1\":{\"600\":1}}],[\"plugin>\",{\"1\":{\"600\":1}}],[\"plugin<\",{\"1\":{\"600\":1}}],[\"plugin\",{\"0\":{\"665\":1},\"1\":{\"11\":1,\"656\":1}}],[\"pair\",{\"1\":{\"505\":1}}],[\"pair<v>\",{\"1\":{\"505\":2}}],[\"password\",{\"1\":{\"428\":1,\"595\":1,\"598\":2,\"599\":1}}],[\"pause\",{\"1\":{\"141\":2,\"148\":1,\"577\":1}}],[\"parser\",{\"0\":{\"695\":1}}],[\"parseint\",{\"1\":{\"273\":1}}],[\"parkinglot\",{\"1\":{\"357\":8,\"359\":3}}],[\"park\",{\"1\":{\"346\":1,\"496\":1}}],[\"parametermap可以方便地被parameterhandler使用\",{\"1\":{\"656\":1}}],[\"parametermap用于定义sql语句中参数与java对象属性之间的映射关系\",{\"1\":{\"656\":1}}],[\"parametermap\",{\"1\":{\"656\":1}}],[\"parameterhandler负责处理sql语句中的参数\",{\"1\":{\"656\":1}}],[\"parameterhandler\",{\"1\":{\"656\":1}}],[\"parameter\",{\"1\":{\"289\":1}}],[\"paralleldataprocessingexample\",{\"1\":{\"432\":1}}],[\"parallelism\",{\"1\":{\"319\":1}}],[\"parallel\",{\"1\":{\"137\":4,\"159\":1}}],[\"parallelgcthreads=4\",{\"1\":{\"73\":1}}],[\"parallelgcthreads\",{\"1\":{\"73\":1}}],[\"parentmap\",{\"1\":{\"336\":4}}],[\"parentdelegationexample\",{\"1\":{\"207\":2}}],[\"parent\",{\"1\":{\"203\":1,\"205\":1,\"207\":2,\"336\":2}}],[\"parnew是serial收集器的多线程版本\",{\"1\":{\"137\":1}}],[\"parnew收集器\",{\"1\":{\"137\":1}}],[\"path=$path\",{\"1\":{\"592\":1}}],[\"path\",{\"1\":{\"75\":1,\"204\":1}}],[\"padding\",{\"1\":{\"51\":1,\"121\":3}}],[\"packet\",{\"1\":{\"51\":2}}],[\"packages\",{\"1\":{\"11\":1}}],[\"package\",{\"1\":{\"11\":1}}],[\"pages是发布分支\",{\"1\":{\"22\":1}}],[\"pages分支\",{\"0\":{\"22\":1}}],[\"pages\",{\"0\":{\"19\":1,\"21\":1},\"1\":{\"11\":1,\"21\":1,\"22\":1}}],[\"pages搭建\",{\"1\":{\"8\":1}}],[\"psh\",{\"1\":{\"51\":1}}],[\"ps\",{\"1\":{\"11\":1,\"54\":1,\"580\":2}}],[\"pnpm\",{\"1\":{\"10\":1,\"11\":5}}],[\"和$\",{\"0\":{\"766\":1}}],[\"和立即加载\",{\"0\":{\"686\":1}}],[\"和服务器通信可访问数据对象\",{\"1\":{\"636\":1}}],[\"和hashmap的get流程基本相同\",{\"1\":{\"549\":1}}],[\"和统计学有关\",{\"1\":{\"539\":1}}],[\"和安全失败\",{\"0\":{\"520\":1}}],[\"和内存位置\",{\"1\":{\"502\":1}}],[\"和内存泄漏\",{\"1\":{\"123\":1}}],[\"和新值\",{\"1\":{\"502\":1}}],[\"和公平锁一样都会进入到\",{\"1\":{\"501\":1}}],[\"和notify\",{\"1\":{\"495\":1}}],[\"和unlock\",{\"1\":{\"495\":1}}],[\"和第\",{\"1\":{\"480\":1}}],[\"和recursiveaction用于表示没有返回值的任务\",{\"1\":{\"480\":1}}],[\"和submit\",{\"1\":{\"451\":1}}],[\"和string\",{\"0\":{\"269\":1}}],[\"和无界队列\",{\"1\":{\"448\":1}}],[\"和任务队列\",{\"1\":{\"442\":1}}],[\"和join\",{\"1\":{\"351\":1}}],[\"和非静态内部类\",{\"1\":{\"309\":1}}],[\"和引用数据类型变量的地址值\",{\"1\":{\"307\":1}}],[\"和引用类型的null\",{\"1\":{\"117\":1}}],[\"和常量\",{\"1\":{\"299\":1}}],[\"和接口\",{\"0\":{\"299\":1}}],[\"和接⼝\",{\"1\":{\"295\":1}}],[\"和重写\",{\"0\":{\"296\":1}}],[\"和⼯具\",{\"1\":{\"247\":1}}],[\"和其对应的类加载器一起替换\",{\"1\":{\"224\":1}}],[\"和卸载\",{\"1\":{\"183\":1}}],[\"和即时编译器\",{\"1\":{\"179\":1}}],[\"和本地方法栈\",{\"1\":{\"179\":1}}],[\"和栈\",{\"1\":{\"178\":1}}],[\"和标记\",{\"1\":{\"148\":1}}],[\"和清理\",{\"1\":{\"141\":1}}],[\"和类unloading的机制\",{\"1\":{\"139\":1}}],[\"和对齐填充\",{\"1\":{\"121\":1}}],[\"和符号引用\",{\"1\":{\"107\":1}}],[\"和两个幸存者区\",{\"1\":{\"92\":1}}],[\"和老年代\",{\"1\":{\"87\":1,\"92\":1}}],[\"和\",{\"0\":{\"247\":1,\"261\":1,\"269\":1,\"467\":1,\"672\":1,\"684\":1,\"759\":1},\"1\":{\"8\":1,\"89\":3,\"126\":1,\"234\":1,\"236\":3,\"247\":1,\"320\":1,\"350\":1,\"355\":1,\"519\":1,\"530\":1,\"543\":1,\"609\":1,\"612\":1,\"614\":1,\"618\":2}}],[\"幻灯片页\",{\"0\":{\"6\":1}}],[\"趋势\",{\"0\":{\"4\":1}}],[\"||\",{\"1\":{\"531\":3,\"532\":2,\"549\":5,\"554\":1}}],[\"|\",{\"1\":{\"1\":1,\"11\":2,\"85\":1,\"86\":1,\"88\":1,\"121\":14,\"220\":4,\"355\":1,\"375\":1,\"383\":1,\"385\":1}}],[\"欢迎来到鱼塘\",{\"1\":{\"1\":1}}],[\"鱼塘\",{\"0\":{\"0\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n}})=>{e==="suggest"?self.postMessage(st(t,v[s],n)):e==="search"?self.postMessage(et(t,v[s],n)):self.postMessage({suggestions:st(t,v[s],n),results:et(t,v[s],n)})};
//# sourceMappingURL=index.js.map
