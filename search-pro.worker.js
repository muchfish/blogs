const nt="ENTRIES",V="KEYS",T="VALUES",F="";class D{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===F)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==F).join("")}value(){return E(this._path).node.get(F)}result(){switch(this._type){case T:return this.value();case V:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],ot=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return W(e,t,s,n,i,1,o,""),n},W=(e,t,s,n,o,u,i,r)=>{const h=u*i;t:for(const c of e.keys())if(c===F){const d=o[h-1];d<=s&&n.set(r,[e.get(c),d])}else{let d=u;for(let l=0;l<c.length;++l,++d){const p=c[l],f=i*d,g=f-i;let a=o[f];const m=Math.max(0,d-s-1),y=Math.min(i-1,d+s);for(let _=m;_<y;++_){const b=p!==t[_],z=o[g+_]+ +b,A=o[g+_+1]+1,w=o[f+_]+1,L=o[f+_+1]=Math.min(z,A,w);L<a&&(a=L)}if(a>s)continue t}W(e.get(c),t,s,n,o,d,i,r+c)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=O(n);for(const i of o.keys())if(i!==F&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ut(this._tree,t)}entries(){return new D(this,nt)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return ot(this._tree,t,s)}get(t){const s=I(this._tree,t);return s!==void 0?s.get(F):void 0}has(t){const s=I(this._tree,t);return s!==void 0&&s.has(F)}keys(){return new D(this,V)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,M(this._tree,t).set(F,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=M(this._tree,t);return n.set(F,s(n.get(F))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=M(this._tree,t);let o=n.get(F);return o===void 0&&n.set(F,o=s()),o}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==F&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},I=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==F&&t.startsWith(s))return I(e.get(s),t.slice(s.length))},M=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==F&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const h=e.get(u);if(r===u.length)e=h;else{const c=new Map;c.set(u.slice(r),h),e.set(t.slice(n,n+r),c),e.delete(u),e=c}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ut=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(F),s.size===0)R(n);else if(s.size===1){const[o,u]=s.entries().next().value;$(n,o,u)}}},R=e=>{if(e.length===0)return;const[t,s]=O(e);if(t.delete(s),t.size===0)R(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==F&&$(e.slice(0,-1),n,o)}},$=(e,t,s)=>{if(e.length===0)return;const[n,o]=O(e);n.set(o+t,s),n.delete(o)},O=e=>e[e.length-1],it=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},rt=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,S="or",q="and",ct="and_not",lt=(e,t)=>{e.includes(t)||e.push(t)},P=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},G=({score:e},{score:t})=>t-e,ht=()=>new Map,k=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},N=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,dt={[S]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),P(n.terms,u)}}return e},[q]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);P(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[ct]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},at=(e,t,s,n,o,u)=>{const{k:i,b:r,d:h}=u;return Math.log(1+(s-t+.5)/(t+.5))*(h+e*(i+1)/(e+i*(1-r+r*n/o)))},ft=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},H=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},gt=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const o=e._index.fetch(n,ht),u=o.get(t);u==null||u.get(s)==null?H(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},mt={k:1.2,b:.7,d:.5},pt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(rt),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof(console==null?void 0:console[e])=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:S,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:mt},Ft={combineWith:q,prefix:(e,t,s)=>t===s.length-1},_t={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},yt={..._t,...U},Y=(e,t=S)=>{if(e.length===0)return new Map;const s=t.toLowerCase();return e.reduce(dt[s])||new Map},B=(e,t,s,n,o,u,i,r,h=new Map)=>{if(o==null)return h;for(const c of Object.keys(u)){const d=u[c],l=e._fieldIds[c],p=o.get(l);if(p==null)continue;let f=p.size;const g=e._avgFieldLength[l];for(const a of p.keys()){if(!e._documentIds.has(a)){gt(e,l,a,s),f-=1;continue}const m=i?i(e._documentIds.get(a),s,e._storedFields.get(a)):1;if(!m)continue;const y=p.get(a),_=e._fieldLength.get(a)[l],b=at(y,f,e._documentCount,_,g,r),z=n*d*m*b,A=h.get(a);if(A){A.score+=z,lt(A.terms,t);const w=N(A.match,s);w?w.push(c):A.match[s]=[c]}else h.set(a,{score:z,terms:[t],match:{[s]:[c]}})}}return h},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((a,m)=>({...a,[m]:N(n.boost,m)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:h}=n,{fuzzy:c,prefix:d}={...J.weights,...i},l=e._index.get(t.term),p=B(e,t.term,t.term,1,l,o,u,h);let f,g;if(t.prefix&&(f=e._index.atPrefix(t.term)),t.fuzzy){const a=t.fuzzy===!0?.2:t.fuzzy,m=a<1?Math.min(r,Math.round(t.term.length*a)):a;m&&(g=e._index.fuzzyGet(t.term,m))}if(f)for(const[a,m]of f){const y=a.length-t.term.length;if(!y)continue;g==null||g.delete(a);const _=d*a.length/(a.length+.3*y);B(e,t.term,a,_,m,o,u,h,p)}if(g)for(const a of g.keys()){const[m,y]=g.get(a);if(!y)continue;const _=c*a.length/(a.length+y);B(e,t.term,a,_,m,o,u,h,p)}return p},X=(e,t,s={})=>{if(typeof t!="string"){const d={...s,...t,queries:void 0},l=t.queries.map(p=>X(e,p,d));return Y(l,d.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:h}=i,c=r(t).flatMap(d=>h(d)).filter(d=>!!d).map(ft(i)).map(d=>At(e,d,i));return Y(c,i.combineWith)},K=(e,t,s={})=>{const n=X(e,t,s),o=[];for(const[u,{score:i,terms:r,match:h}]of n){const c=r.length,d={id:e._documentIds.get(u),score:i*c,terms:Object.keys(h),match:h};Object.assign(d,e._storedFields.get(u)),(s.filter==null||s.filter(d))&&o.push(d)}return o.sort(G),o},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of K(e,t,s)){const r=i.join(" "),h=n.get(r);h!=null?(h.score+=u,h.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:h}]of n)o.push({suggestion:u,terms:r,score:i/h});return o.sort(G),o};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if((t==null?void 0:t.fields)==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?yt:t.autoVacuum;this._options={...pt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...Ft,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:h,serializationVersion:c},d)=>{if(c!==1&&c!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const l=new Et(d);l._documentCount=t,l._nextId=s,l._documentIds=k(n),l._idToShortId=new Map,l._fieldIds=o,l._fieldLength=k(u),l._avgFieldLength=i,l._storedFields=k(r),l._dirtCount=h||0,l._index=new C;for(const[p,f]of l._documentIds)l._idToShortId.set(f,p);for(const[p,f]of e){const g=new Map;for(const a of Object.keys(f)){let m=f[a];c===1&&(m=m.ds),g.set(parseInt(a,10),k(m))}l._index.set(p,g)}return l},Q=Object.entries,wt=Object.fromEntries,j=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(c,d=!1)=>{let l="";i===0?l=c.length>20?`… ${c.slice(-20)}`:c:d?l=c.length+i>100?`${c.slice(0,100-i)}… `:c:l=c.length>20?`${c.slice(0,20)} … ${c.slice(-20)}`:c,l&&o.push(l),i+=l.length,d||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let h=s.indexOf(n,u);if(h===-1)return null;for(;h>=0;){const c=h+n.length;if(r(e.slice(u,h)),u=c,i>100)break;h=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},Z=/[\u4e00-\u9fa5]/g,tt=(e={})=>({fuzzy:.2,prefix:!0,processTerm:t=>{const s=t.match(Z)||[],n=t.replace(Z,"").toLowerCase();return n?[n,...s]:[...s]},...e}),xt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),kt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),et=(e,t,s={})=>{const n={};return K(t,e,tt({boost:{h:2,t:1,c:4},...s})).forEach(o=>{const{id:u,terms:i,score:r}=o,h=u.includes("@"),c=u.includes("#"),[d,l]=u.split(/[#@]/),{contents:p}=n[d]??={title:"",contents:[]};if(h)p.push([{type:"customField",key:d,index:l,display:i.map(f=>o.c.map(g=>j(g,f))).flat().filter(f=>f!==null)},r]);else{const f=i.map(g=>j(o.h,g)).filter(g=>g!==null);if(f.length&&p.push([{type:c?"heading":"title",key:d,...c&&{anchor:l},display:f},r]),"t"in o)for(const g of o.t){const a=i.map(m=>j(g,m)).filter(m=>m!==null);a.length&&p.push([{type:"text",key:d,...c&&{anchor:l},display:a},r])}}}),Q(n).sort(([,o],[,u])=>"max"==="total"?xt(o,u):kt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=it(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},st=(e,t,s={})=>Ct(t,e,tt(s)).map(({suggestion:n})=>n),v=wt(Q(JSON.parse("{\"/\":{\"documentCount\":75,\"nextId\":75,\"documentIds\":{\"0\":\"v-8daa1a0e\",\"1\":\"v-8daa1a0e#关于网站\",\"2\":\"v-8daa1a0e#关于作者\",\"3\":\"v-8daa1a0e#占个位\",\"4\":\"v-8daa1a0e#star-趋势\",\"5\":\"v-184f4da6\",\"6\":\"v-2e3eac9e\",\"7\":\"v-528d4ac2\",\"8\":\"v-528d4ac2#单例模式\",\"9\":\"v-528d4ac2#观察者模式\",\"10\":\"v-528d4ac2#发布-订阅模式\",\"11\":\"v-528d4ac2#中介者模式\",\"12\":\"v-528d4ac2#策略模式\",\"13\":\"v-528d4ac2#装饰器模式\",\"14\":\"v-528d4ac2@0\",\"15\":\"v-528d4ac2@1\",\"16\":\"v-6124e2da\",\"17\":\"v-6124e2da#基础概念与常识\",\"18\":\"v-6124e2da#java-语言有哪些特点\",\"19\":\"v-6124e2da#java-se-vs-java-ee\",\"20\":\"v-6124e2da#jvm-vs-jdk-vs-jre\",\"21\":\"v-6124e2da#jvm\",\"22\":\"v-6124e2da#jdk-和-jre\",\"23\":\"v-6124e2da#什么是字节码-采用字节码的好处是什么\",\"24\":\"v-6124e2da#为什么说-java-语言-编译与解释并存\",\"25\":\"v-6124e2da#aot-有什么优点-为什么不全部使用-aot-呢\",\"26\":\"v-6124e2da#oracle-jdk-vs-openjdk\",\"27\":\"v-6124e2da#java-和-c-的区别\",\"28\":\"v-6124e2da#基本语法\",\"29\":\"v-6124e2da#注释有哪几种形式\",\"30\":\"v-6124e2da#标识符和关键字的区别是什么\",\"31\":\"v-6124e2da#java-语言关键字有哪些\",\"32\":\"v-6124e2da#自增自减运算符\",\"33\":\"v-6124e2da#移位运算符\",\"34\":\"v-6124e2da#continue、break-和-return-的区别是什么\",\"35\":\"v-6124e2da#基本数据类型\",\"36\":\"v-6124e2da#java-中的几种基本数据类型了解么\",\"37\":\"v-6124e2da#基本类型和包装类型的区别\",\"38\":\"v-6124e2da#包装类型的缓存机制了解么\",\"39\":\"v-6124e2da#自动装箱与拆箱了解吗-原理是什么\",\"40\":\"v-6124e2da#为什么浮点数运算的时候会有精度丢失的风险\",\"41\":\"v-6124e2da#如何解决浮点数运算的精度丢失问题\",\"42\":\"v-6124e2da#超过-long-整型的数据应该如何表示\",\"43\":\"v-6124e2da#变量\",\"44\":\"v-6124e2da#成员变量与局部变量的区别\",\"45\":\"v-6124e2da#静态变量有什么作用\",\"46\":\"v-6124e2da#字符型常量和字符串常量的区别\",\"47\":\"v-6124e2da#方法\",\"48\":\"v-6124e2da#什么是方法的返回值-方法有哪几种类型\",\"49\":\"v-6124e2da#静态方法为什么不能调用非静态成员\",\"50\":\"v-6124e2da#静态方法和实例方法有何不同\",\"51\":\"v-6124e2da#重载和重写有什么区别\",\"52\":\"v-6124e2da#重载\",\"53\":\"v-6124e2da#重写\",\"54\":\"v-6124e2da#总结\",\"55\":\"v-6124e2da#什么是可变长参数\",\"56\":\"v-6124e2da#参考\",\"57\":\"v-6124e2da@0\",\"58\":\"v-6124e2da@1\",\"59\":\"v-8c7d3d56\",\"60\":\"v-8c7d3d56#形参-实参\",\"61\":\"v-8c7d3d56#值传递-引用传递\",\"62\":\"v-8c7d3d56#为什么-java-只有值传递\",\"63\":\"v-8c7d3d56#案例-1-传递基本类型参数\",\"64\":\"v-8c7d3d56#案例-2-传递引用类型参数-1\",\"65\":\"v-8c7d3d56#案例-3-传递引用类型参数-2\",\"66\":\"v-8c7d3d56#引用传递是怎么样的\",\"67\":\"v-8c7d3d56#为什么-java-不引入引用传递呢\",\"68\":\"v-8c7d3d56#总结\",\"69\":\"v-8c7d3d56#参考\",\"70\":\"v-8c7d3d56@0\",\"71\":\"v-8c7d3d56@1\",\"72\":\"v-e1e3da16\",\"73\":\"v-ffb970b6\",\"74\":\"v-14c69af4\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1],\"1\":[1,6],\"2\":[1,1],\"3\":[1,1],\"4\":[2,1],\"5\":[1],\"6\":[1],\"7\":[2,4],\"8\":[1,24],\"9\":[1,64],\"10\":[2,96],\"11\":[1,45],\"12\":[1,39],\"13\":[1,32],\"14\":[null,null,1],\"15\":[null,null,2],\"16\":[3,3],\"17\":[1],\"18\":[3,81],\"19\":[4,54],\"20\":[4],\"21\":[1,51],\"22\":[3,121],\"23\":[3,74],\"24\":[5,59],\"25\":[5,114],\"26\":[4,235],\"27\":[5,31],\"28\":[1],\"29\":[2,57],\"30\":[2,30],\"31\":[3,105],\"32\":[1,42],\"33\":[1,128],\"34\":[6,58],\"35\":[1],\"36\":[3,111],\"37\":[2,64],\"38\":[2,105],\"39\":[3,61],\"40\":[2,45],\"41\":[2,31],\"42\":[4,30],\"43\":[1],\"44\":[2,95],\"45\":[2,30],\"46\":[2,55],\"47\":[1],\"48\":[3,37],\"49\":[2,41],\"50\":[2,43],\"51\":[2,6],\"52\":[1,36],\"53\":[1,15],\"54\":[1,66],\"55\":[2,69],\"56\":[1,36],\"57\":[null,null,1],\"58\":[null,null,1],\"59\":[2,6],\"60\":[2,30],\"61\":[2,20],\"62\":[4,8],\"63\":[3,42],\"64\":[4,44],\"65\":[4,40],\"66\":[2,43],\"67\":[4,37],\"68\":[1,13],\"69\":[1,30],\"70\":[null,null,1],\"71\":[null,null,1],\"72\":[1],\"73\":[1],\"74\":[1]},\"averageFieldLength\":[2.11886573576799,46.22029754670109,0.23684675141242936],\"storedFields\":{\"0\":{\"h\":\"鱼塘\"},\"1\":{\"h\":\"关于网站\",\"t\":[\"欢迎来到鱼塘\",\"传送门：GitHub | Gitee。\",\"项目介绍\"]},\"2\":{\"h\":\"关于作者\",\"t\":[\"关于作者\"]},\"3\":{\"h\":\"占个位\",\"t\":[\"占个位\"]},\"4\":{\"h\":\"Star 趋势\",\"t\":[\"Stars\"]},\"5\":{\"h\":\"主页\"},\"6\":{\"h\":\"幻灯片页\"},\"7\":{\"h\":\"超级简单的设计模式，看不懂你来打我\",\"t\":[\"未经允许禁止转载\",\"今天介绍几个经常被提到的设计模式，通俗易懂，包教包会\"]},\"8\":{\"h\":\"单例模式\",\"t\":[\"单例模式的精髓就是不管一个构造函数被实例化多少次，全局只有一个实例\",\"const Singleton = (function () { let instance; function init () { return new Object(); } return function () { if (!instance) { instance = init(); } return instance; } })() let mySingleton1 = new Singltron(); let mySingleton2 = new Singltron(); console.log(mySing1 === mySing2) // true \",\"单例模式的本质就是共享同一个作用域链，很明显这是JavaScript的闭包机制实现的\"]},\"9\":{\"h\":\"观察者模式\",\"t\":[\"观察者模式主要是通过一个目标（Suject）维护一系列的观察者（Observer），当目标发生变化时，通过广播事件，将目标具体的变化通知所有的观察者\",\"观察者模式主要由四个角色组成：目标（Suject）、 观察者（Observer）、具体目标、具体观察者\",\"下面的例子中，当data对象的name或者age属性发生变化时，都会对应的观察者会接受到变化\",\"class Observer { constructor (code) { this.code = code; } update () { console.log('我是：', this.code, '我知道我该更新了') } } class Suject { constructor () { this.observerList = []; } addObserver (observer) { this.observerList.push(observer) } notify () { this.observerList.map((observer) => observer.update()) } } // 具体的观察者 const concreteObservver1 = new Observer('concreteObservver1'); const concreteObservver2 = new Observer('concreteObservver2'); const concreteObservver3 = new Observer('concreteObservver3'); const concreteObservver4 = new Observer('concreteObservver4'); // 具体的目标 const concreteSuject1 = new Suject(); const concreteSuject2 = new Suject(); // 具体的对应关系 concreteSuject1.addObserver(concreteObservver1); concreteSuject1.addObserver(concreteObservver2); // 具体的对应关系 concreteSuject2.addObserver(concreteObservver3); concreteSuject2.addObserver(concreteObservver4); const data = {name: '萌萌哒草头将军', age: 18} // 当data的name属性变化，对应的观察者concreteObservver1、 // concreteObservver2就会被广播事件通知，从而更新 Object.defineProperty(data, 'name', { get: () => this.name, set: (newValue) => { concreteSuject1.notify(); this.name = newValue; } }) // 当data的age属性变化，对应的观察者concreteObservver3、 // concreteObservver4就会被广播事件通知，从而更新 Object.defineProperty(data, 'age', { get: () => this.age, set: (newValue) => { concreteSuject2.notify(); this.age = newValue; } }) data.name = 'mmdctjj' // 我是： concreteObservver1 我知道我该更新了 // 我是： concreteObservver2 我知道我该更新了 data.age = 18 // 我是： concreteObservver3 我知道我该更新了 // 我是： concreteObservver4 我知道我该更新了 \",\"如果Observer的update方法里是跟新对应的dom，那恭喜你，这和vue的基思路理是一样的了\"]},\"10\":{\"h\":\"发布/订阅模式\",\"t\":[\"虽然观察者模式可以轻松实现发布订阅模式的功能，但是观察者模式使得concreteSuject和concreteObservver耦合在了一起，对于复杂的系统，解耦才能算得上是优秀的系统。\",\"发布/订阅者模式（Public/Subscribe），可以很好的解决观察者模式耦合问题，那么它是怎么解耦的呢？\",\"发布/订阅模式提供了主题/事件通道(Topic/event Channer)，，订阅者通过Subscribe功能和topic绑定，当发布者发生变化时，将所有的变更通过event广播给所有订阅该topic的订阅者们。这样就将发布者和订阅者完全隔离开了\",\"还是上面的例子，我们用发布/订阅模式实现\",\"class PubSub { constructor() { this.topics = {} this.uuid = 0 // 每个订阅者的唯一标识，可以随时取消订阅 } // 发布器 publish(topic, value) { if (this.topics[topic]) { this.topics[topic].map(({ event }) => event(value)) } } // 订阅器 subscribe(topic, event) { const uuid = this.uuid++ this.topics[topic] = this.topics[topic] ? [...this.topics[topic], { event, uuid }] : [{ event, uuid }] return uuid } } const MyPubSub = (function () { let instance; function init() { return new PubSub(); } return function () { if (!instance) { instance = init(); } return instance; } })() const myPubSub = new MyPubSub() const data = { name: '萌萌哒草头将军', age: 18 } myPubSub.subscribe('data.name', (value) => console.log( '我知道', 'name发生变化了:', value )) myPubSub.subscribe('data.name', (value) => console.log( '我也知道', 'name发生变化了:', value )) myPubSub.subscribe('data.age', (value) => console.log('我知道', 'age发生变化了:', value)) Object.defineProperty(data, 'name', { get: () => this.name, set: (newValue) => { myPubSub.publish('data.name', newValue) this.name = newValue; } }) Object.defineProperty(data, 'age', { get: () => this.age, set: (newValue) => { myPubSub.publish('data.age', newValue) this.age = newValue; } }) data.name = 'mmdctjj' // 我知道 name发生变化了: mmdctjj // 我也知道 name发生变化了: mmdctjj data.age = 18 // 我知道 age发生变化了: 18 \",\"jauery的实现了标准的发布订阅模式\",\"$.trigger('login', {userName: 'MMDCTJJ', password: '*******'}) $.on('login', (userInfo) => console.log(userInfo)) \",\"vue中，可以使用$emit方法和$on\",\"<button @click=\\\"$emit('increaseBy', 1)\\\"> Increase by 1 </button> <MyButton @increase-by=\\\"(n) => count += n\\\" /> \"]},\"11\":{\"h\":\"中介者模式\",\"t\":[\"中介者模式也和观察者类似，中介者模式由中介者和订阅者组成 所有的订阅者们不能互相沟通，必须通过中介者同步信息。\",\"const mediator = (function () { let topics = [], uuid = 0; function subscribe (topic, callback) { uuid ++ topics[topic] = topics[topic] ? [...topics[topic], { callback, uuid }] : [{ callback, uuid }] } function publish (topic, value) { if (topics[topic]) { topics[topic].map(item => item.callback(value)) } } return { install: function (obj) { obj.uuid = uuid obj.publish = publish obj.subscribe = subscribe return obj } } })() const subscribe1 = mediator.install({}) const subscribe2 = mediator.install({}) const subscribe3 = mediator.install({}) subscribe1.subscribe('data.name', (value) => console.log('我是subscribe1', value)) subscribe2.subscribe('data.name', (value) => console.log('我是subscribe3', value)) const data = { name: '萌萌哒草头将军', age: 18 } Object.defineProperty(data, 'name', { get: () => this.name, set: (newValue) => { subscribe3.publish('data.name', newValue) this.name = newValue; } }) data.name = 'mmdctjj' // 我是subscribe1 mmdctjj // 我是subscribe3 mmdctjj \"]},\"12\":{\"h\":\"策略模式\",\"t\":[\"策略模式可以在不同的时机，采用不同的策略解决开发中的问题\",\"相信你经常遇到同事这样的代码\",\"// bad let arr = [1, 2, 3] arr.map(a => { if (a === 1) { console.log('11') } else if (a === 2) { console.log('22') } else if (a === 3) { console.log('33') } }) \",\"这种如果需要优化，可以使用策略模式\",\"class Strategy { constructor() { this.strategy = {} // JavaScript的策略模式可以通过对象来巧妙实现 } addStrategy(name, callback) { this.strategy[name] = callback } execute(name, args) { this.strategy[name]?.(args) } } // good let arr = [1, 2, 3] const strategy = new Strategy() strategy.addStrategy(1, () => console.log(11)) strategy.addStrategy(2, () => console.log(22)) strategy.addStrategy(3, () => console.log(33)) arr.map(a => strategy.execute(a, 'your args')) \"]},\"13\":{\"h\":\"装饰器模式\",\"t\":[\"装饰器模式(Decorater)，主要通过扩展已有的类增加新功能，它不会修改底层代码，是一种对象子类继承的替代方案\",\"class YourClass { constructor () { this.number = 0 } count () { this.number ++ return this.number } } class Decorater { constructor (other) { this.number = other.number + 66 } count () { this.number = this.number + 100 return this.number } } const yourClass = new YourClass() const decorater = new Decorater(yourClass) console.log(yourClass.count(), 'yourClass') // 1 console.log(decorater.count(), 'decorater') // 166 console.log(yourClass.count(), 'yourClass') // 2 console.log(decorater.count(), 'decorater') // 266 \",\"好了，今天先分享到这里了，欢迎指正\"]},\"14\":{\"c\":[\"前端\"]},\"15\":{\"c\":[\"JavaScript\",\"设计模式\"]},\"16\":{\"h\":\"Java基础常见面试题总结(上)\",\"t\":[\"File not found\"]},\"17\":{\"h\":\"基础概念与常识\"},\"18\":{\"h\":\"Java 语言有哪些特点?\",\"t\":[\"简单易学；\",\"面向对象（封装，继承，多态）；\",\"平台无关性（ Java 虚拟机实现平台无关性）；\",\"支持多线程（ C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持）；\",\"可靠性（具备异常处理和自动内存管理机制）；\",\"安全性（Java 语言本身的设计就提供了多重安全防护机制如访问权限修饰符、限制程序直接访问操作系统资源）；\",\"高效性（通过 Just In Time 编译器等技术的优化，Java 语言的运行效率还是非常不错的）；\",\"支持网络编程并且很方便；\",\"编译与解释并存；\",\"……\",\"🐛 修正（参见：issue#544）：C++11 开始（2011 年的时候）,C++就引入了多线程库，在 windows、linux、macos 都可以使用std::thread和std::async来创建线程。参考链接：http://www.cplusplus.com/reference/thread/thread/?kw=thread\",\"🌈 拓展一下：\",\"“Write Once, Run Anywhere（一次编写，随处运行）”这句宣传口号，真心经典，流传了好多年！以至于，直到今天，依然有很多人觉得跨平台是 Java 语言最大的优势。实际上，跨平台已经不是 Java 最大的卖点了，各种 JDK 新特性也不是。目前市面上虚拟化技术已经非常成熟，比如你通过 Docker 就很容易实现跨平台了。在我看来，Java 强大的生态才是！\"]},\"19\":{\"h\":\"Java SE vs Java EE\",\"t\":[\"Java SE（Java Platform，Standard Edition）: Java 平台标准版，Java 编程语言的基础，它包含了支持 Java 应用程序开发和运行的核心类库以及虚拟机等核心组件。Java SE 可以用于构建桌面应用程序或简单的服务器应用程序。\",\"Java EE（Java Platform, Enterprise Edition ）：Java 平台企业版，建立在 Java SE 的基础上，包含了支持企业级应用程序开发和部署的标准和规范（比如 Servlet、JSP、EJB、JDBC、JPA、JTA、JavaMail、JMS）。 Java EE 可以用于构建分布式、可移植、健壮、可伸缩和安全的服务端 Java 应用程序，例如 Web 应用程序。\",\"简单来说，Java SE 是 Java 的基础版本，Java EE 是 Java 的高级版本。Java SE 更适合开发桌面应用程序或简单的服务器应用程序，Java EE 更适合开发复杂的企业级应用程序或 Web 应用程序。\",\"除了 Java SE 和 Java EE，还有一个 Java ME（Java Platform，Micro Edition）。Java ME 是 Java 的微型版本，主要用于开发嵌入式消费电子设备的应用程序，例如手机、PDA、机顶盒、冰箱、空调等。Java ME 无需重点关注，知道有这个东西就好了，现在已经用不上了。\"]},\"20\":{\"h\":\"JVM vs JDK vs JRE\"},\"21\":{\"h\":\"JVM\",\"t\":[\"Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。\",\"运行在 Java 虚拟机之上的编程语言\",\"JVM 并不是只有一种！只要满足 JVM 规范，每个公司、组织或者个人都可以开发自己的专属 JVM。 也就是说我们平时接触到的 HotSpot VM 仅仅是是 JVM 规范的一种实现而已。\",\"除了我们平时最常用的 HotSpot VM 外，还有 J9 VM、Zing VM、JRockit VM 等 JVM 。维基百科上就有常见 JVM 的对比：Comparison of Java virtual machines ，感兴趣的可以去看看。并且，你可以在 Java SE Specifications 上找到各个版本的 JDK 对应的 JVM 规范。\"]},\"22\":{\"h\":\"JDK 和 JRE\",\"t\":[\"JDK（Java Development Kit），它是功能齐全的 Java SDK，是提供给开发者使用，能够创建和编译 Java 程序的开发套件。它包含了 JRE，同时还包含了编译 java 源码的编译器 javac 以及一些其他工具比如 javadoc（文档注释工具）、jdb（调试器）、jconsole（基于 JMX 的可视化监控⼯具）、javap（反编译工具）等等。\",\"JRE（Java Runtime Environment） 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，主要包括 Java 虚拟机（JVM）、Java 基础类库（Class Library）。\",\"也就是说，JRE 是 Java 运行时环境，仅包含 Java 应用程序的运行时环境和必要的类库。而 JDK 则包含了 JRE，同时还包括了 javac、javadoc、jdb、jconsole、javap 等工具，可以用于 Java 应用程序的开发和调试。如果需要进行 Java 编程工作，比如编写和编译 Java 程序、使用 Java API 文档等，就需要安装 JDK。而对于某些需要使用 Java 特性的应用程序，如 JSP 转换为 Java Servlet、使用反射等，也需要 JDK 来编译和运行 Java 代码。因此，即使不打算进行 Java 应用程序的开发工作，也有可能需要安装 JDK。\",\"JDK 包含 JRE\",\"不过，从 JDK 9 开始，就不需要区分 JDK 和 JRE 的关系了，取而代之的是模块系统（JDK 被重新组织成 94 个模块）+ jlink 工具 (随 Java 9 一起发布的新命令行工具，用于生成自定义 Java 运行时映像，该映像仅包含给定应用程序所需的模块) 。并且，从 JDK 11 开始，Oracle 不再提供单独的 JRE 下载。\",\"在 Java 9 新特性概览这篇文章中，我在介绍模块化系统的时候提到：\",\"在引入了模块系统之后，JDK 被重新组织成 94 个模块。Java 应用可以通过新增的 jlink 工具，创建出只包含所依赖的 JDK 模块的自定义运行时镜像。这样可以极大的减少 Java 运行时环境的大小。\",\"也就是说，可以用 jlink 根据自己的需求，创建一个更小的 runtime（运行时），而不是不管什么应用，都是同样的 JRE。\",\"定制的、模块化的 Java 运行时映像有助于简化 Java 应用的部署和节省内存并增强安全性和可维护性。这对于满足现代应用程序架构的需求，如虚拟化、容器化、微服务和云原生开发，是非常重要的。\"]},\"23\":{\"h\":\"什么是字节码?采用字节码的好处是什么?\",\"t\":[\"在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 .class 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以， Java 程序运行时相对来说还是高效的（不过，和 C、 C++，Rust，Go 等语言还是有一定差距的），而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。\",\"Java 程序从源代码到运行的过程如下图所示：\",\"Java程序转变为机器代码的过程\",\"我们需要格外注意的是 .class->机器码 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 JIT（Just in Time Compilation） 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 Java 是编译与解释共存的语言 。\",\"Java程序转变为机器代码的过程\",\"HotSpot 采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是 JIT 所需要编译的部分。JVM 会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。\",\"JDK、JRE、JVM、JIT 这四者的关系如下图所示。\",\"JDK、JRE、JVM、JIT 这四者的关系\",\"下面这张图是 JVM 的大致结构模型。\",\"JVM 的大致结构模型\"]},\"24\":{\"h\":\"为什么说 Java 语言“编译与解释并存”？\",\"t\":[\"其实这个问题我们讲字节码的时候已经提到过，因为比较重要，所以我们这里再提一下。\",\"我们可以将高级编程语言按照程序的执行方式分为两种：\",\"编译型：编译型语言 会通过编译器将源代码一次性翻译成可被该平台执行的机器码。一般情况下，编译语言的执行速度比较快，开发效率比较低。常见的编译性语言有 C、C++、Go、Rust 等等。\",\"解释型：解释型语言会通过解释器一句一句的将代码解释（interpret）为机器代码后再执行。解释型语言开发效率比较快，执行速度比较慢。常见的解释性语言有 Python、JavaScript、PHP 等等。\",\"编译型语言和解释型语言\",\"根据维基百科介绍：\",\"为了改善编译语言的效率而发展出的即时编译技术，已经缩小了这两种语言间的差距。这种技术混合了编译语言与解释型语言的优点，它像编译语言一样，先把程序源代码编译成字节码。到执行期时，再将字节码直译，之后执行。Java与LLVM是这种技术的代表产物。\",\"相关阅读：基本功 | Java 即时编译器原理解析及实践\",\"为什么说 Java 语言“编译与解释并存”？\",\"这是因为 Java 语言既具有编译型语言的特征，也具有解释型语言的特征。因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（.class 文件），这种字节码必须由 Java 解释器来解释执行。\"]},\"25\":{\"h\":\"AOT 有什么优点？为什么不全部使用 AOT 呢？\",\"t\":[\"JDK 9 引入了一种新的编译模式 AOT(Ahead of Time Compilation) 。和 JIT 不同的是，这种编译模式会在程序被执行前就将其编译成机器码，属于静态编译（C、 C++，Rust，Go 等语言就是静态编译）。AOT 避免了 JIT 预热等各方面的开销，可以提高 Java 程序的启动速度，避免预热时间长。并且，AOT 还能减少内存占用和增强 Java 程序的安全性（AOT 编译后的代码不容易被反编译和修改），特别适合云原生场景。\",\"JIT 与 AOT 两者的关键指标对比:\",\"JIT vs AOT\",\"可以看出，AOT 的主要优势在于启动时间、内存占用和打包体积。JIT 的主要优势在于具备更高的极限处理能力，可以降低请求的最大延迟。\",\"提到 AOT 就不得不提 GraalVM 了！GraalVM 是一种高性能的 JDK（完整的 JDK 发行版本），它可以运行 Java 和其他 JVM 语言，以及 JavaScript、Python 等非 JVM 语言。 GraalVM 不仅能提供 AOT 编译，还能提供 JIT 编译。感兴趣的同学，可以去看看 GraalVM 的官方文档：https://www.graalvm.org/latest/docs/。如果觉得官方文档看着比较难理解的话，也可以找一些文章来看看，比如：\",\"基于静态编译构建微服务应用\",\"走向 Native 化：Spring&Dubbo AOT 技术示例与原理讲解\",\"既然 AOT 这么多优点，那为什么不全部使用这种编译方式呢？\",\"我们前面也对比过 JIT 与 AOT，两者各有优点，只能说 AOT 更适合当下的云原生场景，对微服务架构的支持也比较友好。除此之外，AOT 编译无法支持 Java 的一些动态特性，如反射、动态代理、动态加载、JNI（Java Native Interface）等。然而，很多框架和库（如 Spring、CGLIB）都用到了这些特性。如果只使用 AOT 编译，那就没办法使用这些框架和库了，或者说需要针对性地去做适配和优化。举个例子，CGLIB 动态代理使用的是 ASM 技术，而这种技术大致原理是运行时直接在内存中生成并加载修改后的字节码文件也就是 .class 文件，如果全部使用 AOT 提前编译，也就不能使用 ASM 技术了。为了支持类似的动态特性，所以选择使用 JIT 即时编译器。\"]},\"26\":{\"h\":\"Oracle JDK vs OpenJDK\",\"t\":[\"可能在看这个问题之前很多人和我一样并没有接触和使用过 OpenJDK 。那么 Oracle JDK 和 OpenJDK 之间是否存在重大差异？下面我通过收集到的一些资料，为你解答这个被很多人忽视的问题。\",\"首先，2006 年 SUN 公司将 Java 开源，也就有了 OpenJDK。2009 年 Oracle 收购了 Sun 公司，于是自己在 OpenJDK 的基础上搞了一个 Oracle JDK。Oracle JDK 是不开源的，并且刚开始的几个版本（Java8 ~ Java11）还会相比于 OpenJDK 添加一些特有的功能和工具。\",\"其次，对于 Java 7 而言，OpenJDK 和 Oracle JDK 是十分接近的。 Oracle JDK 是基于 OpenJDK 7 构建的，只添加了一些小功能，由 Oracle 工程师参与维护。\",\"下面这段话摘自 Oracle 官方在 2012 年发表的一个博客：\",\"问：OpenJDK 存储库中的源代码与用于构建 Oracle JDK 的代码之间有什么区别？\",\"答：非常接近 - 我们的 Oracle JDK 版本构建过程基于 OpenJDK 7 构建，只添加了几个部分，例如部署代码，其中包括 Oracle 的 Java 插件和 Java WebStart 的实现，以及一些闭源的第三方组件，如图形光栅化器，一些开源的第三方组件，如 Rhino，以及一些零碎的东西，如附加文档或第三方字体。展望未来，我们的目的是开源 Oracle JDK 的所有部分，除了我们考虑商业功能的部分。\",\"最后，简单总结一下 Oracle JDK 和 OpenJDK 的区别：\",\"是否开源：OpenJDK 是一个参考模型并且是完全开源的，而 Oracle JDK 是基于 OpenJDK 实现的，并不是完全开源的（个人观点：众所周知，JDK 原来是 SUN 公司开发的，后来 SUN 公司又卖给了 Oracle 公司，Oracle 公司以 Oracle 数据库而著名，而 Oracle 数据库又是闭源的，这个时候 Oracle 公司就不想完全开源了，但是原来的 SUN 公司又把 JDK 给开源了，如果这个时候 Oracle 收购回来之后就把他给闭源，必然会引起很多 Java 开发者的不满，导致大家对 Java 失去信心，那 Oracle 公司收购回来不就把 Java 烂在手里了吗！然后，Oracle 公司就想了个骚操作，这样吧，我把一部分核心代码开源出来给你们玩，并且我要和你们自己搞的 JDK 区分下，你们叫 OpenJDK，我叫 Oracle JDK，我发布我的，你们继续玩你们的，要是你们搞出来什么好玩的东西，我后续发布 Oracle JDK 也会拿来用一下，一举两得！）OpenJDK 开源项目：https://github.com/openjdk/jdk 。\",\"是否免费：Oracle JDK 会提供免费版本，但一般有时间限制。JDK17 之后的版本可以免费分发和商用，但是仅有 3 年时间，3 年后无法免费商用。不过，JDK8u221 之前只要不升级可以无限期免费。OpenJDK 是完全免费的。\",\"功能性：Oracle JDK 在 OpenJDK 的基础上添加了一些特有的功能和工具，比如 Java Flight Recorder（JFR，一种监控工具）、Java Mission Control（JMC，一种监控工具）等工具。不过，在 Java 11 之后，OracleJDK 和 OpenJDK 的功能基本一致，之前 OracleJDK 中的私有组件大多数也已经被捐赠给开源组织。\",\"稳定性：OpenJDK 不提供 LTS 服务，而 OracleJDK 大概每三年都会推出一个 LTS 版进行长期支持。不过，很多公司都基于 OpenJDK 提供了对应的和 OracleJDK 周期相同的 LTS 版。因此，两者稳定性其实也是差不多的。\",\"协议：Oracle JDK 使用 BCL/OTN 协议获得许可，而 OpenJDK 根据 GPL v2 许可获得许可。\",\"既然 Oracle JDK 这么好，那为什么还要有 OpenJDK？\",\"答：\",\"OpenJDK 是开源的，开源意味着你可以对它根据你自己的需要进行修改、优化，比如 Alibaba 基于 OpenJDK 开发了 Dragonwell8：https://github.com/alibaba/dragonwell8\",\"OpenJDK 是商业免费的（这也是为什么通过 yum 包管理器上默认安装的 JDK 是 OpenJDK 而不是 Oracle JDK）。虽然 Oracle JDK 也是商业免费（比如 JDK 8），但并不是所有版本都是免费的。\",\"OpenJDK 更新频率更快。Oracle JDK 一般是每 6 个月发布一个新版本，而 OpenJDK 一般是每 3 个月发布一个新版本。（现在你知道为啥 Oracle JDK 更稳定了吧，先在 OpenJDK 试试水，把大部分问题都解决掉了才在 Oracle JDK 上发布）\",\"基于以上这些原因，OpenJDK 还是有存在的必要的！\",\"oracle jdk release cadence\",\"Oracle JDK 和 OpenJDK 如何选择？\",\"建议选择 OpenJDK 或者基于 OpenJDK 的发行版，比如 AWS 的 Amazon Corretto，阿里巴巴的 Alibaba Dragonwell。\",\"🌈 拓展一下：\",\"BCL 协议（Oracle Binary Code License Agreement）：可以使用 JDK（支持商用），但是不能进行修改。\",\"OTN 协议（Oracle Technology Network License Agreement）：11 及之后新发布的 JDK 用的都是这个协议，可以自己私下用，但是商用需要付费。\"]},\"27\":{\"h\":\"Java 和 C++ 的区别?\",\"t\":[\"我知道很多人没学过 C++，但是面试官就是没事喜欢拿咱们 Java 和 C++ 比呀！没办法！！！就算没学过 C++，也要记下来。\",\"虽然，Java 和 C++ 都是面向对象的语言，都支持封装、继承和多态，但是，它们还是有挺多不相同的地方：\",\"Java 不提供指针来直接访问内存，程序内存更加安全\",\"Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。\",\"Java 有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存。\",\"C ++同时支持方法重载和操作符重载，但是 Java 只支持方法重载（操作符重载增加了复杂性，这与 Java 最初的设计思想不符）。\",\"……\"]},\"28\":{\"h\":\"基本语法\"},\"29\":{\"h\":\"注释有哪几种形式？\",\"t\":[\"Java 中的注释有三种：\",\"Java 注释类型总结\",\"单行注释：通常用于解释方法内某单行代码的作用。\",\"多行注释：通常用于解释一段代码的作用。\",\"文档注释：通常用于生成 Java 开发文档。\",\"用的比较多的还是单行注释和文档注释，多行注释在实际开发中使用的相对较少。\",\"在我们编写代码的时候，如果代码量比较少，我们自己或者团队其他成员还可以很轻易地看懂代码，但是当项目结构一旦复杂起来，我们就需要用到注释了。注释并不会执行(编译器在编译代码之前会把代码中的所有注释抹掉,字节码中不保留注释)，是我们程序员写给自己看的，注释是你的代码说明书，能够帮助看代码的人快速地理清代码之间的逻辑关系。因此，在写程序的时候随手加上注释是一个非常好的习惯。\",\"《Clean Code》这本书明确指出：\",\"代码的注释不是越详细越好。实际上好的代码本身就是注释，我们要尽量规范和美化自己的代码来减少不必要的注释。\",\"若编程语言足够有表达力，就不需要注释，尽量通过代码来阐述。\",\"举个例子：\",\"去掉下面复杂的注释，只需要创建一个与注释所言同一事物的函数即可\",\"// check to see if the employee is eligible for full benefits if ((employee.flags & HOURLY_FLAG) && (employee.age > 65)) \",\"应替换为\",\"if (employee.isEligibleForFullBenefits()) \"]},\"30\":{\"h\":\"标识符和关键字的区别是什么？\",\"t\":[\"在我们编写程序的时候，需要大量地为程序、类、变量、方法等取名字，于是就有了 标识符 。简单来说， 标识符就是一个名字 。\",\"有一些标识符，Java 语言已经赋予了其特殊的含义，只能用于特定的地方，这些特殊的标识符就是 关键字 。简单来说，关键字是被赋予特殊含义的标识符 。比如，在我们的日常生活中，如果我们想要开一家店，则要给这个店起一个名字，起的这个“名字”就叫标识符。但是我们店的名字不能叫“警察局”，因为“警察局”这个名字已经被赋予了特殊的含义，而“警察局”就是我们日常生活中的关键字。\"]},\"31\":{\"h\":\"Java 语言关键字有哪些？\",\"t\":[\"分类\",\"关键字\",\"访问控制\",\"private\",\"protected\",\"public\",\"类，方法和变量修饰符\",\"abstract\",\"class\",\"extends\",\"final\",\"implements\",\"interface\",\"native\",\"new\",\"static\",\"strictfp\",\"synchronized\",\"transient\",\"volatile\",\"enum\",\"程序控制\",\"break\",\"continue\",\"return\",\"do\",\"while\",\"if\",\"else\",\"for\",\"instanceof\",\"switch\",\"case\",\"default\",\"assert\",\"错误处理\",\"try\",\"catch\",\"throw\",\"throws\",\"finally\",\"包相关\",\"import\",\"package\",\"基本类型\",\"boolean\",\"byte\",\"char\",\"double\",\"float\",\"int\",\"long\",\"short\",\"变量引用\",\"super\",\"this\",\"void\",\"保留字\",\"goto\",\"const\",\"Tips：所有的关键字都是小写的，在 IDE 中会以特殊颜色显示。\",\"default 这个关键字很特殊，既属于程序控制，也属于类，方法和变量修饰符，还属于访问控制。\",\"在程序控制中，当在 switch 中匹配不到任何情况时，可以使用 default 来编写默认匹配的情况。\",\"在类，方法和变量修饰符中，从 JDK8 开始引入了默认方法，可以使用 default 关键字来定义一个方法的默认实现。\",\"在访问控制中，如果一个方法前没有任何修饰符，则默认会有一个修饰符 default，但是这个修饰符加上了就会报错。\",\"⚠️ 注意：虽然 true, false, 和 null 看起来像关键字但实际上他们是字面值，同时你也不可以作为标识符来使用。\",\"官方文档：https://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html\"]},\"32\":{\"h\":\"自增自减运算符\",\"t\":[\"在写代码的过程中，常见的一种情况是需要某个整数类型变量增加 1 或减少 1，Java 提供了一种特殊的运算符，用于这种表达式，叫做自增运算符（++)和自减运算符（--）。\",\"++ 和 -- 运算符可以放在变量之前，也可以放在变量之后，当运算符放在变量之前时(前缀)，先自增/减，再赋值；当运算符放在变量之后时(后缀)，先赋值，再自增/减。例如，当 b = ++a 时，先自增（自己增加 1），再赋值（赋值给 b）；当 b = a++ 时，先赋值(赋值给 b)，再自增（自己增加 1）。也就是，++a 输出的是 a+1 的值，a++输出的是 a 值。用一句口诀就是：“符号在前就先加/减，符号在后就后加/减”。\"]},\"33\":{\"h\":\"移位运算符\",\"t\":[\"移位运算符是最基本的运算符之一，几乎每种编程语言都包含这一运算符。移位操作中，被操作的数据被视为二进制数，移位就是将其向左或向右移动若干位的运算。\",\"移位运算符在各种框架以及 JDK 自身的源码中使用还是挺广泛的，HashMap（JDK1.8） 中的 hash 方法的源码就用到了移位运算符：\",\"static final int hash(Object key) { int h; // key.hashCode()：返回散列值也就是hashcode // ^：按位异或 // >>>:无符号右移，忽略符号位，空位都以0补齐 return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16); } \",\"在 Java 代码里使用 <<、 >> 和>>>转换成的指令码运行起来会更高效些。\",\"掌握最基本的移位运算符知识还是很有必要的，这不光可以帮助我们在代码中使用，还可以帮助我们理解源码中涉及到移位运算符的代码。\",\"Java 中有三种移位运算符：\",\"Java 移位运算符总结\",\"<< :左移运算符，向左移若干位，高位丢弃，低位补零。x << 1,相当于 x 乘以 2(不溢出的情况下)。\",\">> :带符号右移，向右移若干位，高位补符号位，低位丢弃。正数高位补 0,负数高位补 1。x >> 1,相当于 x 除以 2。\",\">>> :无符号右移，忽略符号位，空位都以 0 补齐。\",\"由于 double，float 在二进制中的表现比较特殊，因此不能来进行移位操作。\",\"移位操作符实际上支持的类型只有int和long，编译器在对short、byte、char类型进行移位前，都会将其转换为int类型再操作。\",\"如果移位的位数超过数值所占有的位数会怎样？\",\"当 int 类型左移/右移位数大于等于 32 位操作时，会先求余（%）后再进行左移/右移操作。也就是说左移/右移 32 位相当于不进行移位操作（32%32=0），左移/右移 42 位相当于左移/右移 10 位（42%32=10）。当 long 类型进行左移/右移操作时，由于 long 对应的二进制是 64 位，因此求余操作的基数也变成了 64。\",\"也就是说：x<<42等同于x<<10，x>>42等同于x>>10，x >>>42等同于x >>> 10。\",\"左移运算符代码示例：\",\"int i = -1; System.out.println(\\\"初始数据：\\\" + i); System.out.println(\\\"初始数据对应的二进制字符串：\\\" + Integer.toBinaryString(i)); i <<= 10; System.out.println(\\\"左移 10 位后的数据 \\\" + i); System.out.println(\\\"左移 10 位后的数据对应的二进制字符 \\\" + Integer.toBinaryString(i)); \",\"输出：\",\"初始数据：-1 初始数据对应的二进制字符串：11111111111111111111111111111111 左移 10 位后的数据 -1024 左移 10 位后的数据对应的二进制字符 11111111111111111111110000000000 \",\"由于左移位数大于等于 32 位操作时，会先求余（%）后再进行左移操作，所以下面的代码左移 42 位相当于左移 10 位（42%32=10），输出结果和前面的代码一样。\",\"int i = -1; System.out.println(\\\"初始数据：\\\" + i); System.out.println(\\\"初始数据对应的二进制字符串：\\\" + Integer.toBinaryString(i)); i <<= 42; System.out.println(\\\"左移 10 位后的数据 \\\" + i); System.out.println(\\\"左移 10 位后的数据对应的二进制字符 \\\" + Integer.toBinaryString(i)); \",\"右移运算符使用类似，篇幅问题，这里就不做演示了。\"]},\"34\":{\"h\":\"continue、break 和 return 的区别是什么？\",\"t\":[\"在循环结构中，当循环条件不满足或者循环次数达到要求时，循环会正常结束。但是，有时候可能需要在循环的过程中，当发生了某种条件之后 ，提前终止循环，这就需要用到下面几个关键词：\",\"continue：指跳出当前的这一次循环，继续下一次循环。\",\"break：指跳出整个循环体，继续执行循环下面的语句。\",\"return 用于跳出所在方法，结束该方法的运行。return 一般有两种用法：\",\"return;：直接使用 return 结束方法执行，用于没有返回值函数的方法\",\"return value;：return 一个特定值，用于有返回值函数的方法\",\"思考一下：下列语句的运行结果是什么？\",\" public static void main(String[] args) { boolean flag = false; for (int i = 0; i <= 3; i++) { if (i == 0) { System.out.println(\\\"0\\\"); } else if (i == 1) { System.out.println(\\\"1\\\"); continue; } else if (i == 2) { System.out.println(\\\"2\\\"); flag = true; } else if (i == 3) { System.out.println(\\\"3\\\"); break; } else if (i == 4) { System.out.println(\\\"4\\\"); } System.out.println(\\\"xixi\\\"); } if (flag) { System.out.println(\\\"haha\\\"); return; } System.out.println(\\\"heihei\\\"); } \",\"运行结果：\",\"0 xixi 1 2 xixi 3 haha \"]},\"35\":{\"h\":\"基本数据类型\"},\"36\":{\"h\":\"Java 中的几种基本数据类型了解么？\",\"t\":[\"Java 中有 8 种基本数据类型，分别为：\",\"6 种数字类型： \",\"4 种整数型：byte、short、int、long\",\"2 种浮点型：float、double\",\"1 种字符类型：char\",\"1 种布尔型：boolean。\",\"这 8 种基本数据类型的默认值以及所占空间的大小如下：\",\"基本类型\",\"位数\",\"字节\",\"默认值\",\"取值范围\",\"byte\",\"8\",\"1\",\"0\",\"-128 ~ 127\",\"short\",\"16\",\"2\",\"0\",\"-32768（-2^15） ~ 32767（2^15 - 1）\",\"int\",\"32\",\"4\",\"0\",\"-2147483648 ~ 2147483647\",\"long\",\"64\",\"8\",\"0L\",\"-9223372036854775808（-2^63） ~ 9223372036854775807（2^63 -1）\",\"char\",\"16\",\"2\",\"'u0000'\",\"0 ~ 65535（2^16 - 1）\",\"float\",\"32\",\"4\",\"0f\",\"1.4E-45 ~ 3.4028235E38\",\"double\",\"64\",\"8\",\"0d\",\"4.9E-324 ~ 1.7976931348623157E308\",\"boolean\",\"1\",\"false\",\"true、false\",\"可以看到，像 byte、short、int、long能表示的最大正数都减 1 了。这是为什么呢？这是因为在二进制补码表示法中，最高位是用来表示符号的（0 表示正数，1 表示负数），其余位表示数值部分。所以，如果我们要表示最大的正数，我们需要把除了最高位之外的所有位都设为 1。如果我们再加 1，就会导致溢出，变成一个负数。\",\"对于 boolean，官方文档未明确定义，它依赖于 JVM 厂商的具体实现。逻辑上理解是占用 1 位，但是实际中会考虑计算机高效存储因素。\",\"另外，Java 的每种基本类型所占存储空间的大小不会像其他大多数语言那样随机器硬件架构的变化而变化。这种所占存储空间大小的不变性是 Java 程序比用其他大多数语言编写的程序更具可移植性的原因之一（《Java 编程思想》2.2 节有提到）。\",\"注意：\",\"Java 里使用 long 类型的数据一定要在数值后面加上 L，否则将作为整型解析。\",\"char a = 'h'char :单引号，String a = \\\"hello\\\" :双引号。\",\"这八种基本类型都有对应的包装类分别为：Byte、Short、Integer、Long、Float、Double、Character、Boolean 。\"]},\"37\":{\"h\":\"基本类型和包装类型的区别？\",\"t\":[\"基本类型 vs 包装类型\",\"用途：除了定义一些常量和局部变量之外，我们在其他地方比如方法参数、对象属性中很少会使用基本类型来定义变量。并且，包装类型可用于泛型，而基本类型不可以。\",\"存储方式：基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 static 修饰 ）存放在 Java 虚拟机的堆中。包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中。\",\"占用空间：相比于包装类型（对象类型）， 基本数据类型占用的空间往往非常小。\",\"默认值：成员变量包装类型不赋值就是 null ，而基本类型有默认值且不是 null。\",\"比较方式：对于基本数据类型来说，== 比较的是值。对于包装数据类型来说，== 比较的是对象的内存地址。所有整型包装类对象之间值的比较，全部使用 equals() 方法。\",\"为什么说是几乎所有对象实例都存在于堆中呢？ 这是因为 HotSpot 虚拟机引入了 JIT 优化之后，会对对象进行逃逸分析，如果发现某一个对象并没有逃逸到方法外部，那么就可能通过标量替换来实现栈上分配，而避免堆上分配内存\",\"⚠️ 注意：基本数据类型存放在栈中是一个常见的误区！ 基本数据类型的成员变量如果没有被 static 修饰的话（不建议这么使用，应该要使用基本数据类型对应的包装类型），就存放在堆中。\",\"class BasicTypeVar{ private int x; } \"]},\"38\":{\"h\":\"包装类型的缓存机制了解么？\",\"t\":[\"Java 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能。\",\"Byte,Short,Integer,Long 这 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据，Character 创建了数值在 [0,127] 范围的缓存数据，Boolean 直接返回 True or False。\",\"Integer 缓存源码：\",\"public static Integer valueOf(int i) { if (i >= IntegerCache.low && i <= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); } private static class IntegerCache { static final int low = -128; static final int high; static { // high value may be configured by property int h = 127; } } \",\"Character 缓存源码:\",\"public static Character valueOf(char c) { if (c <= 127) { // must cache return CharacterCache.cache[(int)c]; } return new Character(c); } private static class CharacterCache { private CharacterCache(){} static final Character cache[] = new Character[127 + 1]; static { for (int i = 0; i < cache.length; i++) cache[i] = new Character((char)i); } } \",\"Boolean 缓存源码：\",\"public static Boolean valueOf(boolean b) { return (b ? TRUE : FALSE); } \",\"如果超出对应范围仍然会去创建新的对象，缓存的范围区间的大小只是在性能和资源之间的权衡。\",\"两种浮点数类型的包装类 Float,Double 并没有实现缓存机制。\",\"Integer i1 = 33; Integer i2 = 33; System.out.println(i1 == i2);// 输出 true Float i11 = 333f; Float i22 = 333f; System.out.println(i11 == i22);// 输出 false Double i3 = 1.2; Double i4 = 1.2; System.out.println(i3 == i4);// 输出 false \",\"下面我们来看一个问题：下面的代码的输出结果是 true 还是 false 呢？\",\"Integer i1 = 40; Integer i2 = new Integer(40); System.out.println(i1==i2); \",\"Integer i1=40 这一行代码会发生装箱，也就是说这行代码等价于 Integer i1=Integer.valueOf(40) 。因此，i1 直接使用的是缓存中的对象。而Integer i2 = new Integer(40) 会直接创建新的对象。\",\"因此，答案是 false 。你答对了吗？\",\"记住：所有整型包装类对象之间值的比较，全部使用 equals 方法比较。\"]},\"39\":{\"h\":\"自动装箱与拆箱了解吗？原理是什么？\",\"t\":[\"什么是自动拆装箱？\",\"装箱：将基本类型用它们对应的引用类型包装起来；\",\"拆箱：将包装类型转换为基本数据类型；\",\"举例：\",\"Integer i = 10; //装箱 int n = i; //拆箱 \",\"上面这两行代码对应的字节码为：\",\" L1 LINENUMBER 8 L1 ALOAD 0 BIPUSH 10 INVOKESTATIC java/lang/Integer.valueOf (I)Ljava/lang/Integer; PUTFIELD AutoBoxTest.i : Ljava/lang/Integer; L2 LINENUMBER 9 L2 ALOAD 0 ALOAD 0 GETFIELD AutoBoxTest.i : Ljava/lang/Integer; INVOKEVIRTUAL java/lang/Integer.intValue ()I PUTFIELD AutoBoxTest.n : I RETURN \",\"从字节码中，我们发现装箱其实就是调用了 包装类的valueOf()方法，拆箱其实就是调用了 xxxValue()方法。\",\"因此，\",\"Integer i = 10 等价于 Integer i = Integer.valueOf(10)\",\"int n = i 等价于 int n = i.intValue();\",\"注意：如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作。\",\"private static long sum() { // 应该使用 long 而不是 Long Long sum = 0L; for (long i = 0; i <= Integer.MAX_VALUE; i++) sum += i; return sum; } \"]},\"40\":{\"h\":\"为什么浮点数运算的时候会有精度丢失的风险？\",\"t\":[\"浮点数运算精度丢失代码演示：\",\"float a = 2.0f - 1.9f; float b = 1.8f - 1.7f; System.out.println(a);// 0.100000024 System.out.println(b);// 0.099999905 System.out.println(a == b);// false \",\"为什么会出现这个问题呢？\",\"这个和计算机保存浮点数的机制有很大关系。我们知道计算机是二进制的，而且计算机在表示一个数字时，宽度是有限的，无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况。这也就是解释了为什么浮点数没有办法用二进制精确表示。\",\"就比如说十进制下的 0.2 就没办法精确转换成二进制小数：\",\"// 0.2 转换为二进制数的过程为，不断乘以 2，直到不存在小数为止， // 在这个计算过程中，得到的整数部分从上到下排列就是二进制的结果。 0.2 * 2 = 0.4 -> 0 0.4 * 2 = 0.8 -> 0 0.8 * 2 = 1.6 -> 1 0.6 * 2 = 1.2 -> 1 0.2 * 2 = 0.4 -> 0（发生循环） ... \",\"关于浮点数的更多内容，建议看一下计算机系统基础（四）浮点数这篇文章。\"]},\"41\":{\"h\":\"如何解决浮点数运算的精度丢失问题？\",\"t\":[\"BigDecimal 可以实现对浮点数的运算，不会造成精度丢失。通常情况下，大部分需要浮点数精确运算结果的业务场景（比如涉及到钱的场景）都是通过 BigDecimal 来做的。\",\"BigDecimal a = new BigDecimal(\\\"1.0\\\"); BigDecimal b = new BigDecimal(\\\"0.9\\\"); BigDecimal c = new BigDecimal(\\\"0.8\\\"); BigDecimal x = a.subtract(b); BigDecimal y = b.subtract(c); System.out.println(x); /* 0.1 */ System.out.println(y); /* 0.1 */ System.out.println(Objects.equals(x, y)); /* true */ \",\"关于 BigDecimal 的详细介绍，可以看看我写的这篇文章：BigDecimal 详解。\"]},\"42\":{\"h\":\"超过 long 整型的数据应该如何表示？\",\"t\":[\"基本数值类型都有一个表达范围，如果超过这个范围就会有数值溢出的风险。\",\"在 Java 中，64 位 long 整型是最大的整数类型。\",\"long l = Long.MAX_VALUE; System.out.println(l + 1); // -9223372036854775808 System.out.println(l + 1 == Long.MIN_VALUE); // true \",\"BigInteger 内部使用 int[] 数组来存储任意大小的整形数据。\",\"相对于常规整数类型的运算来说，BigInteger 运算的效率会相对较低。\"]},\"43\":{\"h\":\"变量\"},\"44\":{\"h\":\"成员变量与局部变量的区别？\",\"t\":[\"成员变量 vs 局部变量\",\"语法形式：从语法形式上看，成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 public,private,static 等修饰符所修饰，而局部变量不能被访问控制修饰符及 static 所修饰；但是，成员变量和局部变量都能被 final 所修饰。\",\"存储方式：从变量在内存中的存储方式来看，如果成员变量是使用 static 修饰的，那么这个成员变量是属于类的，如果没有使用 static 修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。\",\"生存时间：从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动生成，随着方法的调用结束而消亡。\",\"默认值：从变量是否有默认值来看，成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值（一种情况例外:被 final 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。\",\"为什么成员变量有默认值？\",\"先不考虑变量类型，如果没有默认值会怎样？变量存储的是内存地址对应的任意随机值，程序读取该值运行会出现意外。\",\"默认值有两种设置方式：手动和自动，根据第一点，没有手动赋值一定要自动赋值。成员变量在运行时可借助反射等方法手动赋值，而局部变量不行。\",\"对于编译器（javac）来说，局部变量没赋值很好判断，可以直接报错。而成员变量可能是运行时赋值，无法判断，误报“没默认值”又会影响用户体验，所以采用自动赋默认值。\",\"成员变量与局部变量代码示例：\",\"public class VariableExample { // 成员变量 private String name; private int age; // 方法中的局部变量 public void method() { int num1 = 10; // 栈中分配的局部变量 String str = \\\"Hello, world!\\\"; // 栈中分配的局部变量 System.out.println(num1); System.out.println(str); } // 带参数的方法中的局部变量 public void method2(int num2) { int sum = num2 + 10; // 栈中分配的局部变量 System.out.println(sum); } // 构造方法中的局部变量 public VariableExample(String name, int age) { this.name = name; // 对成员变量进行赋值 this.age = age; // 对成员变量进行赋值 int num3 = 20; // 栈中分配的局部变量 String str2 = \\\"Hello, \\\" + this.name + \\\"!\\\"; // 栈中分配的局部变量 System.out.println(num3); System.out.println(str2); } } \"]},\"45\":{\"h\":\"静态变量有什么作用？\",\"t\":[\"静态变量也就是被 static 关键字修饰的变量。它可以被类的所有实例共享，无论一个类创建了多少个对象，它们都共享同一份静态变量。也就是说，静态变量只会被分配一次内存，即使创建多个对象，这样可以节省内存。\",\"静态变量是通过类名来访问的，例如StaticVariableExample.staticVar（如果被 private关键字修饰就无法这样访问了）。\",\"public class StaticVariableExample { // 静态变量 public static int staticVar = 0; } \",\"通常情况下，静态变量会被 final 关键字修饰成为常量。\",\"public class ConstantVariableExample { // 常量 public static final int constantVar = 0; } \"]},\"46\":{\"h\":\"字符型常量和字符串常量的区别?\",\"t\":[\"形式 : 字符常量是单引号引起的一个字符，字符串常量是双引号引起的 0 个或若干个字符。\",\"含义 : 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)。\",\"占内存大小：字符常量只占 2 个字节; 字符串常量占若干个字节。\",\"⚠️ 注意 char 在 Java 中占两个字节。\",\"字符型常量和字符串常量代码示例：\",\"public class StringExample { // 字符型常量 public static final char LETTER_A = 'A'; // 字符串常量 public static final String GREETING_MESSAGE = \\\"Hello, world!\\\"; public static void main(String[] args) { System.out.println(\\\"字符型常量占用的字节数为：\\\"+Character.BYTES); System.out.println(\\\"字符串常量占用的字节数为：\\\"+GREETING_MESSAGE.getBytes().length); } } \",\"输出：\",\"字符型常量占用的字节数为：2 字符串常量占用的字节数为：13 \"]},\"47\":{\"h\":\"方法\"},\"48\":{\"h\":\"什么是方法的返回值?方法有哪几种类型？\",\"t\":[\"方法的返回值 是指我们获取到的某个方法体中的代码执行后产生的结果！（前提是该方法可能产生结果）。返回值的作用是接收出结果，使得它可以用于其他的操作！\",\"我们可以按照方法的返回值和参数类型将方法分为下面这几种：\",\"1、无参数无返回值的方法\",\"public void f1() { //...... } // 下面这个方法也没有返回值，虽然用到了 return public void f(int a) { if (...) { // 表示结束方法的执行,下方的输出语句不会执行 return; } System.out.println(a); } \",\"2、有参数无返回值的方法\",\"public void f2(Parameter 1, ..., Parameter n) { //...... } \",\"3、有返回值无参数的方法\",\"public int f3() { //...... return x; } \",\"4、有返回值有参数的方法\",\"public int f4(int a, int b) { return a * b; } \"]},\"49\":{\"h\":\"静态方法为什么不能调用非静态成员?\",\"t\":[\"这个需要结合 JVM 的相关知识，主要原因如下：\",\"静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。\",\"在类的非静态成员不存在的时候静态方法就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。\",\"public class Example { // 定义一个字符型常量 public static final char LETTER_A = 'A'; // 定义一个字符串常量 public static final String GREETING_MESSAGE = \\\"Hello, world!\\\"; public static void main(String[] args) { // 输出字符型常量的值 System.out.println(\\\"字符型常量的值为：\\\" + LETTER_A); // 输出字符串常量的值 System.out.println(\\\"字符串常量的值为：\\\" + GREETING_MESSAGE); } } \"]},\"50\":{\"h\":\"静态方法和实例方法有何不同？\",\"t\":[\"1、调用方式\",\"在外部调用静态方法时，可以使用 类名.方法名 的方式，也可以使用 对象.方法名 的方式，而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象 。\",\"不过，需要注意的是一般不建议使用 对象.方法名 的方式来调用静态方法。这种方式非常容易造成混淆，静态方法不属于类的某个对象而是属于这个类。\",\"因此，一般建议使用 类名.方法名 的方式来调用静态方法。\",\"public class Person { public void method() { //...... } public static void staicMethod(){ //...... } public static void main(String[] args) { Person person = new Person(); // 调用实例方法 person.method(); // 调用静态方法 Person.staicMethod() } } \",\"2、访问类成员是否存在限制\",\"静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），不允许访问实例成员（即实例成员变量和实例方法），而实例方法不存在这个限制。\"]},\"51\":{\"h\":\"重载和重写有什么区别？\",\"t\":[\"重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理\",\"重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法\"]},\"52\":{\"h\":\"重载\",\"t\":[\"发生在同一个类中（或者父类和子类之间），方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。\",\"《Java 核心技术》这本书是这样介绍重载的：\",\"如果多个方法(比如 StringBuilder 的构造方法)有相同的名字、不同的参数， 便产生了重载。\",\"StringBuilder sb = new StringBuilder(); StringBuilder sb2 = new StringBuilder(\\\"HelloWorld\\\"); \",\"编译器必须挑选出具体执行哪个方法，它通过用各个方法给出的参数类型与特定方法调用所使用的值类型进行匹配来挑选出相应的方法。 如果编译器找不到匹配的参数， 就会产生编译时错误， 因为根本不存在匹配， 或者没有一个比其他的更好(这个过程被称为重载解析(overloading resolution))。\",\"Java 允许重载任何方法， 而不只是构造器方法。\",\"综上：重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。\"]},\"53\":{\"h\":\"重写\",\"t\":[\"重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。\",\"方法名、参数列表必须相同，子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。\",\"如果父类方法访问修饰符为 private/final/static 则子类就不能重写该方法，但是被 static 修饰的方法能够被再次声明。\",\"构造方法无法被重写\"]},\"54\":{\"h\":\"总结\",\"t\":[\"综上：重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变。\",\"区别点\",\"重载方法\",\"重写方法\",\"发生范围\",\"同一个类\",\"子类\",\"参数列表\",\"必须修改\",\"一定不能修改\",\"返回类型\",\"可修改\",\"子类方法返回值类型应比父类方法返回值类型更小或相等\",\"异常\",\"可修改\",\"子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；\",\"访问修饰符\",\"可修改\",\"一定不能做更严格的限制（可以降低限制）\",\"发生阶段\",\"编译期\",\"运行期\",\"方法的重写要遵循“两同两小一大”（以下内容摘录自《疯狂 Java 讲义》，issue#892 ）：\",\"“两同”即方法名相同、形参列表相同；\",\"“两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；\",\"“一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。\",\"⭐️ 关于 重写的返回值类型 这里需要额外多说明一下，上面的表述不太清晰准确：如果方法的返回类型是 void 和基本数据类型，则返回值重写时不可修改。但是如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的。\",\"public class Hero { public String name() { return \\\"超级英雄\\\"; } } public class SuperMan extends Hero{ @Override public String name() { return \\\"超人\\\"; } public Hero hero() { return new Hero(); } } public class SuperSuperMan extends SuperMan { public String name() { return \\\"超级超级英雄\\\"; } @Override public SuperMan hero() { return new SuperMan(); } } \"]},\"55\":{\"h\":\"什么是可变长参数？\",\"t\":[\"从 Java5 开始，Java 支持定义可变长参数，所谓可变长参数就是允许在调用方法时传入不定长度的参数。就比如下面的这个 printVariable 方法就可以接受 0 个或者多个参数。\",\"public static void method1(String... args) { //...... } \",\"另外，可变参数只能作为函数的最后一个参数，但其前面可以有也可以没有任何其他参数。\",\"public static void method2(String arg1, String... args) { //...... } \",\"遇到方法重载的情况怎么办呢？会优先匹配固定参数还是可变参数的方法呢？\",\"答案是会优先匹配固定参数的方法，因为固定参数的方法匹配度更高。\",\"我们通过下面这个例子来证明一下。\",\"/** * 微信搜 JavaGuide 回复\\\"面试突击\\\"即可免费领取个人原创的 Java 面试手册 * * @author Guide哥 * @date 2021/12/13 16:52 **/ public class VariableLengthArgument { public static void printVariable(String... args) { for (String s : args) { System.out.println(s); } } public static void printVariable(String arg1, String arg2) { System.out.println(arg1 + arg2); } public static void main(String[] args) { printVariable(\\\"a\\\", \\\"b\\\"); printVariable(\\\"a\\\", \\\"b\\\", \\\"c\\\", \\\"d\\\"); } } \",\"输出：\",\"ab a b c d \",\"另外，Java 的可变参数编译后实际会被转换成一个数组，我们看编译后生成的 class文件就可以看出来了。\",\"public class VariableLengthArgument { public static void printVariable(String... args) { String[] var1 = args; int var2 = args.length; for(int var3 = 0; var3 < var2; ++var3) { String s = var1[var3]; System.out.println(s); } } // ...... } \"]},\"56\":{\"h\":\"参考\",\"t\":[\"What is the difference between JDK and JRE?：https://stackoverflow.com/questions/1906445/what-is-the-difference-between-jdk-and-jre\",\"Oracle vs OpenJDK：https://www.educba.com/oracle-vs-openjdk/\",\"Differences between Oracle JDK and OpenJDK：https://stackoverflow.com/questions/22358071/differences-between-oracle-jdk-and-openjdk\",\"彻底弄懂 Java 的移位操作符：https://juejin.cn/post/6844904025880526861\",\"File not found\"]},\"57\":{\"c\":[\"Java\"]},\"58\":{\"c\":[\"Java基础\"]},\"59\":{\"h\":\"Java 值传递详解\",\"t\":[\"开始之前，我们先来搞懂下面这两个概念：\",\"形参&实参\",\"值传递&引用传递\"]},\"60\":{\"h\":\"形参&实参\",\"t\":[\"方法的定义可能会用到 参数（有参的方法），参数在程序语言中分为：\",\"实参（实际参数，Arguments）：用于传递给函数/方法的参数，必须有确定的值。\",\"形参（形式参数，Parameters）：用于定义函数/方法，接收实参，不需要有确定的值。\",\"String hello = \\\"Hello!\\\"; // hello 为实参 sayHello(hello); // str 为形参 void sayHello(String str) { System.out.println(str); } \"]},\"61\":{\"h\":\"值传递&引用传递\",\"t\":[\"程序设计语言将实参传递给方法（或函数）的方式分为两种：\",\"值传递：方法接收的是实参值的拷贝，会创建副本。\",\"引用传递：方法接收的直接是实参所引用的对象在堆中的地址，不会创建副本，对形参的修改将影响到实参。\",\"很多程序设计语言（比如 C++、 Pascal )提供了两种参数传递的方式，不过，在 Java 中只有值传递。\"]},\"62\":{\"h\":\"为什么 Java 只有值传递？\",\"t\":[\"为什么说 Java 只有值传递呢？ 不需要太多废话，我通过 3 个例子来给大家证明。\"]},\"63\":{\"h\":\"案例 1：传递基本类型参数\",\"t\":[\"代码：\",\"public static void main(String[] args) { int num1 = 10; int num2 = 20; swap(num1, num2); System.out.println(\\\"num1 = \\\" + num1); System.out.println(\\\"num2 = \\\" + num2); } public static void swap(int a, int b) { int temp = a; a = b; b = temp; System.out.println(\\\"a = \\\" + a); System.out.println(\\\"b = \\\" + b); } \",\"输出：\",\"a = 20 b = 10 num1 = 10 num2 = 20 \",\"解析：\",\"在 swap() 方法中，a、b 的值进行交换，并不会影响到 num1、num2。因为，a、b 的值，只是从 num1、num2 的复制过来的。也就是说，a、b 相当于 num1、num2 的副本，副本的内容无论怎么修改，都不会影响到原件本身。\",\"通过上面例子，我们已经知道了一个方法不能修改一个基本数据类型的参数，而对象引用作为参数就不一样，请看案例 2。\"]},\"64\":{\"h\":\"案例 2：传递引用类型参数 1\",\"t\":[\"代码：\",\" public static void main(String[] args) { int[] arr = { 1, 2, 3, 4, 5 }; System.out.println(arr[0]); change(arr); System.out.println(arr[0]); } public static void change(int[] array) { // 将数组的第一个元素变为0 array[0] = 0; } \",\"输出：\",\"1 0 \",\"解析：\",\"看了这个案例很多人肯定觉得 Java 对引用类型的参数采用的是引用传递。\",\"实际上，并不是的，这里传递的还是值，不过，这个值是实参的地址罢了！\",\"也就是说 change 方法的参数拷贝的是 arr （实参）的地址，因此，它和 arr 指向的是同一个数组对象。这也就说明了为什么方法内部对形参的修改会影响到实参。\",\"为了更强有力地反驳 Java 对引用类型的参数采用的不是引用传递，我们再来看下面这个案例！\"]},\"65\":{\"h\":\"案例 3：传递引用类型参数 2\",\"t\":[\"public class Person { private String name; // 省略构造函数、Getter&Setter方法 } public static void main(String[] args) { Person xiaoZhang = new Person(\\\"小张\\\"); Person xiaoLi = new Person(\\\"小李\\\"); swap(xiaoZhang, xiaoLi); System.out.println(\\\"xiaoZhang:\\\" + xiaoZhang.getName()); System.out.println(\\\"xiaoLi:\\\" + xiaoLi.getName()); } public static void swap(Person person1, Person person2) { Person temp = person1; person1 = person2; person2 = temp; System.out.println(\\\"person1:\\\" + person1.getName()); System.out.println(\\\"person2:\\\" + person2.getName()); } \",\"输出:\",\"person1:小李 person2:小张 xiaoZhang:小张 xiaoLi:小李 \",\"解析：\",\"怎么回事？？？两个引用类型的形参互换并没有影响实参啊！\",\"swap 方法的参数 person1 和 person2 只是拷贝的实参 xiaoZhang 和 xiaoLi 的地址。因此， person1 和 person2 的互换只是拷贝的两个地址的互换罢了，并不会影响到实参 xiaoZhang 和 xiaoLi 。\"]},\"66\":{\"h\":\"引用传递是怎么样的？\",\"t\":[\"看到这里，相信你已经知道了 Java 中只有值传递，是没有引用传递的。 但是，引用传递到底长什么样呢？下面以 C++ 的代码为例，让你看一下引用传递的庐山真面目。\",\"#include <iostream> void incr(int& num) { std::cout << \\\"incr before: \\\" << num << \\\"\\\\n\\\"; num++; std::cout << \\\"incr after: \\\" << num << \\\"\\\\n\\\"; } int main() { int age = 10; std::cout << \\\"invoke before: \\\" << age << \\\"\\\\n\\\"; incr(age); std::cout << \\\"invoke after: \\\" << age << \\\"\\\\n\\\"; } \",\"输出结果：\",\"invoke before: 10 incr before: 10 incr after: 11 invoke after: 11 \",\"分析：可以看到，在 incr 函数中对形参的修改，可以影响到实参的值。要注意：这里的 incr 形参的数据类型用的是 int& 才为引用传递，如果是用 int 的话还是值传递哦！\"]},\"67\":{\"h\":\"为什么 Java 不引入引用传递呢？\",\"t\":[\"引用传递看似很好，能在方法内就直接把实参的值修改了，但是，为什么 Java 不引入引用传递呢？\",\"注意：以下为个人观点看法，并非来自于 Java 官方：\",\"出于安全考虑，方法内部对值进行的操作，对于调用者都是未知的（把方法定义为接口，调用方不关心具体实现）。你也想象一下，如果拿着银行卡去取钱，取的是 100，扣的是 200，是不是很可怕。\",\"Java 之父 James Gosling 在设计之初就看到了 C、C++ 的许多弊端，所以才想着去设计一门新的语言 Java。在他设计 Java 的时候就遵循了简单易用的原则，摒弃了许多开发者一不留意就会造成问题的“特性”，语言本身的东西少了，开发者要学习的东西也少了。\"]},\"68\":{\"h\":\"总结\",\"t\":[\"Java 中将实参传递给方法（或函数）的方式是 值传递：\",\"如果参数是基本类型的话，很简单，传递的就是基本类型的字面量值的拷贝，会创建副本。\",\"如果参数是引用类型，传递的就是实参所引用的对象在堆中地址值的拷贝，同样也会创建副本。\"]},\"69\":{\"h\":\"参考\",\"t\":[\"《Java 核心技术卷 Ⅰ》基础知识第十版第四章 4.5 小节\",\"Java 到底是值传递还是引用传递？ - Hollis 的回答 - 知乎\",\"Oracle Java Tutorials - Passing Information to a Method or a Constructor\",\"Interview with James Gosling, Father of Java\",\"File not found\"]},\"70\":{\"c\":[\"Java\"]},\"71\":{\"c\":[\"Java基础\"]},\"72\":{\"h\":\"Posts\"},\"73\":{\"h\":\"Basis\"},\"74\":{\"h\":\"Java\"}},\"dirtCount\":0,\"index\":[[\"知乎\",{\"1\":{\"69\":1}}],[\"知道有这个东西就好了\",{\"1\":{\"19\":1}}],[\"到底是值传递还是引用传递\",{\"1\":{\"69\":1}}],[\"到执行期时\",{\"1\":{\"24\":1}}],[\"ⅰ\",{\"1\":{\"69\":1}}],[\"摒弃了许多开发者一不留意就会造成问题的\",{\"1\":{\"67\":1}}],[\"扣的是\",{\"1\":{\"67\":1}}],[\"把方法定义为接口\",{\"1\":{\"67\":1}}],[\"把大部分问题都解决掉了才在\",{\"1\":{\"26\":1}}],[\"出于安全考虑\",{\"1\":{\"67\":1}}],[\"能在方法内就直接把实参的值修改了\",{\"1\":{\"67\":1}}],[\"能够帮助看代码的人快速地理清代码之间的逻辑关系\",{\"1\":{\"29\":1}}],[\"能够创建和编译\",{\"1\":{\"22\":1}}],[\"才为引用传递\",{\"1\":{\"66\":1}}],[\"要注意\",{\"1\":{\"66\":1}}],[\"要是你们搞出来什么好玩的东西\",{\"1\":{\"26\":1}}],[\"函数中对形参的修改\",{\"1\":{\"66\":1}}],[\"让你看一下引用传递的庐山真面目\",{\"1\":{\"66\":1}}],[\"怎么回事\",{\"1\":{\"65\":1}}],[\"小节\",{\"1\":{\"69\":1}}],[\"小李\",{\"1\":{\"65\":3}}],[\"小张\",{\"1\":{\"65\":3}}],[\"省略构造函数\",{\"1\":{\"65\":1}}],[\"请看案例\",{\"1\":{\"63\":1}}],[\"副本的内容无论怎么修改\",{\"1\":{\"63\":1}}],[\"传递的就是实参所引用的对象在堆中地址值的拷贝\",{\"1\":{\"68\":1}}],[\"传递的就是基本类型的字面量值的拷贝\",{\"1\":{\"68\":1}}],[\"传递引用类型参数\",{\"0\":{\"64\":1,\"65\":1}}],[\"传递基本类型参数\",{\"0\":{\"63\":1}}],[\"传送门\",{\"1\":{\"1\":1}}],[\"案例\",{\"0\":{\"63\":1,\"64\":1,\"65\":1}}],[\"接收实参\",{\"1\":{\"60\":1}}],[\"引用传递看似很好\",{\"1\":{\"67\":1}}],[\"引用传递到底长什么样呢\",{\"1\":{\"66\":1}}],[\"引用传递是怎么样的\",{\"0\":{\"66\":1}}],[\"引用传递\",{\"0\":{\"61\":1},\"1\":{\"59\":1,\"61\":1}}],[\"引入了一种新的编译模式\",{\"1\":{\"25\":1}}],[\"彻底弄懂\",{\"1\":{\"56\":1}}],[\"questions\",{\"1\":{\"56\":2}}],[\"5\",{\"1\":{\"64\":1,\"69\":1}}],[\"52\",{\"1\":{\"55\":1}}],[\"544\",{\"1\":{\"18\":1}}],[\"面试手册\",{\"1\":{\"55\":1}}],[\"面试突击\",{\"1\":{\"55\":1}}],[\"面向对象\",{\"1\":{\"18\":1}}],[\"回复\",{\"1\":{\"55\":1}}],[\"微信搜\",{\"1\":{\"55\":1}}],[\"微服务和云原生开发\",{\"1\":{\"22\":1}}],[\"遇到方法重载的情况怎么办呢\",{\"1\":{\"55\":1}}],[\"⭐️\",{\"1\":{\"54\":1}}],[\"指向的是同一个数组对象\",{\"1\":{\"64\":1}}],[\"指的是子类方法的访问权限应比父类方法的访问权限更大或相等\",{\"1\":{\"54\":1}}],[\"指的是子类方法返回值类型应比父类方法返回值类型更小或相等\",{\"1\":{\"54\":1}}],[\"指跳出整个循环体\",{\"1\":{\"34\":1}}],[\"指跳出当前的这一次循环\",{\"1\":{\"34\":1}}],[\"形参的数据类型用的是\",{\"1\":{\"66\":1}}],[\"形参\",{\"0\":{\"60\":1},\"1\":{\"59\":1,\"60\":1}}],[\"形参列表相同\",{\"1\":{\"54\":1}}],[\"形式参数\",{\"1\":{\"60\":1}}],[\"形式\",{\"1\":{\"46\":1}}],[\"讲义\",{\"1\":{\"54\":1}}],[\"疯狂\",{\"1\":{\"54\":1}}],[\"异常\",{\"1\":{\"54\":1}}],[\"子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等\",{\"1\":{\"54\":2}}],[\"子类方法返回值类型应比父类方法返回值类型更小或相等\",{\"1\":{\"53\":1,\"54\":1}}],[\"子类\",{\"1\":{\"54\":1}}],[\"同样也会创建副本\",{\"1\":{\"68\":1}}],[\"同一个类\",{\"1\":{\"54\":1}}],[\"同时你也不可以作为标识符来使用\",{\"1\":{\"31\":1}}],[\"同时又保留了解释型语言可移植的特点\",{\"1\":{\"23\":1}}],[\"同时还包括了\",{\"1\":{\"22\":1}}],[\"同时还包含了编译\",{\"1\":{\"22\":1}}],[\"区别点\",{\"1\":{\"54\":1}}],[\"区分下\",{\"1\":{\"26\":1}}],[\"总结\",{\"0\":{\"54\":1,\"68\":1}}],[\"抛出的异常范围小于等于父类\",{\"1\":{\"53\":1}}],[\"综上\",{\"1\":{\"52\":1,\"54\":1}}],[\"允许重载任何方法\",{\"1\":{\"52\":1}}],[\"便产生了重载\",{\"1\":{\"52\":1}}],[\"核心技术卷\",{\"1\":{\"69\":1}}],[\"核心技术\",{\"1\":{\"52\":1}}],[\"顺序不同\",{\"1\":{\"52\":1}}],[\"输入数据一样\",{\"1\":{\"51\":1}}],[\"输出结果\",{\"1\":{\"66\":1}}],[\"输出结果和前面的代码一样\",{\"1\":{\"33\":1}}],[\"输出字符串常量的值\",{\"1\":{\"49\":1}}],[\"输出字符型常量的值\",{\"1\":{\"49\":1}}],[\"输出\",{\"1\":{\"33\":1,\"38\":3,\"46\":1,\"55\":1,\"63\":1,\"64\":1,\"65\":1}}],[\"输出的是\",{\"1\":{\"32\":1}}],[\"重写时是可以返回该引用类型的子类的\",{\"1\":{\"54\":1}}],[\"重写的返回值类型\",{\"1\":{\"54\":1}}],[\"重写方法\",{\"1\":{\"54\":1}}],[\"重写就是子类对父类方法的重新改造\",{\"1\":{\"54\":1}}],[\"重写就是当子类继承自父类的相同方法\",{\"1\":{\"51\":1}}],[\"重写发生在运行期\",{\"1\":{\"53\":1}}],[\"重写\",{\"0\":{\"53\":1}}],[\"重载方法\",{\"1\":{\"54\":1}}],[\"重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理\",{\"1\":{\"52\":1}}],[\"重载就是同样的一个方法能够根据输入数据的不同\",{\"1\":{\"51\":1}}],[\"重载\",{\"0\":{\"52\":1}}],[\"重载和重写有什么区别\",{\"0\":{\"51\":1}}],[\"做出不同的处理\",{\"1\":{\"51\":1}}],[\"访问修饰符\",{\"1\":{\"54\":1}}],[\"访问修饰符范围大于等于父类\",{\"1\":{\"53\":1}}],[\"访问类成员是否存在限制\",{\"1\":{\"50\":1}}],[\"访问控制\",{\"1\":{\"31\":1}}],[\"调用方不关心具体实现\",{\"1\":{\"67\":1}}],[\"调用方式\",{\"1\":{\"50\":1}}],[\"调用静态方法\",{\"1\":{\"50\":1}}],[\"调用静态方法可以无需创建对象\",{\"1\":{\"50\":1}}],[\"调用实例方法\",{\"1\":{\"50\":1}}],[\"调试器\",{\"1\":{\"22\":1}}],[\"定义一个字符串常量\",{\"1\":{\"49\":1}}],[\"定义一个字符型常量\",{\"1\":{\"49\":1}}],[\"定制的\",{\"1\":{\"22\":1}}],[\"此时调用在内存中还不存在的非静态成员\",{\"1\":{\"49\":1}}],[\"需要注意的是一般不建议使用\",{\"1\":{\"50\":1}}],[\"需要通过类的实例对象去访问\",{\"1\":{\"49\":1}}],[\"需要大量地为程序\",{\"1\":{\"30\":1}}],[\"静态方法在访问本类的成员时\",{\"1\":{\"50\":1}}],[\"静态方法不属于类的某个对象而是属于这个类\",{\"1\":{\"50\":1}}],[\"静态方法和实例方法有何不同\",{\"0\":{\"50\":1}}],[\"静态方法是属于类的\",{\"1\":{\"49\":1}}],[\"静态方法为什么不能调用非静态成员\",{\"0\":{\"49\":1}}],[\"静态变量会被\",{\"1\":{\"45\":1}}],[\"静态变量\",{\"1\":{\"45\":1}}],[\"静态变量是通过类名来访问的\",{\"1\":{\"45\":1}}],[\"静态变量只会被分配一次内存\",{\"1\":{\"45\":1}}],[\"静态变量也就是被\",{\"1\":{\"45\":1}}],[\"静态变量有什么作用\",{\"0\":{\"45\":1}}],[\"使得它可以用于其他的操作\",{\"1\":{\"48\":1}}],[\"使用反射等\",{\"1\":{\"22\":1}}],[\"使用\",{\"1\":{\"22\":1,\"26\":1}}],[\"返回类型\",{\"1\":{\"54\":1}}],[\"返回值的作用是接收出结果\",{\"1\":{\"48\":1}}],[\"返回散列值也就是hashcode\",{\"1\":{\"33\":1}}],[\"该字符串在内存中存放位置\",{\"1\":{\"46\":1}}],[\"该映像仅包含给定应用程序所需的模块\",{\"1\":{\"22\":1}}],[\"含义\",{\"1\":{\"46\":1}}],[\"字符型常量的值为\",{\"1\":{\"49\":1}}],[\"字符型常量占用的字节数为\",{\"1\":{\"46\":2}}],[\"字符型常量\",{\"1\":{\"46\":1}}],[\"字符型常量和字符串常量代码示例\",{\"1\":{\"46\":1}}],[\"字符型常量和字符串常量的区别\",{\"0\":{\"46\":1}}],[\"字符串常量的值为\",{\"1\":{\"49\":1}}],[\"字符串常量占用的字节数为\",{\"1\":{\"46\":2}}],[\"字符串常量占若干个字节\",{\"1\":{\"46\":1}}],[\"字符串常量\",{\"1\":{\"46\":1}}],[\"字符串常量代表一个地址值\",{\"1\":{\"46\":1}}],[\"字符串常量是双引号引起的\",{\"1\":{\"46\":1}}],[\"字符常量只占\",{\"1\":{\"46\":1}}],[\"字符常量相当于一个整型值\",{\"1\":{\"46\":1}}],[\"字符常量是单引号引起的一个字符\",{\"1\":{\"46\":1}}],[\"字节\",{\"1\":{\"36\":1}}],[\"字节码中不保留注释\",{\"1\":{\"29\":1}}],[\"字节码和不同系统的\",{\"1\":{\"21\":1}}],[\"字节码的虚拟机\",{\"1\":{\"21\":1}}],[\"常量\",{\"1\":{\"45\":1}}],[\"常见的一种情况是需要某个整数类型变量增加\",{\"1\":{\"32\":1}}],[\"常见的解释性语言有\",{\"1\":{\"24\":1}}],[\"常见的编译性语言有\",{\"1\":{\"24\":1}}],[\"构造方法无法被重写\",{\"1\":{\"53\":1}}],[\"构造方法中的局部变量\",{\"1\":{\"44\":1}}],[\"构建\",{\"1\":{\"26\":1}}],[\"构建的\",{\"1\":{\"26\":1}}],[\"带参数的方法中的局部变量\",{\"1\":{\"44\":1}}],[\"带符号右移\",{\"1\":{\"33\":1}}],[\"栈中分配的局部变量\",{\"1\":{\"44\":5}}],[\"又会影响用户体验\",{\"1\":{\"44\":1}}],[\"误报\",{\"1\":{\"44\":1}}],[\"没默认值\",{\"1\":{\"44\":1}}],[\"没有手动赋值一定要自动赋值\",{\"1\":{\"44\":1}}],[\"没办法\",{\"1\":{\"27\":1}}],[\"手动和自动\",{\"1\":{\"44\":1}}],[\"生存时间\",{\"1\":{\"44\":1}}],[\"生成字节码\",{\"1\":{\"24\":1}}],[\"语法形式\",{\"1\":{\"44\":1}}],[\"语言本身的东西少了\",{\"1\":{\"67\":1}}],[\"语言本身的设计就提供了多重安全防护机制如访问权限修饰符\",{\"1\":{\"18\":1}}],[\"语言关键字有哪些\",{\"0\":{\"31\":1}}],[\"语言已经赋予了其特殊的含义\",{\"1\":{\"30\":1}}],[\"语言既具有编译型语言的特征\",{\"1\":{\"24\":1}}],[\"语言通过字节码的方式\",{\"1\":{\"23\":1}}],[\"语言\",{\"0\":{\"24\":1},\"1\":{\"21\":1,\"24\":1,\"25\":2}}],[\"语言最大的优势\",{\"1\":{\"18\":1}}],[\"语言的运行效率还是非常不错的\",{\"1\":{\"18\":1}}],[\"语言却提供了多线程支持\",{\"1\":{\"18\":1}}],[\"语言没有内置的多线程机制\",{\"1\":{\"18\":1}}],[\"语言有哪些特点\",{\"0\":{\"18\":1}}],[\"局部变量没赋值很好判断\",{\"1\":{\"44\":1}}],[\"局部变量则存在于栈内存\",{\"1\":{\"44\":1}}],[\"局部变量\",{\"1\":{\"44\":1}}],[\"成员变量与局部变量代码示例\",{\"1\":{\"44\":1}}],[\"成员变量与局部变量的区别\",{\"0\":{\"44\":1}}],[\"成员变量在运行时可借助反射等方法手动赋值\",{\"1\":{\"44\":1}}],[\"成员变量如果没有被赋初始值\",{\"1\":{\"44\":1}}],[\"成员变量是对象的一部分\",{\"1\":{\"44\":1}}],[\"成员变量是属于类的\",{\"1\":{\"44\":1}}],[\"成员变量和局部变量都能被\",{\"1\":{\"44\":1}}],[\"成员变量可以被\",{\"1\":{\"44\":1}}],[\"成员变量\",{\"1\":{\"44\":2}}],[\"成员变量包装类型不赋值就是\",{\"1\":{\"37\":1}}],[\"数组来存储任意大小的整形数据\",{\"1\":{\"42\":1}}],[\"数据库又是闭源的\",{\"1\":{\"26\":1}}],[\"数据库而著名\",{\"1\":{\"26\":1}}],[\"内部逻辑可以改变\",{\"1\":{\"54\":1}}],[\"内部使用\",{\"1\":{\"42\":1}}],[\"内存占用和打包体积\",{\"1\":{\"25\":1}}],[\"整型是最大的整数类型\",{\"1\":{\"42\":1}}],[\"整型的数据应该如何表示\",{\"0\":{\"42\":1}}],[\"超人\",{\"1\":{\"54\":1}}],[\"超级超级英雄\",{\"1\":{\"54\":1}}],[\"超级英雄\",{\"1\":{\"54\":1}}],[\"超级简单的设计模式\",{\"0\":{\"7\":1}}],[\"超过\",{\"0\":{\"42\":1}}],[\"详解\",{\"1\":{\"41\":1}}],[\"来说\",{\"1\":{\"44\":1}}],[\"来做的\",{\"1\":{\"41\":1}}],[\"来编写默认匹配的情况\",{\"1\":{\"31\":1}}],[\"来编译和运行\",{\"1\":{\"22\":1}}],[\"大部分需要浮点数精确运算结果的业务场景\",{\"1\":{\"41\":1}}],[\"大概每三年都会推出一个\",{\"1\":{\"26\":1}}],[\"浮点数这篇文章\",{\"1\":{\"40\":1}}],[\"浮点数运算精度丢失代码演示\",{\"1\":{\"40\":1}}],[\"四\",{\"1\":{\"40\":1}}],[\"得到的整数部分从上到下排列就是二进制的结果\",{\"1\":{\"40\":1}}],[\"宽度是有限的\",{\"1\":{\"40\":1}}],[\"举例\",{\"1\":{\"39\":1}}],[\"举个例子\",{\"1\":{\"25\":1,\"29\":1}}],[\"拆箱其实就是调用了\",{\"1\":{\"39\":1}}],[\"拆箱\",{\"1\":{\"39\":2}}],[\"装箱\",{\"1\":{\"39\":2}}],[\"装饰器模式\",{\"0\":{\"13\":1},\"1\":{\"13\":1}}],[\"什么是可变长参数\",{\"0\":{\"55\":1}}],[\"什么是方法的返回值\",{\"0\":{\"48\":1}}],[\"什么是自动拆装箱\",{\"1\":{\"39\":1}}],[\"什么是字节码\",{\"0\":{\"23\":1}}],[\"原理是什么\",{\"0\":{\"39\":1}}],[\"原来是\",{\"1\":{\"26\":1}}],[\"记住\",{\"1\":{\"38\":1}}],[\"两个引用类型的形参互换并没有影响实参啊\",{\"1\":{\"65\":1}}],[\"两小\",{\"1\":{\"54\":1}}],[\"两同\",{\"1\":{\"54\":1}}],[\"两同两小一大\",{\"1\":{\"54\":1}}],[\"两种浮点数类型的包装类\",{\"1\":{\"38\":1}}],[\"两者稳定性其实也是差不多的\",{\"1\":{\"26\":1}}],[\"两者各有优点\",{\"1\":{\"25\":1}}],[\"两者的关键指标对比\",{\"1\":{\"25\":1}}],[\"缓存的范围区间的大小只是在性能和资源之间的权衡\",{\"1\":{\"38\":1}}],[\"缓存源码\",{\"1\":{\"38\":3}}],[\"范围的缓存数据\",{\"1\":{\"38\":1}}],[\"全部使用\",{\"1\":{\"37\":1,\"38\":1}}],[\"全局只有一个实例\",{\"1\":{\"8\":1}}],[\"占内存大小\",{\"1\":{\"46\":1}}],[\"占用空间\",{\"1\":{\"37\":1}}],[\"占个位\",{\"0\":{\"3\":1},\"1\":{\"3\":1}}],[\"存放在\",{\"1\":{\"37\":1}}],[\"存储方式\",{\"1\":{\"37\":1,\"44\":1}}],[\"存储库中的源代码与用于构建\",{\"1\":{\"26\":1}}],[\"修饰的方法能够被再次声明\",{\"1\":{\"53\":1}}],[\"修饰的成员变量也必须显式地赋值\",{\"1\":{\"44\":1}}],[\"修饰的\",{\"1\":{\"44\":1}}],[\"修饰的话\",{\"1\":{\"37\":1}}],[\"修饰\",{\"1\":{\"37\":1,\"44\":1}}],[\"修正\",{\"1\":{\"18\":1}}],[\"未被\",{\"1\":{\"37\":1}}],[\"未经允许禁止转载\",{\"1\":{\"7\":1}}],[\"双引号\",{\"1\":{\"36\":1}}],[\"否则将作为整型解析\",{\"1\":{\"36\":1}}],[\"里使用\",{\"1\":{\"36\":1}}],[\"节有提到\",{\"1\":{\"36\":1}}],[\"另外\",{\"1\":{\"36\":1,\"55\":2}}],[\"逻辑上理解是占用\",{\"1\":{\"36\":1}}],[\"厂商的具体实现\",{\"1\":{\"36\":1}}],[\"变成一个负数\",{\"1\":{\"36\":1}}],[\"变量存储的是内存地址对应的任意随机值\",{\"1\":{\"44\":1}}],[\"变量引用\",{\"1\":{\"31\":1}}],[\"变量\",{\"0\":{\"43\":1},\"1\":{\"30\":1}}],[\"表示结束方法的执行\",{\"1\":{\"48\":1}}],[\"表示负数\",{\"1\":{\"36\":1}}],[\"表示正数\",{\"1\":{\"36\":1}}],[\"像\",{\"1\":{\"36\":1}}],[\"取的是\",{\"1\":{\"67\":1}}],[\"取值范围\",{\"1\":{\"36\":1}}],[\"取而代之的是模块系统\",{\"1\":{\"22\":1}}],[\"默认值有两种设置方式\",{\"1\":{\"44\":1}}],[\"默认值\",{\"1\":{\"36\":1,\"37\":1,\"44\":1}}],[\"种包装类默认创建了数值\",{\"1\":{\"38\":1}}],[\"种布尔型\",{\"1\":{\"36\":1}}],[\"种字符类型\",{\"1\":{\"36\":1}}],[\"种浮点型\",{\"1\":{\"36\":1}}],[\"种整数型\",{\"1\":{\"36\":1}}],[\"种数字类型\",{\"1\":{\"36\":1}}],[\"种基本数据类型的默认值以及所占空间的大小如下\",{\"1\":{\"36\":1}}],[\"种基本数据类型\",{\"1\":{\"36\":1}}],[\"分析\",{\"1\":{\"66\":1}}],[\"分别为\",{\"1\":{\"36\":1}}],[\"分类\",{\"1\":{\"31\":1}}],[\"40\",{\"1\":{\"38\":4}}],[\"4028235e38\",{\"1\":{\"36\":1}}],[\"45\",{\"1\":{\"36\":1}}],[\"4e\",{\"1\":{\"36\":1}}],[\"4\",{\"1\":{\"34\":2,\"36\":4,\"38\":1,\"40\":3,\"48\":1,\"64\":1,\"69\":1}}],[\"42\",{\"1\":{\"33\":5}}],[\"思考一下\",{\"1\":{\"34\":1}}],[\"结束方法执行\",{\"1\":{\"34\":1}}],[\"结束该方法的运行\",{\"1\":{\"34\":1}}],[\"直到不存在小数为止\",{\"1\":{\"40\":1}}],[\"直到今天\",{\"1\":{\"18\":1}}],[\"直接返回\",{\"1\":{\"38\":1}}],[\"直接使用的是缓存中的对象\",{\"1\":{\"38\":1}}],[\"直接使用\",{\"1\":{\"34\":1}}],[\"继续执行循环下面的语句\",{\"1\":{\"34\":1}}],[\"继续下一次循环\",{\"1\":{\"34\":1}}],[\"继承和多态\",{\"1\":{\"27\":1}}],[\"继承\",{\"1\":{\"18\":1}}],[\"循环会正常结束\",{\"1\":{\"34\":1}}],[\"篇幅问题\",{\"1\":{\"33\":1}}],[\"初始数据对应的二进制字符串\",{\"1\":{\"33\":3}}],[\"初始数据\",{\"1\":{\"33\":3}}],[\"左移\",{\"1\":{\"33\":7}}],[\"左移运算符代码示例\",{\"1\":{\"33\":1}}],[\"左移运算符\",{\"1\":{\"33\":1}}],[\"位数\",{\"1\":{\"36\":1}}],[\"位后的数据对应的二进制字符\",{\"1\":{\"33\":3}}],[\"位后的数据\",{\"1\":{\"33\":3}}],[\"位\",{\"1\":{\"33\":3,\"36\":1,\"42\":1}}],[\"位相当于左移\",{\"1\":{\"33\":2}}],[\"位相当于不进行移位操作\",{\"1\":{\"33\":1}}],[\"位操作时\",{\"1\":{\"33\":2}}],[\"右移运算符使用类似\",{\"1\":{\"33\":1}}],[\"右移\",{\"1\":{\"33\":3}}],[\"右移操作时\",{\"1\":{\"33\":1}}],[\"右移操作\",{\"1\":{\"33\":1}}],[\"右移位数大于等于\",{\"1\":{\"33\":1}}],[\"补齐\",{\"1\":{\"33\":1}}],[\"负数高位补\",{\"1\":{\"33\":1}}],[\"正数高位补\",{\"1\":{\"33\":1}}],[\"低位丢弃\",{\"1\":{\"33\":1}}],[\"低位补零\",{\"1\":{\"33\":1}}],[\"向右移若干位\",{\"1\":{\"33\":1}}],[\"向左移若干位\",{\"1\":{\"33\":1}}],[\"乘以\",{\"1\":{\"33\":1}}],[\"xiaoli\",{\"1\":{\"65\":7}}],[\"xiaozhang\",{\"1\":{\"65\":7}}],[\"xixi\",{\"1\":{\"34\":3}}],[\"xxxvalue\",{\"1\":{\"39\":1}}],[\"x>>42等同于x>>10\",{\"1\":{\"33\":1}}],[\"x<<42等同于x<<10\",{\"1\":{\"33\":1}}],[\"x\",{\"1\":{\"33\":5,\"37\":1,\"41\":3,\"48\":1}}],[\"高位补符号位\",{\"1\":{\"33\":1}}],[\"高位丢弃\",{\"1\":{\"33\":1}}],[\"高效性\",{\"1\":{\"18\":1}}],[\"掌握最基本的移位运算符知识还是很有必要的\",{\"1\":{\"33\":1}}],[\"空位都以\",{\"1\":{\"33\":1}}],[\"空位都以0补齐\",{\"1\":{\"33\":1}}],[\"空调等\",{\"1\":{\"19\":1}}],[\"忽略符号位\",{\"1\":{\"33\":2}}],[\"无参数无返回值的方法\",{\"1\":{\"48\":1}}],[\"无论一个类创建了多少个对象\",{\"1\":{\"45\":1}}],[\"无法判断\",{\"1\":{\"44\":1}}],[\"无限循环的小数存储在计算机时\",{\"1\":{\"40\":1}}],[\"无符号右移\",{\"1\":{\"33\":2}}],[\"无需重点关注\",{\"1\":{\"19\":1}}],[\"按位异或\",{\"1\":{\"33\":1}}],[\"^\",{\"1\":{\"33\":2}}],[\"被\",{\"1\":{\"44\":1}}],[\"被操作的数据被视为二进制数\",{\"1\":{\"33\":1}}],[\"被重新组织成\",{\"1\":{\"22\":2}}],[\"移位操作符实际上支持的类型只有int和long\",{\"1\":{\"33\":1}}],[\"移位操作中\",{\"1\":{\"33\":1}}],[\"移位就是将其向左或向右移动若干位的运算\",{\"1\":{\"33\":1}}],[\"移位运算符总结\",{\"1\":{\"33\":1}}],[\"移位运算符在各种框架以及\",{\"1\":{\"33\":1}}],[\"移位运算符是最基本的运算符之一\",{\"1\":{\"33\":1}}],[\"移位运算符\",{\"0\":{\"33\":1}}],[\"几乎每种编程语言都包含这一运算符\",{\"1\":{\"33\":1}}],[\"符号在后就后加\",{\"1\":{\"32\":1}}],[\"符号在前就先加\",{\"1\":{\"32\":1}}],[\"值传递\",{\"0\":{\"61\":1},\"1\":{\"59\":1,\"61\":1,\"68\":1}}],[\"值传递详解\",{\"0\":{\"59\":1}}],[\"值\",{\"1\":{\"32\":1,\"46\":1}}],[\"赋值给\",{\"1\":{\"32\":2}}],[\"自动装箱与拆箱了解吗\",{\"0\":{\"39\":1}}],[\"自身的源码中使用还是挺广泛的\",{\"1\":{\"33\":1}}],[\"自己增加\",{\"1\":{\"32\":2}}],[\"自增自减运算符\",{\"0\":{\"32\":1}}],[\"时\",{\"1\":{\"32\":2}}],[\"再自增\",{\"1\":{\"32\":2}}],[\"再赋值\",{\"1\":{\"32\":2}}],[\"再将字节码直译\",{\"1\":{\"24\":1}}],[\"减\",{\"1\":{\"32\":4}}],[\"前提是该方法可能产生结果\",{\"1\":{\"48\":1}}],[\"前缀\",{\"1\":{\"32\":1}}],[\"前端\",{\"2\":{\"14\":1}}],[\"运算的效率会相对较低\",{\"1\":{\"42\":1}}],[\"运算符可以放在变量之前\",{\"1\":{\"32\":1}}],[\"运行期\",{\"1\":{\"54\":1}}],[\"运行结果\",{\"1\":{\"34\":1}}],[\"运行时\",{\"1\":{\"22\":1}}],[\"运行时映像有助于简化\",{\"1\":{\"22\":1}}],[\"运行时映像\",{\"1\":{\"22\":1}}],[\"运行时环境的大小\",{\"1\":{\"22\":1}}],[\"运行时环境\",{\"1\":{\"22\":2}}],[\"运行在\",{\"1\":{\"21\":1}}],[\"叫做自增运算符\",{\"1\":{\"32\":1}}],[\"或函数\",{\"1\":{\"61\":1,\"68\":1}}],[\"或减少\",{\"1\":{\"32\":1}}],[\"或者没有一个比其他的更好\",{\"1\":{\"52\":1}}],[\"或者父类和子类之间\",{\"1\":{\"52\":1}}],[\"或者基于\",{\"1\":{\"26\":1}}],[\"或者说需要针对性地去做适配和优化\",{\"1\":{\"25\":1}}],[\"官方\",{\"1\":{\"67\":1}}],[\"官方文档未明确定义\",{\"1\":{\"36\":1}}],[\"官方文档\",{\"1\":{\"31\":1}}],[\"官方在\",{\"1\":{\"26\":1}}],[\"看到这里\",{\"1\":{\"66\":1}}],[\"看了这个案例很多人肯定觉得\",{\"1\":{\"64\":1}}],[\"看起来像关键字但实际上他们是字面值\",{\"1\":{\"31\":1}}],[\"看不懂你来打我\",{\"0\":{\"7\":1}}],[\"注意\",{\"1\":{\"31\":1,\"36\":1,\"37\":1,\"39\":1,\"46\":1,\"67\":1}}],[\"注释是你的代码说明书\",{\"1\":{\"29\":1}}],[\"注释并不会执行\",{\"1\":{\"29\":1}}],[\"注释类型总结\",{\"1\":{\"29\":1}}],[\"注释有哪几种形式\",{\"0\":{\"29\":1}}],[\"⚠️\",{\"1\":{\"31\":1,\"37\":1,\"46\":1}}],[\"既属于程序控制\",{\"1\":{\"31\":1}}],[\"既然\",{\"1\":{\"25\":1,\"26\":1}}],[\"保留字\",{\"1\":{\"31\":1}}],[\"错误处理\",{\"1\":{\"31\":1}}],[\"方法内部对值进行的操作\",{\"1\":{\"67\":1}}],[\"方法中\",{\"1\":{\"63\":1}}],[\"方法中的局部变量\",{\"1\":{\"44\":1}}],[\"方法接收的直接是实参所引用的对象在堆中的地址\",{\"1\":{\"61\":1}}],[\"方法接收的是实参值的拷贝\",{\"1\":{\"61\":1}}],[\"方法就可以接受\",{\"1\":{\"55\":1}}],[\"方法返回值和访问修饰符可以不同\",{\"1\":{\"52\":1}}],[\"方法名必须相同\",{\"1\":{\"52\":1}}],[\"方法名\",{\"1\":{\"50\":4,\"53\":1}}],[\"方法的参数拷贝的是\",{\"1\":{\"64\":1}}],[\"方法的参数\",{\"1\":{\"60\":1,\"65\":1}}],[\"方法的定义可能会用到\",{\"1\":{\"60\":1}}],[\"方法的重写要遵循\",{\"1\":{\"54\":1}}],[\"方法的返回值\",{\"1\":{\"48\":1}}],[\"方法的源码就用到了移位运算符\",{\"1\":{\"33\":1}}],[\"方法有哪几种类型\",{\"0\":{\"48\":1}}],[\"方法比较\",{\"1\":{\"38\":1}}],[\"方法\",{\"0\":{\"47\":1},\"1\":{\"37\":1,\"39\":2,\"60\":1}}],[\"方法和变量修饰符中\",{\"1\":{\"31\":1}}],[\"方法和变量修饰符\",{\"1\":{\"31\":2}}],[\"方法等取名字\",{\"1\":{\"30\":1}}],[\"警察局\",{\"1\":{\"30\":3}}],[\"名字\",{\"1\":{\"30\":1}}],[\"起的这个\",{\"1\":{\"30\":1}}],[\"则返回值重写时不可修改\",{\"1\":{\"54\":1}}],[\"则子类就不能重写该方法\",{\"1\":{\"53\":1}}],[\"则会自动以类型的默认值而赋值\",{\"1\":{\"44\":1}}],[\"则默认会有一个修饰符\",{\"1\":{\"31\":1}}],[\"则要给这个店起一个名字\",{\"1\":{\"30\":1}}],[\"则包含了\",{\"1\":{\"22\":1}}],[\"关键字修饰成为常量\",{\"1\":{\"45\":1}}],[\"关键字修饰的变量\",{\"1\":{\"45\":1}}],[\"关键字来定义一个方法的默认实现\",{\"1\":{\"31\":1}}],[\"关键字是被赋予特殊含义的标识符\",{\"1\":{\"30\":1}}],[\"关键字\",{\"1\":{\"30\":1,\"31\":1}}],[\"关于\",{\"1\":{\"41\":1,\"54\":1}}],[\"关于浮点数的更多内容\",{\"1\":{\"40\":1}}],[\"关于作者\",{\"0\":{\"2\":1},\"1\":{\"2\":1}}],[\"关于网站\",{\"0\":{\"1\":1}}],[\"标识符就是一个名字\",{\"1\":{\"30\":1}}],[\"标识符\",{\"1\":{\"30\":1}}],[\"标识符和关键字的区别是什么\",{\"0\":{\"30\":1}}],[\"于是就有了\",{\"1\":{\"30\":1}}],[\"于是自己在\",{\"1\":{\"26\":1}}],[\"类名\",{\"1\":{\"50\":2}}],[\"类型的数据一定要在数值后面加上\",{\"1\":{\"36\":1}}],[\"类型进行左移\",{\"1\":{\"33\":1}}],[\"类型左移\",{\"1\":{\"33\":1}}],[\"类\",{\"1\":{\"30\":1,\"31\":1}}],[\"类加载器首先加载字节码文件\",{\"1\":{\"23\":1}}],[\"应该使用\",{\"1\":{\"39\":1}}],[\"应该要使用基本数据类型对应的包装类型\",{\"1\":{\"37\":1}}],[\"应替换为\",{\"1\":{\"29\":1}}],[\"应用的部署和节省内存并增强安全性和可维护性\",{\"1\":{\"22\":1}}],[\"应用可以通过新增的\",{\"1\":{\"22\":1}}],[\"应用程序的开发工作\",{\"1\":{\"22\":1}}],[\"应用程序的开发和调试\",{\"1\":{\"22\":1}}],[\"应用程序的运行时环境和必要的类库\",{\"1\":{\"22\":1}}],[\"应用程序\",{\"1\":{\"19\":3}}],[\"应用程序开发和运行的核心类库以及虚拟机等核心组件\",{\"1\":{\"19\":1}}],[\"去掉下面复杂的注释\",{\"1\":{\"29\":1}}],[\"尽量通过代码来阐述\",{\"1\":{\"29\":1}}],[\"若编程语言足够有表达力\",{\"1\":{\"29\":1}}],[\"多行注释在实际开发中使用的相对较少\",{\"1\":{\"29\":1}}],[\"多行注释\",{\"1\":{\"29\":1}}],[\"多态\",{\"1\":{\"18\":1}}],[\"单引号\",{\"1\":{\"36\":1}}],[\"单行注释\",{\"1\":{\"29\":1}}],[\"单例模式的本质就是共享同一个作用域链\",{\"1\":{\"8\":1}}],[\"单例模式的精髓就是不管一个构造函数被实例化多少次\",{\"1\":{\"8\":1}}],[\"单例模式\",{\"0\":{\"8\":1}}],[\"操作符重载增加了复杂性\",{\"1\":{\"27\":1}}],[\"比较的是对象的内存地址\",{\"1\":{\"37\":1}}],[\"比较的是值\",{\"1\":{\"37\":1}}],[\"比较方式\",{\"1\":{\"37\":1}}],[\"比呀\",{\"1\":{\"27\":1}}],[\"比如涉及到钱的场景\",{\"1\":{\"41\":1}}],[\"比如编写和编译\",{\"1\":{\"22\":1}}],[\"比如\",{\"1\":{\"19\":1,\"25\":1,\"26\":4,\"30\":1,\"52\":1,\"61\":1}}],[\"比如你通过\",{\"1\":{\"18\":1}}],[\"用途\",{\"1\":{\"37\":1}}],[\"用一句口诀就是\",{\"1\":{\"32\":1}}],[\"用于定义函数\",{\"1\":{\"60\":1}}],[\"用于传递给函数\",{\"1\":{\"60\":1}}],[\"用于有返回值函数的方法\",{\"1\":{\"34\":1}}],[\"用于没有返回值函数的方法\",{\"1\":{\"34\":1}}],[\"用于跳出所在方法\",{\"1\":{\"34\":1}}],[\"用于这种表达式\",{\"1\":{\"32\":1}}],[\"用于生成自定义\",{\"1\":{\"22\":1}}],[\"用的比较多的还是单行注释和文档注释\",{\"1\":{\"29\":1}}],[\"用的都是这个协议\",{\"1\":{\"26\":1}}],[\"及之后新发布的\",{\"1\":{\"26\":1}}],[\"阿里巴巴的\",{\"1\":{\"26\":1}}],[\"建议看一下计算机系统基础\",{\"1\":{\"40\":1}}],[\"建议选择\",{\"1\":{\"26\":1}}],[\"建立在\",{\"1\":{\"19\":1}}],[\"试试水\",{\"1\":{\"26\":1}}],[\"先不考虑变量类型\",{\"1\":{\"44\":1}}],[\"先赋值\",{\"1\":{\"32\":2}}],[\"先自增\",{\"1\":{\"32\":2}}],[\"先在\",{\"1\":{\"26\":1}}],[\"先把程序源代码编译成字节码\",{\"1\":{\"24\":1}}],[\"现在你知道为啥\",{\"1\":{\"26\":1}}],[\"现在已经用不上了\",{\"1\":{\"19\":1}}],[\"6844904025880526861\",{\"1\":{\"56\":1}}],[\"64\",{\"1\":{\"33\":2,\"36\":2,\"42\":1}}],[\"65535\",{\"1\":{\"36\":1}}],[\"65\",{\"1\":{\"29\":1}}],[\"6\",{\"1\":{\"26\":1,\"36\":1,\"40\":2}}],[\"66\",{\"1\":{\"13\":1}}],[\"更稳定了吧\",{\"1\":{\"26\":1}}],[\"更新频率更快\",{\"1\":{\"26\":1}}],[\"更适合当下的云原生场景\",{\"1\":{\"25\":1}}],[\"更适合开发复杂的企业级应用程序或\",{\"1\":{\"19\":1}}],[\"更适合开发桌面应用程序或简单的服务器应用程序\",{\"1\":{\"19\":1}}],[\"892\",{\"1\":{\"54\":1}}],[\"8f\",{\"1\":{\"40\":1}}],[\"8\",{\"1\":{\"26\":1,\"33\":1,\"36\":5,\"39\":1,\"40\":2,\"41\":1}}],[\"虽然用到了\",{\"1\":{\"48\":1}}],[\"虽然\",{\"1\":{\"26\":1,\"27\":2,\"31\":1}}],[\"虽然观察者模式可以轻松实现发布订阅模式的功能\",{\"1\":{\"10\":1}}],[\"y\",{\"1\":{\"41\":3}}],[\"yum\",{\"1\":{\"26\":1}}],[\"yourclass\",{\"1\":{\"13\":8}}],[\"your\",{\"1\":{\"12\":1}}],[\"优化之后\",{\"1\":{\"37\":1}}],[\"优化\",{\"1\":{\"26\":1}}],[\"许可获得许可\",{\"1\":{\"26\":1}}],[\"协议获得许可\",{\"1\":{\"26\":1}}],[\"协议\",{\"1\":{\"26\":3}}],[\"周期相同的\",{\"1\":{\"26\":1}}],[\"版\",{\"1\":{\"26\":1}}],[\"版进行长期支持\",{\"1\":{\"26\":1}}],[\"版本构建过程基于\",{\"1\":{\"26\":1}}],[\"服务\",{\"1\":{\"26\":1}}],[\"稳定性\",{\"1\":{\"26\":1}}],[\"功能性\",{\"1\":{\"26\":1}}],[\"但其前面可以有也可以没有任何其他参数\",{\"1\":{\"55\":1}}],[\"但要做出有别于父类的响应时\",{\"1\":{\"51\":1}}],[\"但并不是所有版本都是免费的\",{\"1\":{\"26\":1}}],[\"但一般有时间限制\",{\"1\":{\"26\":1}}],[\"但是如果方法的返回值是引用类型\",{\"1\":{\"54\":1}}],[\"但是被\",{\"1\":{\"53\":1}}],[\"但是实际中会考虑计算机高效存储因素\",{\"1\":{\"36\":1}}],[\"但是这个修饰符加上了就会报错\",{\"1\":{\"31\":1}}],[\"但是我们店的名字不能叫\",{\"1\":{\"30\":1}}],[\"但是当项目结构一旦复杂起来\",{\"1\":{\"29\":1}}],[\"但是接口可以多继承\",{\"1\":{\"27\":1}}],[\"但是\",{\"1\":{\"27\":2,\"34\":1,\"44\":1,\"66\":1,\"67\":1}}],[\"但是面试官就是没事喜欢拿咱们\",{\"1\":{\"27\":1}}],[\"但是商用需要付费\",{\"1\":{\"26\":1}}],[\"但是不能进行修改\",{\"1\":{\"26\":1}}],[\"但是仅有\",{\"1\":{\"26\":1}}],[\"但是原来的\",{\"1\":{\"26\":1}}],[\"但是观察者模式使得concretesuject和concreteobservver耦合在了一起\",{\"1\":{\"10\":1}}],[\"你也想象一下\",{\"1\":{\"67\":1}}],[\"你就要覆盖父类方法\",{\"1\":{\"51\":1}}],[\"你答对了吗\",{\"1\":{\"38\":1}}],[\"你们继续玩你们的\",{\"1\":{\"26\":1}}],[\"你们叫\",{\"1\":{\"26\":1}}],[\"你可以在\",{\"1\":{\"21\":1}}],[\"烂在手里了吗\",{\"1\":{\"26\":1}}],[\"失去信心\",{\"1\":{\"26\":1}}],[\"导致大家对\",{\"1\":{\"26\":1}}],[\"必须有确定的值\",{\"1\":{\"60\":1}}],[\"必须修改\",{\"1\":{\"54\":1}}],[\"必须通过中介者同步信息\",{\"1\":{\"11\":1}}],[\"必然会引起很多\",{\"1\":{\"26\":1}}],[\"收购回来之后就把他给闭源\",{\"1\":{\"26\":1}}],[\"收购了\",{\"1\":{\"26\":1}}],[\"给开源了\",{\"1\":{\"26\":1}}],[\"后再进行左移操作\",{\"1\":{\"33\":1}}],[\"后再进行左移\",{\"1\":{\"33\":1}}],[\"后缀\",{\"1\":{\"32\":1}}],[\"后来\",{\"1\":{\"26\":1}}],[\"后解释两个步骤\",{\"1\":{\"24\":1}}],[\"众所周知\",{\"1\":{\"26\":1}}],[\"个例子来给大家证明\",{\"1\":{\"62\":1}}],[\"个或者多个参数\",{\"1\":{\"55\":1}}],[\"个或若干个字符\",{\"1\":{\"46\":1}}],[\"个数不同\",{\"1\":{\"52\":1}}],[\"个字节\",{\"1\":{\"46\":1}}],[\"个月发布一个新版本\",{\"1\":{\"26\":2}}],[\"个人观点\",{\"1\":{\"26\":1}}],[\"个模块\",{\"1\":{\"22\":2}}],[\"最高位是用来表示符号的\",{\"1\":{\"36\":1}}],[\"最初的设计思想不符\",{\"1\":{\"27\":1}}],[\"最后\",{\"1\":{\"26\":1}}],[\"最大的卖点了\",{\"1\":{\"18\":1}}],[\"展望未来\",{\"1\":{\"26\":1}}],[\"插件和\",{\"1\":{\"26\":1}}],[\"非常接近\",{\"1\":{\"26\":1}}],[\"答案是会优先匹配固定参数的方法\",{\"1\":{\"55\":1}}],[\"答案是\",{\"1\":{\"38\":1}}],[\"答\",{\"1\":{\"26\":2}}],[\"问\",{\"1\":{\"26\":1}}],[\"工程师参与维护\",{\"1\":{\"26\":1}}],[\"工具\",{\"1\":{\"22\":2}}],[\"7f\",{\"1\":{\"40\":1}}],[\"7976931348623157e308\",{\"1\":{\"36\":1}}],[\"7\",{\"1\":{\"26\":3}}],[\"添加一些特有的功能和工具\",{\"1\":{\"26\":1}}],[\"~\",{\"1\":{\"26\":1,\"36\":7}}],[\"公司就想了个骚操作\",{\"1\":{\"26\":1}}],[\"公司就不想完全开源了\",{\"1\":{\"26\":1}}],[\"公司收购回来不就把\",{\"1\":{\"26\":1}}],[\"公司又把\",{\"1\":{\"26\":1}}],[\"公司又卖给了\",{\"1\":{\"26\":1}}],[\"公司以\",{\"1\":{\"26\":1}}],[\"公司开发的\",{\"1\":{\"26\":1}}],[\"公司\",{\"1\":{\"26\":2}}],[\"公司将\",{\"1\":{\"26\":1}}],[\"年后无法免费商用\",{\"1\":{\"26\":1}}],[\"年时间\",{\"1\":{\"26\":1}}],[\"年发表的一个博客\",{\"1\":{\"26\":1}}],[\"年\",{\"1\":{\"26\":2}}],[\"年的时候\",{\"1\":{\"18\":1}}],[\"首先\",{\"1\":{\"26\":1}}],[\"之父\",{\"1\":{\"67\":1}}],[\"之前\",{\"1\":{\"26\":1}}],[\"之前只要不升级可以无限期免费\",{\"1\":{\"26\":1}}],[\"之后\",{\"1\":{\"26\":1}}],[\"之后的版本可以免费分发和商用\",{\"1\":{\"26\":1}}],[\"之后执行\",{\"1\":{\"24\":1}}],[\"之间是否存在重大差异\",{\"1\":{\"26\":1}}],[\"提前终止循环\",{\"1\":{\"34\":1}}],[\"提前编译\",{\"1\":{\"25\":1}}],[\"提供了两种参数传递的方式\",{\"1\":{\"61\":1}}],[\"提供了一种特殊的运算符\",{\"1\":{\"32\":1}}],[\"提供了对应的和\",{\"1\":{\"26\":1}}],[\"提到\",{\"1\":{\"25\":1}}],[\"技术了\",{\"1\":{\"25\":1}}],[\"技术\",{\"1\":{\"25\":1}}],[\"技术示例与原理讲解\",{\"1\":{\"25\":1}}],[\"很简单\",{\"1\":{\"68\":1}}],[\"很多程序设计语言\",{\"1\":{\"61\":1}}],[\"很多公司都基于\",{\"1\":{\"26\":1}}],[\"很多框架和库\",{\"1\":{\"25\":1}}],[\"很明显这是javascript的闭包机制实现的\",{\"1\":{\"8\":1}}],[\"然后\",{\"1\":{\"26\":1}}],[\"然后通过解释器逐行解释执行\",{\"1\":{\"23\":1}}],[\"然而\",{\"1\":{\"25\":1}}],[\"动态加载\",{\"1\":{\"25\":1}}],[\"动态代理使用的是\",{\"1\":{\"25\":1}}],[\"动态代理\",{\"1\":{\"25\":1}}],[\"除以\",{\"1\":{\"33\":1}}],[\"除此之外\",{\"1\":{\"25\":1}}],[\"除了定义一些常量和局部变量之外\",{\"1\":{\"37\":1}}],[\"除了我们考虑商业功能的部分\",{\"1\":{\"26\":1}}],[\"除了我们平时最常用的\",{\"1\":{\"21\":1}}],[\"除了\",{\"1\":{\"19\":1}}],[\"化\",{\"1\":{\"25\":1}}],[\"走向\",{\"1\":{\"25\":1}}],[\"感兴趣的同学\",{\"1\":{\"25\":1}}],[\"感兴趣的可以去看看\",{\"1\":{\"21\":1}}],[\"发生阶段\",{\"1\":{\"54\":1}}],[\"发生范围\",{\"1\":{\"54\":1}}],[\"发生在同一个类中\",{\"1\":{\"52\":1}}],[\"发生循环\",{\"1\":{\"40\":1}}],[\"发行版本\",{\"1\":{\"25\":1}}],[\"发布器\",{\"1\":{\"10\":1}}],[\"发布\",{\"0\":{\"10\":1},\"1\":{\"10\":2}}],[\"完整的\",{\"1\":{\"25\":1}}],[\"了\",{\"1\":{\"25\":1,\"36\":1}}],[\"与\",{\"1\":{\"25\":2}}],[\"特性\",{\"1\":{\"67\":1}}],[\"特性的应用程序\",{\"1\":{\"22\":1}}],[\"特别适合云原生场景\",{\"1\":{\"25\":1}}],[\"避免预热时间长\",{\"1\":{\"25\":1}}],[\"避免了\",{\"1\":{\"25\":1}}],[\"预热等各方面的开销\",{\"1\":{\"25\":1}}],[\"属于非法操作\",{\"1\":{\"49\":1}}],[\"属于静态编译\",{\"1\":{\"25\":1}}],[\"属于运行时编译\",{\"1\":{\"23\":1}}],[\"呢\",{\"0\":{\"25\":1},\"1\":{\"38\":1}}],[\"文件\",{\"1\":{\"24\":1,\"25\":1}}],[\"文档注释\",{\"1\":{\"29\":1}}],[\"文档注释工具\",{\"1\":{\"22\":1}}],[\"文档等\",{\"1\":{\"22\":1}}],[\"由于左移位数大于等于\",{\"1\":{\"33\":1}}],[\"由于\",{\"1\":{\"33\":2}}],[\"由于字节码并不针对一种特定的机器\",{\"1\":{\"23\":1}}],[\"由\",{\"1\":{\"24\":1,\"26\":1}}],[\"相信你已经知道了\",{\"1\":{\"66\":1}}],[\"相信你经常遇到同事这样的代码\",{\"1\":{\"12\":1}}],[\"相对于常规整数类型的运算来说\",{\"1\":{\"42\":1}}],[\"相比于包装类型\",{\"1\":{\"37\":1}}],[\"相当于\",{\"1\":{\"33\":2,\"63\":1}}],[\"相关阅读\",{\"1\":{\"24\":1}}],[\"已经缩小了这两种语言间的差距\",{\"1\":{\"24\":1}}],[\"执行速度比较慢\",{\"1\":{\"24\":1}}],[\"为形参\",{\"1\":{\"60\":1}}],[\"为实参\",{\"1\":{\"60\":1}}],[\"为你解答这个被很多人忽视的问题\",{\"1\":{\"26\":1}}],[\"为了更强有力地反驳\",{\"1\":{\"64\":1}}],[\"为了支持类似的动态特性\",{\"1\":{\"25\":1}}],[\"为了改善编译语言的效率而发展出的即时编译技术\",{\"1\":{\"24\":1}}],[\"为什么\",{\"0\":{\"62\":1,\"67\":1},\"1\":{\"67\":1}}],[\"为什么成员变量有默认值\",{\"1\":{\"44\":1}}],[\"为什么会出现这个问题呢\",{\"1\":{\"40\":1}}],[\"为什么浮点数运算的时候会有精度丢失的风险\",{\"0\":{\"40\":1}}],[\"为什么不全部使用\",{\"0\":{\"25\":1}}],[\"为什么说是几乎所有对象实例都存在于堆中呢\",{\"1\":{\"37\":1}}],[\"为什么说\",{\"0\":{\"24\":1},\"1\":{\"24\":1,\"62\":1}}],[\"为机器代码后再执行\",{\"1\":{\"24\":1}}],[\"开发者要学习的东西也少了\",{\"1\":{\"67\":1}}],[\"开发者的不满\",{\"1\":{\"26\":1}}],[\"开发文档\",{\"1\":{\"29\":1}}],[\"开发了\",{\"1\":{\"26\":1}}],[\"开发效率比较低\",{\"1\":{\"24\":1}}],[\"开源意味着你可以对它根据你自己的需要进行修改\",{\"1\":{\"26\":1}}],[\"开源项目\",{\"1\":{\"26\":1}}],[\"开源\",{\"1\":{\"26\":1}}],[\"开始之前\",{\"1\":{\"59\":1}}],[\"开始引入了默认方法\",{\"1\":{\"31\":1}}],[\"开始\",{\"1\":{\"18\":1,\"22\":2,\"55\":1}}],[\"会创建副本\",{\"1\":{\"61\":1,\"68\":1}}],[\"会优先匹配固定参数还是可变参数的方法呢\",{\"1\":{\"55\":1}}],[\"会直接创建新的对象\",{\"1\":{\"38\":1}}],[\"会对对象进行逃逸分析\",{\"1\":{\"37\":1}}],[\"会先求余\",{\"1\":{\"33\":2}}],[\"会提供免费版本\",{\"1\":{\"26\":1}}],[\"会通过编译器将源代码一次性翻译成可被该平台执行的机器码\",{\"1\":{\"24\":1}}],[\"会根据代码每次被执行的情况收集信息并相应地做出一些优化\",{\"1\":{\"23\":1}}],[\"因为固定参数的方法匹配度更高\",{\"1\":{\"55\":1}}],[\"因为根本不存在匹配\",{\"1\":{\"52\":1}}],[\"因为\",{\"1\":{\"24\":1,\"30\":1,\"63\":1}}],[\"因为比较重要\",{\"1\":{\"24\":1}}],[\"因此求余操作的基数也变成了\",{\"1\":{\"33\":1}}],[\"因此不能来进行移位操作\",{\"1\":{\"33\":1}}],[\"因此执行的次数越多\",{\"1\":{\"23\":1}}],[\"因此\",{\"1\":{\"22\":1,\"23\":1,\"26\":1,\"29\":1,\"38\":2,\"39\":1,\"50\":1,\"64\":1,\"65\":1}}],[\"因此必须调用操作系统的多线程功能来进行多线程程序设计\",{\"1\":{\"18\":1}}],[\"其余位表示数值部分\",{\"1\":{\"36\":1}}],[\"其中包括\",{\"1\":{\"26\":1}}],[\"其次\",{\"1\":{\"26\":1}}],[\"其实这个问题我们讲字节码的时候已经提到过\",{\"1\":{\"24\":1}}],[\"其会将字节码对应的机器码保存下来\",{\"1\":{\"23\":1}}],[\"热点代码\",{\"1\":{\"23\":1}}],[\"消耗大部分系统资源的只有那一小部分的代码\",{\"1\":{\"23\":1}}],[\"根据第一点\",{\"1\":{\"44\":1}}],[\"根据\",{\"1\":{\"26\":1}}],[\"根据维基百科介绍\",{\"1\":{\"24\":1}}],[\"根据二八定律\",{\"1\":{\"23\":1}}],[\"根据自己的需求\",{\"1\":{\"22\":1}}],[\"解析\",{\"1\":{\"63\":1,\"64\":1,\"65\":1}}],[\"解释器来解释执行\",{\"1\":{\"24\":1}}],[\"解释器的\",{\"1\":{\"23\":1}}],[\"解释型语言开发效率比较快\",{\"1\":{\"24\":1}}],[\"解释型语言会通过解释器一句一句的将代码解释\",{\"1\":{\"24\":1}}],[\"解释型\",{\"1\":{\"24\":1}}],[\"解耦才能算得上是优秀的系统\",{\"1\":{\"10\":1}}],[\"机器码的运行效率肯定是高于\",{\"1\":{\"23\":1}}],[\"机顶盒\",{\"1\":{\"19\":1}}],[\"有参的方法\",{\"1\":{\"60\":1}}],[\"有参数无返回值的方法\",{\"1\":{\"48\":1}}],[\"有相同的名字\",{\"1\":{\"52\":1}}],[\"有返回值有参数的方法\",{\"1\":{\"48\":1}}],[\"有返回值无参数的方法\",{\"1\":{\"48\":1}}],[\"有时候可能需要在循环的过程中\",{\"1\":{\"34\":1}}],[\"有一些标识符\",{\"1\":{\"30\":1}}],[\"有自动内存管理垃圾回收机制\",{\"1\":{\"27\":1}}],[\"有什么优点\",{\"0\":{\"25\":1}}],[\"有些方法和代码块是经常需要被调用的\",{\"1\":{\"23\":1}}],[\"有针对不同系统的特定实现\",{\"1\":{\"21\":1}}],[\"所谓可变长参数就是允许在调用方法时传入不定长度的参数\",{\"1\":{\"55\":1}}],[\"所修饰\",{\"1\":{\"44\":2}}],[\"所有整型包装类对象之间值的比较\",{\"1\":{\"37\":1,\"38\":1}}],[\"所有的关键字都是小写的\",{\"1\":{\"31\":1}}],[\"所有的订阅者们不能互相沟通\",{\"1\":{\"11\":1}}],[\"所需要编译的部分\",{\"1\":{\"23\":1}}],[\"所以才想着去设计一门新的语言\",{\"1\":{\"67\":1}}],[\"所以采用自动赋默认值\",{\"1\":{\"44\":1}}],[\"所以就会导致小数精度发生损失的情况\",{\"1\":{\"40\":1}}],[\"所以下面的代码左移\",{\"1\":{\"33\":1}}],[\"所以选择使用\",{\"1\":{\"25\":1}}],[\"所以我们这里再提一下\",{\"1\":{\"24\":1}}],[\"所以后面引进了\",{\"1\":{\"23\":1}}],[\"所以\",{\"1\":{\"23\":1,\"36\":1}}],[\"只是拷贝的实参\",{\"1\":{\"65\":1}}],[\"只是从\",{\"1\":{\"63\":1}}],[\"只有值传递呢\",{\"1\":{\"62\":1}}],[\"只有值传递\",{\"0\":{\"62\":1}}],[\"只有在对象实例化之后才存在\",{\"1\":{\"49\":1}}],[\"只允许访问静态成员\",{\"1\":{\"50\":1}}],[\"只能被截断\",{\"1\":{\"40\":1}}],[\"只能用于特定的地方\",{\"1\":{\"30\":1}}],[\"只能说\",{\"1\":{\"25\":1}}],[\"只需要创建一个与注释所言同一事物的函数即可\",{\"1\":{\"29\":1}}],[\"只支持方法重载\",{\"1\":{\"27\":1}}],[\"只添加了几个部分\",{\"1\":{\"26\":1}}],[\"只添加了一些小功能\",{\"1\":{\"26\":1}}],[\"只面向虚拟机\",{\"1\":{\"23\":1}}],[\"只要满足\",{\"1\":{\"21\":1}}],[\"即可免费领取个人原创的\",{\"1\":{\"55\":1}}],[\"即方法名相同\",{\"1\":{\"54\":1}}],[\"即实例成员变量和实例方法\",{\"1\":{\"50\":1}}],[\"即静态成员变量和静态方法\",{\"1\":{\"50\":1}}],[\"即使创建多个对象\",{\"1\":{\"45\":1}}],[\"即使不打算进行\",{\"1\":{\"22\":1}}],[\"即时编译器\",{\"1\":{\"25\":1}}],[\"即时编译器原理解析及实践\",{\"1\":{\"24\":1}}],[\"即扩展名为\",{\"1\":{\"23\":1}}],[\"中将实参传递给方法\",{\"1\":{\"68\":1}}],[\"中只有值传递\",{\"1\":{\"61\":1,\"66\":1}}],[\"中占两个字节\",{\"1\":{\"46\":1}}],[\"中有\",{\"1\":{\"36\":1}}],[\"中有三种移位运算符\",{\"1\":{\"33\":1}}],[\"中匹配不到任何情况时\",{\"1\":{\"31\":1}}],[\"中会以特殊颜色显示\",{\"1\":{\"31\":1}}],[\"中的几种基本数据类型了解么\",{\"0\":{\"36\":1}}],[\"中的\",{\"1\":{\"33\":1}}],[\"中的注释有三种\",{\"1\":{\"29\":1}}],[\"中的私有组件大多数也已经被捐赠给开源组织\",{\"1\":{\"26\":1}}],[\"中\",{\"1\":{\"23\":1,\"42\":1}}],[\"中介者模式由中介者和订阅者组成\",{\"1\":{\"11\":1}}],[\"中介者模式也和观察者类似\",{\"1\":{\"11\":1}}],[\"中介者模式\",{\"0\":{\"11\":1}}],[\"采用了惰性评估\",{\"1\":{\"23\":1}}],[\"采用字节码的好处是什么\",{\"0\":{\"23\":1}}],[\"采用不同的策略解决开发中的问题\",{\"1\":{\"12\":1}}],[\"容器化\",{\"1\":{\"22\":1}}],[\"模块化的\",{\"1\":{\"22\":1}}],[\"模块的自定义运行时镜像\",{\"1\":{\"22\":1}}],[\"创建了数值在\",{\"1\":{\"38\":1}}],[\"创建一个更小的\",{\"1\":{\"22\":1}}],[\"创建出只包含所依赖的\",{\"1\":{\"22\":1}}],[\"新特性概览这篇文章中\",{\"1\":{\"22\":1}}],[\"新特性也不是\",{\"1\":{\"18\":1}}],[\"下方的输出语句不会执行\",{\"1\":{\"48\":1}}],[\"下列语句的运行结果是什么\",{\"1\":{\"34\":1}}],[\"下面以\",{\"1\":{\"66\":1}}],[\"下面的代码的输出结果是\",{\"1\":{\"38\":1}}],[\"下面的例子中\",{\"1\":{\"9\":1}}],[\"下面我们来看一个问题\",{\"1\":{\"38\":1}}],[\"下面我通过收集到的一些资料\",{\"1\":{\"26\":1}}],[\"下面这个方法也没有返回值\",{\"1\":{\"48\":1}}],[\"下面这段话摘自\",{\"1\":{\"26\":1}}],[\"下面这张图是\",{\"1\":{\"23\":1}}],[\"下次可以直接使用\",{\"1\":{\"23\":1}}],[\"下载\",{\"1\":{\"22\":1}}],[\"不引入引用传递呢\",{\"0\":{\"67\":1},\"1\":{\"67\":1}}],[\"不会创建副本\",{\"1\":{\"61\":1}}],[\"不会造成精度丢失\",{\"1\":{\"41\":1}}],[\"不需要太多废话\",{\"1\":{\"62\":1}}],[\"不需要有确定的值\",{\"1\":{\"60\":1}}],[\"不需要程序员手动释放无用内存\",{\"1\":{\"27\":1}}],[\"不同的参数\",{\"1\":{\"52\":1}}],[\"不同的是\",{\"1\":{\"25\":1}}],[\"不允许访问实例成员\",{\"1\":{\"50\":1}}],[\"不断乘以\",{\"1\":{\"40\":1}}],[\"不建议这么使用\",{\"1\":{\"37\":1}}],[\"不溢出的情况下\",{\"1\":{\"33\":1}}],[\"不提供指针来直接访问内存\",{\"1\":{\"27\":1}}],[\"不提供\",{\"1\":{\"26\":1}}],[\"不仅能提供\",{\"1\":{\"25\":1}}],[\"不再提供单独的\",{\"1\":{\"22\":1}}],[\"不过\",{\"1\":{\"22\":1,\"23\":1,\"26\":3,\"50\":1,\"61\":1,\"64\":1}}],[\"一大\",{\"1\":{\"54\":1}}],[\"一定不能做更严格的限制\",{\"1\":{\"54\":1}}],[\"一定不能修改\",{\"1\":{\"54\":1}}],[\"一种情况例外\",{\"1\":{\"44\":1}}],[\"一种监控工具\",{\"1\":{\"26\":2}}],[\"一个特定值\",{\"1\":{\"34\":1}}],[\"一般建议使用\",{\"1\":{\"50\":1}}],[\"一般有两种用法\",{\"1\":{\"34\":1}}],[\"一般是每\",{\"1\":{\"26\":2}}],[\"一般情况下\",{\"1\":{\"24\":1}}],[\"一举两得\",{\"1\":{\"26\":1}}],[\"一些开源的第三方组件\",{\"1\":{\"26\":1}}],[\"一起发布的新命令行工具\",{\"1\":{\"22\":1}}],[\"一次编译\",{\"1\":{\"21\":1}}],[\"一次编写\",{\"1\":{\"18\":1}}],[\"随着方法的调用结束而消亡\",{\"1\":{\"44\":1}}],[\"随\",{\"1\":{\"22\":1}}],[\"随处可以运行\",{\"1\":{\"21\":1}}],[\"随处运行\",{\"1\":{\"18\":1}}],[\"9f\",{\"1\":{\"40\":1}}],[\"9e\",{\"1\":{\"36\":1}}],[\"9223372036854775807\",{\"1\":{\"36\":1}}],[\"9223372036854775808\",{\"1\":{\"36\":1,\"42\":1}}],[\"94\",{\"1\":{\"22\":2}}],[\"9\",{\"1\":{\"22\":3,\"25\":1,\"39\":1,\"41\":1}}],[\"从变量是否有默认值来看\",{\"1\":{\"44\":1}}],[\"从变量在内存中的生存时间上看\",{\"1\":{\"44\":1}}],[\"从变量在内存中的存储方式来看\",{\"1\":{\"44\":1}}],[\"从语法形式上看\",{\"1\":{\"44\":1}}],[\"从字节码中\",{\"1\":{\"39\":1}}],[\"从\",{\"1\":{\"22\":2,\"31\":1,\"55\":1}}],[\"从而更新\",{\"1\":{\"9\":2}}],[\"代码里使用\",{\"1\":{\"33\":1}}],[\"代码的注释不是越详细越好\",{\"1\":{\"29\":1}}],[\"代码\",{\"1\":{\"22\":1,\"63\":1,\"64\":1}}],[\"也会严重影响系统的性能\",{\"1\":{\"39\":1}}],[\"也会拿来用一下\",{\"1\":{\"26\":1}}],[\"也可以使用\",{\"1\":{\"50\":1}}],[\"也可以放在变量之后\",{\"1\":{\"32\":1}}],[\"也可以找一些文章来看看\",{\"1\":{\"25\":1}}],[\"也属于类\",{\"1\":{\"31\":1}}],[\"也要记下来\",{\"1\":{\"27\":1}}],[\"也是商业免费\",{\"1\":{\"26\":1}}],[\"也就有了\",{\"1\":{\"26\":1}}],[\"也就不能使用\",{\"1\":{\"25\":1}}],[\"也就是\",{\"1\":{\"32\":1}}],[\"也就是所谓的热点代码\",{\"1\":{\"23\":1}}],[\"也就是说这行代码等价于\",{\"1\":{\"38\":1}}],[\"也就是说左移\",{\"1\":{\"33\":1}}],[\"也就是说\",{\"1\":{\"22\":2,\"33\":1,\"45\":1,\"50\":1,\"63\":1,\"64\":1}}],[\"也就是说我们平时接触到的\",{\"1\":{\"21\":1}}],[\"也具有解释型语言的特征\",{\"1\":{\"24\":1}}],[\"也有可能需要安装\",{\"1\":{\"22\":1}}],[\"也需要\",{\"1\":{\"22\":1}}],[\"转换为二进制数的过程为\",{\"1\":{\"40\":1}}],[\"转换为\",{\"1\":{\"22\":1}}],[\"如何解决浮点数运算的精度丢失问题\",{\"0\":{\"41\":1}}],[\"如何选择\",{\"1\":{\"26\":1}}],[\"如附加文档或第三方字体\",{\"1\":{\"26\":1}}],[\"如图形光栅化器\",{\"1\":{\"26\":1}}],[\"如反射\",{\"1\":{\"25\":1}}],[\"如虚拟化\",{\"1\":{\"22\":1}}],[\"如\",{\"1\":{\"22\":1,\"25\":1,\"26\":1}}],[\"如果参数是引用类型\",{\"1\":{\"68\":1}}],[\"如果参数是基本类型的话\",{\"1\":{\"68\":1}}],[\"如果拿着银行卡去取钱\",{\"1\":{\"67\":1}}],[\"如果是用\",{\"1\":{\"66\":1}}],[\"如果方法的返回类型是\",{\"1\":{\"54\":1}}],[\"如果父类方法访问修饰符为\",{\"1\":{\"53\":1}}],[\"如果编译器找不到匹配的参数\",{\"1\":{\"52\":1}}],[\"如果多个方法\",{\"1\":{\"52\":1}}],[\"如果被\",{\"1\":{\"45\":1}}],[\"如果没有默认值会怎样\",{\"1\":{\"44\":1}}],[\"如果没有使用\",{\"1\":{\"44\":1}}],[\"如果成员变量是使用\",{\"1\":{\"44\":1}}],[\"如果超过这个范围就会有数值溢出的风险\",{\"1\":{\"42\":1}}],[\"如果超出对应范围仍然会去创建新的对象\",{\"1\":{\"38\":1}}],[\"如果频繁拆装箱的话\",{\"1\":{\"39\":1}}],[\"如果发现某一个对象并没有逃逸到方法外部\",{\"1\":{\"37\":1}}],[\"如果我们再加\",{\"1\":{\"36\":1}}],[\"如果我们要表示最大的正数\",{\"1\":{\"36\":1}}],[\"如果我们想要开一家店\",{\"1\":{\"30\":1}}],[\"如果移位的位数超过数值所占有的位数会怎样\",{\"1\":{\"33\":1}}],[\"如果一个方法前没有任何修饰符\",{\"1\":{\"31\":1}}],[\"如果代码量比较少\",{\"1\":{\"29\":1}}],[\"如果这个时候\",{\"1\":{\"26\":1}}],[\"如果全部使用\",{\"1\":{\"25\":1}}],[\"如果只使用\",{\"1\":{\"25\":1}}],[\"如果觉得官方文档看着比较难理解的话\",{\"1\":{\"25\":1}}],[\"如果需要进行\",{\"1\":{\"22\":1}}],[\"如果observer的update方法里是跟新对应的dom\",{\"1\":{\"9\":1}}],[\"就比如下面的这个\",{\"1\":{\"55\":1}}],[\"就比如说十进制下的\",{\"1\":{\"40\":1}}],[\"就会产生编译时错误\",{\"1\":{\"52\":1}}],[\"就会导致溢出\",{\"1\":{\"36\":1}}],[\"就没办法精确转换成二进制小数\",{\"1\":{\"40\":1}}],[\"就存放在堆中\",{\"1\":{\"37\":1}}],[\"就是我们日常生活中的关键字\",{\"1\":{\"30\":1}}],[\"就叫标识符\",{\"1\":{\"30\":1}}],[\"就算没学过\",{\"1\":{\"27\":1}}],[\"就不需要注释\",{\"1\":{\"29\":1}}],[\"就不需要区分\",{\"1\":{\"22\":1}}],[\"就不得不提\",{\"1\":{\"25\":1}}],[\"就需要安装\",{\"1\":{\"22\":1}}],[\"就很容易实现跨平台了\",{\"1\":{\"18\":1}}],[\"仅包含\",{\"1\":{\"22\":1}}],[\"仅仅是是\",{\"1\":{\"21\":1}}],[\"程序设计语言将实参传递给方法\",{\"1\":{\"61\":1}}],[\"程序读取该值运行会出现意外\",{\"1\":{\"44\":1}}],[\"程序比用其他大多数语言编写的程序更具可移植性的原因之一\",{\"1\":{\"36\":1}}],[\"程序控制\",{\"1\":{\"31\":1}}],[\"程序内存更加安全\",{\"1\":{\"27\":1}}],[\"程序的安全性\",{\"1\":{\"25\":1}}],[\"程序的启动速度\",{\"1\":{\"25\":1}}],[\"程序的开发套件\",{\"1\":{\"22\":1}}],[\"程序要经过先编译\",{\"1\":{\"24\":1}}],[\"程序从源代码到运行的过程如下图所示\",{\"1\":{\"23\":1}}],[\"程序无须重新编译便可在多种不同操作系统的计算机上运行\",{\"1\":{\"23\":1}}],[\"程序运行时相对来说还是高效的\",{\"1\":{\"23\":1}}],[\"程序\",{\"1\":{\"22\":1}}],[\"程序所需的所有内容的集合\",{\"1\":{\"22\":1}}],[\"反编译工具\",{\"1\":{\"22\":1}}],[\"基本数值类型都有一个表达范围\",{\"1\":{\"42\":1}}],[\"基本数据类型存放在栈中是一个常见的误区\",{\"1\":{\"37\":1}}],[\"基本数据类型占用的空间往往非常小\",{\"1\":{\"37\":1}}],[\"基本数据类型的包装类型的大部分都用到了缓存机制来提升性能\",{\"1\":{\"38\":1}}],[\"基本数据类型的成员变量如果没有被\",{\"1\":{\"37\":1}}],[\"基本数据类型的成员变量\",{\"1\":{\"37\":1}}],[\"基本数据类型的局部变量存放在\",{\"1\":{\"37\":1}}],[\"基本数据类型\",{\"0\":{\"35\":1}}],[\"基本类型和包装类型的区别\",{\"0\":{\"37\":1}}],[\"基本类型\",{\"1\":{\"31\":1,\"36\":1,\"37\":1}}],[\"基本语法\",{\"0\":{\"28\":1}}],[\"基本功\",{\"1\":{\"24\":1}}],[\"基础知识第十版第四章\",{\"1\":{\"69\":1}}],[\"基础类库\",{\"1\":{\"22\":1}}],[\"基础概念与常识\",{\"0\":{\"17\":1}}],[\"基于以上这些原因\",{\"1\":{\"26\":1}}],[\"基于静态编译构建微服务应用\",{\"1\":{\"25\":1}}],[\"基于\",{\"1\":{\"22\":1,\"26\":1}}],[\"以下为个人观点看法\",{\"1\":{\"67\":1}}],[\"以下内容摘录自\",{\"1\":{\"54\":1}}],[\"以及一些零碎的东西\",{\"1\":{\"26\":1}}],[\"以及一些闭源的第三方组件\",{\"1\":{\"26\":1}}],[\"以及一些其他工具比如\",{\"1\":{\"22\":1}}],[\"以及\",{\"1\":{\"25\":1}}],[\"以至于\",{\"1\":{\"18\":1}}],[\"源码的编译器\",{\"1\":{\"22\":1}}],[\"key\",{\"1\":{\"33\":4}}],[\"keywords\",{\"1\":{\"31\":1}}],[\"kit\",{\"1\":{\"22\":1}}],[\"kw=thread\",{\"1\":{\"18\":1}}],[\"并非来自于\",{\"1\":{\"67\":1}}],[\"并不会影响到实参\",{\"1\":{\"65\":1}}],[\"并不会影响到\",{\"1\":{\"63\":1}}],[\"并不是的\",{\"1\":{\"64\":1}}],[\"并不是完全开源的\",{\"1\":{\"26\":1}}],[\"并不是只有一种\",{\"1\":{\"21\":1}}],[\"并没有实现缓存机制\",{\"1\":{\"38\":1}}],[\"并且我要和你们自己搞的\",{\"1\":{\"26\":1}}],[\"并且刚开始的几个版本\",{\"1\":{\"26\":1}}],[\"并且\",{\"1\":{\"21\":1,\"22\":1,\"25\":1,\"37\":1}}],[\"维基百科上就有常见\",{\"1\":{\"21\":1}}],[\"维护一系列的观察者\",{\"1\":{\"9\":1}}],[\"等修饰符所修饰\",{\"1\":{\"44\":1}}],[\"等价于\",{\"1\":{\"39\":2}}],[\"等非\",{\"1\":{\"25\":1}}],[\"等语言就是静态编译\",{\"1\":{\"25\":1}}],[\"等语言还是有一定差距的\",{\"1\":{\"23\":1}}],[\"等工具\",{\"1\":{\"22\":1,\"26\":1}}],[\"等等\",{\"1\":{\"22\":1,\"24\":2}}],[\"等\",{\"1\":{\"21\":1,\"25\":1}}],[\"zing\",{\"1\":{\"21\":1}}],[\"外部样子不能改变\",{\"1\":{\"54\":1}}],[\"外\",{\"1\":{\"21\":1}}],[\"high\",{\"1\":{\"38\":3}}],[\"hero\",{\"1\":{\"54\":6}}],[\"helloworld\",{\"1\":{\"52\":1}}],[\"hello\",{\"1\":{\"36\":1,\"44\":2,\"46\":1,\"49\":1,\"60\":4}}],[\"heihei\",{\"1\":{\"34\":1}}],[\"haha\",{\"1\":{\"34\":2}}],[\"hashcode\",{\"1\":{\"33\":2}}],[\"hash\",{\"1\":{\"33\":2}}],[\"hashmap\",{\"1\":{\"33\":1}}],[\"h\",{\"1\":{\"33\":3,\"36\":1,\"38\":1}}],[\"html\",{\"1\":{\"31\":1}}],[\"https\",{\"1\":{\"25\":1,\"26\":2,\"31\":1,\"56\":4}}],[\"http\",{\"1\":{\"18\":1}}],[\"hollis\",{\"1\":{\"69\":1}}],[\"hourly\",{\"1\":{\"29\":1}}],[\"hotspot\",{\"1\":{\"21\":2,\"23\":1,\"37\":1}}],[\"组织或者个人都可以开发自己的专属\",{\"1\":{\"21\":1}}],[\"每个公司\",{\"1\":{\"21\":1}}],[\"每个订阅者的唯一标识\",{\"1\":{\"10\":1}}],[\"规范的一种实现而已\",{\"1\":{\"21\":1}}],[\"规范\",{\"1\":{\"21\":2}}],[\"实际参数\",{\"1\":{\"60\":1}}],[\"实际上好的代码本身就是注释\",{\"1\":{\"29\":1}}],[\"实际上\",{\"1\":{\"18\":1,\"64\":1}}],[\"实参\",{\"0\":{\"60\":1},\"1\":{\"59\":1,\"60\":1,\"64\":1}}],[\"实现的\",{\"1\":{\"26\":1}}],[\"实现是\",{\"1\":{\"21\":1}}],[\"虚拟机引入了\",{\"1\":{\"37\":1}}],[\"虚拟机的堆中\",{\"1\":{\"37\":1}}],[\"虚拟机栈中的局部变量表中\",{\"1\":{\"37\":1}}],[\"虚拟机之上的编程语言\",{\"1\":{\"21\":1}}],[\"虚拟机\",{\"1\":{\"21\":1,\"22\":1}}],[\"虚拟机实现平台无关性\",{\"1\":{\"18\":1}}],[\"冰箱\",{\"1\":{\"19\":1}}],[\"还可以帮助我们理解源码中涉及到移位运算符的代码\",{\"1\":{\"33\":1}}],[\"还属于访问控制\",{\"1\":{\"31\":1}}],[\"还是\",{\"1\":{\"38\":1}}],[\"还是有存在的必要的\",{\"1\":{\"26\":1}}],[\"还是上面的例子\",{\"1\":{\"10\":1}}],[\"还会相比于\",{\"1\":{\"26\":1}}],[\"还能提供\",{\"1\":{\"25\":1}}],[\"还能减少内存占用和增强\",{\"1\":{\"25\":1}}],[\"还有\",{\"1\":{\"21\":1}}],[\"还有一个\",{\"1\":{\"19\":1}}],[\"和基本数据类型\",{\"1\":{\"54\":1}}],[\"和>>>转换成的指令码运行起来会更高效些\",{\"1\":{\"33\":1}}],[\"和自减运算符\",{\"1\":{\"32\":1}}],[\"和其他\",{\"1\":{\"25\":1}}],[\"和\",{\"0\":{\"22\":1,\"27\":1,\"34\":1},\"1\":{\"19\":1,\"22\":1,\"23\":1,\"25\":1,\"26\":5,\"27\":2,\"31\":1,\"32\":1,\"65\":4}}],[\"的回答\",{\"1\":{\"69\":1}}],[\"的时候就遵循了简单易用的原则\",{\"1\":{\"67\":1}}],[\"的许多弊端\",{\"1\":{\"67\":1}}],[\"的话还是值传递哦\",{\"1\":{\"66\":1}}],[\"的代码为例\",{\"1\":{\"66\":1}}],[\"的代码之间有什么区别\",{\"1\":{\"26\":1}}],[\"的互换只是拷贝的两个地址的互换罢了\",{\"1\":{\"65\":1}}],[\"的地址\",{\"1\":{\"64\":1,\"65\":1}}],[\"的副本\",{\"1\":{\"63\":1}}],[\"的复制过来的\",{\"1\":{\"63\":1}}],[\"的移位操作符\",{\"1\":{\"56\":1}}],[\"的可变参数编译后实际会被转换成一个数组\",{\"1\":{\"55\":1}}],[\"的可视化监控⼯具\",{\"1\":{\"22\":1}}],[\"的构造方法\",{\"1\":{\"52\":1}}],[\"的方式是\",{\"1\":{\"68\":1}}],[\"的方式分为两种\",{\"1\":{\"61\":1}}],[\"的方式来调用静态方法\",{\"1\":{\"50\":2}}],[\"的方式\",{\"1\":{\"50\":2}}],[\"的相关知识\",{\"1\":{\"49\":1}}],[\"的相应类型的缓存数据\",{\"1\":{\"38\":1}}],[\"的详细介绍\",{\"1\":{\"41\":1}}],[\"的每种基本类型所占存储空间的大小不会像其他大多数语言那样随机器硬件架构的变化而变化\",{\"1\":{\"36\":1}}],[\"的值进行交换\",{\"1\":{\"63\":1}}],[\"的值\",{\"1\":{\"32\":1,\"63\":1}}],[\"的类不可以多继承\",{\"1\":{\"27\":1}}],[\"的类是单继承的\",{\"1\":{\"27\":1}}],[\"的发行版\",{\"1\":{\"26\":1}}],[\"的功能基本一致\",{\"1\":{\"26\":1}}],[\"的区别是什么\",{\"0\":{\"34\":1}}],[\"的区别\",{\"0\":{\"27\":1},\"1\":{\"26\":1}}],[\"的所有部分\",{\"1\":{\"26\":1}}],[\"的实现\",{\"1\":{\"26\":1}}],[\"的\",{\"1\":{\"26\":2}}],[\"的一些动态特性\",{\"1\":{\"25\":1}}],[\"的官方文档\",{\"1\":{\"25\":1}}],[\"的主要优势在于具备更高的极限处理能力\",{\"1\":{\"25\":1}}],[\"的主要优势在于启动时间\",{\"1\":{\"25\":1}}],[\"的大致结构模型\",{\"1\":{\"23\":2}}],[\"的做法\",{\"1\":{\"23\":1}}],[\"的文件\",{\"1\":{\"23\":1}}],[\"的关系了\",{\"1\":{\"22\":1}}],[\"的关键所在\",{\"1\":{\"21\":1}}],[\"的对比\",{\"1\":{\"21\":1}}],[\"的微型版本\",{\"1\":{\"19\":1}}],[\"的高级版本\",{\"1\":{\"19\":1}}],[\"的基础版本\",{\"1\":{\"19\":1}}],[\"的基础上添加了一些特有的功能和工具\",{\"1\":{\"26\":1}}],[\"的基础上搞了一个\",{\"1\":{\"26\":1}}],[\"的基础上\",{\"1\":{\"19\":1}}],[\"是不是很可怕\",{\"1\":{\"67\":1}}],[\"是不开源的\",{\"1\":{\"26\":1}}],[\"是没有引用传递的\",{\"1\":{\"66\":1}}],[\"是子类对父类的允许访问的方法的实现过程进行重新编写\",{\"1\":{\"53\":1}}],[\"是指我们获取到的某个方法体中的代码执行后产生的结果\",{\"1\":{\"48\":1}}],[\"是我们程序员写给自己看的\",{\"1\":{\"29\":1}}],[\"是商业免费的\",{\"1\":{\"26\":1}}],[\"是开源的\",{\"1\":{\"26\":1}}],[\"是完全免费的\",{\"1\":{\"26\":1}}],[\"是否免费\",{\"1\":{\"26\":1}}],[\"是否开源\",{\"1\":{\"26\":1}}],[\"是一个参考模型并且是完全开源的\",{\"1\":{\"26\":1}}],[\"是一种高性能的\",{\"1\":{\"25\":1}}],[\"是一种对象子类继承的替代方案\",{\"1\":{\"13\":1}}],[\"是基于\",{\"1\":{\"26\":2}}],[\"是十分接近的\",{\"1\":{\"26\":1}}],[\"是编译与解释共存的语言\",{\"1\":{\"23\":1}}],[\"是非常重要的\",{\"1\":{\"22\":1}}],[\"是提供给开发者使用\",{\"1\":{\"22\":1}}],[\"是运行\",{\"1\":{\"21\":1}}],[\"是\",{\"1\":{\"19\":3,\"22\":2,\"26\":1}}],[\"简单总结一下\",{\"1\":{\"26\":1}}],[\"简单来说\",{\"1\":{\"19\":1,\"30\":2}}],[\"简单易学\",{\"1\":{\"18\":1}}],[\"例如staticvariableexample\",{\"1\":{\"45\":1}}],[\"例如部署代码\",{\"1\":{\"26\":1}}],[\"例如手机\",{\"1\":{\"19\":1}}],[\"例如\",{\"1\":{\"19\":1,\"32\":1}}],[\"健壮\",{\"1\":{\"19\":1}}],[\"包装类的valueof\",{\"1\":{\"39\":1}}],[\"包装类型的缓存机制了解么\",{\"0\":{\"38\":1}}],[\"包装类型属于对象类型\",{\"1\":{\"37\":1}}],[\"包装类型可用于泛型\",{\"1\":{\"37\":1}}],[\"包装类型\",{\"1\":{\"37\":1}}],[\"包相关\",{\"1\":{\"31\":1}}],[\"包管理器上默认安装的\",{\"1\":{\"26\":1}}],[\"包含\",{\"1\":{\"22\":1}}],[\"包含了支持企业级应用程序开发和部署的标准和规范\",{\"1\":{\"19\":1}}],[\"包教包会\",{\"1\":{\"7\":1}}],[\"它和\",{\"1\":{\"64\":1}}],[\"它通过用各个方法给出的参数类型与特定方法调用所使用的值类型进行匹配来挑选出相应的方法\",{\"1\":{\"52\":1}}],[\"它可以被类的所有实例共享\",{\"1\":{\"45\":1}}],[\"它可以运行\",{\"1\":{\"25\":1}}],[\"它随着对象的创建而存在\",{\"1\":{\"44\":1}}],[\"它依赖于\",{\"1\":{\"36\":1}}],[\"它们都共享同一份静态变量\",{\"1\":{\"45\":1}}],[\"它们都会给出相同的结果\",{\"1\":{\"21\":1}}],[\"它们还是有挺多不相同的地方\",{\"1\":{\"27\":1}}],[\"它像编译语言一样\",{\"1\":{\"24\":1}}],[\"它的速度就越快\",{\"1\":{\"23\":1}}],[\"它不面向任何特定的处理器\",{\"1\":{\"23\":1}}],[\"它不会修改底层代码\",{\"1\":{\"13\":1}}],[\"它是运行已编译\",{\"1\":{\"22\":1}}],[\"它是功能齐全的\",{\"1\":{\"22\":1}}],[\"它包含了\",{\"1\":{\"22\":1}}],[\"它包含了支持\",{\"1\":{\"19\":1}}],[\"编写的程序需要先经过编译步骤\",{\"1\":{\"24\":1}}],[\"编程思想\",{\"1\":{\"36\":1}}],[\"编程工作\",{\"1\":{\"22\":1}}],[\"编程语言的基础\",{\"1\":{\"19\":1}}],[\"编译期\",{\"1\":{\"54\":1}}],[\"编译无法支持\",{\"1\":{\"25\":1}}],[\"编译\",{\"1\":{\"25\":3}}],[\"编译后的代码不容易被反编译和修改\",{\"1\":{\"25\":1}}],[\"编译语言的执行速度比较快\",{\"1\":{\"24\":1}}],[\"编译型语言和解释型语言\",{\"1\":{\"24\":1}}],[\"编译型语言\",{\"1\":{\"24\":1}}],[\"编译型\",{\"1\":{\"24\":1}}],[\"编译器必须挑选出具体执行哪个方法\",{\"1\":{\"52\":1}}],[\"编译器在对short\",{\"1\":{\"33\":1}}],[\"编译器在编译代码之前会把代码中的所有注释抹掉\",{\"1\":{\"29\":1}}],[\"编译器完成第一次编译后\",{\"1\":{\"23\":1}}],[\"编译器\",{\"1\":{\"23\":1}}],[\"编译器等技术的优化\",{\"1\":{\"18\":1}}],[\"编译与解释并存\",{\"0\":{\"24\":1},\"1\":{\"18\":1,\"24\":1}}],[\"平台企业版\",{\"1\":{\"19\":1}}],[\"平台标准版\",{\"1\":{\"19\":1}}],[\"平台无关性\",{\"1\":{\"18\":1}}],[\"强大的生态才是\",{\"1\":{\"18\":1}}],[\"目的是使用相同的字节码\",{\"1\":{\"21\":1}}],[\"目前市面上虚拟化技术已经非常成熟\",{\"1\":{\"18\":1}}],[\"目标\",{\"1\":{\"9\":1}}],[\"各种\",{\"1\":{\"18\":1}}],[\"跨平台已经不是\",{\"1\":{\"18\":1}}],[\"依然有很多人觉得跨平台是\",{\"1\":{\"18\":1}}],[\"流传了好多年\",{\"1\":{\"18\":1}}],[\"真心经典\",{\"1\":{\"18\":1}}],[\"rhino\",{\"1\":{\"26\":1}}],[\"rust\",{\"1\":{\"23\":1,\"24\":1,\"25\":1}}],[\"runtime\",{\"1\":{\"22\":2}}],[\"run\",{\"1\":{\"18\":1}}],[\"resolution\",{\"1\":{\"52\":1}}],[\"release\",{\"1\":{\"26\":1}}],[\"recorder\",{\"1\":{\"26\":1}}],[\"reference\",{\"1\":{\"18\":1}}],[\"return\",{\"0\":{\"34\":1},\"1\":{\"8\":3,\"10\":4,\"11\":2,\"13\":2,\"31\":1,\"33\":1,\"34\":7,\"38\":5,\"39\":2,\"48\":4,\"54\":5}}],[\"拓展一下\",{\"1\":{\"18\":1,\"26\":1}}],[\"🌈\",{\"1\":{\"18\":1,\"26\":1}}],[\"with\",{\"1\":{\"69\":1}}],[\"windows\",{\"1\":{\"18\":1,\"21\":1}}],[\"what\",{\"1\":{\"56\":2}}],[\"while\",{\"1\":{\"31\":1}}],[\"world\",{\"1\":{\"44\":1,\"46\":1,\"49\":1}}],[\"webstart\",{\"1\":{\"26\":1}}],[\"web\",{\"1\":{\"19\":2}}],[\"write\",{\"1\":{\"18\":1}}],[\"www\",{\"1\":{\"18\":1,\"25\":1,\"56\":1}}],[\"参考\",{\"0\":{\"56\":1,\"69\":1}}],[\"参考链接\",{\"1\":{\"18\":1}}],[\"参数在程序语言中分为\",{\"1\":{\"60\":1}}],[\"参数\",{\"1\":{\"60\":1}}],[\"参数列表\",{\"1\":{\"54\":1}}],[\"参数列表必须相同\",{\"1\":{\"53\":1}}],[\"参数类型不同\",{\"1\":{\"52\":1}}],[\"参见\",{\"1\":{\"18\":1}}],[\"都不会影响到原件本身\",{\"1\":{\"63\":1}}],[\"都会将其转换为int类型再操作\",{\"1\":{\"33\":1}}],[\"都会对应的观察者会接受到变化\",{\"1\":{\"9\":1}}],[\"都支持封装\",{\"1\":{\"27\":1}}],[\"都是通过\",{\"1\":{\"41\":1}}],[\"都是面向对象的语言\",{\"1\":{\"27\":1}}],[\"都是同样的\",{\"1\":{\"22\":1}}],[\"都用到了这些特性\",{\"1\":{\"25\":1}}],[\"都可以使用std\",{\"1\":{\"18\":1}}],[\"在他设计\",{\"1\":{\"67\":1}}],[\"在设计之初就看到了\",{\"1\":{\"67\":1}}],[\"在外部调用静态方法时\",{\"1\":{\"50\":1}}],[\"在这个计算过程中\",{\"1\":{\"40\":1}}],[\"在这一步\",{\"1\":{\"23\":1}}],[\"在循环结构中\",{\"1\":{\"34\":1}}],[\"在二进制中的表现比较特殊\",{\"1\":{\"33\":1}}],[\"在写代码的过程中\",{\"1\":{\"32\":1}}],[\"在写程序的时候随手加上注释是一个非常好的习惯\",{\"1\":{\"29\":1}}],[\"在访问控制中\",{\"1\":{\"31\":1}}],[\"在类的非静态成员不存在的时候静态方法就已经存在了\",{\"1\":{\"49\":1}}],[\"在类加载的时候就会分配内存\",{\"1\":{\"49\":1}}],[\"在类\",{\"1\":{\"31\":1}}],[\"在程序控制中\",{\"1\":{\"31\":1}}],[\"在我们的日常生活中\",{\"1\":{\"30\":1}}],[\"在我们编写程序的时候\",{\"1\":{\"30\":1}}],[\"在我们编写代码的时候\",{\"1\":{\"29\":1}}],[\"在我看来\",{\"1\":{\"18\":1}}],[\"在一定程度上解决了传统解释型语言执行效率低的问题\",{\"1\":{\"23\":1}}],[\"在引入了模块系统之后\",{\"1\":{\"22\":1}}],[\"在\",{\"1\":{\"18\":1,\"22\":1,\"23\":1,\"26\":2,\"31\":1,\"33\":1,\"42\":1,\"46\":1,\"61\":1,\"63\":1,\"66\":1}}],[\"🐛\",{\"1\":{\"18\":1}}],[\"支持定义可变长参数\",{\"1\":{\"55\":1}}],[\"支持多重继承\",{\"1\":{\"27\":1}}],[\"支持多线程\",{\"1\":{\"18\":1}}],[\"支持商用\",{\"1\":{\"26\":1}}],[\"支持网络编程并且很方便\",{\"1\":{\"18\":1}}],[\"juejin\",{\"1\":{\"56\":1}}],[\"just\",{\"1\":{\"18\":1,\"23\":1}}],[\"jfr\",{\"1\":{\"26\":1}}],[\"jni\",{\"1\":{\"25\":1}}],[\"jit\",{\"1\":{\"23\":6,\"25\":8,\"37\":1}}],[\"jlink\",{\"1\":{\"22\":3}}],[\"jmc\",{\"1\":{\"26\":1}}],[\"jmx\",{\"1\":{\"22\":1}}],[\"jms\",{\"1\":{\"19\":1}}],[\"jconsole\",{\"1\":{\"22\":2}}],[\"jrockit\",{\"1\":{\"21\":1}}],[\"jre\",{\"0\":{\"20\":1,\"22\":1},\"1\":{\"22\":8,\"23\":2,\"56\":2}}],[\"j9\",{\"1\":{\"21\":1}}],[\"jvm\",{\"0\":{\"20\":1,\"21\":1},\"1\":{\"21\":10,\"22\":1,\"23\":7,\"25\":2,\"36\":1,\"49\":1}}],[\"jta\",{\"1\":{\"19\":1}}],[\"jpa\",{\"1\":{\"19\":1}}],[\"jdb\",{\"1\":{\"22\":2}}],[\"jdbc\",{\"1\":{\"19\":1}}],[\"jdk1\",{\"1\":{\"33\":1}}],[\"jdk17\",{\"1\":{\"26\":1}}],[\"jdk8\",{\"1\":{\"31\":1}}],[\"jdk8u221\",{\"1\":{\"26\":1}}],[\"jdk\",{\"0\":{\"20\":1,\"22\":1,\"26\":1},\"1\":{\"18\":1,\"21\":1,\"22\":12,\"23\":2,\"25\":3,\"26\":31,\"33\":1,\"56\":4}}],[\"jsp\",{\"1\":{\"19\":1,\"22\":1}}],[\"james\",{\"1\":{\"67\":1,\"69\":1}}],[\"java基础\",{\"2\":{\"58\":1,\"71\":1}}],[\"java基础常见面试题总结\",{\"0\":{\"16\":1}}],[\"javaguide\",{\"1\":{\"55\":1}}],[\"java5\",{\"1\":{\"55\":1}}],[\"javase\",{\"1\":{\"31\":1}}],[\"javascript\",{\"1\":{\"24\":1,\"25\":1},\"2\":{\"15\":1}}],[\"javascript的策略模式可以通过对象来巧妙实现\",{\"1\":{\"12\":1}}],[\"java11\",{\"1\":{\"26\":1}}],[\"java8\",{\"1\":{\"26\":1}}],[\"java与llvm是这种技术的代表产物\",{\"1\":{\"24\":1}}],[\"java程序转变为机器代码的过程\",{\"1\":{\"23\":2}}],[\"javap\",{\"1\":{\"22\":2}}],[\"javadoc\",{\"1\":{\"22\":2}}],[\"javac\",{\"1\":{\"22\":2,\"44\":1}}],[\"javamail\",{\"1\":{\"19\":1}}],[\"java\",{\"0\":{\"18\":1,\"19\":2,\"24\":1,\"27\":1,\"31\":1,\"36\":1,\"59\":1,\"62\":1,\"67\":1,\"74\":1},\"1\":{\"18\":7,\"19\":25,\"21\":6,\"22\":26,\"23\":7,\"24\":6,\"25\":5,\"26\":10,\"27\":8,\"29\":3,\"30\":1,\"31\":1,\"32\":1,\"33\":3,\"36\":5,\"37\":2,\"38\":1,\"39\":2,\"42\":1,\"46\":1,\"52\":2,\"54\":1,\"55\":3,\"56\":1,\"61\":1,\"62\":1,\"64\":2,\"66\":1,\"67\":5,\"68\":1,\"69\":4},\"2\":{\"57\":1,\"70\":1}}],[\"jauery的实现了标准的发布订阅模式\",{\"1\":{\"10\":1}}],[\"限制程序直接访问操作系统资源\",{\"1\":{\"18\":1}}],[\"安全性\",{\"1\":{\"18\":1}}],[\"具备异常处理和自动内存管理机制\",{\"1\":{\"18\":1}}],[\"具体的对应关系\",{\"1\":{\"9\":2}}],[\"具体的目标\",{\"1\":{\"9\":1}}],[\"具体的观察者\",{\"1\":{\"9\":1}}],[\"具体观察者\",{\"1\":{\"9\":1}}],[\"具体目标\",{\"1\":{\"9\":1}}],[\"可变参数只能作为函数的最后一个参数\",{\"1\":{\"55\":1}}],[\"可修改\",{\"1\":{\"54\":3}}],[\"可能在看这个问题之前很多人和我一样并没有接触和使用过\",{\"1\":{\"26\":1}}],[\"可伸缩和安全的服务端\",{\"1\":{\"19\":1}}],[\"可移植\",{\"1\":{\"19\":1}}],[\"可靠性\",{\"1\":{\"18\":1}}],[\"可以影响到实参的值\",{\"1\":{\"66\":1}}],[\"可以降低限制\",{\"1\":{\"54\":1}}],[\"可以降低请求的最大延迟\",{\"1\":{\"25\":1}}],[\"可以通过类名直接访问\",{\"1\":{\"49\":1}}],[\"可以参加表达式运算\",{\"1\":{\"46\":1}}],[\"可以直接报错\",{\"1\":{\"44\":1}}],[\"可以实现对浮点数的运算\",{\"1\":{\"41\":1}}],[\"可以看看我写的这篇文章\",{\"1\":{\"41\":1}}],[\"可以看到\",{\"1\":{\"36\":1,\"66\":1}}],[\"可以看出\",{\"1\":{\"25\":1}}],[\"可以自己私下用\",{\"1\":{\"26\":1}}],[\"可以去看看\",{\"1\":{\"25\":1}}],[\"可以提高\",{\"1\":{\"25\":1}}],[\"可以理解的代码就叫做字节码\",{\"1\":{\"23\":1}}],[\"可以用\",{\"1\":{\"22\":1}}],[\"可以用于\",{\"1\":{\"22\":1}}],[\"可以用于构建分布式\",{\"1\":{\"19\":1}}],[\"可以用于构建桌面应用程序或简单的服务器应用程序\",{\"1\":{\"19\":1}}],[\"可以使用\",{\"1\":{\"26\":1,\"31\":2,\"50\":1}}],[\"可以使用策略模式\",{\"1\":{\"12\":1}}],[\"可以使用$emit方法和$on\",{\"1\":{\"10\":1}}],[\"可以随时取消订阅\",{\"1\":{\"10\":1}}],[\"可以很好的解决观察者模式耦合问题\",{\"1\":{\"10\":1}}],[\"而不只是构造器方法\",{\"1\":{\"52\":1}}],[\"而不是\",{\"1\":{\"26\":1,\"39\":1}}],[\"而不是不管什么应用\",{\"1\":{\"22\":1}}],[\"而实例方法不存在这个限制\",{\"1\":{\"50\":1}}],[\"而实例方法只有后面这种方式\",{\"1\":{\"50\":1}}],[\"而非静态成员属于实例对象\",{\"1\":{\"49\":1}}],[\"而成员变量可能是运行时赋值\",{\"1\":{\"44\":1}}],[\"而对象引用作为参数就不一样\",{\"1\":{\"63\":1}}],[\"而对象存在于堆内存\",{\"1\":{\"44\":1}}],[\"而对于某些需要使用\",{\"1\":{\"22\":1}}],[\"而局部变量不行\",{\"1\":{\"44\":1}}],[\"而局部变量不能被访问控制修饰符及\",{\"1\":{\"44\":1}}],[\"而局部变量则不会自动赋值\",{\"1\":{\"44\":1}}],[\"而局部变量随着方法的调用而自动生成\",{\"1\":{\"44\":1}}],[\"而局部变量是在代码块或方法中定义的变量或是方法的参数\",{\"1\":{\"44\":1}}],[\"而integer\",{\"1\":{\"38\":1}}],[\"而避免堆上分配内存\",{\"1\":{\"37\":1}}],[\"而基本类型有默认值且不是\",{\"1\":{\"37\":1}}],[\"而基本类型不可以\",{\"1\":{\"37\":1}}],[\"而言\",{\"1\":{\"26\":1}}],[\"而这种技术大致原理是运行时直接在内存中生成并加载修改后的字节码文件也就是\",{\"1\":{\"25\":1}}],[\"而这也就是\",{\"1\":{\"23\":1}}],[\"而我们知道\",{\"1\":{\"23\":1}}],[\"而且计算机在表示一个数字时\",{\"1\":{\"40\":1}}],[\"而且\",{\"1\":{\"23\":2}}],[\"而\",{\"1\":{\"18\":1,\"22\":1,\"23\":1,\"26\":5,\"30\":1}}],[\"封装\",{\"1\":{\"18\":1}}],[\"father\",{\"1\":{\"69\":1}}],[\"false\",{\"1\":{\"31\":1,\"34\":1,\"36\":2,\"38\":6,\"40\":1}}],[\"f4\",{\"1\":{\"48\":1}}],[\"f3\",{\"1\":{\"48\":1}}],[\"f2\",{\"1\":{\"48\":1}}],[\"f\",{\"1\":{\"48\":1}}],[\"f1\",{\"1\":{\"48\":1}}],[\"finally\",{\"1\":{\"31\":1}}],[\"final\",{\"1\":{\"31\":1,\"33\":1,\"38\":3,\"44\":2,\"45\":2,\"46\":2,\"49\":2,\"53\":1}}],[\"file\",{\"1\":{\"16\":1,\"56\":1,\"69\":1}}],[\"float\",{\"1\":{\"31\":1,\"33\":1,\"36\":3,\"38\":3,\"40\":2}}],[\"flag\",{\"1\":{\"29\":1,\"34\":3}}],[\"flags\",{\"1\":{\"29\":1}}],[\"flight\",{\"1\":{\"26\":1}}],[\"full\",{\"1\":{\"29\":1}}],[\"function\",{\"1\":{\"8\":3,\"10\":3,\"11\":4}}],[\"for\",{\"1\":{\"29\":1,\"31\":1,\"34\":1,\"38\":1,\"39\":1,\"55\":2}}],[\"found\",{\"1\":{\"16\":1,\"56\":1,\"69\":1}}],[\"上面的表述不太清晰准确\",{\"1\":{\"54\":1}}],[\"上面这两行代码对应的字节码为\",{\"1\":{\"39\":1}}],[\"上发布\",{\"1\":{\"26\":1}}],[\"上找到各个版本的\",{\"1\":{\"21\":1}}],[\"上\",{\"0\":{\"16\":1}}],[\"设计模式\",{\"2\":{\"15\":1}}],[\"欢迎指正\",{\"1\":{\"13\":1}}],[\"欢迎来到鱼塘\",{\"1\":{\"1\":1}}],[\"今天先分享到这里了\",{\"1\":{\"13\":1}}],[\"今天介绍几个经常被提到的设计模式\",{\"1\":{\"7\":1}}],[\"好了\",{\"1\":{\"13\":1}}],[\"主要原因如下\",{\"1\":{\"49\":1}}],[\"主要包括\",{\"1\":{\"22\":1}}],[\"主要用于开发嵌入式消费电子设备的应用程序\",{\"1\":{\"19\":1}}],[\"主要通过扩展已有的类增加新功能\",{\"1\":{\"13\":1}}],[\"主页\",{\"0\":{\"5\":1}}],[\"educba\",{\"1\":{\"56\":1}}],[\"edition\",{\"1\":{\"19\":3}}],[\"equals\",{\"1\":{\"37\":1,\"38\":1,\"41\":1}}],[\"example\",{\"1\":{\"49\":1}}],[\"extends\",{\"1\":{\"31\":1,\"54\":2}}],[\"execute\",{\"1\":{\"12\":2}}],[\"eligible\",{\"1\":{\"29\":1}}],[\"else\",{\"1\":{\"12\":2,\"31\":1,\"34\":4}}],[\"employee\",{\"1\":{\"29\":4}}],[\"evaluation\",{\"1\":{\"23\":1}}],[\"event\",{\"1\":{\"10\":6}}],[\"enum\",{\"1\":{\"31\":1}}],[\"environment\",{\"1\":{\"22\":1}}],[\"enterprise\",{\"1\":{\"19\":1}}],[\"ejb\",{\"1\":{\"19\":1}}],[\"ee\",{\"0\":{\"19\":1},\"1\":{\"19\":5}}],[\"324\",{\"1\":{\"36\":1}}],[\"32767\",{\"1\":{\"36\":1}}],[\"32768\",{\"1\":{\"36\":1}}],[\"32=10\",{\"1\":{\"33\":2}}],[\"32=0\",{\"1\":{\"33\":1}}],[\"32\",{\"1\":{\"33\":4,\"36\":2}}],[\"333f\",{\"1\":{\"38\":2}}],[\"33\",{\"1\":{\"12\":2,\"38\":2}}],[\"3\",{\"0\":{\"65\":1},\"1\":{\"12\":4,\"26\":3,\"34\":4,\"36\":1,\"48\":1,\"62\":1,\"64\":1}}],[\"2^16\",{\"1\":{\"36\":1}}],[\"2^15\",{\"1\":{\"36\":2}}],[\"2^63\",{\"1\":{\"36\":2}}],[\"2147483647\",{\"1\":{\"36\":1}}],[\"2147483648\",{\"1\":{\"36\":1}}],[\"2021\",{\"1\":{\"55\":1}}],[\"20\",{\"1\":{\"44\":1,\"63\":3}}],[\"2012\",{\"1\":{\"26\":1}}],[\"2011\",{\"1\":{\"18\":1}}],[\"200\",{\"1\":{\"67\":1}}],[\"2009\",{\"1\":{\"26\":1}}],[\"2006\",{\"1\":{\"26\":1}}],[\"266\",{\"1\":{\"13\":1}}],[\"22358071\",{\"1\":{\"56\":1}}],[\"22\",{\"1\":{\"12\":2}}],[\"2\",{\"0\":{\"64\":1,\"65\":1},\"1\":{\"12\":4,\"13\":1,\"33\":2,\"34\":3,\"36\":5,\"38\":2,\"40\":12,\"46\":2,\"48\":1,\"50\":1,\"63\":1,\"64\":1}}],[\"策略模式可以在不同的时机\",{\"1\":{\"12\":1}}],[\"策略模式\",{\"0\":{\"12\":1}}],[\"+greeting\",{\"1\":{\"46\":1}}],[\"+character\",{\"1\":{\"46\":1}}],[\"+\",{\"1\":{\"13\":2,\"22\":1,\"33\":8,\"38\":2,\"42\":2,\"44\":3,\"49\":2,\"55\":1,\"63\":4,\"65\":4}}],[\"++var3\",{\"1\":{\"55\":1}}],[\"++a\",{\"1\":{\"32\":2}}],[\"++同时支持方法重载和操作符重载\",{\"1\":{\"27\":1}}],[\"++\",{\"1\":{\"11\":1,\"13\":1,\"32\":2}}],[\"+=\",{\"1\":{\"10\":1,\"39\":1}}],[\"biginteger\",{\"1\":{\"42\":2}}],[\"bigdecimal\",{\"1\":{\"41\":12}}],[\"bipush\",{\"1\":{\"39\":1}}],[\"binary\",{\"1\":{\"26\":1}}],[\"before\",{\"1\":{\"66\":4}}],[\"between\",{\"1\":{\"56\":4}}],[\"be\",{\"1\":{\"38\":1}}],[\"benefits\",{\"1\":{\"29\":1}}],[\"basis\",{\"0\":{\"73\":1}}],[\"basictypevar\",{\"1\":{\"37\":1}}],[\"bad\",{\"1\":{\"12\":1}}],[\"b\",{\"1\":{\"32\":4,\"38\":2,\"40\":3,\"41\":3,\"48\":2,\"55\":3,\"63\":9}}],[\"boolean\",{\"1\":{\"31\":1,\"34\":1,\"36\":4,\"38\":4}}],[\"break\",{\"0\":{\"34\":1},\"1\":{\"31\":1,\"34\":2}}],[\"bcl\",{\"1\":{\"26\":2}}],[\"button>\",{\"1\":{\"10\":1}}],[\"bytes\",{\"1\":{\"46\":1}}],[\"byte\",{\"1\":{\"31\":1,\"33\":1,\"36\":4,\"38\":1}}],[\"by=\",{\"1\":{\"10\":1}}],[\"by\",{\"1\":{\"10\":1,\"38\":1}}],[\"<iostream>\",{\"1\":{\"66\":1}}],[\"<=\",{\"1\":{\"34\":1,\"38\":2,\"39\":1}}],[\"<<=\",{\"1\":{\"33\":2}}],[\"<<\",{\"1\":{\"33\":3,\"66\":12}}],[\"<mybutton\",{\"1\":{\"10\":1}}],[\"<\",{\"1\":{\"10\":1,\"38\":1,\"55\":1}}],[\"<button\",{\"1\":{\"10\":1}}],[\">=\",{\"1\":{\"38\":1}}],[\">>\",{\"1\":{\"33\":3}}],[\">>>42等同于x\",{\"1\":{\"33\":1}}],[\">>>\",{\"1\":{\"33\":4}}],[\">机器码\",{\"1\":{\"23\":1}}],[\">\",{\"1\":{\"10\":2,\"29\":1,\"40\":5}}],[\"1906445\",{\"1\":{\"56\":1}}],[\"13\",{\"1\":{\"46\":1,\"55\":1}}],[\"12\",{\"1\":{\"55\":1}}],[\"127\",{\"1\":{\"36\":1,\"38\":5}}],[\"128\",{\"1\":{\"36\":1,\"38\":2}}],[\"1024\",{\"1\":{\"33\":1}}],[\"10\",{\"1\":{\"33\":10,\"39\":4,\"44\":2,\"63\":3,\"66\":3}}],[\"100000024\",{\"1\":{\"40\":1}}],[\"100\",{\"1\":{\"13\":1,\"67\":1}}],[\"16\",{\"1\":{\"33\":1,\"36\":2,\"55\":1}}],[\"166\",{\"1\":{\"13\":1}}],[\"11111111111111111111110000000000\",{\"1\":{\"33\":1}}],[\"11111111111111111111111111111111\",{\"1\":{\"33\":1}}],[\"11\",{\"1\":{\"12\":2,\"22\":1,\"26\":2,\"66\":2}}],[\"1\",{\"0\":{\"63\":1,\"64\":1},\"1\":{\"10\":2,\"12\":4,\"13\":1,\"32\":4,\"33\":6,\"34\":3,\"36\":14,\"38\":3,\"40\":7,\"41\":3,\"42\":2,\"48\":2,\"50\":1,\"64\":2}}],[\"18\",{\"1\":{\"9\":2,\"10\":3,\"11\":1}}],[\"var3\",{\"1\":{\"55\":3}}],[\"var2\",{\"1\":{\"55\":2}}],[\"var1\",{\"1\":{\"55\":2}}],[\"variablelengthargument\",{\"1\":{\"55\":2}}],[\"variableexample\",{\"1\":{\"44\":2}}],[\"valueof\",{\"1\":{\"38\":4,\"39\":2}}],[\"value\",{\"1\":{\"10\":8,\"11\":6,\"34\":1,\"38\":1,\"39\":1,\"42\":2}}],[\"void\",{\"1\":{\"31\":1,\"34\":1,\"44\":2,\"46\":1,\"48\":3,\"49\":1,\"50\":3,\"54\":1,\"55\":6,\"60\":1,\"63\":2,\"64\":2,\"65\":2,\"66\":1}}],[\"volatile\",{\"1\":{\"31\":1}}],[\"v2\",{\"1\":{\"26\":1}}],[\"virtual\",{\"1\":{\"21\":1}}],[\"vm\",{\"1\":{\"21\":5}}],[\"vs\",{\"0\":{\"19\":1,\"20\":2,\"26\":1},\"1\":{\"25\":1,\"37\":1,\"44\":1,\"56\":2}}],[\"vue中\",{\"1\":{\"10\":1}}],[\"override\",{\"1\":{\"54\":2}}],[\"overloading\",{\"1\":{\"52\":1}}],[\"out\",{\"1\":{\"33\":8,\"34\":8,\"38\":4,\"40\":3,\"41\":3,\"42\":2,\"44\":5,\"46\":2,\"48\":1,\"49\":2,\"55\":3,\"60\":1,\"63\":4,\"64\":2,\"65\":4}}],[\"otn\",{\"1\":{\"26\":2}}],[\"other\",{\"1\":{\"13\":2}}],[\"openjdk\",{\"0\":{\"26\":1},\"1\":{\"26\":33,\"56\":4}}],[\"or\",{\"1\":{\"38\":1,\"69\":1}}],[\"org\",{\"1\":{\"25\":1}}],[\"oraclejdk\",{\"1\":{\"26\":4}}],[\"oracle\",{\"0\":{\"26\":1},\"1\":{\"22\":1,\"26\":37,\"31\":1,\"56\":4,\"69\":1}}],[\"of\",{\"1\":{\"21\":1,\"25\":1,\"69\":1}}],[\"once\",{\"1\":{\"18\":1}}],[\"on\",{\"1\":{\"10\":1}}],[\"obj\",{\"1\":{\"11\":5}}],[\"objects\",{\"1\":{\"41\":1}}],[\"object\",{\"1\":{\"8\":1,\"9\":2,\"10\":2,\"11\":1,\"33\":1}}],[\"observerlist\",{\"1\":{\"9\":3}}],[\"observer\",{\"1\":{\"9\":11}}],[\"posts\",{\"0\":{\"72\":1}}],[\"post\",{\"1\":{\"56\":1}}],[\"person2\",{\"1\":{\"65\":8}}],[\"person1\",{\"1\":{\"65\":8}}],[\"person\",{\"1\":{\"50\":6,\"65\":8}}],[\"passing\",{\"1\":{\"69\":1}}],[\"password\",{\"1\":{\"10\":1}}],[\"pascal\",{\"1\":{\"61\":1}}],[\"parameters\",{\"1\":{\"60\":1}}],[\"parameter\",{\"1\":{\"48\":2}}],[\"package\",{\"1\":{\"31\":1}}],[\"property\",{\"1\":{\"38\":1}}],[\"protected\",{\"1\":{\"31\":1}}],[\"printvariable\",{\"1\":{\"55\":6}}],[\"println\",{\"1\":{\"33\":8,\"34\":8,\"38\":4,\"40\":3,\"41\":3,\"42\":2,\"44\":5,\"46\":2,\"48\":1,\"49\":2,\"55\":3,\"60\":1,\"63\":4,\"64\":2,\"65\":4}}],[\"private关键字修饰就无法这样访问了\",{\"1\":{\"45\":1}}],[\"private\",{\"1\":{\"31\":1,\"37\":1,\"38\":3,\"39\":1,\"44\":3,\"53\":1,\"65\":1}}],[\"php\",{\"1\":{\"24\":1}}],[\"python\",{\"1\":{\"24\":1,\"25\":1}}],[\"pda\",{\"1\":{\"19\":1}}],[\"platform\",{\"1\":{\"19\":3}}],[\"putfield\",{\"1\":{\"39\":2}}],[\"publish\",{\"1\":{\"10\":3,\"11\":4}}],[\"public\",{\"1\":{\"10\":1,\"31\":1,\"34\":1,\"38\":3,\"44\":5,\"45\":4,\"46\":4,\"48\":5,\"49\":4,\"50\":4,\"54\":8,\"55\":8,\"63\":2,\"64\":2,\"65\":3}}],[\"pubsub\",{\"1\":{\"10\":2}}],[\"push\",{\"1\":{\"9\":1}}],[\"$emit\",{\"1\":{\"10\":1}}],[\"$\",{\"1\":{\"10\":2}}],[\"099999905\",{\"1\":{\"40\":1}}],[\"0d\",{\"1\":{\"36\":1}}],[\"0f\",{\"1\":{\"36\":1,\"40\":1}}],[\"0l\",{\"1\":{\"36\":1,\"39\":1}}],[\"0\",{\"1\":{\"10\":1,\"11\":1,\"13\":1,\"33\":3,\"34\":4,\"36\":5,\"38\":2,\"39\":4,\"40\":15,\"41\":5,\"45\":2,\"46\":1,\"55\":2,\"64\":5}}],[\"u0000\",{\"1\":{\"36\":1}}],[\"userinfo\",{\"1\":{\"10\":2}}],[\"username\",{\"1\":{\"10\":1}}],[\"uuid++\",{\"1\":{\"10\":1}}],[\"uuid\",{\"1\":{\"10\":5,\"11\":6}}],[\"update\",{\"1\":{\"9\":2}}],[\"这里的\",{\"1\":{\"66\":1}}],[\"这里传递的还是值\",{\"1\":{\"64\":1}}],[\"这里需要额外多说明一下\",{\"1\":{\"54\":1}}],[\"这里就不做演示了\",{\"1\":{\"33\":1}}],[\"这本书是这样介绍重载的\",{\"1\":{\"52\":1}}],[\"这本书明确指出\",{\"1\":{\"29\":1}}],[\"这一行代码会发生装箱\",{\"1\":{\"38\":1}}],[\"这一步\",{\"1\":{\"23\":1}}],[\"这八种基本类型都有对应的包装类分别为\",{\"1\":{\"36\":1}}],[\"这是为什么呢\",{\"1\":{\"36\":1}}],[\"这是因为在二进制补码表示法中\",{\"1\":{\"36\":1}}],[\"这是因为\",{\"1\":{\"24\":1,\"37\":1}}],[\"这\",{\"1\":{\"36\":1,\"38\":1}}],[\"这就需要用到下面几个关键词\",{\"1\":{\"34\":1}}],[\"这不光可以帮助我们在代码中使用\",{\"1\":{\"33\":1}}],[\"这个值是实参的地址罢了\",{\"1\":{\"64\":1}}],[\"这个过程被称为重载解析\",{\"1\":{\"52\":1}}],[\"这个需要结合\",{\"1\":{\"49\":1}}],[\"这个成员变量是属于实例的\",{\"1\":{\"44\":1}}],[\"这个和计算机保存浮点数的机制有很大关系\",{\"1\":{\"40\":1}}],[\"这个关键字很特殊\",{\"1\":{\"31\":1}}],[\"这个名字已经被赋予了特殊的含义\",{\"1\":{\"30\":1}}],[\"这个时候\",{\"1\":{\"26\":1}}],[\"这些特殊的标识符就是\",{\"1\":{\"30\":1}}],[\"这与\",{\"1\":{\"27\":1}}],[\"这也就说明了为什么方法内部对形参的修改会影响到实参\",{\"1\":{\"64\":1}}],[\"这也就是解释了为什么浮点数没有办法用二进制精确表示\",{\"1\":{\"40\":1}}],[\"这也是为什么通过\",{\"1\":{\"26\":1}}],[\"这也解释了我们为什么经常会说\",{\"1\":{\"23\":1}}],[\"这么好\",{\"1\":{\"26\":1}}],[\"这么多优点\",{\"1\":{\"25\":1}}],[\"这四者的关系\",{\"1\":{\"23\":1}}],[\"这四者的关系如下图所示\",{\"1\":{\"23\":1}}],[\"这种方式非常容易造成混淆\",{\"1\":{\"50\":1}}],[\"这种方式的执行速度会相对比较慢\",{\"1\":{\"23\":1}}],[\"这种所占存储空间大小的不变性是\",{\"1\":{\"36\":1}}],[\"这种编译模式会在程序被执行前就将其编译成机器码\",{\"1\":{\"25\":1}}],[\"这种字节码必须由\",{\"1\":{\"24\":1}}],[\"这种技术混合了编译语言与解释型语言的优点\",{\"1\":{\"24\":1}}],[\"这种如果需要优化\",{\"1\":{\"12\":1}}],[\"这对于满足现代应用程序架构的需求\",{\"1\":{\"22\":1}}],[\"这样可以节省内存\",{\"1\":{\"45\":1}}],[\"这样可以极大的减少\",{\"1\":{\"22\":1}}],[\"这样吧\",{\"1\":{\"26\":1}}],[\"这样就将发布者和订阅者完全隔离开了\",{\"1\":{\"10\":1}}],[\"这句宣传口号\",{\"1\":{\"18\":1}}],[\"这和vue的基思路理是一样的了\",{\"1\":{\"9\":1}}],[\"将数组的第一个元素变为0\",{\"1\":{\"64\":1}}],[\"将包装类型转换为基本数据类型\",{\"1\":{\"39\":1}}],[\"将基本类型用它们对应的引用类型包装起来\",{\"1\":{\"39\":1}}],[\"将所有的变更通过event广播给所有订阅该topic的订阅者们\",{\"1\":{\"10\":1}}],[\"将目标具体的变化通知所有的观察者\",{\"1\":{\"9\":1}}],[\"事件通道\",{\"1\":{\"10\":1}}],[\"那为什么还要有\",{\"1\":{\"26\":1}}],[\"那为什么不全部使用这种编译方式呢\",{\"1\":{\"25\":1}}],[\"那\",{\"1\":{\"26\":1}}],[\"那么这个成员变量是属于类的\",{\"1\":{\"44\":1}}],[\"那么就可能通过标量替换来实现栈上分配\",{\"1\":{\"37\":1}}],[\"那么\",{\"1\":{\"26\":1}}],[\"那么它是怎么解耦的呢\",{\"1\":{\"10\":1}}],[\"那就没办法使用这些框架和库了\",{\"1\":{\"25\":1}}],[\"那恭喜你\",{\"1\":{\"9\":1}}],[\"订阅器\",{\"1\":{\"10\":1}}],[\"订阅者通过subscribe功能和topic绑定\",{\"1\":{\"10\":1}}],[\"订阅者模式\",{\"1\":{\"10\":1}}],[\"订阅模式实现\",{\"1\":{\"10\":1}}],[\"订阅模式提供了主题\",{\"1\":{\"10\":1}}],[\"订阅模式\",{\"0\":{\"10\":1}}],[\"对引用类型的参数采用的不是引用传递\",{\"1\":{\"64\":1}}],[\"对引用类型的参数采用的是引用传递\",{\"1\":{\"64\":1}}],[\"对形参的修改将影响到实参\",{\"1\":{\"61\":1}}],[\"对成员变量进行赋值\",{\"1\":{\"44\":2}}],[\"对象\",{\"1\":{\"50\":2}}],[\"对象类型\",{\"1\":{\"37\":1}}],[\"对象属性中很少会使用基本类型来定义变量\",{\"1\":{\"37\":1}}],[\"对于调用者都是未知的\",{\"1\":{\"67\":1}}],[\"对于编译器\",{\"1\":{\"44\":1}}],[\"对于包装数据类型来说\",{\"1\":{\"37\":1}}],[\"对于基本数据类型来说\",{\"1\":{\"37\":1}}],[\"对于\",{\"1\":{\"26\":1,\"36\":1}}],[\"对于复杂的系统\",{\"1\":{\"10\":1}}],[\"对微服务架构的支持也比较友好\",{\"1\":{\"25\":1}}],[\"对应的二进制是\",{\"1\":{\"33\":1}}],[\"对应的\",{\"1\":{\"21\":1}}],[\"对应的观察者concreteobservver3\",{\"1\":{\"9\":1}}],[\"对应的观察者concreteobservver1\",{\"1\":{\"9\":1}}],[\"guide哥\",{\"1\":{\"55\":1}}],[\"greeting\",{\"1\":{\"46\":1,\"49\":2}}],[\"graalvm\",{\"1\":{\"25\":5}}],[\"gc\",{\"1\":{\"27\":1}}],[\"gpl\",{\"1\":{\"26\":1}}],[\"gosling\",{\"1\":{\"67\":1,\"69\":1}}],[\"goto\",{\"1\":{\"31\":1}}],[\"go\",{\"1\":{\"23\":1,\"24\":1,\"25\":1}}],[\"good\",{\"1\":{\"12\":1}}],[\"getname\",{\"1\":{\"65\":4}}],[\"getter\",{\"1\":{\"65\":1}}],[\"getbytes\",{\"1\":{\"46\":1}}],[\"getfield\",{\"1\":{\"39\":1}}],[\"get\",{\"1\":{\"9\":2,\"10\":2,\"11\":1}}],[\"gitee\",{\"1\":{\"1\":1}}],[\"github\",{\"1\":{\"1\":1,\"26\":2}}],[\"differences\",{\"1\":{\"56\":2}}],[\"difference\",{\"1\":{\"56\":2}}],[\"d\",{\"1\":{\"55\":2}}],[\"date\",{\"1\":{\"55\":1}}],[\"data\",{\"1\":{\"9\":5,\"10\":10,\"11\":6}}],[\"double\",{\"1\":{\"31\":1,\"33\":1,\"36\":3,\"38\":3}}],[\"do\",{\"1\":{\"31\":1}}],[\"docs\",{\"1\":{\"25\":1,\"31\":1}}],[\"docker\",{\"1\":{\"18\":1}}],[\"dragonwell\",{\"1\":{\"26\":1}}],[\"dragonwell8\",{\"1\":{\"26\":2}}],[\"dubbo\",{\"1\":{\"25\":1}}],[\"default\",{\"1\":{\"31\":5}}],[\"defineproperty\",{\"1\":{\"9\":2,\"10\":2,\"11\":1}}],[\"development\",{\"1\":{\"22\":1}}],[\"decorater\",{\"1\":{\"13\":8}}],[\"after\",{\"1\":{\"66\":4}}],[\"and\",{\"1\":{\"56\":4}}],[\"anywhere\",{\"1\":{\"18\":1}}],[\"ab\",{\"1\":{\"55\":1}}],[\"abstract\",{\"1\":{\"31\":1}}],[\"author\",{\"1\":{\"55\":1}}],[\"autoboxtest\",{\"1\":{\"39\":3}}],[\"aload\",{\"1\":{\"39\":3}}],[\"alibaba\",{\"1\":{\"26\":3}}],[\"a+1\",{\"1\":{\"32\":1}}],[\"a++输出的是\",{\"1\":{\"32\":1}}],[\"a++\",{\"1\":{\"32\":1}}],[\"agreement\",{\"1\":{\"26\":2}}],[\"age发生变化了\",{\"1\":{\"10\":2}}],[\"age\",{\"1\":{\"9\":5,\"10\":7,\"11\":1,\"29\":1,\"44\":4,\"66\":4}}],[\"amazon\",{\"1\":{\"26\":1}}],[\"aws\",{\"1\":{\"26\":1}}],[\"ascii\",{\"1\":{\"46\":1}}],[\"assert\",{\"1\":{\"31\":1}}],[\"asm\",{\"1\":{\"25\":2}}],[\"async来创建线程\",{\"1\":{\"18\":1}}],[\"ahead\",{\"1\":{\"25\":1}}],[\"aot\",{\"0\":{\"25\":2},\"1\":{\"25\":16}}],[\"api\",{\"1\":{\"22\":1}}],[\"arguments\",{\"1\":{\"60\":1}}],[\"arg2\",{\"1\":{\"55\":2}}],[\"arg1\",{\"1\":{\"55\":3}}],[\"args\",{\"1\":{\"12\":3,\"34\":1,\"46\":1,\"49\":1,\"50\":1,\"55\":8,\"63\":1,\"64\":1,\"65\":1}}],[\"array\",{\"1\":{\"64\":2}}],[\"arr\",{\"1\":{\"12\":4,\"64\":6}}],[\"addstrategy\",{\"1\":{\"12\":4}}],[\"addobserver\",{\"1\":{\"9\":5}}],[\"a\",{\"1\":{\"12\":6,\"32\":1,\"36\":2,\"40\":3,\"41\":2,\"46\":2,\"48\":4,\"49\":3,\"55\":3,\"63\":9,\"69\":2}}],[\"萌萌哒草头将军\",{\"1\":{\"9\":1,\"10\":1,\"11\":1}}],[\"must\",{\"1\":{\"38\":1}}],[\"min\",{\"1\":{\"42\":1}}],[\"mission\",{\"1\":{\"26\":1}}],[\"micro\",{\"1\":{\"19\":1}}],[\"message\",{\"1\":{\"46\":2,\"49\":2}}],[\"method1\",{\"1\":{\"55\":1}}],[\"method2\",{\"1\":{\"44\":1,\"55\":1}}],[\"method\",{\"1\":{\"44\":1,\"50\":2,\"69\":1}}],[\"me\",{\"1\":{\"19\":3}}],[\"mediator\",{\"1\":{\"11\":4}}],[\"max\",{\"1\":{\"39\":1,\"42\":1}}],[\"may\",{\"1\":{\"38\":1}}],[\"main\",{\"1\":{\"34\":1,\"46\":1,\"49\":1,\"50\":1,\"55\":1,\"63\":1,\"64\":1,\"65\":1,\"66\":1}}],[\"machines\",{\"1\":{\"21\":1}}],[\"macos\",{\"1\":{\"18\":1,\"21\":1}}],[\"map\",{\"1\":{\"9\":1,\"10\":1,\"11\":1,\"12\":2}}],[\"mypubsub\",{\"1\":{\"10\":8}}],[\"mysing2\",{\"1\":{\"8\":1}}],[\"mysing1\",{\"1\":{\"8\":1}}],[\"mysingleton2\",{\"1\":{\"8\":1}}],[\"mysingleton1\",{\"1\":{\"8\":1}}],[\"mmdctjj\",{\"1\":{\"9\":1,\"10\":4,\"11\":3}}],[\"num++\",{\"1\":{\"66\":1}}],[\"num\",{\"1\":{\"66\":3}}],[\"num3\",{\"1\":{\"44\":2}}],[\"num2\",{\"1\":{\"44\":2,\"63\":8}}],[\"num1\",{\"1\":{\"44\":2,\"63\":8}}],[\"number\",{\"1\":{\"13\":8}}],[\"nutsandbolts\",{\"1\":{\"31\":1}}],[\"null\",{\"1\":{\"31\":1,\"33\":1,\"37\":2}}],[\"network\",{\"1\":{\"26\":1}}],[\"newvalue\",{\"1\":{\"9\":4,\"10\":6,\"11\":3}}],[\"new\",{\"1\":{\"8\":3,\"9\":6,\"10\":2,\"12\":1,\"13\":2,\"31\":1,\"38\":6,\"41\":3,\"50\":1,\"52\":2,\"54\":2,\"65\":2}}],[\"native\",{\"1\":{\"25\":2,\"31\":1}}],[\"name发生变化了\",{\"1\":{\"10\":4}}],[\"name\",{\"1\":{\"9\":5,\"10\":8,\"11\":8,\"12\":4,\"44\":5,\"54\":3,\"65\":1}}],[\"not\",{\"1\":{\"16\":1,\"56\":1,\"69\":1}}],[\"notify\",{\"1\":{\"9\":3}}],[\"n\",{\"1\":{\"10\":2,\"39\":4,\"48\":1,\"66\":4}}],[\"我通过\",{\"1\":{\"62\":1}}],[\"我后续发布\",{\"1\":{\"26\":1}}],[\"我发布我的\",{\"1\":{\"26\":1}}],[\"我叫\",{\"1\":{\"26\":1}}],[\"我把一部分核心代码开源出来给你们玩\",{\"1\":{\"26\":1}}],[\"我们再来看下面这个案例\",{\"1\":{\"64\":1}}],[\"我们已经知道了一个方法不能修改一个基本数据类型的参数\",{\"1\":{\"63\":1}}],[\"我们先来搞懂下面这两个概念\",{\"1\":{\"59\":1}}],[\"我们看编译后生成的\",{\"1\":{\"55\":1}}],[\"我们通过下面这个例子来证明一下\",{\"1\":{\"55\":1}}],[\"我们可以按照方法的返回值和参数类型将方法分为下面这几种\",{\"1\":{\"48\":1}}],[\"我们可以将高级编程语言按照程序的执行方式分为两种\",{\"1\":{\"24\":1}}],[\"我们知道计算机是二进制的\",{\"1\":{\"40\":1}}],[\"我们知道几乎所有对象实例都存在于堆中\",{\"1\":{\"37\":1}}],[\"我们应该尽量避免不必要的拆装箱操作\",{\"1\":{\"39\":1}}],[\"我们发现装箱其实就是调用了\",{\"1\":{\"39\":1}}],[\"我们在其他地方比如方法参数\",{\"1\":{\"37\":1}}],[\"我们需要把除了最高位之外的所有位都设为\",{\"1\":{\"36\":1}}],[\"我们需要格外注意的是\",{\"1\":{\"23\":1}}],[\"我们要尽量规范和美化自己的代码来减少不必要的注释\",{\"1\":{\"29\":1}}],[\"我们就需要用到注释了\",{\"1\":{\"29\":1}}],[\"我们自己或者团队其他成员还可以很轻易地看懂代码\",{\"1\":{\"29\":1}}],[\"我们的目的是开源\",{\"1\":{\"26\":1}}],[\"我们的\",{\"1\":{\"26\":1}}],[\"我们前面也对比过\",{\"1\":{\"25\":1}}],[\"我们用发布\",{\"1\":{\"10\":1}}],[\"我在介绍模块化系统的时候提到\",{\"1\":{\"22\":1}}],[\"我也知道\",{\"1\":{\"10\":2}}],[\"我知道很多人没学过\",{\"1\":{\"27\":1}}],[\"我知道\",{\"1\":{\"10\":4}}],[\"我知道我该更新了\",{\"1\":{\"9\":5}}],[\"我是subscribe3\",{\"1\":{\"11\":2}}],[\"我是subscribe1\",{\"1\":{\"11\":2}}],[\"我是\",{\"1\":{\"9\":5}}],[\"temp\",{\"1\":{\"63\":2,\"65\":2}}],[\"technology\",{\"1\":{\"26\":1}}],[\"tutorials\",{\"1\":{\"69\":1}}],[\"tutorial\",{\"1\":{\"31\":1}}],[\"tips\",{\"1\":{\"31\":1}}],[\"time\",{\"1\":{\"18\":1,\"23\":1,\"25\":1}}],[\"tobinarystring\",{\"1\":{\"33\":4}}],[\"to\",{\"1\":{\"29\":1,\"69\":1}}],[\"topics\",{\"1\":{\"10\":6,\"11\":6}}],[\"topic\",{\"1\":{\"10\":8,\"11\":7}}],[\"throws\",{\"1\":{\"31\":1}}],[\"throw\",{\"1\":{\"31\":1}}],[\"thread\",{\"1\":{\"18\":2}}],[\"thread和std\",{\"1\":{\"18\":1}}],[\"the\",{\"1\":{\"29\":1,\"56\":2}}],[\"this\",{\"1\":{\"9\":9,\"10\":12,\"11\":2,\"12\":3,\"13\":7,\"31\":1,\"44\":3}}],[\"try\",{\"1\":{\"31\":1}}],[\"transient\",{\"1\":{\"31\":1}}],[\"trigger\",{\"1\":{\"10\":1}}],[\"true\",{\"1\":{\"8\":1,\"31\":1,\"34\":1,\"36\":1,\"38\":4,\"41\":1,\"42\":1}}],[\"cn\",{\"1\":{\"56\":1}}],[\"change\",{\"1\":{\"64\":3}}],[\"channer\",{\"1\":{\"10\":1}}],[\"charactercache\",{\"1\":{\"38\":3}}],[\"character\",{\"1\":{\"36\":1,\"38\":7}}],[\"char类型进行移位前\",{\"1\":{\"33\":1}}],[\"char\",{\"1\":{\"31\":1,\"36\":4,\"38\":2,\"46\":2,\"49\":1}}],[\"check\",{\"1\":{\"29\":1}}],[\"cache\",{\"1\":{\"38\":6}}],[\"catch\",{\"1\":{\"31\":1}}],[\"case\",{\"1\":{\"31\":1}}],[\"cadence\",{\"1\":{\"26\":1}}],[\"callback\",{\"1\":{\"11\":4,\"12\":2}}],[\"cglib\",{\"1\":{\"25\":2}}],[\"c\",{\"1\":{\"23\":1,\"24\":1,\"25\":1,\"27\":1,\"38\":4,\"41\":2,\"55\":2,\"67\":1}}],[\"cplusplus\",{\"1\":{\"18\":1}}],[\"c++就引入了多线程库\",{\"1\":{\"18\":1}}],[\"c++11\",{\"1\":{\"18\":1}}],[\"c++\",{\"0\":{\"27\":1},\"1\":{\"18\":1,\"23\":1,\"24\":1,\"25\":1,\"27\":5,\"61\":1,\"66\":1,\"67\":1}}],[\"clean\",{\"1\":{\"29\":1}}],[\"click=\",{\"1\":{\"10\":1}}],[\"class文件就可以看出来了\",{\"1\":{\"55\":1}}],[\"class\",{\"1\":{\"9\":2,\"10\":1,\"12\":1,\"13\":2,\"22\":1,\"23\":2,\"24\":1,\"25\":1,\"31\":1,\"37\":1,\"38\":2,\"44\":1,\"45\":2,\"46\":1,\"49\":1,\"50\":1,\"54\":3,\"55\":2,\"65\":1}}],[\"cout\",{\"1\":{\"66\":4}}],[\"count\",{\"1\":{\"10\":1,\"13\":6}}],[\"corretto\",{\"1\":{\"26\":1}}],[\"compilation\",{\"1\":{\"23\":1,\"25\":1}}],[\"comparison\",{\"1\":{\"21\":1}}],[\"com\",{\"1\":{\"18\":1,\"26\":2,\"31\":1,\"56\":3}}],[\"configured\",{\"1\":{\"38\":1}}],[\"continue\",{\"0\":{\"34\":1},\"1\":{\"31\":1,\"34\":2}}],[\"control\",{\"1\":{\"26\":1}}],[\"concretesuject2\",{\"1\":{\"9\":4}}],[\"concretesuject1\",{\"1\":{\"9\":4}}],[\"concreteobservver4就会被广播事件通知\",{\"1\":{\"9\":1}}],[\"concreteobservver4\",{\"1\":{\"9\":4}}],[\"concreteobservver3\",{\"1\":{\"9\":4}}],[\"concreteobservver2就会被广播事件通知\",{\"1\":{\"9\":1}}],[\"concreteobservver2\",{\"1\":{\"9\":4}}],[\"concreteobservver1\",{\"1\":{\"9\":4}}],[\"console\",{\"1\":{\"8\":1,\"9\":1,\"10\":4,\"11\":2,\"12\":6,\"13\":4}}],[\"constantvar\",{\"1\":{\"45\":1}}],[\"constantvariableexample\",{\"1\":{\"45\":1}}],[\"constructor\",{\"1\":{\"9\":2,\"10\":1,\"12\":1,\"13\":2,\"69\":1}}],[\"const\",{\"1\":{\"8\":1,\"9\":7,\"10\":4,\"11\":5,\"12\":1,\"13\":2,\"31\":1}}],[\"code\",{\"1\":{\"9\":4,\"26\":1,\"29\":1}}],[\"当发生了某种条件之后\",{\"1\":{\"34\":1}}],[\"当发布者发生变化时\",{\"1\":{\"10\":1}}],[\"当循环条件不满足或者循环次数达到要求时\",{\"1\":{\"34\":1}}],[\"当运算符放在变量之后时\",{\"1\":{\"32\":1}}],[\"当运算符放在变量之前时\",{\"1\":{\"32\":1}}],[\"当在\",{\"1\":{\"31\":1}}],[\"当\",{\"1\":{\"23\":1,\"32\":2,\"33\":2}}],[\"当data的age属性变化\",{\"1\":{\"9\":1}}],[\"当data的name属性变化\",{\"1\":{\"9\":1}}],[\"当data对象的name或者age属性发生变化时\",{\"1\":{\"9\":1}}],[\"当目标发生变化时\",{\"1\":{\"9\":1}}],[\"观察者\",{\"1\":{\"9\":1}}],[\"观察者模式主要由四个角色组成\",{\"1\":{\"9\":1}}],[\"观察者模式主要是通过一个目标\",{\"1\":{\"9\":1}}],[\"观察者模式\",{\"0\":{\"9\":1}}],[\"通常情况下\",{\"1\":{\"41\":1,\"45\":1}}],[\"通常用于生成\",{\"1\":{\"29\":1}}],[\"通常用于解释一段代码的作用\",{\"1\":{\"29\":1}}],[\"通常用于解释方法内某单行代码的作用\",{\"1\":{\"29\":1}}],[\"通过上面例子\",{\"1\":{\"63\":1}}],[\"通过\",{\"1\":{\"18\":1}}],[\"通过广播事件\",{\"1\":{\"9\":1}}],[\"通俗易懂\",{\"1\":{\"7\":1}}],[\"l2\",{\"1\":{\"39\":2}}],[\"ljava\",{\"1\":{\"39\":3}}],[\"l1\",{\"1\":{\"39\":2}}],[\"length\",{\"1\":{\"38\":1,\"46\":1,\"55\":1}}],[\"letter\",{\"1\":{\"46\":1,\"49\":2}}],[\"let\",{\"1\":{\"8\":3,\"10\":1,\"11\":1,\"12\":2}}],[\"l\",{\"1\":{\"36\":1,\"42\":3}}],[\"low\",{\"1\":{\"38\":3}}],[\"long能表示的最大正数都减\",{\"1\":{\"36\":1}}],[\"long\",{\"0\":{\"42\":1},\"1\":{\"31\":1,\"33\":2,\"36\":4,\"38\":1,\"39\":5,\"42\":4}}],[\"login\",{\"1\":{\"10\":2}}],[\"log\",{\"1\":{\"8\":1,\"9\":1,\"10\":4,\"11\":2,\"12\":6,\"13\":4}}],[\"lts\",{\"1\":{\"26\":3}}],[\"lang\",{\"1\":{\"39\":5}}],[\"latest\",{\"1\":{\"25\":1}}],[\"lazy\",{\"1\":{\"23\":1}}],[\"linenumber\",{\"1\":{\"39\":2}}],[\"linux\",{\"1\":{\"18\":1,\"21\":1}}],[\"license\",{\"1\":{\"26\":2}}],[\"library\",{\"1\":{\"22\":1}}],[\"i4\",{\"1\":{\"38\":2}}],[\"i3\",{\"1\":{\"38\":2}}],[\"i22\",{\"1\":{\"38\":2}}],[\"i2\",{\"1\":{\"38\":4}}],[\"i1=integer\",{\"1\":{\"38\":1}}],[\"i1=40\",{\"1\":{\"38\":1}}],[\"i1==i2\",{\"1\":{\"38\":1}}],[\"i11\",{\"1\":{\"38\":2}}],[\"i1\",{\"1\":{\"38\":4}}],[\"i++\",{\"1\":{\"34\":1,\"38\":1,\"39\":1}}],[\"i\",{\"1\":{\"33\":12,\"34\":7,\"38\":9,\"39\":14}}],[\"ide\",{\"1\":{\"31\":1}}],[\"import\",{\"1\":{\"31\":1}}],[\"implements\",{\"1\":{\"31\":1}}],[\"iseligibleforfullbenefits\",{\"1\":{\"29\":1}}],[\"is\",{\"1\":{\"29\":1,\"56\":2}}],[\"issue\",{\"1\":{\"18\":1,\"54\":1}}],[\"item\",{\"1\":{\"11\":2}}],[\"if\",{\"1\":{\"8\":1,\"10\":2,\"11\":1,\"12\":3,\"29\":3,\"31\":1,\"34\":6,\"38\":2,\"48\":1}}],[\"information\",{\"1\":{\"69\":1}}],[\"incr\",{\"1\":{\"66\":8}}],[\"increase\",{\"1\":{\"10\":2}}],[\"increaseby\",{\"1\":{\"10\":1}}],[\"include\",{\"1\":{\"66\":1}}],[\"invoke\",{\"1\":{\"66\":4}}],[\"invokevirtual\",{\"1\":{\"39\":1}}],[\"invokestatic\",{\"1\":{\"39\":1}}],[\"intvalue\",{\"1\":{\"39\":2}}],[\"integercache\",{\"1\":{\"38\":5}}],[\"integer\",{\"1\":{\"33\":4,\"36\":1,\"38\":12,\"39\":10}}],[\"interview\",{\"1\":{\"69\":1}}],[\"interface\",{\"1\":{\"25\":1,\"31\":1}}],[\"interpret\",{\"1\":{\"24\":1}}],[\"int\",{\"1\":{\"31\":1,\"33\":5,\"34\":1,\"36\":3,\"37\":1,\"38\":6,\"39\":3,\"42\":1,\"44\":6,\"45\":2,\"48\":5,\"55\":2,\"63\":5,\"64\":2,\"66\":5}}],[\"in\",{\"1\":{\"18\":1,\"23\":1}}],[\"install\",{\"1\":{\"11\":4}}],[\"instanceof\",{\"1\":{\"31\":1}}],[\"instance\",{\"1\":{\"8\":4,\"10\":4}}],[\"init\",{\"1\":{\"8\":2,\"10\":2}}],[\"==\",{\"1\":{\"33\":1,\"34\":5,\"37\":2,\"38\":3,\"40\":1,\"42\":1}}],[\"===\",{\"1\":{\"8\":1,\"12\":3}}],[\"=>\",{\"1\":{\"9\":5,\"10\":10,\"11\":5,\"12\":5}}],[\"=\",{\"1\":{\"8\":4,\"9\":13,\"10\":12,\"11\":13,\"12\":5,\"13\":5,\"32\":2,\"33\":3,\"34\":3,\"36\":2,\"38\":14,\"39\":8,\"40\":7,\"41\":5,\"42\":1,\"44\":7,\"45\":2,\"46\":2,\"49\":2,\"50\":1,\"52\":2,\"55\":4,\"60\":1,\"63\":13,\"64\":2,\"65\":5,\"66\":1}}],[\"swap\",{\"1\":{\"63\":3,\"65\":3}}],[\"switch\",{\"1\":{\"31\":2}}],[\"sayhello\",{\"1\":{\"60\":2}}],[\"s\",{\"1\":{\"55\":4}}],[\"sb2\",{\"1\":{\"52\":1}}],[\"sb\",{\"1\":{\"52\":1}}],[\"system\",{\"1\":{\"33\":8,\"34\":8,\"38\":4,\"40\":3,\"41\":3,\"42\":2,\"44\":5,\"46\":2,\"48\":1,\"49\":2,\"55\":3,\"60\":1,\"63\":4,\"64\":2,\"65\":4}}],[\"synchronized\",{\"1\":{\"31\":1}}],[\"short\",{\"1\":{\"31\":1,\"36\":4,\"38\":1}}],[\"spring\",{\"1\":{\"25\":2}}],[\"specifications\",{\"1\":{\"21\":1}}],[\"sdk\",{\"1\":{\"22\":1}}],[\"see\",{\"1\":{\"29\":1}}],[\"servlet\",{\"1\":{\"19\":1,\"22\":1}}],[\"se\",{\"0\":{\"19\":1},\"1\":{\"19\":6,\"21\":1}}],[\"setter方法\",{\"1\":{\"65\":1}}],[\"set\",{\"1\":{\"9\":2,\"10\":2,\"11\":1}}],[\"std\",{\"1\":{\"66\":4}}],[\"str2\",{\"1\":{\"44\":2}}],[\"str\",{\"1\":{\"44\":2,\"60\":3}}],[\"stringbuilder\",{\"1\":{\"52\":5}}],[\"stringexample\",{\"1\":{\"46\":1}}],[\"string\",{\"1\":{\"34\":1,\"36\":1,\"44\":4,\"46\":2,\"49\":2,\"50\":1,\"54\":3,\"55\":11,\"60\":2,\"63\":1,\"64\":1,\"65\":2}}],[\"strictfp\",{\"1\":{\"31\":1}}],[\"strategy\",{\"1\":{\"12\":10}}],[\"stackoverflow\",{\"1\":{\"56\":2}}],[\"staicmethod\",{\"1\":{\"50\":2}}],[\"staticvariableexample\",{\"1\":{\"45\":1}}],[\"staticvar\",{\"1\":{\"45\":2}}],[\"static\",{\"1\":{\"31\":1,\"33\":1,\"34\":1,\"37\":2,\"38\":10,\"39\":1,\"44\":4,\"45\":3,\"46\":3,\"49\":3,\"50\":2,\"53\":2,\"55\":6,\"63\":2,\"64\":2,\"65\":2}}],[\"standard\",{\"1\":{\"19\":1}}],[\"stars\",{\"1\":{\"4\":1}}],[\"star\",{\"0\":{\"4\":1}}],[\"subtract\",{\"1\":{\"41\":2}}],[\"subscribe3\",{\"1\":{\"11\":2}}],[\"subscribe2\",{\"1\":{\"11\":2}}],[\"subscribe1\",{\"1\":{\"11\":2}}],[\"subscribe\",{\"1\":{\"10\":5,\"11\":5}}],[\"sum\",{\"1\":{\"39\":4,\"44\":2}}],[\"supersuperman\",{\"1\":{\"54\":1}}],[\"superman\",{\"1\":{\"54\":4}}],[\"super\",{\"1\":{\"31\":1}}],[\"sun\",{\"1\":{\"26\":5}}],[\"suject\",{\"1\":{\"9\":5}}],[\"singltron\",{\"1\":{\"8\":2}}],[\"singleton\",{\"1\":{\"8\":1}}],[\"幻灯片页\",{\"0\":{\"6\":1}}],[\"趋势\",{\"0\":{\"4\":1}}],[\"项目介绍\",{\"1\":{\"1\":1}}],[\"|\",{\"1\":{\"1\":1,\"24\":1}}],[\"鱼塘\",{\"0\":{\"0\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n}})=>{e==="suggest"?self.postMessage(st(t,v[s],n)):e==="search"?self.postMessage(et(t,v[s],n)):self.postMessage({suggestions:st(t,v[s],n),results:et(t,v[s],n)})};
//# sourceMappingURL=index.js.map
