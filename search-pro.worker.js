const nt="ENTRIES",V="KEYS",T="VALUES",F="";class D{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===F)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==F).join("")}value(){return E(this._path).node.get(F)}result(){switch(this._type){case T:return this.value();case V:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],ot=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return W(e,t,s,n,i,1,o,""),n},W=(e,t,s,n,o,u,i,r)=>{const h=u*i;t:for(const c of e.keys())if(c===F){const d=o[h-1];d<=s&&n.set(r,[e.get(c),d])}else{let d=u;for(let l=0;l<c.length;++l,++d){const p=c[l],f=i*d,g=f-i;let a=o[f];const m=Math.max(0,d-s-1),y=Math.min(i-1,d+s);for(let _=m;_<y;++_){const b=p!==t[_],z=o[g+_]+ +b,A=o[g+_+1]+1,w=o[f+_]+1,L=o[f+_+1]=Math.min(z,A,w);L<a&&(a=L)}if(a>s)continue t}W(e.get(c),t,s,n,o,d,i,r+c)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=O(n);for(const i of o.keys())if(i!==F&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ut(this._tree,t)}entries(){return new D(this,nt)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return ot(this._tree,t,s)}get(t){const s=I(this._tree,t);return s!==void 0?s.get(F):void 0}has(t){const s=I(this._tree,t);return s!==void 0&&s.has(F)}keys(){return new D(this,V)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,M(this._tree,t).set(F,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=M(this._tree,t);return n.set(F,s(n.get(F))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=M(this._tree,t);let o=n.get(F);return o===void 0&&n.set(F,o=s()),o}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==F&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},I=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==F&&t.startsWith(s))return I(e.get(s),t.slice(s.length))},M=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==F&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const h=e.get(u);if(r===u.length)e=h;else{const c=new Map;c.set(u.slice(r),h),e.set(t.slice(n,n+r),c),e.delete(u),e=c}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ut=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(F),s.size===0)R(n);else if(s.size===1){const[o,u]=s.entries().next().value;$(n,o,u)}}},R=e=>{if(e.length===0)return;const[t,s]=O(e);if(t.delete(s),t.size===0)R(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==F&&$(e.slice(0,-1),n,o)}},$=(e,t,s)=>{if(e.length===0)return;const[n,o]=O(e);n.set(o+t,s),n.delete(o)},O=e=>e[e.length-1],it=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},rt=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,S="or",q="and",ct="and_not",lt=(e,t)=>{e.includes(t)||e.push(t)},P=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},G=({score:e},{score:t})=>t-e,ht=()=>new Map,k=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},N=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,dt={[S]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),P(n.terms,u)}}return e},[q]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);P(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[ct]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},at=(e,t,s,n,o,u)=>{const{k:i,b:r,d:h}=u;return Math.log(1+(s-t+.5)/(t+.5))*(h+e*(i+1)/(e+i*(1-r+r*n/o)))},ft=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},H=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},gt=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const o=e._index.fetch(n,ht),u=o.get(t);u==null||u.get(s)==null?H(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},mt={k:1.2,b:.7,d:.5},pt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(rt),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof(console==null?void 0:console[e])=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:S,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:mt},Ft={combineWith:q,prefix:(e,t,s)=>t===s.length-1},_t={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},yt={..._t,...U},Y=(e,t=S)=>{if(e.length===0)return new Map;const s=t.toLowerCase();return e.reduce(dt[s])||new Map},B=(e,t,s,n,o,u,i,r,h=new Map)=>{if(o==null)return h;for(const c of Object.keys(u)){const d=u[c],l=e._fieldIds[c],p=o.get(l);if(p==null)continue;let f=p.size;const g=e._avgFieldLength[l];for(const a of p.keys()){if(!e._documentIds.has(a)){gt(e,l,a,s),f-=1;continue}const m=i?i(e._documentIds.get(a),s,e._storedFields.get(a)):1;if(!m)continue;const y=p.get(a),_=e._fieldLength.get(a)[l],b=at(y,f,e._documentCount,_,g,r),z=n*d*m*b,A=h.get(a);if(A){A.score+=z,lt(A.terms,t);const w=N(A.match,s);w?w.push(c):A.match[s]=[c]}else h.set(a,{score:z,terms:[t],match:{[s]:[c]}})}}return h},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((a,m)=>({...a,[m]:N(n.boost,m)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:h}=n,{fuzzy:c,prefix:d}={...J.weights,...i},l=e._index.get(t.term),p=B(e,t.term,t.term,1,l,o,u,h);let f,g;if(t.prefix&&(f=e._index.atPrefix(t.term)),t.fuzzy){const a=t.fuzzy===!0?.2:t.fuzzy,m=a<1?Math.min(r,Math.round(t.term.length*a)):a;m&&(g=e._index.fuzzyGet(t.term,m))}if(f)for(const[a,m]of f){const y=a.length-t.term.length;if(!y)continue;g==null||g.delete(a);const _=d*a.length/(a.length+.3*y);B(e,t.term,a,_,m,o,u,h,p)}if(g)for(const a of g.keys()){const[m,y]=g.get(a);if(!y)continue;const _=c*a.length/(a.length+y);B(e,t.term,a,_,m,o,u,h,p)}return p},X=(e,t,s={})=>{if(typeof t!="string"){const d={...s,...t,queries:void 0},l=t.queries.map(p=>X(e,p,d));return Y(l,d.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:h}=i,c=r(t).flatMap(d=>h(d)).filter(d=>!!d).map(ft(i)).map(d=>At(e,d,i));return Y(c,i.combineWith)},K=(e,t,s={})=>{const n=X(e,t,s),o=[];for(const[u,{score:i,terms:r,match:h}]of n){const c=r.length,d={id:e._documentIds.get(u),score:i*c,terms:Object.keys(h),match:h};Object.assign(d,e._storedFields.get(u)),(s.filter==null||s.filter(d))&&o.push(d)}return o.sort(G),o},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of K(e,t,s)){const r=i.join(" "),h=n.get(r);h!=null?(h.score+=u,h.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:h}]of n)o.push({suggestion:u,terms:r,score:i/h});return o.sort(G),o};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if((t==null?void 0:t.fields)==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?yt:t.autoVacuum;this._options={...pt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...Ft,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:h,serializationVersion:c},d)=>{if(c!==1&&c!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const l=new Et(d);l._documentCount=t,l._nextId=s,l._documentIds=k(n),l._idToShortId=new Map,l._fieldIds=o,l._fieldLength=k(u),l._avgFieldLength=i,l._storedFields=k(r),l._dirtCount=h||0,l._index=new C;for(const[p,f]of l._documentIds)l._idToShortId.set(f,p);for(const[p,f]of e){const g=new Map;for(const a of Object.keys(f)){let m=f[a];c===1&&(m=m.ds),g.set(parseInt(a,10),k(m))}l._index.set(p,g)}return l},Q=Object.entries,wt=Object.fromEntries,j=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(c,d=!1)=>{let l="";i===0?l=c.length>20?`… ${c.slice(-20)}`:c:d?l=c.length+i>100?`${c.slice(0,100-i)}… `:c:l=c.length>20?`${c.slice(0,20)} … ${c.slice(-20)}`:c,l&&o.push(l),i+=l.length,d||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let h=s.indexOf(n,u);if(h===-1)return null;for(;h>=0;){const c=h+n.length;if(r(e.slice(u,h)),u=c,i>100)break;h=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},Z=/[\u4e00-\u9fa5]/g,tt=(e={})=>({fuzzy:.2,prefix:!0,processTerm:t=>{const s=t.match(Z)||[],n=t.replace(Z,"").toLowerCase();return n?[n,...s]:[...s]},...e}),xt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),kt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),et=(e,t,s={})=>{const n={};return K(t,e,tt({boost:{h:2,t:1,c:4},...s})).forEach(o=>{const{id:u,terms:i,score:r}=o,h=u.includes("@"),c=u.includes("#"),[d,l]=u.split(/[#@]/),{contents:p}=n[d]??={title:"",contents:[]};if(h)p.push([{type:"customField",key:d,index:l,display:i.map(f=>o.c.map(g=>j(g,f))).flat().filter(f=>f!==null)},r]);else{const f=i.map(g=>j(o.h,g)).filter(g=>g!==null);if(f.length&&p.push([{type:c?"heading":"title",key:d,...c&&{anchor:l},display:f},r]),"t"in o)for(const g of o.t){const a=i.map(m=>j(g,m)).filter(m=>m!==null);a.length&&p.push([{type:"text",key:d,...c&&{anchor:l},display:a},r])}}}),Q(n).sort(([,o],[,u])=>"max"==="total"?xt(o,u):kt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=it(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},st=(e,t,s={})=>Ct(t,e,tt(s)).map(({suggestion:n})=>n),v=wt(Q(JSON.parse("{\"/\":{\"documentCount\":349,\"nextId\":349,\"documentIds\":{\"0\":\"v-8daa1a0e\",\"1\":\"v-8daa1a0e#关于网站\",\"2\":\"v-8daa1a0e#关于作者\",\"3\":\"v-8daa1a0e#占个位\",\"4\":\"v-8daa1a0e#star-趋势\",\"5\":\"v-184f4da6\",\"6\":\"v-2e3eac9e\",\"7\":\"v-4bc4557f\",\"8\":\"v-4bc4557f#三分钟搭建一个博客网站\",\"9\":\"v-4bc4557f#准备运行环境\",\"10\":\"v-4bc4557f#创建项目模板\",\"11\":\"v-4bc4557f#创建过程\",\"12\":\"v-4bc4557f#访问\",\"13\":\"v-4bc4557f#效果\",\"14\":\"v-4bc4557f#项目启动命令\",\"15\":\"v-4bc4557f#发布到github\",\"16\":\"v-4bc4557f#修改deploy-docs-yml\",\"17\":\"v-4bc4557f#修改config-ts\",\"18\":\"v-4bc4557f#共享项目到github\",\"19\":\"v-4bc4557f#从master新建分支gh-pages-推送新分支到github\",\"20\":\"v-4bc4557f#github上开源\",\"21\":\"v-4bc4557f#配置github-pages\",\"22\":\"v-4bc4557f#更新博客只在master分支上改-不要动gh-pages分支\",\"23\":\"v-4bc4557f#修复-编辑此页-功能链接跳转不对问题\",\"24\":\"v-4bc4557f#踩坑\",\"25\":\"v-4bc4557f@0\",\"26\":\"v-4bc4557f@1\",\"27\":\"v-20738152\",\"28\":\"v-20738152#java-中-io-流分为几种\",\"29\":\"v-20738152#既然有了字节流-为什么还要有字符流\",\"30\":\"v-20738152#bio、nio、aio\",\"31\":\"v-fc32ae94\",\"32\":\"v-fc32ae94#jdk1-8都有哪些新特性\",\"33\":\"v-fc32ae94#lambda-表达式了解多少\",\"34\":\"v-fc32ae94#java8有哪些内置函数式接口\",\"35\":\"v-fc32ae94#optional了解吗\",\"36\":\"v-fc32ae94#stream-流用过吗\",\"37\":\"v-1cf004e2\",\"38\":\"v-1cf004e2#java语言有哪些特点\",\"39\":\"v-1cf004e2#jvm、jdk-和-jre-有什么区别\",\"40\":\"v-1cf004e2#说说什么是跨平台性-原理是什么\",\"41\":\"v-1cf004e2#什么是字节码-采用字节码的好处是什么\",\"42\":\"v-1cf004e2#为什么说-java-语言-编译与解释并存\",\"43\":\"v-5982fa10\",\"44\":\"v-5982fa10#说下什么是java的spi机制\",\"45\":\"v-70c64af0\",\"46\":\"v-70c64af0#什么是反射\",\"47\":\"v-70c64af0#反射的应用场景\",\"48\":\"v-70c64af0#反射的实现原理\",\"49\":\"v-1e829856\",\"50\":\"v-1e829856#java有哪些数据类型\",\"51\":\"v-1e829856#什么是自动类型转换、强制类型转换\",\"52\":\"v-1e829856#什么是自动拆箱-封箱\",\"53\":\"v-1e829856#和-有什么区别\",\"54\":\"v-1e829856#switch-是否能作用在-byte-long-string上\",\"55\":\"v-1e829856#break-continue-return-的区别及作用\",\"56\":\"v-1e829856#用最有效率的方法计算2乘以8\",\"57\":\"v-1e829856#说说自增自减运算\",\"58\":\"v-63c28b90\",\"59\":\"v-63c28b90#string-是-java-基本数据类型吗-可以被继承吗\",\"60\":\"v-63c28b90#string和stringbuilder、stringbuffer\",\"61\":\"v-63c28b90#string-str1-new-string-abc-和string-str2-abc-和-区别\",\"62\":\"v-63c28b90#string不是不可变类吗-字符串拼接是如何实现的\",\"63\":\"v-63c28b90#intern方法有什么作用\",\"64\":\"v-63c28b90#integer-a-127-integer-b-127-integer-c-128-integer-d-128-相等吗\",\"65\":\"v-63c28b90#string怎么转成integer的-原理\",\"66\":\"v-63c28b90#object-类的常见方法\",\"67\":\"v-a668a33c\",\"68\":\"v-a668a33c#什么是序列化-什么是反序列化\",\"69\":\"v-a668a33c#说说有哪些常见的序列化方式\",\"70\":\"v-09de2f71\",\"71\":\"v-09de2f71#java-中异常层级结构\",\"72\":\"v-09de2f71#异常的处理机制\",\"73\":\"v-09de2f71#finally一定会执行吗\",\"74\":\"v-09de2f71#三道经典异常处理代码题\",\"75\":\"v-1ed0dc53\",\"76\":\"v-1ed0dc53#什么是泛型\",\"77\":\"v-1ed0dc53#泛型的使用方法\",\"78\":\"v-1ed0dc53#泛型常用的通配符有哪些\",\"79\":\"v-1ed0dc53#什么是泛型擦除\",\"80\":\"v-08ef6fc0\",\"81\":\"v-08ef6fc0#说一下你对注解的理解\",\"82\":\"v-f52152e0\",\"83\":\"v-f52152e0#java中实现map接口的有哪些类\",\"84\":\"v-f52152e0#遍历hashmap的几种方法\",\"85\":\"v-95dc3ca2\",\"86\":\"v-95dc3ca2#面向对象和面向过程的区别\",\"87\":\"v-95dc3ca2#面向对象有哪些特性\",\"88\":\"v-95dc3ca2#重载-overload-和重写-override-的区别\",\"89\":\"v-95dc3ca2#访问修饰符public、private、protected、以及不写-默认-时的-区别\",\"90\":\"v-95dc3ca2#this关键字有什么作用\",\"91\":\"v-95dc3ca2#抽象类-abstract-class-和接口-interface-有什么区别\",\"92\":\"v-95dc3ca2#成员变量与局部变量的区别有哪些\",\"93\":\"v-95dc3ca2#静态变量和实例变量的区别-静态方法、实例方法呢\",\"94\":\"v-95dc3ca2#final关键字有什么作用\",\"95\":\"v-95dc3ca2#final、finally、finalize的区别\",\"96\":\"v-95dc3ca2#和-equals-的区别\",\"97\":\"v-95dc3ca2#hashcode与-equals\",\"98\":\"v-95dc3ca2#java是值传递-还是引用传递\",\"99\":\"v-95dc3ca2#什么是深拷贝和浅拷贝\",\"100\":\"v-95dc3ca2#java-创建对象有哪几种方式\",\"101\":\"v-fdfaa92c\",\"102\":\"v-fdfaa92c#说一下你对java内存模型-jmm-的理解\",\"103\":\"v-fdfaa92c#说说你对原子性、可见性、有序性的理解\",\"104\":\"v-fdfaa92c#分析下面几行代码的原子性\",\"105\":\"v-fdfaa92c#原子性、可见性、有序性都应该怎么保证呢\",\"106\":\"v-fdfaa92c#那说说什么是指令重排\",\"107\":\"v-fdfaa92c#指令重排有限制吗-happens-before了解吗\",\"108\":\"v-fdfaa92c#as-if-serial又是什么-单线程的程序一定是顺序的吗\",\"109\":\"v-fdfaa92c#volatile实现原理了解吗\",\"110\":\"v-fdfaa92c#volatile怎么保证可见性的呢\",\"111\":\"v-fdfaa92c#volatile怎么保证有序性的呢\",\"112\":\"v-b1bf17b8\",\"113\":\"v-b1bf17b8#threadlocal是什么\",\"114\":\"v-b1bf17b8#你在工作中用到过threadlocal吗\",\"115\":\"v-b1bf17b8#threadlocal怎么实现的呢\",\"116\":\"v-b1bf17b8#threadlocal-内存泄露是怎么回事\",\"117\":\"v-b1bf17b8#那怎么解决内存泄漏问题呢\",\"118\":\"v-b1bf17b8#为什么key还要设计成弱引用\",\"119\":\"v-b1bf17b8#threadlocalmap的结构了解吗\",\"120\":\"v-b1bf17b8#threadlocalmap怎么解决hash冲突的\",\"121\":\"v-b1bf17b8#threadlocalmap扩容机制了解吗\",\"122\":\"v-b1bf17b8#父子线程怎么共享数据\",\"123\":\"v-b1bf17b8#inheritablethreadlocal原理是什么呢\",\"124\":\"v-b1bf17b8#还有什么其它办法-ttl\",\"125\":\"v-758586f5\",\"126\":\"v-758586f5#并行跟并发有什么区别\",\"127\":\"v-758586f5#说说什么是进程和线程\",\"128\":\"v-758586f5#说说线程有几种创建方式\",\"129\":\"v-758586f5#为什么调用start-方法时会执行run-方法-那怎么不直接调用run-方法\",\"130\":\"v-758586f5#thread和runnable有什么区别\",\"131\":\"v-758586f5#线程有哪些常用的调度方法\",\"132\":\"v-758586f5#线程有几种状态\",\"133\":\"v-758586f5#blocked和waiting有什么区别\",\"134\":\"v-758586f5#waiting和terminated有什么区别\",\"135\":\"v-758586f5#什么是线程上下文切换\",\"136\":\"v-758586f5#线程上下文切换通常发生在以下几种情况下\",\"137\":\"v-758586f5#守护线程了解吗\",\"138\":\"v-758586f5#线程间有哪些通信方式\",\"139\":\"v-4cbedf23\",\"140\":\"v-4cbedf23#countdownlatch-倒计数器-了解吗\",\"141\":\"v-4cbedf23#cyclicbarrier-同步屏障-了解吗\",\"142\":\"v-4cbedf23#重要注意事项\",\"143\":\"v-4cbedf23#cyclicbarrier和countdownlatch有什么区别\",\"144\":\"v-4cbedf23#semaphore-信号量-了解吗\",\"145\":\"v-4cbedf23#解释\",\"146\":\"v-4cbedf23#重要注意事项-1\",\"147\":\"v-4cbedf23#exchanger-了解吗\",\"148\":\"v-4cbedf23#代码示例\",\"149\":\"v-4cbedf23#解释-1\",\"150\":\"v-4cbedf23#重要注意事项-2\",\"151\":\"v-4cbedf23#说说你对completablefuture的理解\",\"152\":\"v-4cbedf23#_1-引言\",\"153\":\"v-4cbedf23#_2-基本概念\",\"154\":\"v-4cbedf23#_2-1-创建-completablefuture\",\"155\":\"v-4cbedf23#_3-任务完成后的回调\",\"156\":\"v-4cbedf23#_3-1-thenapply\",\"157\":\"v-4cbedf23#_3-2-thenaccept\",\"158\":\"v-4cbedf23#_3-3-thenrun\",\"159\":\"v-4cbedf23#_4-组合多个-completablefuture\",\"160\":\"v-4cbedf23#_4-1-thencompose\",\"161\":\"v-4cbedf23#_4-2-thencombine\",\"162\":\"v-4cbedf23#_4-3-allof\",\"163\":\"v-4cbedf23#_5-处理异常\",\"164\":\"v-4cbedf23#_5-1-exceptionally\",\"165\":\"v-4cbedf23#_5-2-handle\",\"166\":\"v-4cbedf23#_6-超时控制\",\"167\":\"v-4cbedf23#_6-1-ortimeout\",\"168\":\"v-4cbedf23#_6-2-completeontimeout\",\"169\":\"v-4cbedf23#_7-并行执行多个任务\",\"170\":\"v-4cbedf23#示例\",\"171\":\"v-4cbedf23#_8-真实场景应用\",\"172\":\"v-4cbedf23#_8-1-并行获取数据\",\"173\":\"v-4cbedf23#_9-总结\",\"174\":\"v-4cbedf23#completablefuture的线程池设置\",\"175\":\"v-4cbedf23#_1-使用默认线程池\",\"176\":\"v-4cbedf23#_2-指定自定义线程池\",\"177\":\"v-4cbedf23#_2-1-创建自定义线程池\",\"178\":\"v-4cbedf23#_2-2-使用自定义线程池\",\"179\":\"v-4cbedf23#_3-完整示例\",\"180\":\"v-4cbedf23#_4-线程池类型\",\"181\":\"v-4cbedf23#_4-1-固定大小线程池\",\"182\":\"v-4cbedf23#_4-2-缓存线程池\",\"183\":\"v-4cbedf23#_4-3-单线程池\",\"184\":\"v-4cbedf23#_4-4-调度线程池\",\"185\":\"v-4cbedf23#_5-异步任务链中的线程池\",\"186\":\"v-bc3a2618\",\"187\":\"v-bc3a2618#说说阻塞队列是怎么实现的\",\"188\":\"v-266a0586\",\"189\":\"v-266a0586#什么是线程池\",\"190\":\"v-266a0586#_1-线程池的基本概念\",\"191\":\"v-266a0586#_2-线程池的优势\",\"192\":\"v-266a0586#_3-java中的线程池实现\",\"193\":\"v-266a0586#_3-1-常见的线程池类型\",\"194\":\"v-266a0586#_4-线程池的使用示例\",\"195\":\"v-266a0586#_5-线程池的配置参数\",\"196\":\"v-266a0586#_6-自定义线程池\",\"197\":\"v-266a0586#为什么说频繁创建和销毁线程的开销大\",\"198\":\"v-266a0586#_1-系统资源消耗\",\"199\":\"v-266a0586#_1-1-内存开销\",\"200\":\"v-266a0586#_1-2-操作系统资源\",\"201\":\"v-266a0586#_2-cpu消耗\",\"202\":\"v-266a0586#_2-1-线程上下文切换\",\"203\":\"v-266a0586#_2-2-同步开销\",\"204\":\"v-266a0586#_3-jvm的开销\",\"205\":\"v-266a0586#_3-1-垃圾回收\",\"206\":\"v-266a0586#_3-2-jit优化\",\"207\":\"v-266a0586#能说说工作中线程池的应用吗\",\"208\":\"v-266a0586#_1-web服务器\",\"209\":\"v-266a0586#场景描述\",\"210\":\"v-266a0586#解决方案\",\"211\":\"v-266a0586#代码示例\",\"212\":\"v-266a0586#_2-数据库连接池\",\"213\":\"v-266a0586#场景描述-1\",\"214\":\"v-266a0586#解决方案-1\",\"215\":\"v-266a0586#代码示例-1\",\"216\":\"v-266a0586#_3-并行数据处理\",\"217\":\"v-266a0586#场景描述-2\",\"218\":\"v-266a0586#解决方案-2\",\"219\":\"v-266a0586#代码示例-2\",\"220\":\"v-266a0586#_4-异步任务执行\",\"221\":\"v-266a0586#场景描述-3\",\"222\":\"v-266a0586#解决方案-3\",\"223\":\"v-266a0586#代码示例-3\",\"224\":\"v-266a0586#_5-定时任务\",\"225\":\"v-266a0586#场景描述-4\",\"226\":\"v-266a0586#解决方案-4\",\"227\":\"v-266a0586#代码示例-4\",\"228\":\"v-266a0586#能简单说一下线程池的工作流程吗\",\"229\":\"v-266a0586#_1-线程池初始化\",\"230\":\"v-266a0586#_2-任务提交\",\"231\":\"v-266a0586#_3-任务执行\",\"232\":\"v-266a0586#_4-任务执行完成\",\"233\":\"v-266a0586#_5-线程池关闭\",\"234\":\"v-266a0586#线程池的完整工作流程\",\"235\":\"v-266a0586#线程池主要参数有哪些\",\"236\":\"v-266a0586#线程池的拒绝策略有哪些\",\"237\":\"v-266a0586#线程池有哪几种工作队列\",\"238\":\"v-266a0586#线程池提交execute和submit有什么区别\",\"239\":\"v-266a0586#线程池怎么关闭知道吗\",\"240\":\"v-266a0586#线程池的线程数应该怎么配置\",\"241\":\"v-266a0586#线程池是怎么实现线程复用的\",\"242\":\"v-266a0586#有哪几种常见的线程池\",\"243\":\"v-266a0586#能说一下四种常见线程池的原理吗\",\"244\":\"v-266a0586#_1-fixedthreadpool-固定大小线程池\",\"245\":\"v-266a0586#_2-cachedthreadpool-缓存线程池\",\"246\":\"v-266a0586#_3-singlethreadexecutor-单线程线程池\",\"247\":\"v-266a0586#_4-scheduledthreadpool-定时任务线程池\",\"248\":\"v-266a0586#线程池异常怎么处理知道吗\",\"249\":\"v-266a0586#_1-捕获并处理异常\",\"250\":\"v-266a0586#_2-自定义线程池\",\"251\":\"v-266a0586#_3-使用-uncaughtexceptionhandler\",\"252\":\"v-266a0586#_4-使用自定义-rejectedexecutionhandler\",\"253\":\"v-266a0586#_5-使用-completablefuture-处理异步任务\",\"254\":\"v-266a0586#_6-使用-callable-和-future\",\"255\":\"v-266a0586#能说一下线程池有几种状态吗\",\"256\":\"v-266a0586#_1-running\",\"257\":\"v-266a0586#_2-shutdown\",\"258\":\"v-266a0586#_3-stop\",\"259\":\"v-266a0586#_4-tidying\",\"260\":\"v-266a0586#_5-terminated\",\"261\":\"v-266a0586#状态转换图\",\"262\":\"v-266a0586#线程池如何实现参数的动态修改\",\"263\":\"v-266a0586#线程池调优了解吗\",\"264\":\"v-266a0586#你能设计实现一个线程池吗\",\"265\":\"v-266a0586#单机线程池执行断电了应该怎么处理\",\"266\":\"v-266a0586#线程池并发调用api-有个调用特别耗时-怎么优化\",\"267\":\"v-266a0586#fork-join框架了解吗\",\"268\":\"v-421103ae\",\"269\":\"v-421103ae#synchronized用过吗-怎么使用\",\"270\":\"v-421103ae#synchronized的实现原理\",\"271\":\"v-421103ae#synchronized是怎么加锁的呢\",\"272\":\"v-421103ae#synchronized锁住的是什么呢\",\"273\":\"v-421103ae#除了原子性-synchronized可见性-有序性-可重入性怎么实现\",\"274\":\"v-421103ae#synchronized怎么保证可见性\",\"275\":\"v-421103ae#synchronized怎么保证有序性\",\"276\":\"v-421103ae#synchronized怎么实现可重入的呢\",\"277\":\"v-421103ae#锁升级-synchronized优化了解吗\",\"278\":\"v-421103ae#synchronized做了哪些优化\",\"279\":\"v-421103ae#锁升级的过程是什么样的\",\"280\":\"v-421103ae#偏向锁\",\"281\":\"v-421103ae#轻量级锁\",\"282\":\"v-421103ae#说说synchronized和reentrantlock的区别\",\"283\":\"v-421103ae#aqs了解多少\",\"284\":\"v-421103ae#reentrantlock实现原理\",\"285\":\"v-421103ae#公平锁-fairsync\",\"286\":\"v-421103ae#非公平锁-nonfairsync\",\"287\":\"v-421103ae#lock-的执行过程\",\"288\":\"v-421103ae#reentrantlock怎么实现公平锁的\",\"289\":\"v-421103ae#什么是cas\",\"290\":\"v-421103ae#cas-有什么问题-如何解决\",\"291\":\"v-421103ae#aba-问题\",\"292\":\"v-421103ae#怎么解决aba问题\",\"293\":\"v-421103ae#循环性能开销\",\"294\":\"v-421103ae#怎么解决循环性能开销问题\",\"295\":\"v-421103ae#只能保证一个变量的原子操作\",\"296\":\"v-421103ae#java有哪些保证原子性的方法-如何保证多线程下i-结果正确\",\"297\":\"v-421103ae#原子操作类了解多少\",\"298\":\"v-421103ae#atomicinteger-的原理\",\"299\":\"v-421103ae#线程死锁了解吗-该如何避免\",\"300\":\"v-421103ae#死锁问题怎么排查呢\",\"301\":\"v-2fb9c1b2\",\"302\":\"v-2fb9c1b2#arraylist和linkedlist有什么区别\",\"303\":\"v-2fb9c1b2#arraylist的扩容机制了解吗\",\"304\":\"v-2fb9c1b2#arraylist怎么序列化的知道吗-为什么用transient修饰数组\",\"305\":\"v-2fb9c1b2#为什么最arraylist不直接序列化元素数组呢\",\"306\":\"v-2fb9c1b2#那arraylist怎么序列化呢\",\"307\":\"v-2fb9c1b2#快速失败-fail-fast-和安全失败-fail-safe-了解吗\",\"308\":\"v-2fb9c1b2#实现arraylist线程安全有哪几种方法\",\"309\":\"v-2fb9c1b2#copyonwritearraylist了解多少\",\"310\":\"v-2fb9c1b2#数据拷贝的过程中-有其它线程写入数据怎么办\",\"311\":\"v-ae523934\",\"312\":\"v-ae523934#能说一下hashmap的数据结构吗\",\"313\":\"v-ae523934#你对红黑树了解多少-为什么不用二叉树-平衡树呢\",\"314\":\"v-ae523934#什么是红黑树\",\"315\":\"v-ae523934#为什么不用二叉树\",\"316\":\"v-ae523934#为什么不用平衡二叉树\",\"317\":\"v-ae523934#红黑树怎么保持平衡的知道吗\",\"318\":\"v-ae523934#hashmap的put流程知道吗\",\"319\":\"v-ae523934#hashmap怎么查找元素的呢\",\"320\":\"v-ae523934#hashmap的哈希-扰动函数是怎么设计的\",\"321\":\"v-ae523934#为什么哈希-扰动函数能降hash碰撞\",\"322\":\"v-ae523934#为什么hashmap的容量是2的倍数呢\",\"323\":\"v-ae523934#如果初始化hashmap-传一个17的值-new-hashmap-它会怎么处理\",\"324\":\"v-ae523934#你还知道哪些哈希函数的构造方法呢\",\"325\":\"v-ae523934#解决哈希冲突有哪些方法呢\",\"326\":\"v-ae523934#为什么hashmap链表转红黑树的阈值为8呢\",\"327\":\"v-ae523934#扩容在什么时候呢-为什么扩容因子是0-75\",\"328\":\"v-ae523934#那么为什么选择了0-75作为hashmap的默认加载因子呢\",\"329\":\"v-ae523934#hashmap扩容机制了解吗\",\"330\":\"v-ae523934#jdk1-8对hashmap主要做了哪些优化呢-为什么\",\"331\":\"v-ae523934#你能自己设计实现一个hashmap吗\",\"332\":\"v-ae523934#hashmap-是线程安全的吗-多线程下会有什么问题\",\"333\":\"v-ae523934#有什么办法能解决hashmap线程不安全的问题呢\",\"334\":\"v-ae523934#能说一下concurrenthashmap的具体实现吗\",\"335\":\"v-ae523934#jdk1-7-分段锁\",\"336\":\"v-ae523934#jdk1-8-cas-synchronized\",\"337\":\"v-ae523934#hashmap-内部节点是有序的吗\",\"338\":\"v-ae523934#讲讲-linkedhashmap-怎么实现有序的\",\"339\":\"v-ae523934#讲讲-treemap-怎么实现有序的\",\"340\":\"v-1aeb7fc0\",\"341\":\"v-1aeb7fc0#讲讲hashset的底层实现\",\"342\":\"v-03c57507\",\"343\":\"v-03c57507#说说有哪些常见集合\",\"344\":\"v-e1e3da16\",\"345\":\"v-aefb69fe\",\"346\":\"v-1303aad4\",\"347\":\"v-152c160c\",\"348\":\"v-5911796e\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1],\"1\":[1,6],\"2\":[1,1],\"3\":[1,1],\"4\":[2,1],\"5\":[1],\"6\":[1],\"7\":[1],\"8\":[1,6],\"9\":[1,4],\"10\":[1,8],\"11\":[1,154],\"12\":[1,4],\"13\":[1],\"14\":[1,7],\"15\":[1],\"16\":[4,6],\"17\":[3,23],\"18\":[1],\"19\":[3],\"20\":[1,8],\"21\":[2,12],\"22\":[3,8],\"23\":[3,7],\"24\":[1,2],\"25\":[null,null,1],\"26\":[null,null,1],\"27\":[1],\"28\":[5,22],\"29\":[3,22],\"30\":[4,55],\"31\":[2],\"32\":[3,45],\"33\":[3,7],\"34\":[2,10],\"35\":[2,38],\"36\":[3,105],\"37\":[1],\"38\":[2,7],\"39\":[6,44],\"40\":[3,5],\"41\":[3,15],\"42\":[5,12],\"43\":[1],\"44\":[2,85],\"45\":[1],\"46\":[2,15],\"47\":[2,8],\"48\":[1,11],\"49\":[1],\"50\":[2,53],\"51\":[3,5],\"52\":[3,4],\"53\":[3,3],\"54\":[6,24],\"55\":[5,15],\"56\":[2,6],\"57\":[2,12],\"58\":[1],\"59\":[6,30],\"60\":[3,56],\"61\":[10,20],\"62\":[3,13],\"63\":[2,8],\"64\":[11,33],\"65\":[3,10],\"66\":[3,21],\"67\":[1],\"68\":[3,53],\"69\":[2,43],\"70\":[1],\"71\":[3,14],\"72\":[2,7],\"73\":[2,15],\"74\":[1,65],\"75\":[1],\"76\":[2,7],\"77\":[2,15],\"78\":[2,19],\"79\":[2,12],\"80\":[1],\"81\":[2,56],\"82\":[1],\"83\":[2,16],\"84\":[2,7],\"85\":[1],\"86\":[2,13],\"87\":[2,21],\"88\":[6,23],\"89\":[8,19],\"90\":[2,7],\"91\":[7,42],\"92\":[2,41],\"93\":[4,29],\"94\":[2,6],\"95\":[4,42],\"96\":[4,10],\"97\":[3,32],\"98\":[3,14],\"99\":[2,24],\"100\":[3,6],\"101\":[1],\"102\":[4,32],\"103\":[4,33],\"104\":[2,19],\"105\":[4,13],\"106\":[2,34],\"107\":[4,51],\"108\":[5,14],\"109\":[2,2],\"110\":[2,10],\"111\":[2,29],\"112\":[1],\"113\":[2,29],\"114\":[2,2],\"115\":[2,14],\"116\":[3,20],\"117\":[2,3],\"118\":[2,9],\"119\":[2,43],\"120\":[2,26],\"121\":[2,82],\"122\":[2,33],\"123\":[2,48],\"124\":[3,12],\"125\":[1],\"126\":[2,10],\"127\":[2,10],\"128\":[2,12],\"129\":[5,10],\"130\":[2,25],\"131\":[2,97],\"132\":[2,31],\"133\":[2,11],\"134\":[2,7],\"135\":[2,16],\"136\":[1,15],\"137\":[2,22],\"138\":[2,56],\"139\":[1],\"140\":[4,74],\"141\":[4,15],\"142\":[1,98],\"143\":[2,46],\"144\":[4,76],\"145\":[1,25],\"146\":[1,30],\"147\":[3,16],\"148\":[1,59],\"149\":[1,19],\"150\":[1,39],\"151\":[2],\"152\":[2,8],\"153\":[2],\"154\":[4,16],\"155\":[2],\"156\":[3,14],\"157\":[3,12],\"158\":[2,11],\"159\":[3],\"160\":[3,15],\"161\":[3,17],\"162\":[3,34],\"163\":[2],\"164\":[3,22],\"165\":[3,24],\"166\":[2],\"167\":[3,24],\"168\":[3,25],\"169\":[2],\"170\":[1,70],\"171\":[2],\"172\":[3,67],\"173\":[2,2],\"174\":[2,9],\"175\":[2,17],\"176\":[2,7],\"177\":[3,16],\"178\":[2,13],\"179\":[2,58],\"180\":[2],\"181\":[3,8],\"182\":[3,8],\"183\":[3,7],\"184\":[2,8],\"185\":[2,35],\"186\":[1],\"187\":[2,43],\"188\":[1],\"189\":[2,6],\"190\":[2,12],\"191\":[2,9],\"192\":[2,5],\"193\":[3,27],\"194\":[2,59],\"195\":[2,16],\"196\":[2,70],\"197\":[2,5],\"198\":[2],\"199\":[2,11],\"200\":[3,5],\"201\":[2],\"202\":[3,9],\"203\":[2,5],\"204\":[2],\"205\":[3,6],\"206\":[3,6],\"207\":[2,4],\"208\":[2],\"209\":[1,6],\"210\":[1,5],\"211\":[1,44],\"212\":[2],\"213\":[1,4],\"214\":[1,5],\"215\":[1,66],\"216\":[2],\"217\":[1,7],\"218\":[1,5],\"219\":[1,65],\"220\":[2],\"221\":[1,8],\"222\":[1,4],\"223\":[1,47],\"224\":[2],\"225\":[1,4],\"226\":[1,4],\"227\":[1,49],\"228\":[2,7],\"229\":[2,26],\"230\":[2,18],\"231\":[2,18],\"232\":[2,8],\"233\":[2,23],\"234\":[1,16],\"235\":[2,50],\"236\":[2,24],\"237\":[2,55],\"238\":[2,39],\"239\":[2,48],\"240\":[2,47],\"241\":[2,19],\"242\":[2,42],\"243\":[2],\"244\":[4,36],\"245\":[4,43],\"246\":[4,36],\"247\":[4,29],\"248\":[2,5],\"249\":[2,23],\"250\":[2,51],\"251\":[3,26],\"252\":[3,31],\"253\":[4,14],\"254\":[5,63],\"255\":[2,12],\"256\":[2,9],\"257\":[2,13],\"258\":[2,15],\"259\":[2,15],\"260\":[2,12],\"261\":[1,2],\"262\":[2,35],\"263\":[2,54],\"264\":[2,86],\"265\":[2,33],\"266\":[4,48],\"267\":[3,174],\"268\":[1],\"269\":[3,34],\"270\":[2],\"271\":[2,12],\"272\":[2,72],\"273\":[5],\"274\":[2,7],\"275\":[2,12],\"276\":[2,12],\"277\":[3,22],\"278\":[2,33],\"279\":[2,7],\"280\":[1,47],\"281\":[1,43],\"282\":[2,42],\"283\":[2,52],\"284\":[2,9],\"285\":[2,8],\"286\":[2,11],\"287\":[2,17],\"288\":[2,50],\"289\":[2,36],\"290\":[4,4],\"291\":[2,13],\"292\":[2,29],\"293\":[1,4],\"294\":[2,5],\"295\":[1,8],\"296\":[4,10],\"297\":[2,24],\"298\":[3,32],\"299\":[3,57],\"300\":[2,23],\"301\":[1],\"302\":[2,51],\"303\":[2,41],\"304\":[3,7],\"305\":[2,6],\"306\":[2,7],\"307\":[7,68],\"308\":[2,25],\"309\":[2,37],\"310\":[3,3],\"311\":[1],\"312\":[2,32],\"313\":[4],\"314\":[2,17],\"315\":[2,11],\"316\":[2,8],\"317\":[2,6],\"318\":[2,71],\"319\":[2,51],\"320\":[3,12],\"321\":[3,8],\"322\":[2,26],\"323\":[6,7],\"324\":[2,20],\"325\":[2,23],\"326\":[2,21],\"327\":[4,6],\"328\":[3,17],\"329\":[2,9],\"330\":[4,43],\"331\":[2,7],\"332\":[4,26],\"333\":[2,19],\"334\":[2,6],\"335\":[3,30],\"336\":[3,109],\"337\":[3,13],\"338\":[4,8],\"339\":[4,13],\"340\":[1],\"341\":[2,47],\"342\":[1],\"343\":[2,3],\"344\":[1],\"345\":[1],\"346\":[1],\"347\":[1],\"348\":[1]},\"averageFieldLength\":[2.315300859598851,24.12819520125805,0.07407407407407407],\"storedFields\":{\"0\":{\"h\":\"鱼塘\"},\"1\":{\"h\":\"关于网站\",\"t\":[\"欢迎来到鱼塘\",\"传送门：GitHub | Gitee。\",\"项目介绍\"]},\"2\":{\"h\":\"关于作者\",\"t\":[\"关于作者\"]},\"3\":{\"h\":\"占个位\",\"t\":[\"占个位\"]},\"4\":{\"h\":\"Star 趋势\",\"t\":[\"Stars\"]},\"5\":{\"h\":\"主页\"},\"6\":{\"h\":\"幻灯片页\"},\"7\":{\"h\":\"三分钟搭建一个博客网站\"},\"8\":{\"h\":\"三分钟搭建一个博客网站\",\"t\":[\"基于vuepress-theme-hope 和 github pages搭建\"]},\"9\":{\"h\":\"准备运行环境\",\"t\":[\"安装nodejs 下载地址\",\"安装pnpm 参考资料\"]},\"10\":{\"h\":\"创建项目模板\",\"t\":[\"pnpm create vuepress-theme-hope my-docs \"]},\"11\":{\"h\":\"创建过程\",\"t\":[\"PowerShell 7.4.0 PS C:\\\\Users\\\\daiwencheng\\\\Documents\\\\BaiduSyncdisk\\\\ob\\\\ob\\\\blogs> pnpm create vuepress-theme-hope my-docs .../Local/pnpm/store/v3/tmp/dlx-7428 | +83 ++++++++ .../Local/pnpm/store/v3/tmp/dlx-7428 | Progress: resolved 83, reused 61, downloaded 22, added 83, done ? Select a language to display / 选择显示语言 简体中文 ? 选择包管理器 pnpm 生成 package.json... ? 设置应用名称 vuepress-theme-hope-template ? 设置应用版本号 2.0.0 ? 设置应用描述 A project of vuepress-theme-hope ? 设置协议 MIT ? 项目需要用到多语言么? No ? 是否需要一个自动部署文档到 GitHub Pages 的工作流？ Yes ? 你想要创建什么类型的项目？ blog 生成模板... ? 是否初始化 Git 仓库? Yes 安装依赖... 这可能需要数分钟，请耐心等待. 我们无法正确输出子进程的进度条，所以进程可能会看似未响应 WARN 2 deprecated subdependencies found: rollup-plugin-terser@7.0.2, sourcemap-codec@1.4.8 Packages: +606 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ Progress: resolved 639, reused 409, downloaded 197, added 606, done node_modules/.pnpm/esbuild@0.19.8/node_modules/esbuild: Running postinstall script, done in 825ms devDependencies: + @vuepress/client 2.0.0-rc.0 + vue 3.3.10 + vuepress 2.0.0-rc.0 + vuepress-theme-hope 2.0.0-rc.2 The dependency was already listed in devDependencies. If you want to make it a prod dependency, then move it manually. Done in 25.3s 模板已成功生成! ? 是否想要现在启动 Demo 查看? Yes 启动开发服务器... 启动成功后，请在浏览器输入给出的开发服务器地址(默认为 'localhost:8080') > vuepress-theme-hope-template@2.0.0 docs:dev C:\\\\Users\\\\daiwencheng\\\\Documents\\\\BaiduSyncdisk\\\\ob\\\\ob\\\\blogs\\\\my-docs > vuepress dev src vite v5.0.6 dev server running at: ➜ Local: http://localhost:8080/ ➜ Network: http://10.246.84.128:8080/ \"]},\"12\":{\"h\":\"访问\",\"t\":[\"打开http://localhost:8080/ 访问\"]},\"13\":{\"h\":\"效果\"},\"14\":{\"h\":\"项目启动命令\",\"t\":[\"需要先进入项目目录 my-docs\",\"npm run docs:dev \"]},\"15\":{\"h\":\"发布到github\"},\"16\":{\"h\":\"修改 deploy-docs.yml\",\"t\":[\"on: push: branches: # 确保这是你正在使用的分支名称 - master \"]},\"17\":{\"h\":\"修改 config.ts\",\"t\":[\"export default defineUserConfig({ base: \\\"/my-docs/\\\", lang: \\\"zh-CN\\\", title: \\\"博客演示\\\", description: \\\"vuepress-theme-hope 的博客演示\\\", theme, // Enable it with pwa // shouldPrefetch: false, }); \"]},\"18\":{\"h\":\"共享项目到GitHub\"},\"19\":{\"h\":\"从master新建分支gh-pages,推送新分支到github\"},\"20\":{\"h\":\"GitHub上开源\",\"t\":[\"打开仓库my-docs\",\"打开Settings\",\"底部设置Change visibility 为change to public\"]},\"21\":{\"h\":\"配置Github Pages\",\"t\":[\"打开仓库my-docs的Settings项,选中侧边栏pages,配置部署分支为gh-pages,点击save.\",\"在actions菜单栏中应该会触发自动发布,没有的话随便修改下master分支代码,就会触发自动发布\",\"发布完成后,此时pages页会显示访问域名,点击访问即可\"]},\"22\":{\"h\":\"更新博客只在master分支上改,不要动gh-pages分支\",\"t\":[\"master 是源码分支 gh-pages是发布分支 master的代码都是ts和一些markdown文件,需要build成html文件和js才行,即gh-pages\"]},\"23\":{\"h\":\"修复\\\"编辑此页\\\"功能链接跳转不对问题\",\"t\":[\"修改theme.ts\",\"docsBranch: 文档所在分支,默认值: \\\"main\\\"\"]},\"24\":{\"h\":\"踩坑\",\"t\":[\"踩了一些坑,可以看提交记录\"]},\"25\":{\"c\":[\"前端\"]},\"26\":{\"c\":[\"JavaScript\"]},\"27\":{\"h\":\"IO\"},\"28\":{\"h\":\"Java 中 IO 流分为几种?\",\"t\":[\"按照流的流向分，可以分为 输入流 和 输出流 \",\"InputStream / Reader : 所有的输入流的基类，前者是字节输入流，后者是字符输入流\",\"OutputStream / Writer : 所有输出流的基类，前者是字节输出流，后者是字符输出流\",\"按照操作单元划分，可以划分为 字节流 和 字符流\",\"按照流的角色划分为 节点流 和 处理流\"]},\"29\":{\"h\":\"既然有了字节流,为什么还要有字符流？\",\"t\":[\"字节流\",\"字节流则更适合处理二进制数据\",\"字节流以字节为单位进行输入输出，适用于处理二进制数据（例如图像、音频、视频等）或与底层设备进行通信时。字节流通常用于处理文件和网络连接中的数据传输。它们是处理数据的底层工具，提供了最基本的输入输出操作。\",\"字符流\",\"字符流更适合读取和写入文本文件\",\"字符流以字符为单位进行输入输出，适用于处理文本数据。字符流会自动处理字符编码和解码，而字节流则需要手动处理。这使得字符流在处理文本数据时更方便和高效，尤其是当涉及到国际化和本地化时、\",\"尽管字节流可以处理所有类型的数据，但为了更方便地处理文本数据，Java提供了字符流\"]},\"30\":{\"h\":\"BIO、NIO、AIO？\",\"t\":[\"BIO\",\"同步阻塞IO\",\"客户端有连接请求时服务器端就需要启动一个线程进行处理（可以使用连接池优化）\",\"JDK1.4之前的选择\",\"NIO\",\"同步非阻塞IO\",\"服务器端用一个线程处理多个连接，客户端发送的连接请求会注册到多路复用器上，多路复用器轮询到连接有IO请求就进行处理\",\"NIO工作原理\",\"应用程序（A）通过选择器（B）发起连接请求\",\"选择器（B）将通道（channel代表了服务端与客户端的连接）注册，使其成为监视对象，以便选择器可以监听多个通道的事件。\",\"当有新的连接请求到达时，选择器（B）会处理这个事件，并将新的通道（C）加入到已注册的通道列表（D）中，以备后续操作。\",\"选择器（B）不断监听通道列表（D）中通道的读写事件。\",\"当某个通道（E）有读或写事件时，选择器（B）会将该通道标记为就绪状态，并执行相应的读取或写入操作。\",\"读取或写入操作使用缓冲区（F）来处理数据，应用程序可以在缓冲区中读取或写入数据。\",\"AIO\",\"异步非阻塞IO\",\"Java 的 NIO 就是 Reactor\",\"当有事件触发时，服务器端得到通知，进行相应的处理，完成后才通知(回调)服务端程序启动线程去处理\",\"一般适用于连接数较多且连接时间较长的应用\"]},\"31\":{\"h\":\"JDK1.8新特性\"},\"32\":{\"h\":\"JDK1.8都有哪些新特性？\",\"t\":[\"接口的默认方法和静态方法 \",\"在Java 8中，接口可以包含默认方法和静态方法\",\"Lambda 表达式和函数式接口 \",\"Lambda 表达式本质上是一段匿名内部类，可以传递一段代码\",\"Lambda 允许把函数作为一个方法的参数（函数作为参数传递到方法中），使用 Lambda 表达式使代码更加简洁\",\"但是也不要滥用，否则会有可读性等问题\",\"《Effective Java》作者 Josh Bloch 建议使用 Lambda 表达式最好不要超过3行\",\"Stream API \",\"Stream API提供了一种更简洁、更易于并行处理数据集合的方式\",\"通过Stream API，我们可以对集合进行过滤、映射、排序、聚合等操作，提高了代码的可读性和简洁性\",\"新的日期和时间API \",\"Java 8引入了新的日期和时间API（java.time包），提供了更好的日期和时间处理方式\",\"新的API解决了旧的Date和Calendar类在处理日期和时间时的一些问题，并提供了更多的功能和灵活性\",\"Optional 类 \",\"Optional类是一个容器类，用于表示一个值可能存在或不存在\",\"通过Optional类，我们可以避免空指针异常，并更好地处理可能为空的值\"]},\"33\":{\"h\":\"Lambda 表达式了解多少？\",\"t\":[\"Lambda 表达式本质上是一段匿名内部类，也可以是一段可以传递的代码\",\"只有函数式接口（FunctionalInterface）才能缩写成 Lambda 表示式\"]},\"34\":{\"h\":\"Java8有哪些内置函数式接口？\",\"t\":[\"添加了 @FunctionalInterface 注解的接口 \",\"Comparator\",\"Runnable\",\"Callable\",\"Predicate\",\"Function\",\"Supplier\",\"Consumer\"]},\"35\":{\"h\":\"Optional了解吗？\",\"t\":[\"Optional 是用于防范 NullPointerException\",\"可以将 Optional 看做是包装对象（可能是 null , 也有可能非 null ）的容器\",\"当我们定义了 一个方法，这个方法返回的对象可能是空，也有可能非空的时候，我们就可以考虑用 Optional 来包装它，这也是在 Java 8 被推荐使用的做法\",\"Optional<String> optional = Optional.of(\\\"bam\\\"); optional.isPresent(); // true optional.get(); // \\\"bam\\\" optional.orElse(\\\"fallback\\\"); // \\\"bam\\\" optional.ifPresent((s) -> System.out.println(s.charAt(0))); \"]},\"36\":{\"h\":\"Stream 流用过吗？\",\"t\":[\"Stream 流，简单来说，使用 java.util.Stream 对一个包含一个或多个元素的集合做各种操作\",\"这些操作可能是 中间操作 亦或是 终端操作\",\"终端操作会返回一个结果，而中间操作会返回一个 Stream 流\",\"Stream流一般用于集合，Stream的常用操作有\",\" List<String> stringCollection = new ArrayList<>(); stringCollection.add(\\\"ddd2\\\"); stringCollection.add(\\\"aaa2\\\"); stringCollection.add(\\\"bbb1\\\"); stringCollection.add(\\\"aaa1\\\"); stringCollection.add(\\\"bbb3\\\"); stringCollection.add(\\\"ccc\\\"); stringCollection.add(\\\"bbb2\\\"); stringCollection.add(\\\"ddd1\\\"); \",\"Filter 过滤\",\"stringCollection .stream() .filter((s) -> s.startsWith(\\\"a\\\")) .forEach(System.out::println); \",\"Sorted 排序\",\" stringCollection .stream() .sorted() .filter((s) -> s.startsWith(\\\"a\\\")) .forEach(System.out::println); \",\"Map 转换\",\" stringCollection .stream() .map(String::toUpperCase) .sorted((a, b) -> b.compareTo(a)) .forEach(System.out::println); \",\"Match 匹配\",\"// 验证 list 中 string 是否有以 a 开头的, 匹配到第一个，即返回 true boolean anyStartsWithA = stringCollection .stream() .anyMatch((s) -> s.startsWith(\\\"a\\\")) boolean allStartsWithA = stringCollection .stream() .allMatch((s) -> s.startsWith(\\\"a\\\")); System.out.println(allStartsWithA); // false // 验证 list 中 string 是否都不是以 z 开头的, boolean noneStartsWithZ = stringCollection .stream() .noneMatch((s) -> s.startsWith(\\\"z\\\")) \",\"Count 计数\",\"// 先对 list 中字符串开头为 b 进行过滤，让后统计数量 long startsWithB = stringCollection .stream() .filter((s) -> s.startsWith(\\\"b\\\")) .count(); \",\"count 是一个终端操作，它能够统计 stream 流中的元素总数，返回值是 long类型\",\"Reduce归约\",\"Optional<String> reduced = stringCollection .stream() .sorted() .reduce((s1, s2) -> s1 + \\\"#\\\" + s2); \",\"Reduce 中文翻译为：减少、缩小。通过入参的 Function ，我们能够将 list归约成一个值。它的返回类型是 Optional 类型\",\"Stream的常用API\"]},\"37\":{\"h\":\"Java概述\"},\"38\":{\"h\":\"Java语言有哪些特点？\",\"t\":[\"面向对象 \",\"封装\",\"继承\",\"多态\",\"平台无关性\",\"支持多线程\",\"编译与解释并存\"]},\"39\":{\"h\":\"JVM、JDK 和 JRE 有什么区别？\",\"t\":[\"JVM\",\"Java Virtual Machine，Java虚拟机，Java程序运行在Java虚拟机上。针对不同 系统的实现（Windows，Linux，macOS）不同的JVM，因此Java语言可以实现跨平 台。\",\"JRE\",\"Java 运⾏时环境。它是运⾏已编译 Java 程序所需的所有内容的集合，包括Java 虚拟机（JVM），Java 类库，Java 命令和其他的⼀些基础构件。但是，它不能⽤于创建新程序。\",\"JDK\",\"Java Development Kit，它是功能⻬全的 Java SDK。它拥有 JRE 所拥有的⼀ 切，还有编译器（javac）和⼯具（如 javadoc 和 jdb）。它能够创建和编译程序。 简单来说，JDK包含JRE，JRE包含JVM。\"]},\"40\":{\"h\":\"说说什么是跨平台性？原理是什么?\",\"t\":[\"跨平台：一次编译，多操作系统运行\",\"实现原理：不同系统安装不同Java虚拟机\"]},\"41\":{\"h\":\"什么是字节码？采用字节码的好处是什么?\",\"t\":[\".class文件\",\"字节码能够被虚拟机识别，从而实现Java程序的跨平台性\",\"Java 程序从源代码到运行主要有三步 \",\"编译：.java ->.class\",\"解释：虚拟机执行Java字节码，.class -机器码\",\"执行 ：对应的操作系统执行二进制机器码\"]},\"42\":{\"h\":\"为什么说 Java 语言“编译与解释并存”？\",\"t\":[\"因为 Java 程序要经过先编译，后解释两个步骤 \",\"由 Java 编写的程序需要先经过编译步骤，生成字节码（ *.class 文件）\",\"这种字节码必须再经过JVM，解释成操作系统能识别的机器码，再由操作系统执行\"]},\"43\":{\"h\":\"其它\"},\"44\":{\"h\":\"说下什么是Java的SPI机制？\",\"t\":[\"Java的SPI（Service Provider Interface）机制是Java标准库提供的一种服务发现机制\",\"它允许第三方组件在不修改源代码的情况下，通过在Classpath中提供配置文件，向应用程序注入实现了特定接口的服务提供者\",\"SPI中的几个关键元素\",\"服务接口（Service Interface）： 定义了服务的契约，描述了服务提供者需要实现的接口或抽象类\",\"服务提供者（Service Provider）： 实现了服务接口的具体类，并通过配置文件等方式注册到SPI框架中\",\"服务提供者配置文件（Service Provider Configuration File）： 是一种元数据文件，通常位于META-INF/services/目录下，文件名为服务接口的全限定名。该文件包含了服务接口的实现类的全限定名，每个实现类占据一行\",\"服务加载器（Service Loader）： 是用于加载和实例化服务提供者的API。它在运行时查找并加载META-INF/services/目录下的配置文件，并根据配置文件中指定的实现类实例化相应的对象\",\"SPI机制的工作原理如下\",\"定义服务接口\",\"首先，应用程序定义一个接口，这个接口是服务的契约，规定了需要提供的功能或扩展点\",\"public interface HelloService { void sayHello(); } \",\"编写服务提供者\",\"接着，编写服务提供者，实现服务接口，并提供了具体的功能实现\",\"public class HelloServiceImpl implements HelloService { @Override public void sayHello() { System.out.println(\\\"Hello from HelloServiceImpl!\\\"); } } \",\"编写服务提供者配置文件\",\"每个服务提供者将自己的实现类配置到一个特定的配置文件中，该文件位于 META-INF/services/ 目录下，以接口的全限定名命名\",\"com.example.service.HelloServiceImpl com.example.service.HelloServiceImpl2 \",\"服务加载\",\"在应用程序运行时，Java的SPI机制会使用服务加载器加载这些配置文件，并根据文件中指定的实现类，实例化对应的服务提供者对象\",\"ServiceLoader<HelloService> loader =ServiceLoader.load(HelloService.class) \",\"服务使用\",\"ServiceLoader<HelloService> loader =ServiceLoader.load(HelloService.class) for (HelloService service : loader) { service.sayHello(); } \",\"SPI机制的优势\",\"解耦了服务的实现和调用方\",\"应用程序可以在不修改源代码的情况下，动态地替换、扩展或定制某个功能或组件的实现\",\"SPI机制的应用场景\",\"数据库驱动、日志框架、插件系统等\"]},\"45\":{\"h\":\"反射\"},\"46\":{\"h\":\"什么是反射？\",\"t\":[\"new 对象 \",\"创建对象实例的方式\",\"在编译时候就确定了类型信息\",\"反射 \",\"在运行时动态地获取类信息、创建类实例、调用类方法这时候就要用到反射\",\"通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性\",\"反射相关类 \",\"Class\",\"Method\",\"Field\",\"Constructor\"]},\"47\":{\"h\":\"反射的应用场景？\",\"t\":[\"Spring/Spring Boot、MyBatis 等等框架中都大量使用了反射机制\",\"Spring里的很多注解 ，它真正的功能实现就是利用反射 \",\"@Component\",\"@Value\"]},\"48\":{\"h\":\"反射的实现原理\",\"t\":[\"基于Java虚拟机（JVM）的类加载机制和类对象模型\",\"在Java中，每个类都有一个对应的Class对象，该对象包含了类的名称、字段、方法等信息\",\"通过反射，我们可以获取到Class对象信息，并在运行时动态地操作类和对象\"]},\"49\":{\"h\":\"基础语法\"},\"50\":{\"h\":\"Java有哪些数据类型？\",\"t\":[\"基本数据类型\",\"数值型 \",\"整数类型（byte、short、int、long）\",\"浮点类型（float、double）\",\"字符型（char）\",\"布尔型（boolean）\",\"基本类型\",\"位数\",\"字节\",\"默认值\",\"最小值\",\"最大值\",\"int\",\"32\",\"4\",\"0\",\"-2^31\",\"2^31-1\",\"short\",\"16\",\"2\",\"0\",\"-2^15\",\"2^15-1\",\"long\",\"64\",\"8\",\"0L\",\"-2^63\",\"2^63-1\",\"byte\",\"8\",\"1\",\"0\",\"-128\",\"127\",\"char\",\"16\",\"2\",\"'\\\\u0000'\",\"'\\\\u0000'\",\"'\\\\uffff'\",\"float\",\"32\",\"4\",\"0.0f\",\"1.4E-45\",\"3.4028235E38\",\"double\",\"64\",\"8\",\"0.0d\",\"4.9E-324\",\"1.7976931348623157E308\",\"boolean\",\"1\",\"false\",\"引用数据类型\",\"类（class）\",\"接口（interface）\",\"数组([])\"]},\"51\":{\"h\":\"什么是自动类型转换、强制类型转换？\",\"t\":[\"自动类型转换：把一个表数范围小的数值或变量直接赋给另一个数范围大的变量时\",\"强制类型转换：反之，需要强制转换\"]},\"52\":{\"h\":\"什么是自动拆箱/封箱？\",\"t\":[\"装箱 ：将基本类型用它们对应的引用类型包装起来\",\"拆箱 ：将包装类型转换为基本数据类型\"]},\"53\":{\"h\":\"&和&&有什么区别？\",\"t\":[\"&：短路与\",\"&&：逻辑与\"]},\"54\":{\"h\":\"switch 是否能作用在 byte/long/String上？\",\"t\":[\"Java5 以前 switch(expr)中，expr 只能是 byte、short、char、int\",\"从 Java 5 开始，Java 中引入了枚举类型， expr 也可以是 enum 类型\",\"从 Java 7 开始，expr还可以是字符串(String)，但是长整型(long)在目前所有的版本中都是不可以的\"]},\"55\":{\"h\":\"break ,continue ,return 的区别及作用？\",\"t\":[\"break 跳出整个循环，不再执行循环( 结束当前的循环体 )\",\"continue 跳出本次循环，继续执行下次循环( 结束正在执行的循环 进入下一个循环条件 )\",\"return 程序返回，不再执行下面的代码( 结束当前的方法 直接返回 )\"]},\"56\":{\"h\":\"用最有效率的方法计算2乘以8？\",\"t\":[\"2 << 3。位运算，数字的二进制位左移三位相当于乘以2的三次方。\"]},\"57\":{\"h\":\"说说自增自减运算？\",\"t\":[\"++和--运算符可以放在变量之前，也可以放在变量之后\",\"运算符放在变量之前时(前缀)，先自增/减，再赋值\",\"当运算符放在变量之后时(后缀)，先赋值，再自增/减\"]},\"58\":{\"h\":\"常用类\"},\"59\":{\"h\":\"String 是 Java 基本数据类型吗？可以被继承吗？\",\"t\":[\"String是Java基本数据类型吗？\",\"不是，引用数据类型\",\"String 类可以继承吗?\",\"不行。String类在Java中被声明为final类，这意味着它不能被继承\",\"这样设计的原因\",\"字符串的不可变性\",\"String类的不可变性使得它可以被安全地用于多线程环境下，不会出现线程安全问题\",\"任何对 String 对象的操作（如拼接、替换等）都会返回一个新的 String 对象，而不会修改原始对象的值\",\"字符串常量池的优化\",\"由于字符串是不可变的，Java可以对字符串进行缓存和共享，以提高性能和节省内存\",\"这就是通过字符串常量池来实现的，它存储了所有字符串字面量的唯一实例\",\"安全性和可靠性\",\"String类的不可变性使得它在安全性和可靠性方面更加可靠。例如，它可以被用作Map的键，因为它的哈希值是固定的\"]},\"60\":{\"h\":\"String和StringBuilder、StringBuffer？\",\"t\":[\"类名\",\"可变性\",\"线程安全性\",\"性能\",\"String\",\"不可变\",\"线程安全\",\"低\",\"StringBuffer\",\"可变\",\"线程安全\",\"低\",\"StringBuilder\",\"可变\",\"非线程安全\",\"高\",\"String类 \",\"String是不可变的，使用 private final char value[] 来存储字符串，一旦创建就不能修改其值 \",\"jdk11使用byte[]存储字符串\",\"任何对String的修改都会创建一个新的String对象\",\"String类是线程安全的，因为它的不可变性保证了多个线程可以安全地共享String对象\",\"由于不可变性的特性，对于频繁的字符串拼接操作，会产生大量的临时对象，影响性能\",\"StringBuffer类 \",\"StringBuffer是可变的，使用 char value[] 存储字符串，它的值可以被修改\",\"为了保证线程安全性，StringBuffer的方法都使用synchronized关键字进行同步，在多线程环境下，使用StringBuffer可以保证线程安全\",\"由于同步的开销，StringBuffer的性能相对较低\",\"StringBuilder类 \",\"StringBuilder是StringBuffer的非线程安全版本，它的方法没有使用synchronized关键字进行同步\",\"在单线程环境下，使用StringBuilder可以获得更好的性能\",\"在多线程环境下使用StringBuilder，需要自行保证线程安全\",\"使用建议 \",\"操作的数据量较小，可以使用String类\",\"多线程环境下操作大量的数据，需要保证线程安全，可以使用StringBuffer类\",\"单线程环境下操作大量的数据，可以使用StringBuilder类以，性能更好\"]},\"61\":{\"h\":\"String str1 = new String(\\\"abc\\\")和String str2 = \\\"abc\\\" 和 区别？\",\"t\":[\"对象创建过程 \",\"两个语句都会去字符串常量池中检查是否已经存在 “abc”，如果有则直接使用，如果没有则会在常量池中创建 “abc” 对象\",\"String str1 = new String(\\\"abc\\\") 还会通过 new String() 在堆里创建一个\\\"abc\\\" 字符串对象实例\",\"String s = new String(\\\"abc\\\")创建了几个对象？ \",\"一个或两个 \",\"如果字符串常量池已经有“abc”，则是一个；否则，两个\"]},\"62\":{\"h\":\"String不是不可变类吗？字符串拼接是如何实现的？\",\"t\":[\"String的确是不可变的，“+”的拼接操作，其实是会生成新的对象\",\"在jdk1.8之前，那么会生成多个中间对象 \",\"a和b初始化时位于字符串常量池，a+b拼接后的对象位于堆中。经过拼接新生成了String对象。如果拼接多次，那么会生成多个中间对象\",\"在Java8时JDK对“+”号拼接会编译成StringBuilder的append方法\"]},\"63\":{\"h\":\"intern方法有什么作用？\",\"t\":[\"如果当前字符串内容存在于字符串常量池（即equals()方法为true，也就是内容一样），直接返回字符串常量池中的字符串\",\"否则，将此String对象添加到池中，并返回String对象的引用\"]},\"64\":{\"h\":\"Integer a= 127，Integer b = 127；Integer c= 128，Integer d =128；相等吗?\",\"t\":[\"是a和b相等，c和d不相等 \",\"Integer a= 127这种赋值，是用到了Integer自动装箱的机制。自动装箱的时候会去缓存池里取Integer对象，没有取到才会创建新的对象\",\"如果整型字面量的值在-128到127之间，那么自动装箱时不会new新的Integer对象，而是直接引用缓存池中的Integer对象，超过范围 a1==b1的结果是false\",\"什么是Integer缓存？ \",\"因为根据实践发现大部分的数据操作都集中在值比较小的范围，因此 Integer 搞了个缓存池，默认范围是 -128 到 127，可以根据通过设置 JVM-XX:AutoBoxCacheMax=来修改缓存的最大值，最小值改不了\",\"实现的原理是int 在自动装箱的时候会调用Integer.valueOf，进而用到了IntegerCache\",\"IntegerCache是一个静态内部类， 在静态块中会初始化好缓存值\"]},\"65\":{\"h\":\"String怎么转成Integer的？原理？\",\"t\":[\"方法\",\"Integer.parseInt(String s)\",\"Integer.valueOf(String s)\",\"原理\",\"最终都调用parseInt(String s, int radix) 方法\"]},\"66\":{\"h\":\"Object 类的常见方法?\",\"t\":[\"对象比较 \",\"hashCode()\",\"equals(Object obj)\",\"对象拷贝 \",\"clone()\",\"对象转字符串 \",\"toString()\",\"多线程调度 \",\"wait()\",\"wait(long timeout)\",\"wait(long timeout,int nanos)\",\"notify()\",\"notifyAll()\",\"反射 \",\"getClass()\",\"垃圾回收 \",\"finalize\"]},\"67\":{\"h\":\"序列化\"},\"68\":{\"h\":\"什么是序列化？什么是反序列化？\",\"t\":[\"序列化 \",\"把Java对象转为二进制流，方便存储和传输\",\"反序列化 \",\"把二进制流恢复成对象\",\"Serializable接口有什么用？ \",\"用于标识类可以被序列化\",\"实现Serializable接口的类可以将对象转换为字节流进行传输和存储，实现数据的持久化和 跨平台的数据交换\",\"serialVersionUID 又有什么用 \",\"版本控制 \",\"当一个类被序列化后，如果后续对该类进行了修改，例如添加、删除或修改了类的属性、方法等，那么序列化和反序列化时可能会出现版本不一致的问题。为了避免这种问题，可以在类中显式地定义serialVersionUID字段，并确保在类的修改后，serialVersionUID的值保持不变。当反序列化时，会比较序列化类的版本号和当前类的版本号是否一致，如果不一致，则会抛出InvalidClassException异常\",\"兼容性 \",\"当一个类的实例被序列化后，如果在后续的版本中对该类进行了修改，但是仍然希望能够反序列化之前的序列化数据，那么可以通过显式地指定serialVersionUID来保持兼容性。如果新版本的类和旧版本的类具有相同的serialVersionUID，那么即使类的结构发生了变化，仍然可以成功反序列化之前的序列化数据\",\"Java 序列化不包含静态变量 \",\"Java序列化只会保存对象的非静态成员变量，不包含静态变量\",\"静态变量属于类的状态信息，在序列化时不需要保存\",\"如果有些变量不想序列化，怎么办？ \",\"使用 transient 关键字修饰\",\"transient 关键字的作用 \",\"阻止实例中那些用此关键字修饰的的变量序列化\",\"当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复\",\"transient 只能修饰变量，不能修饰类和方法\"]},\"69\":{\"h\":\"说说有哪些常见的序列化方式？\",\"t\":[\"Java对象流序列化 \",\"Java对象流序列化是Java标准库提供的一种序列化方式\",\"通过实现Serializable接口和Externalizable接口来实现对象的序列化和反序列化\",\"Java序列化可以将对象序列化为字节流，也可以将对象序列化为JSON、XML等格式\",\"JSON序列化 \",\"是一种轻量级的数据交换格式，常用于Web应用中\",\"Java中可以使用第三方库，如Jackson、Gson等，将对象序列化为JSON格式，也可以将JSON格式的数据反序列化为Java对象\",\"XML序列化 \",\"XML（Extensible Markup Language）是一种标记语言，常用于Web应用中\",\"Java中可以使用第三方库，如JAXB、XStream等，将对象序列化为XML格式，也可以将XML格式的数据反序列化为Java对象\",\"Protobuf序列化 \",\"Protobuf（Protocol Buffers）是Google开发的一种高效的序列化协议\",\"可以将结构化的数据序列化为紧凑的二进制格式\",\"Java中可以使用Google提供的protobuf-java库，将对象序列化为Protobuf格式，也可以将Protobuf格式的数据反序列化为Java对象\",\"Hessian序列化 \",\"Hessian是一种基于HTTP的轻量级二进制序列化协议\",\"可以将Java对象序列化为二进制格式，并通过HTTP协议进行传输\",\"Java中可以使用第三方库，如Hessian、Dubbo等，将对象序列化为Hessian格式，也可以将Hessian格式\\n的数据反序列化为Java对象\"]},\"70\":{\"h\":\"异常处理\"},\"71\":{\"h\":\"Java 中异常层级结构?\",\"t\":[\"Throwable \",\"Error \",\"内部错误，是程序无法处理的，比如虚拟机异常\",\"Exception \",\"CheckedException \",\"受检异常：编译器会强制检查并要求处理的异常\",\"RuntimeException \",\"运行时异常：程序运行中出现异常，比如我们熟悉的空指针、数组下标越界等等\",\"Exception\"]},\"72\":{\"h\":\"异常的处理机制？\",\"t\":[\"抛出异常 \",\"throw\",\"throws\",\"系统自动抛异常\",\"捕获异常 \",\"try catch\"]},\"73\":{\"h\":\"finally一定会执行吗？\",\"t\":[\"可能不会执行的情况\",\"程序还没有进入try语句块就因为异常导致程序终止\",\"在try块中调用了System.exit()方法：System.exit()方法会终止Java虚拟机的运行，导致程序直接退出，此时finally块中的代码不会执行\",\"在try块中发生了死循环或无限递归：如果try块中的代码导致了无限循环或无限递归，程序将无法继续执行，finally块中的代码也无法执行\",\"在try块中发生了线程死锁：如果try块中的代码导致了线程死锁，程序将无法继续执行，finally块中的代码也无法执行\"]},\"74\":{\"h\":\"三道经典异常处理代码题\",\"t\":[\"题目1：finally中正常执行（执行顺序：先finally，再catch中return）\",\"public static void main(String[] args) { System.out.println(test()); } public static int test() { try { return 1; } catch (Exception e) { return 2; } finally { System.out.print(\\\"3\\\"); } } \",\"执行结果：31\",\"解析：try、catch。finally 的基础用法，在 return 前会先执行 finally 语句块，所以是先输出 finally 里的 3，再输出 return 的 1\",\"题目2：finally中return（按finally中return的为准）\",\"public static void main(String[] args) { System.out.println(test()); } public static int test() { try { return 2; } finally { return 3; } } \",\"执行结果：3\",\"解析：try 返回前先执行 finally，结果 finally 里不按套路出牌，直接 return 了，自然也就走不到 try 里面的 return 了\",\"题目3：finally中修改try中return的值（修改是无效的）\",\"public static void main(String[] args) { System.out.println(test()); } public static int test() { int i = 0; try { i = 2; return i; } finally { i = 3; } } \",\"执行结果：2\",\"在执行 finally 之前，JVM 会先将 i 的结果暂存起来，然后 finally 执行完毕后，会返回之前暂存的结果，而不是返回 i，所以即使 i 已经被修改为 3，最终返回的还是之前暂存起来的结果 2\"]},\"75\":{\"h\":\"泛型\"},\"76\":{\"h\":\"什么是泛型？\",\"t\":[\"用于在编译时期提供类型安全的参数化类型 \",\"Java泛型是Java 5引入的一个特性\",\"通过使用泛型，可以在编写代码时指定类、接口或方法的参数和返回值的类型，从而增加代码的可读性和安全性\"]},\"77\":{\"h\":\"泛型的使用方法？\",\"t\":[\"泛型类\",\"public class ClassName <T> \",\"泛型接口\",\"public interface InterfaceName <T> \",\"泛型方法\",\"public static <T> ReturnType functionName \",\"public <T> ReturnType functionName(T arg) \"]},\"78\":{\"h\":\"泛型常用的通配符有哪些？\",\"t\":[\"?表示不确定的 java 类型\",\"T(type)表示具体的一个 java 类型\",\"K V (key value) 分别代表 java 键值中的 Key Value\",\"E (element) 代表 Element\"]},\"79\":{\"h\":\"什么是泛型擦除？\",\"t\":[\"泛型主要是为了提供编译时类型检查，而在运行时，泛型信息会被擦除，这就是泛型擦除\",\"优点：提高了代码的运行效率和与旧版本 Java 的兼容性（JDK5之前是没有泛型 ）\",\"缺点：在运行时获取泛型类型信息，以及无法使用基本类型作为泛型参数等\"]},\"80\":{\"h\":\"注解\"},\"81\":{\"h\":\"说一下你对注解的理解？\",\"t\":[\"Java注解本质上是一个标记\",\"注解可以标记在类上、方法上、属性上等，标记自身也可以设置一些值\",\"有了标记之后，我们就可以在编译或者运行阶段去识别这些标记，然后搞一些事情，这就是注解的用处\",\"AOP，使用注解作为切点就是运行期注解的应用\",\"lombok，就是注解在编译期的运行\",\"注解生命周期\",\"RetentionPolicy.SOURCE\",\"给编译器用的，不会写入 class 文件\",\"@Target(ElementType.METHOD) @Retention(RetentionPolicy.SOURCE) public @interface Override { } \",\"RetentionPolicy.CLASS\",\"会写入 class 文件，在类加载阶段丢弃，也就是运行的时候就没这个信息了\",\"没找到 \",\"RetentionPolicy.RUNTIME\",\"会写入 class 文件，永久保存，可以通过反射获取注解信息\",\"@Target({ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.PARAMETER, ElementType.FIELD, ElementType.ANNOTATION_TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface Autowired { /** * Declares whether the annotated dependency is required. * <p>Defaults to {@code true}. */ boolean required() default true; } \"]},\"82\":{\"h\":\"集合基础\"},\"83\":{\"h\":\"Java中实现Map接口的有哪些类？\",\"t\":[\"HashMap：基于哈希表实现的Map，无序，允许键和值为null。\",\"LinkedHashMap：基于哈希表和双向链表实现的Map，保持插入顺序或访问顺序。\",\"TreeMap：基于红黑树实现的有序Map，按照键的自然顺序或自定义顺序进行排序。\",\"Hashtable：基于哈希表实现的Map，线程安全，不允许键和值为null。\",\"ConcurrentHashMap：基于哈希表实现的线程安全的Map，支持高并发操作\"]},\"84\":{\"h\":\"遍历HashMap的几种方法？\",\"t\":[\"使用迭代器遍历\",\"使用for-each循环遍历键集合或值集合\",\"使用for-each循环遍历键值对\",\"使用Java 8的Stream API遍历\"]},\"85\":{\"h\":\"面向对象\"},\"86\":{\"h\":\"⾯向对象和⾯向过程的区别?\",\"t\":[\"⾯向过程\",\"面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候再一个一个的一次调用就可以。\",\"⾯向对象\",\"面向对象，把构成问题的事务分解成各个对象，而建立对象的目的也不是为了完成一个个步骤，而是为了描述某个事件在解决整个问题的过程所发生的行为。 目的是为了写出通用的代码，加强代码的重用，屏蔽差异性。\"]},\"87\":{\"h\":\"面向对象有哪些特性?\",\"t\":[\"封装 \",\"封装把⼀个对象的属性私有化，同时提供⼀些可以被外界访问的属性的⽅法\",\"继承 \",\"继承是使⽤已存在的类的定义作为基础创建新的类，新类的定义可以增加新的属性或新的方法，也可以继承父类的属性和方法。通过继承可以很方便地进行代码复用\",\"多态 \",\"所谓多态就是指程序中定义的引⽤变量所指向的具体类型和通过该引⽤变量发出的⽅法调⽤在编程时并不确定，⽽是在程序运⾏期间才确定\",\"即⼀个引⽤变量到底会指向哪个类的实例对象，该引⽤变量发出的⽅法调⽤到底是哪个类中实现的⽅法，必须在由程序运⾏期间才能决定\",\"在 Java 中有两种形式可以实现多态：继承（多个⼦类对同⼀⽅法的重写）和接⼝（实现接⼝并覆盖接⼝中同⼀⽅法）\"]},\"88\":{\"h\":\"重载（overload）和重写（override）的区别？\",\"t\":[\"方法重载和方法重写都是实现多态性的方式\",\"区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性\",\"方法重载\",\"方法名相同，形参不同（参数个数、参数类型、参数顺序满足任一）则视为重载；\",\"与返回值和修饰符无关\",\"调用方法不同，与异常类型更没关系\",\"发生在同一个类中\",\"方法重写\",\"方法名相同，形参相同\",\"基本数据类型相同，若为引用数据类型则返回值为被重写方法的返回值或是其子类\",\"重写方法不能抛出范围更大的受控异常（父类不希望子类出现更多的异常）\",\"重写方法的访问权限可以更广（子类可以扩大方法的访问范围）\",\"发生在具有继承关系的父子类中\"]},\"89\":{\"h\":\"访问修饰符public、private、protected、以及不写（默认）时的 区别?\",\"t\":[\"default (即默认，什么也不写） \",\"在同一包内可见，不使用任何修饰符。可以修饰在类、接口、变量、方法。\",\"private \",\"在同一类内可见。可以修饰变量、方法。\",\"注意：不能修饰外部类\",\"public \",\"对所有类可见。可以修饰类、接口、变量、方法\",\"protected \",\"对同一包内的类和所有子类可见。可以修饰变量、方法。\",\"注意：不能修饰外部类\"]},\"90\":{\"h\":\"this关键字有什么作用？\",\"t\":[\"指向对象本身的一个指针\",\"this的用法在Java中大体可以分为3种 \",\"普通的直接引用，this相当于是指向当前对象本身\",\"形参与成员变量名字重名，用this来区分\",\"引用本类的构造函数\"]},\"91\":{\"h\":\"抽象类(abstract class)和接口(interface)有什么区别？\",\"t\":[\"方法实现 \",\"接口中的方法默认是公开的(public)，只能定义，不能实现。从JDK 8开始，接口中的方法可以有默认实现，而抽象类可以包含非抽象的方法 \",\"如果同时实现两个接口，并且接口中定义了相同的默认方法，则必须重写方法，否则会报错\",\"在JDK 8中，接口也可以定义静态方法，并且可以直接使用接口名调用 \",\"实现类和实例不能调用静态方法\",\"JDK 9允许在接口中定义私有方法\",\"变量 \",\"接口中只能包含静态(static)和常量(final)变量，不能有其他类型的变量。而抽象类中可以包含任意类型的变量\",\"实现 \",\"一个类可以实现多个接口，但只能继承一个抽象类。接口自身可以通过extends关键字扩展多个接口\",\"方法修饰符 \",\"接口中的方法默认修饰符是public，抽象方法可以有public、protected和default修饰符。抽象方法是为了被重写，所以不能使用private修饰符\",\"设计层面 \",\"抽象类是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为规范\"]},\"92\":{\"h\":\"成员变量与局部变量的区别有哪些？\",\"t\":[\"成员变量 = 实例变量 + 静态变量（类变量）\",\"语法形式 \",\"成员变量是在类中声明的变量，可以被public、private、static等修饰符所修饰\",\"成员变量包括实例变量和静态变量（类变量） \",\"实例变量是每个对象独有的，而静态变量是类共享的\",\"局部变量是在方法中或代码块中声明的变量，不能被访问控制修饰符及static所修饰\",\"存储方式 \",\"实例变量存储在堆内存中\",\"静态变量存储在方法区（元空间）的静态存储区，所有对象共享同一份静态变量的拷贝\",\"局部变量存在栈内存中，随着方法或代码块的执行而创建和销毁\",\"生存周期 \",\"静态变量在类被加载至数据区后，只有当程序结束时才会被销毁，它的生命周期与程序的生命周期相同。\",\"实例变量即对象变量，随对象的创建而生，随对象的销毁而销毁\",\"局部变量只在方法或代码块内有效，一旦超出这个范围就不再有效\",\"默认值 \",\"非final修饰的成员变量具有默认值，而局部变量没有默认值\",\"成员变量的默认值根据其类型而定，例如整型默认为0，布尔型默认为false，引用类型默认为null\",\"局部变量在使用前必须显式地进行初始化\"]},\"93\":{\"h\":\"静态变量和实例变量的区别？静态方法、实例方法呢？\",\"t\":[\"静态变量 \",\"是被 static 修饰符修饰的变量，也称为类变量，它属于类，不属于类的任何一个对象，一个类不管创建多少个对象，静态变量在内存中有且仅有一个副本\",\"实例变量 \",\"必须依存于某一实例，需要先创建对象然后通过对象才能访问到它。静态变量可以实现让多个对象共享内存\",\"静态方法 \",\"static修饰的方法，也被称为类方法\",\"在外部调⽤静态⽅法时，可以使⽤\\\"类名.⽅法名\\\"的⽅式，也可以使⽤\\\"对象名.⽅法名\\\"的⽅式\",\"静态方法里不能访问类的非静态成员变量和方法\",\"实例⽅法 \",\"依存于类的实例\",\"需要使用\\\"对象名.⽅法名\\\"的⽅式调用\",\"可以访问类的所有成员变量和方法\"]},\"94\":{\"h\":\"final关键字有什么作用？\",\"t\":[\"被final修饰的类不可以被继承\",\"被final修饰的方法不可以被重写\",\"被final修饰的变量不可变，被final修饰的变量必须被显式第指定初始值 \",\"这里的不可变指的是变量的引用不可变，不是引用指向的内容的不可变\"]},\"95\":{\"h\":\"final、finally、finalize的区别？\",\"t\":[\"final 用于修饰变量、方法和类 \",\"final修饰的类不可被继承\",\"修饰的方法不可被重写\",\"修饰的变量不可变\",\"在 try/catch 语句中，最终一定被执行 \",\"经常被用在需要释放资源的情况下\",\"System.exit (0) 可以阻断 finally 执行\",\"finalize 是在 java.lang.Object 里定义的方法 \",\"这个方法在 gc 启动，该对象被回收的时候被调用\",\"一个对象的 finalize 方法只会被调用一次，finalize 被调用不一定会立即回收该对象 \",\"不推荐使用 \",\"有可能调用 finalize 后，该对象又不需要被回收了，然后到了真正要被回收的时候，因为前面调用过一次，所以不会再次调用 finalize 了，进而产生问题，因此不推荐使用 finalize 方法\"]},\"96\":{\"h\":\"==和 equals 的区别？\",\"t\":[\"== \",\"判断两个对象是不是同⼀个对象 \",\"基本数据类型==比较的是值\",\"引⽤数据类型==比较的是内存地址\",\"equals() \",\"判断两个对象是否相等\",\"默认情况类没有覆盖 equals() ⽅法，等价于通过“ == ”比较这两个对象\"]},\"97\":{\"h\":\"hashCode与 equals?\",\"t\":[\"什么是HashCode？ \",\"hashCode方法用于获取对象的哈希码，哈希码是一个整数，用来表示对象的唯一标识\",\"哈希码常用于哈希表等数据结构的实现中，可以快速定位对象\",\"为什么重写 quals 时必须重写 hashCode ⽅法？ \",\"这是Java的规定，主要目的是确保 Java 中的集合类（例如 HashMap、HashSet 等）能够正确地工作并保持一致性 \",\"对象相等性原则 \",\"如果两个对象根据 equals() 方法判断相等，则它们的 hashCode() 方法的返回值必须相等\",\"hashCode() 的默认⾏为是对堆上的对象产⽣独特值。如果没有重写 hashCode() ，则该class 的两个对象⽆论如何都不会相等（即使这两个对象指向相同的数据）\"]},\"98\":{\"h\":\"Java是值传递，还是引用传递？\",\"t\":[\"Java语言是值传递 \",\"当传递基本数据类型（如int、float、boolean等）时 \",\"传递的是该值的副本，对形参的修改不会影响实参\",\"当传递对象引用时 \",\"传递的是该引用的副本，而不是对象本身。因此，对形参引用的修改不会影响实参引用的指向，但可以通过引用修改对象的状态\"]},\"99\":{\"h\":\"什么是深拷贝和浅拷贝?\",\"t\":[\"浅拷贝 \",\"仅拷贝被拷贝对象的成员变量的值，也就是基本数据类型变量的值，和引用数据类型变量的地址值，而对于引用类型变量指向的堆中的对象不会拷贝。\",\"深拷贝 \",\"完全拷贝一个对象，拷贝被拷贝对象的成员变量的值，堆中的对象也会拷贝一份\",\"深拷贝是安全的 \",\"浅拷贝的话如果有引用类型，那么拷贝后对象，引用类型变量修改，会影响原对象\",\"浅拷贝如何实现呢？ \",\"Object类提供的clone()方法可以非常简单地实现对象的浅拷贝\",\"深拷贝如何实现呢？ \",\"重写克隆方法 \",\"重写克隆方法，引用类型变量单独克隆，这里可能会涉及多层递归\",\"序列化 \",\"可以先讲原对象序列化，再反序列化成拷贝对象\"]},\"100\":{\"h\":\"Java 创建对象有哪几种方式？\",\"t\":[\"new创建新对象\",\"通过反射机制\",\"采用clone机制\",\"通过序列化机制 \",\"Java中序列化可以通过实现Externalizable或者Serializable来实现\",\"或者使用json序列化\"]},\"101\":{\"h\":\"Java内存模型\"},\"102\":{\"h\":\"说一下你对Java内存模型（JMM）的理解 ？\",\"t\":[\"Java内存模型（Java Memory Model，JMM），是一种抽象的模型，被定义出来屏蔽各种硬件和操作系统的内存访问差异\",\"JMM定义了线程和主内存之间的抽象关系\",\"线程之间的共享变量存储在 主内存（Main Memory）中，每个线程都有一个私有的 本地内存 （Local Memory），本地内存中存储了该线程以读/写共享变量的副本 \",\"Java内存模型的抽象图\",\"本地内存是JMM的 一个抽象概念，并不真实存在，实际的线程工作模型如下图所示，其中每个线程都有自己的控制器和运算器，以及一级缓存。有些架构还有一个共享的二级缓存。这些硬件组件对应着JMM中的工作内存\",\"Java内存模型通过定义内存间的交互操作规则，例如读取、写入和同步操作，来确保多线程程序的可见性、有序性和原子性。\"]},\"103\":{\"h\":\"说说你对原子性、可见性、有序性的理解？\",\"t\":[\"原子性、有序性、可见性是并发编程中非常重要的基础概念，用于描述多线程环境下的内存访问行为，JMM的很多技术都是围绕着这三大特性展开\",\"原子性（Atomicity） \",\"原子性是指一个操作是不可分割的，要么完全执行，要么不执行。\",\"在多线程环境下，原子性保证了对共享变量的操作是原子的，不会被其他线程中断\",\"可见性（Visibility） \",\"可见性是指当一个线程对共享变量进行修改后，其他线程能够立即看到这个修改\",\"在多线程环境下，由于每个线程都有自己的本地内存，线程之间对共享变量的修改不一定能够及时同步到主内存和其他线程的本地内存中\",\"可见性保证了共享变量的修改对其他线程是可见的，即能够正确读取到最新的值\",\"有序性（Ordering） \",\"是指程序执行的顺序与代码的顺序一致\",\"在多线程环境下，由于指令重排序和编译器优化的存在，代码的执行顺序可能与代码的编写顺序不一致\",\"序性保证了程序的执行顺序与代码的顺序一致，即保证了代码的串行语义\",\"为了保证原子性、可见性和有序性，我们可以使用同步机制（如锁、volatile关键字、synchronized关键字等）来控制线程的访问和操作\"]},\"104\":{\"h\":\"分析下面几行代码的原子性？\",\"t\":[\"int i = 2; int j = i; i++; i = i + 1; \",\"第1句是基本类型赋值，是原子性操作\",\"第2句先读i的值，再赋值到j，两步操作，不能保证原子性\",\"第3和第4句其实是等效的，先读取i的值，再+1，最后赋值到i，三步操作了，不能保证原子性\"]},\"105\":{\"h\":\"原子性、可见性、有序性都应该怎么保证呢？\",\"t\":[\"原子性 \",\"使用同步机制，如synchronized关键字、Lock接口、Atomic类等，来控制对共享变量的访问和操作，确保操作是不可分割的\",\"可见性 \",\"使用volatile关键字或者同步机制，如synchronized关键字、Lock接口等，来保证对共享变量的修改对其他线程是可见的\",\"有序性 \",\"使用volatile关键字或者同步机制，如synchronized关键字、Lock接口等，来保证程序执行的顺序与代码的顺序一致\"]},\"106\":{\"h\":\"那说说什么是指令重排？\",\"t\":[\"在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排序\",\"重排序分3种类型 \",\"编译器优化的重排序 \",\"编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序\",\"指令级并行的重排序 \",\"现代处理器采用了指令级并行技术（Instruction-Level Parallelism，ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应 机器指令的执行顺序\",\"内存系统的重排序 \",\"由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行\",\"双重校验单例模式就是一个经典的指令重排的例子：Singleton instance=new Singleton() \",\"对应的JVM指令分为三步：分配内存空间-->初始化对象--->对象指向分配的内存空间\",\"经过了编译器的指令重排序，第二步和第三步就可能会重排序\",\"JMM属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证\"]},\"107\":{\"h\":\"指令重排有限制吗？happens-before了解吗？\",\"t\":[\"指令重排也是有一些限制的，有两个规则 happens-before 和 as-if-serial 来约束\",\"happens-before的定义 \",\"如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前\",\"两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照 happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么这种重排序并不非法\",\"happens-before和我们息息相关的有六大规则 \",\"程序顺序规则 \",\"一个线程中的每个操作，happens-before于该线程中的任意后续操作\",\"监视器锁规则 \",\"对一个锁的解锁，happens-before于随后对这个锁的加锁\",\"volatile变量规则 \",\"对一个volatile域的写，happens-before于任意后续对这个volatile域的读\",\"传递性 \",\"如果A happens-before B，且B happens-before C，那么A happens-beforeC\",\"start()规则 \",\"如果线程A执行操作ThreadB.start()（启动线程B），那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作\",\"join()规则 \",\"如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作 happens-before于线程A从ThreadB.join()操作成功返回\"]},\"108\":{\"h\":\"as-if-serial又是什么？单线程的程序一定是顺序的吗？\",\"t\":[\"as-if-serial语义的意思是：不管怎么重排序（编译器和处理器为了提高并行度），单线程程序的执行结果不能被改变\",\"编译器、runtime和处理器都必须遵守as-if-serial语义\",\"为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果\",\"如果操作之间不存在数据依赖关系，这些操作就可能被编译器和处理器重排序\"]},\"109\":{\"h\":\"volatile实现原理了解吗？\",\"t\":[\"volatile有两个作用，保证可见性和有序性\"]},\"110\":{\"h\":\"volatile怎么保证可见性的呢？\",\"t\":[\"相比synchronized的加锁方式来解决共享变量的内存可见性问题，volatile就是更轻量的选择，它没有上下文切换的额外开销成本\",\"volatile可以确保对某个变量的更新对其他线程马上可见 \",\"一个变量被声明为volatile时，线程在写入变量时不会把值缓存在寄存器或者其他地方，而是会把值刷新回主内存\",\"当其它线程读取该共享变量 ，会从主内存重新获取最新值，而不是使用当前线程的本地内存中的值\"]},\"111\":{\"h\":\"volatile怎么保证有序性的呢？\",\"t\":[\"重排序可以分为编译器重排序和处理器重排序，valatile保证有序性，就是通过分别限制这两种类型的重排序\",\"为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序 \",\"在每个volatile写操作的前面插入一个 StoreStore 屏障 \",\"功能：确保在屏障前的所有写操作（存储操作）都在屏障后的写操作之前被刷新到主内存中。即确保第一个存储操作的结果对后续的存储操作可见。\",\"在每个volatile写操作的后面插入一个 StoreLoad 屏障 \",\"确保在屏障前的所有写操作在屏障后的所有读操作（加载操作）之前被刷新到主内存中。即防止写操作重排序到读操作之后\",\"在每个volatile读操作的后面插入一个 LoadLoad 屏障 \",\"功能：确保在屏障前的所有读操作都完成之后，再进行屏障后的读操作。即确保第一个加载操作的结果对后续的加载操作可见。\",\"在每个volatile读操作的后面插入一个 LoadStore 屏障 \",\"功能：确保在屏障前的所有读操作都完成之后，再进行屏障后的写操作。即防止读操作重排序到写操作之后\",\"​\"]},\"112\":{\"h\":\"ThreadLocal\"},\"113\":{\"h\":\"ThreadLocal是什么？\",\"t\":[\"ThreadLocal，也就是线程本地变量\",\"创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的一个本地拷贝\",\"多个线程操作这个变量的时候，实际是操作自己本地内存里面的变量，从而起到线程隔离的作用，避免了线程 安全问题\",\"创建\",\"创建了一个ThreadLoca变量localVariable，任何一个线程都能并发访问localVariable。\",\"//创建一个ThreadLocal变量 public static ThreadLocal<String> localVariable = new ThreadLocal<>(); \",\"写入\",\"线程可以在任何地方使用localVariable，写入变量\",\"localVariable.set(\\\"鄙人张三”); \",\"读取\",\"线程在任何地方读取的都是它写入的变量。\",\" localVariable.get(); \"]},\"114\":{\"h\":\"你在工作中用到过ThreadLocal吗？\",\"t\":[\"用来做用户信息上下文的存储 \",\"存放token\"]},\"115\":{\"h\":\"ThreadLocal怎么实现的呢？\",\"t\":[\"Thread类有一个类型为ThreadLocal.ThreadLocalMap的实例变量threadLocals，每个线程都有一个属于自己的ThreadLocalMap\",\"ThreadLocalMap内部维护着Entry数组，每个Entry代表一个完整的对象，key是ThreadLocal的弱引用，value是ThreadLocal的泛型值\",\"每个线程在往ThreadLocal里设置值的时候，都是往自己的ThreadLocalMap里存，读也是以某个ThreadLocal作为引用，在自己的map里找对应的key，从而实现了线程隔离\",\"ThreadLocal本身不存储值，它只是作为一个key来让线程往ThreadLocalMap里存取值\"]},\"116\":{\"h\":\"ThreadLocal 内存泄露是怎么回事？\",\"t\":[\"ThreadLocalMap中使用的 key 为 ThreadLocal 的弱引用 \",\"弱引用：只要垃圾回收机制一运行，不管JVM的内存空间是否充足，都会回收该对象占用的内存。\",\"弱引用很容易被回收，如果ThreadLocal（ThreadLocalMap的Key）被垃圾回收器回收了，但是ThreadLocalMap生命周期和Thread是一样的，它这时候如果不被回收，就会出现这种情况：ThreadLocalMap的key没了，value还在，这 就会造成了内存泄漏问题\"]},\"117\":{\"h\":\"那怎么解决内存泄漏问题呢？\",\"t\":[\"使用完ThreadLocal后，及时调用remove()方法释放内存空间\"]},\"118\":{\"h\":\"为什么key还要设计成弱引用？\",\"t\":[\"key设计成弱引用同样是为了防止内存泄漏问题 \",\"在ThreadLocal中，每个ThreadLocal实例都对应着一个ThreadLocalMap对象，而ThreadLocalMap使用ThreadLocal实例作为键，用于存储线程局部变量的值。\",\"如果将ThreadLocal实例作为强引用存储在ThreadLocalMap中，那么即使线程不再使用某个ThreadLocal实例，该实例也无法被垃圾回收，从而可能导致内存泄漏\"]},\"119\":{\"h\":\"ThreadLocalMap的结构了解吗？\",\"t\":[\"元素数组\",\"一个table数组，存储Entry类型的元素，Entry是ThreaLocal弱引用作为key，Object作为value的结构\",\"private Entry[] table \",\"散列方法\",\"散列方法就是怎么把对应的key映射到table数组的相应下标，ThreadLocalMap用的是哈希取余法，取出key的threadLocalHashCode，然后和table数组长度减一&运算（相当于取余）\",\"int i = key.threadLocalHashCode & (table.length - 1); \",\"这里的threadLocalHashCode计算有点东西，每创建一个ThreadLocal对象，它就会新增 0x61c88647\",\"这个值很特殊，它是斐波那契数 也叫 黄金分割数\",\"hash 增量为 这个数字，带来的好处就是 hash 分布非常均匀\",\"private static final int HASH_INCREMENT = 0x61c88647; private static int nextHashCode() { return nextHashCode.getAndAdd(HASH_INCREMENT); } \"]},\"120\":{\"h\":\"ThreadLocalMap怎么解决Hash冲突的？\",\"t\":[\"开放定址法\",\"简单来说，就是这个坑被人占了，那就接着去找空着的坑，往后找一圈没找到就会从头开始找\",\"如上图所示，如果我们插入一个value=27的数据，通过 hash计算后应该落入第 4 个槽位中，而槽位 4 已经有了 Entry数据，而且Entry数据的key和当前不相等。此时就会线性向后查找，一直找到 Entry为 null的槽位才会停止查找，把元素放到空的槽中\",\"在get的时候，也会根据ThreadLocal对象的hash值，定位到table中的位置，然后判断该槽位Entry对象中的key是否和get的key一致，如果不一致，就判断下一个位置\"]},\"121\":{\"h\":\"ThreadLocalMap扩容机制了解吗？\",\"t\":[\"rehash()时机\",\"在ThreadLocalMap.set()方法的最后，如果执行完启发式清理工作后，未清理到任何数据，且当前散列数组中 Entry 的数量已经达到了列表的扩容阈值 (len*2/3) ，就开始执行 rehash() 逻辑\",\"if (!cleanSomeSlots(i, sz) && sz >= threshold) rehash(); \",\"rehash\",\"会先去清理过期的Entry\",\"然后还要根据条件判断size >= threshold - threshold / 4 也就是 size >= threshold* 3/4 来决定是否需要扩容\",\"private void rehash() { //清理过期Entry expungeStaleEntries(); // Use lower threshold for doubling to avoid hysteresis if (size >= threshold - threshold / 4) resize(); } \",\"resize\",\"扩容后的 newTab 的大小为老数组的两倍\",\"然后遍历老的table数组，散列方法重新计算位置\",\"开放地址解决冲突，然后放到新的newTab ，遍历完成之后， oldTab 中所有的 entry 数据都已经放入到 newTab 中了，然后table引用指向 newTab\",\" private void resize() { Entry[] oldTab = table; int oldLen = oldTab.length; int newLen = oldLen * 2; Entry[] newTab = new Entry[newLen]; int count = 0; for (Entry e : oldTab) { if (e != null) { ThreadLocal<?> k = e.get(); if (k == null) { e.value = null; // Help the GC } else { int h = k.threadLocalHashCode & (newLen - 1); while (newTab[h] != null) h = nextIndex(h, newLen); newTab[h] = e; count++; } } } setThreshold(newLen); size = count; table = newTab; } \"]},\"122\":{\"h\":\"父子线程怎么共享数据？\",\"t\":[\"InheritableThreadLocal\",\"在主线程的InheritableThreadLocal实例设置值，在子线程中就可以拿到了\",\"public class InheritableThreadLocalTest { public static void main(String[] args) { final ThreadLocal threadLocal = new InheritableThreadLocal(); // 主线程 threadLocal.set(\\\"不擅技术\\\"); //子线程 Thread t = new Thread() { @Override public void run() { super.run(); System.out.println(\\\"鄙人三某 ，\\\" + threadLocal.get()); } }; t.start(); } } \"]},\"123\":{\"h\":\"InheritableThreadLocal原理是什么呢？\",\"t\":[\"原理很简单，在Thread类里还有另外一个变量\",\"ThreadLocal.ThreadLocalMap inheritableThreadLocals = null; \",\"在Thread的构造函数中，如果父线程的 inheritableThreadLocals 不为空，就把它赋给当前线程（子线程）的 inheritableThreadLocals\",\" // thread locals if (!attached) { if ((characteristics & NO_INHERIT_THREAD_LOCALS) == 0) { ThreadLocal.ThreadLocalMap parentMap = parent.inheritableThreadLocals; if (parentMap != null && parentMap.size() > 0) { //从父线程中取出inheritableThreadLocals this.inheritableThreadLocals = ThreadLocal.createInheritedMap(parentMap); } if (VM.isBooted()) { this.contextClassLoader = contextClassLoader(parent); } } else if (VM.isBooted()) { // default CCL to the system class loader when not inheriting this.contextClassLoader = ClassLoader.getSystemClassLoader(); } } \"]},\"124\":{\"h\":\"还有什么其它办法？TTL？\",\"t\":[\"TransmittableThreadLocal（TTL） \",\"是阿里巴巴开源的基于 InheritableThreadLocal 的增强版\",\"解决了线程池等场景下InheritableThreadLocal 的值传递问题\",\"TTL通过重写 ThreadLocal 的方法和使用特定的数据结构，确保子线程能够正确获取父线程最新的值\",\"它还提供了自定义初始化方法和支持传递不可序列化对象的功能\"]},\"125\":{\"h\":\"基础\"},\"126\":{\"h\":\"并行跟并发有什么区别？\",\"t\":[\"并行就是同一时刻，两个线程都在执行。这就要求有两个CPU去分别执行两个线程\",\"并发就是同一时刻，只有一个执行，但是一个时间段内，两个线程都执行了 \",\"并发的实现依赖于CPU切换线程，因为切换的时间特别短，所以基本对于用户是无感知的\"]},\"127\":{\"h\":\"说说什么是进程和线程？\",\"t\":[\"进程 \",\"进程是代码在数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位\",\"一个进程中有多个线程，多个线程共用进程的堆和方法区资源\",\"线程 \",\"线程是进程的一个执行路径，一个进程中至少有一个线程，进程中的多个线程共享进程的资源\",\"每个线程有自己的程序计数器和栈\"]},\"128\":{\"h\":\"说说线程有几种创建方式？\",\"t\":[\"继承Thread类 \",\"继承Thread类，重写run()方法，调用start()方法启动线程\",\"实现Runnable接口 \",\"实现 Runnable 接口，重写run()方法\",\"实现Callable接口 \",\"实现Callable接口，重写call()方法，这种方式可以通过FutureTask获取任务执行的返回值\"]},\"129\":{\"h\":\"为什么调用start()方法时会执行run()方法，那怎么不直接调用run()方法？\",\"t\":[\"JVM执行start方法，会先创建一条线程，由创建出来的新线程去执行thread的run方法，这才起到多线程的效果\",\"为什么我们不能直接调用run()方法？ \",\"如果直接调用Thread的run()方法，那么run方法还是运行在主线程中，相当于顺序执行，就起不到多线程的效果\"]},\"130\":{\"h\":\"Thread和Runnable有什么区别？\",\"t\":[\"特点\",\"Thread\",\"Runnable\",\"继承关 系\",\"是一个类\",\"是一个接口\",\"代码复 用\",\"不方便，每个线程需要创建新实 例\",\"方便，多个线程可以共享同一实 例\",\"灵活性\",\"相对较低，只能继承Thread类\",\"相对较高，可以与其他接口组合\",\"可控性\",\"相对较低，需要手动管理线程\",\"相对较高，可以通过线程池管理\",\"Thread类适合直接创建新线程\",\"而Runnable接口适合定义线程要执行的任务，并可以与其他接口组合使用\"]},\"131\":{\"h\":\"线程有哪些常用的调度方法？\",\"t\":[\"线程等待与通知 \",\"Object类方法 \",\"wait() \",\"当一个线程A调用一个共享变量的 wait()方法时， 线程A会被阻塞挂起，发生下面几种情况才会返回\",\"其他线程调用了线程A共享对象 notify()或者 notifyAll()方法\",\"其他线程调用了线程A的 interrupt() 方法，线程A抛出InterruptedException异常返回\",\"wait(long timeout) \",\"这个方法相比 wait() 方法多了一个超时参数\",\"在等待时间内没有其他线程调用相同对象的 notify() 或 notifyAll() 方法唤醒它，或者等待时间到期，线程会被自动唤醒，并且重新尝试获取对象的锁\",\"如果等待时间到期而线程没有获取到锁，则线程会被唤醒，但是它不会重新尝试获取锁。相反，它会在等待队列中等待，直到其他线程通过 notify() 或 notifyAll() 方法唤醒它，并且在获取锁之前，线程是不会继续执行的\",\"wait(long timeout, int nanos)\",\"其内部调用的是 wait(long timout）函数\",\"notify() \",\"一个线程A调用共享对象的 notify() 方法后，会唤醒一个在这个共享变量上调用 wait 系列方法后被挂起的线程。 一个共享变量上可能会有多个线程在等待，具体唤醒哪个等待的线程是随机的\",\"notifyAll() \",\"不同于在共享变量上调用 notify() 函数会唤醒被阻塞到该共享变量上的一个线程，notifyAll()方法则会唤醒所有在该共享变量上由于调用 wait 系列方法而被挂起的线程\",\"Thread类的方法 \",\"join() \",\"如果一个线程A执行了thread.join()语句，其含义是：当前线程A等待thread线程终止之后从thread.join()返回\",\"线程休眠 \",\"sleep(long millis) \",\"Thread类中的静态方法\",\"当一个执行中的线程A调用了Thread的sleep方法后，线程A会暂时让出指定时间的执行权\",\"但是线程A所拥有的监视器资源，比如锁还是持有不让出的\",\"指定的睡眠时间到了后该函数会正常返回，接着参与 CPU 的调度，获取到 CPU 资源后就可以继续运行\",\"让出优先权 \",\"yield() \",\"Thread类中的静态方法\",\"当一个线程调用 yield 方法时，实际就是在暗示线程调度器当前线程请求让出自己的CPU ，但是线程调度器可以无条件忽略这个暗示\",\"线程中断 \",\"定义 \",\"Java 中的线程中断是一种线程间的协作模式\",\"通过设置线程的中断标志并不能直接终止该线程的执行，而是被中断的线程根据中断状态自行处理\",\"方法 \",\"void interrupt() \",\"中断线程\",\"例如，当线程A运行时，线程B可以调用线程interrupt() 方法来设置线程的中断标志为true 并立即返回\",\"线程A实际并没有被中断， 会继续往下执行\",\"boolean isInterrupted() \",\"检测当前线程是否被中断\",\"boolean interrupted() \",\"检测当前线程是否被中断，与 isInterrupted 不同的是，该方法如果发现当前线程被中断，则会清除中断标志\"]},\"132\":{\"h\":\"线程有几种状态？\",\"t\":[\"线程共有六种状态\",\"状态\",\"说明\",\"NEW\",\"初始状态：线程被创建，但还没有调用start()方法\",\"RUNNABLE\",\"运行状态：Java线程将操作系统中的就绪和运行两种状态笼 统的称作“运行”\",\"BLOCKED\",\"阻塞状态：表示线程阻塞于锁\",\"WAITING\",\"等待状态：表示线程进入等待状态，进入该状态表示当前线 程需要等待其他线程做出一些特定动作（通知或中断）\",\"TIME_WAITING\",\"超时等待状态：该状态不同于 WAITIND，它是可以在指定 的时间自行返回的\",\"TERMINATED\",\"终止状态：表示当前线程已经执行完毕\"]},\"133\":{\"h\":\"BLOCKED和WAITING有什么区别？\",\"t\":[\"BLOCKED状态表示线程被阻塞，无法继续执行，通常是因为等待获取锁\",\"WAITING状态表示线程正在等待其他线程的通知，通常是因为调用了wait()方法、join()方法或LockSupport.park()方法\",\"这两种状态的区别在于阻塞状态是等待获取锁，而等待状态是等待其他线程的通知或中断\"]},\"134\":{\"h\":\"WAITING和TERMINATED有什么区别？\",\"t\":[\"WAITING状态表示线程在等待其他线程的通知或中断\",\"而TERMINATED状态表示线程已经执行完毕，不再执行任何代码\",\"WAITING状态是暂时的，可以再次进入RUNNABLE状态，而TERMINATED状态是永久的，线程不会再进入任何状态\"]},\"135\":{\"h\":\"什么是线程上下文切换？\",\"t\":[\"线程上下文切换是指在多线程环境下，CPU 从一个线程转而执行另一个线程的过程。\",\"在这个过程中，操作系统会保存当前线程的上下文（包括寄存器状态、程序计数器、堆栈指针等信息），然后恢复下一个线程的上下文，以便该线程可以继续执行。\",\"线程上下文切换是一种非常耗时的操作，因为操作系统需要保存和恢复线程的上下文信息。因此，在编写多线程应用程序时，应尽量减少线程上下文切换的次数，以提高系统的性能和效率\"]},\"136\":{\"h\":\"线程上下文切换通常发生在以下几种情况下\",\"t\":[\"当一个线程的时间片用完时，操作系统会强制进行线程上下文切换，将 CPU 时间片分配给另一个处于就绪状态的线程。\",\"当一个线程因为等待某些事件（如I/O操作、锁的释放等）而被阻塞时，操作系统会将 CPU 时间片分配给另一个处于就绪状态的线程\",\"当一个线程调用了 yield() 方法主动放弃 CPU 时间片时，操作系统会将 CPU 时间片分配给另一个处于就绪状态的线程\"]},\"137\":{\"h\":\"守护线程了解吗？\",\"t\":[\"Java中的线程分为两类，分别为 daemon 线程（守护线程）和 user 线程（用户线程）\",\"在JVM 启动时会调用 main 函数，main函数所在的钱程就是一个用户线程\",\"其实在JVM 内部同时还启动了很多守护线程， 比如垃圾回收线程\",\"那么守护线程和用户线程有什么区别呢 ？ \",\"是当最后一个非守护线程束时，JVM会正常退出，而不管当前是否存在守护线程，也就是说守护线程是否结束并不影响 JVM退出\"]},\"138\":{\"h\":\"线程间有哪些通信方式？\",\"t\":[\"volatile和synchronized关键字 \",\"关键字volatile可以用来修饰字段（成员变量），就是告知程序任何对该变量的访问均需要从共享内存中获取，而对它的改变必须同步刷新回共享内存，它能保证所有线程对变量访问的可见性\",\"关键字synchronized可以修饰方法或者以同步块的形式来进行使用，它主要确保多个线程在同一个时刻，只能有一个线程处于方法或者同步块中，它保证了线程对变量访问的可见性和排他性\",\"等待/通知机制 \",\"可以通过Java内置的等待/通知机制（wait()/notify()）实现一个线程修改一个对象的值，而另一个线程感知到了变化，然后进行相应的操作\",\"管道输入/输出流 \",\"管道输入/输出流和普通的文件输入/输出流或者网络输入/输出流不同之处在于，它主要用于线程之间的数据传输，而传输的媒介为内存\",\"管道输入/输出流主要包括了如下4种具体实现 \",\"PipedOutputStream、PipedInputStream、 PipedReader和PipedWriter，前两种面向字节，而后两种面向字 符\",\"使用Thread.join() \",\"如果一个线程A执行了thread.join()语句，其含义是：当前线程A等待thread线程终止之后才从thread.join()返回\",\"线程Thread除了提供join()方法之外，还提供了join(long millis)和join(long millis,int nanos)两个具备超时特性的方法\",\"使用ThreadLocal（线程内 ） \",\"ThreadLocal，即线程变量，是一个以ThreadLocal对象为键、任意对象为值的存储结构\",\"这个结构被附带在线程上，也就是说一个线程可以根据一个ThreadLocal对象查询到绑定在这个线程上的一个值\"]},\"139\":{\"h\":\"并发工具类\"},\"140\":{\"h\":\"CountDownLatch（倒计数器）了解吗？\",\"t\":[\"CountDownLatch，倒计数器，有两个常见的应用场景\",\"场景1：协调子线程结束动作：等待所有子线程运行结束\",\"public static void main(String[] args) throws InterruptedException { CountDownLatch countDownLatch = new CountDownLatch(5); Thread 大乔 = new Thread(countDownLatch::countDown); Thread 兰陵王 = new Thread(countDownLatch::countDown); Thread 安其拉 = new Thread(countDownLatch::countDown); Thread 哪吒 = new Thread(countDownLatch::countDown); Thread 铠 = new Thread(() -> { try { // 稍等，上个卫生间，马上到... Thread.sleep(1500); countDownLatch.countDown(); } catch (InterruptedException ignored) { } }); 大乔.start(); 兰陵王.start(); 安其拉.start(); 哪吒.start(); 铠.start(); countDownLatch.await(); System.out.println(\\\"所有玩家已经就位！\\\"); } \",\"子线程使用countDownLatch.countDown()进行倒数计数\",\"主线程使用countDownLatch.await()进行阻塞，等待子线程完成\",\"场景2：协调子线程开始动作：统一各线程动作开始的时机\",\" public static void main(String[] args) throws InterruptedException { CountDownLatch countDownLatch = new CountDownLatch(1); Thread 大乔 = new Thread(() -> waitToFight(countDownLatch)); Thread 兰陵王 = new Thread(() -> waitToFight(countDownLatch)); Thread 安其拉 = new Thread(() -> waitToFight(countDownLatch)); Thread 哪吒 = new Thread(() -> waitToFight(countDownLatch)); Thread 铠 = new Thread(() -> waitToFight(countDownLatch)); 大乔.start(); 兰陵王.start(); 安其拉.start(); 哪吒.start(); 铠.start(); Thread.sleep(1000); countDownLatch.countDown(); System.out.println(\\\"敌方还有5秒达到战场，全军出击！\\\"); } private static void waitToFight(CountDownLatch countDownLatch) { try { countDownLatch.await(); // 在此等待信号再继续 System.out.println(\\\"收到，发起进攻！\\\"); } catch (InterruptedException e) { e.printStackTrace(); } } \",\"子线程使用countDownLatch.await()进行阻塞，等待主线程完成\",\"主线程使用countDownLatch.countDown()进行倒数计数\",\"CountDownLatch的核心方法\",\"await() ：等待latch降为0\",\"boolean await(long timeout, TimeUnit unit) ：等待latch降为0，但是可以设置超时时间。比如有玩家超时未确认，那就重新匹配，总不能为了某个玩家等到天荒地老\",\"countDown() ：latch数量减1\",\"getCount() ：获取当前的latch数量\"]},\"141\":{\"h\":\"CyclicBarrier（同步屏障）了解吗？\",\"t\":[\"CyclicBarrier的字面意思是可循环使用（Cyclic）的屏障（Barrier）\",\"它要做的事情是，让一 组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行\",\"它和CountDownLatch类似，都可以协调多线程的结束动作，在它们结束后都可以执行特定动作\"]},\"142\":{\"h\":\"重要注意事项\",\"t\":[\"线程中断：如果某个线程在等待时被中断，会抛出 InterruptedException，此时其他线程也会收到 BrokenBarrierException 并继续执行。\",\"重用性：CyclicBarrier 可以重复使用，当所有等待线程都被释放后，屏障会自动重置，可以再次使用。\",\"异常处理：需要处理可能的 BrokenBarrierException 和 TimeoutException（如果使用带超时参数的 await 方法）。\",\"核心方法await()：\",\"使线程在屏障点等待，直到所有线程都到达。如果当前线程是最后一个到达的线程，则会放行，往下执行\",\"如再次await()则阻塞，当前线程是最后一个到达的线程await时，再次放行，循环往复\",\"public class CyclicBarrierExample { public static void main(String[] args) { // 创建CyclicBarrier实例，并设置屏障点操作（所有线程到达屏障点时执行） CyclicBarrier barrier = new CyclicBarrier(3, new Runnable() { @Override public void run() { System.out.println(\\\"所有线程已到达屏障点，继续执行后续任务...\\\"); } }); // 创建并启动三个线程 for (int i = 1; i <= 3; i++) { new Thread(new Task(barrier), \\\"线程 \\\" + i).start(); } } static class Task implements Runnable { private CyclicBarrier barrier; public Task(CyclicBarrier barrier) { this.barrier = barrier; } @Override public void run() { try { while (true) { System.out.println(Thread.currentThread().getName() + \\\" 正在执行任务...\\\"); // 模拟任务执行时间 Thread.sleep((long) (Math.random() * 1000)); System.out.println(Thread.currentThread().getName() + \\\" 完成任务，等待其他线程...\\\"); // 调用await方法等待其他线程 barrier.await(); // 所有线程到达屏障点后执行的代码 System.out.println(Thread.currentThread().getName() + \\\" 继续执行后续任务...\\\"); } } catch (InterruptedException | BrokenBarrierException e) { e.printStackTrace(); } } } } \",\"线程 1 正在执行任务... 线程 2 正在执行任务... 线程 3 正在执行任务... 线程 3 完成任务，等待其他线程... 线程 2 完成任务，等待其他线程... 线程 1 完成任务，等待其他线程... 所有线程已到达屏障点，继续执行后续任务... 线程 1 继续执行后续任务... 线程 1 正在执行任务... 线程 2 继续执行后续任务... 线程 3 继续执行后续任务... 线程 2 正在执行任务... 线程 3 正在执行任务... 线程 3 完成任务，等待其他线程... 线程 2 完成任务，等待其他线程... 线程 1 完成任务，等待其他线程... 所有线程已到达屏障点，继续执行后续任务... 线程 1 继续执行后续任务... 线程 1 正在执行任务... 线程 3 继续执行后续任务... 线程 3 正在执行任务... 线程 2 继续执行后续任务... 线程 2 正在执行任务... 线程 1 完成任务，等待其他线程... 线程 2 完成任务，等待其他线程... 线程 3 完成任务，等待其他线程... 所有线程已到达屏障点，继续执行后续任务... 线程 3 继续执行后续任务... 线程 3 正在执行任务... 线程 1 继续执行后续任务... 线程 1 正在执行任务... 线程 2 继续执行后续任务... 线程 2 正在执行任务... 线程 3 完成任务，等待其他线程... 线程 1 完成任务，等待其他线程... 线程 2 完成任务，等待其他线程... 所有线程已到达屏障点，继续执行后续任务... ... \",\"线程达到公共屏障点（barrier）前阻塞，知道最后一个线程达到屏障点，然后又开始执行\",\"循环往复的做达到屏障点->放行->达到屏障点->放行...\"]},\"143\":{\"h\":\"CyclicBarrier和CountDownLatch有什么区别？\",\"t\":[\"CountDownLatch是一次性的，而CyclicBarrier则可以多次设置屏障，实现重复利用\",\"CountDownLatch中的各个子线程不可以等待其他线程，只能完成自己的任务；而CyclicBarrier中的各个线程可以等待其他线程\",\"CyclicBarrier\",\"CountDownLatch\",\"CyclicBarrier是可重用的，其中的线程会等待 所有的线程完成任务。届时，屏障将被拆 除，并可以选择性地做一些特定的动作。\",\"CountDownLatch是一次性的， 不同的线程在同一个计数器上 工作，直到计数器为0.\",\"CyclicBarrier面向的是线程数\",\"CountDownLatch面向的是任务 数\",\"在使用CyclicBarrier时，你必须在构造中指定 参与协作的线程数，这些线程必须调用await() 方法\",\"使用CountDownLatch时，则必 须要指定任务数，至于这些任 务由哪些线程完成无关紧要\",\"CyclicBarrier可以在所有的线程释放后重新使 用\",\"CountDownLatch在计数器为0 时不能再使用\",\"在CyclicBarrier中，如果某个线程遇到了中 断、超时等问题时，则处于await的线程都会 出现问题\",\"在CountDownLatch中，如果某 个线程出现问题，其他线程不 受影响\"]},\"144\":{\"h\":\"Semaphore（信号量）了解吗？\",\"t\":[\"定义\",\"Semaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源\",\"应用场景\",\"资源池管理：如数据库连接池，限制同时访问数据库的连接数\",\"限流控制：如限制同时处理的请求数量，防止过载\",\"多线程限量操作：如控制多个线程对某个资源的访问，确保不会出现资源争用\",\"示例代码\",\"public class SemaphoreExample { public static void main(String[] args) { // 创建一个Semaphore实例，设定可用许可数量为3（表示有3个停车位） Semaphore parkingLot = new Semaphore(3); // 创建并启动六个线程模拟汽车 for (int i = 1; i <= 6; i++) { new Thread(new Car(parkingLot), \\\"汽车 \\\" + i).start(); } } static class Car implements Runnable { private Semaphore parkingLot; public Car(Semaphore parkingLot) { this.parkingLot = parkingLot; } @Override public void run() { try { System.out.println(Thread.currentThread().getName() + \\\" 尝试进入停车场...\\\"); // 获取一个许可，阻塞直到有可用的许可 parkingLot.acquire(); System.out.println(Thread.currentThread().getName() + \\\" 成功进入停车场。\\\"); // 模拟停车时间 Thread.sleep((long) (Math.random() * 10000)); System.out.println(Thread.currentThread().getName() + \\\" 离开停车场。\\\"); // 释放许可 parkingLot.release(); } catch (InterruptedException e) { e.printStackTrace(); } } } } \"]},\"145\":{\"h\":\"解释\",\"t\":[\"Semaphore：构造函数中传入的参数表示可以同时访问的资源数量。在这个例子中，设定为3，表示有3个停车位。\",\"acquire() 方法：线程调用这个方法尝试获取一个许可，如果没有可用许可，线程会被阻塞，直到有可用许可为止。\",\"release() 方法：线程调用这个方法释放一个许可，使其他被阻塞的线程可以继续执行。\",\"模拟停车场：Car 类中的 run 方法模拟了汽车进入停车场、停车和离开的过程。线程首先尝试获取一个许可，成功后进入停车场， 停车一段时间后离开，并释放许可。\"]},\"146\":{\"h\":\"重要注意事项\",\"t\":[\"公平性：Semaphore可以设置为公平模式（FIFO），通过在构造函数中传入 true，确保线程按请求顺序获取许可：\",\"Semaphore parkingLot = new Semaphore(3, true); \",\"中断：acquire 方法响应中断，如果线程在等待许可时被中断，会抛出 InterruptedException。\",\"tryAcquire 方法：尝试获取许可但不阻塞，有多种重载形式：\",\"boolean acquired = parkingLot.tryAcquire(); boolean acquiredWithTimeout = parkingLot.tryAcquire(1, TimeUnit.SECONDS); \",\"使用 Semaphore 可以有效控制对资源的并发访问，确保系统资源的有效利用和安全性\"]},\"147\":{\"h\":\"Exchanger 了解吗？\",\"t\":[\"Exchanger 是 Java 中的一个同步辅助类，专门用于在两个线程之间交换数据。它的主要应用场景包括：\",\"双线程数据交换：两个线程需要在某个点交换数据，如生产者和消费者模式中的数据交换。\",\"任务分配与结果收集：一个线程生成任务，另一个线程处理任务并返回结果。\",\"资源双向传递：两个线程互相传递数据或资源，如双缓冲区交换。\"]},\"148\":{\"h\":\"代码示例\",\"t\":[\"以下是一个简单的 Exchanger 使用示例，模拟两个线程之间的数据交换：\",\"import java.util.concurrent.Exchanger; public class ExchangerExample { public static void main(String[] args) { // 创建一个Exchanger实例 Exchanger<String> exchanger = new Exchanger<>(); // 创建并启动两个线程 new Thread(new Producer(exchanger), \\\"生产者\\\").start(); new Thread(new Consumer(exchanger), \\\"消费者\\\").start(); } static class Producer implements Runnable { private Exchanger<String> exchanger; public Producer(Exchanger<String> exchanger) { this.exchanger = exchanger; } @Override public void run() { try { String data = \\\"生产的数据\\\"; System.out.println(Thread.currentThread().getName() + \\\" 生产了数据：\\\" + data); // 与消费者交换数据 String response = exchanger.exchange(data); System.out.println(Thread.currentThread().getName() + \\\" 收到消费者的数据：\\\" + response); } catch (InterruptedException e) { e.printStackTrace(); } } } static class Consumer implements Runnable { private Exchanger<String> exchanger; public Consumer(Exchanger<String> exchanger) { this.exchanger = exchanger; } @Override public void run() { try { String data = \\\"消费者处理的数据\\\"; // 接收生产者的数据并返回处理后的数据 String received = exchanger.exchange(data); System.out.println(Thread.currentThread().getName() + \\\" 接收到生产者的数据：\\\" + received); System.out.println(Thread.currentThread().getName() + \\\" 处理后数据：\\\" + data); } catch (InterruptedException e) { e.printStackTrace(); } } } } \"]},\"149\":{\"h\":\"解释\",\"t\":[\"Exchanger：一个用于在两个线程之间交换数据的同步点。通过 exchange 方法，两个线程可以交换数据，并且这两个线程在此方法处阻塞，直到对方也到达此同步点。\",\"Producer 类：模拟生产者线程，生成数据并与消费者交换。\",\"Consumer 类：模拟消费者线程，准备处理数据并与生产者交换。\",\"exchange() 方法：线程调用此方法进行数据交换，该方法会阻塞，直到另一个线程也调用 exchange 方法。\"]},\"150\":{\"h\":\"重要注意事项\",\"t\":[\"成对使用：Exchanger 是为成对线程设计的，如果有一个线程没有配对线程来交换数据，那么它会一直阻塞。\",\"超时机制：exchange 方法有带超时参数的重载形式，可以指定最大等待时间：\",\"String response = exchanger.exchange(data, 1, TimeUnit.SECONDS); \",\"中断处理：如果线程在等待交换数据时被中断，会抛出 InterruptedException。\",\"Exchanger 可以简化两个线程之间的数据交换逻辑，确保交换操作是同步和线程安全的，非常适合需要双向数据传递的场景。\",\"应用场景\",\"遗传算法 \",\"Exchanger可以用于遗传算法，遗传算法里需要选出两个人作为交配对象，这时候会交换两人的数据，并使用交叉规则得出2个交配结果\",\"校对工作 \",\"Exchanger也可以用于校对工作，比如我们需要将纸制银行流水通过人工的方式录入成电子银行流水，为了避免错误，采用AB岗两人进行录入，录入到Excel之后，系统需要加载这两个Excel，并对两个Excel数据进行校对，看看是否录入一致\"]},\"151\":{\"h\":\"说说你对CompletableFuture的理解？\"},\"152\":{\"h\":\"1. 引言\",\"t\":[\"CompletableFuture 是Java 8引入的一个异步编程工具类，用于处理异步任务的结果和执行流程。它提供了一种简洁而强大的方式来处理异步操作，包括任务的串行执行、并行执行、组合以及异常处理等\"]},\"153\":{\"h\":\"2. 基本概念\"},\"154\":{\"h\":\"2.1 创建 CompletableFuture\",\"t\":[\"你可以使用静态工厂方法来创建 CompletableFuture 对象：\",\"supplyAsync：用于执行有返回值的异步任务。\",\"runAsync：用于执行没有返回值的异步任务。\",\"CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> { // 任务逻辑 return \\\"结果\\\"; }); CompletableFuture<Void> future = CompletableFuture.runAsync(() -> { // 任务逻辑 }); \"]},\"155\":{\"h\":\"3. 任务完成后的回调\"},\"156\":{\"h\":\"3.1 thenApply\",\"t\":[\"用于在任务完成后，对结果进行处理并返回新的结果。\",\"CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> \\\"Hello\\\") .thenApply(result -> result + \\\" World\\\"); \"]},\"157\":{\"h\":\"3.2 thenAccept\",\"t\":[\"用于在任务完成后，消费结果但不返回新的结果。\",\"CompletableFuture.supplyAsync(() -> \\\"Hello\\\") .thenAccept(result -> System.out.println(result)); \"]},\"158\":{\"h\":\"3.3 thenRun\",\"t\":[\"用于在任务完成后执行一个没有返回值的操作。\",\"CompletableFuture.supplyAsync(() -> \\\"Hello\\\") .thenRun(() -> System.out.println(\\\"任务完成\\\")); \"]},\"159\":{\"h\":\"4. 组合多个 CompletableFuture\"},\"160\":{\"h\":\"4.1 thenCompose\",\"t\":[\"用于在一个 CompletableFuture 完成后，启动另一个 CompletableFuture。\",\"CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> \\\"Hello\\\") .thenCompose(result -> CompletableFuture.supplyAsync(() -> result + \\\" World\\\")); \"]},\"161\":{\"h\":\"4.2 thenCombine\",\"t\":[\"用于将两个独立的 CompletableFuture 的结果进行合并。\",\"CompletableFuture<String> future1 = CompletableFuture.supplyAsync(() -> \\\"Hello\\\"); CompletableFuture<String> future2 = CompletableFuture.supplyAsync(() -> \\\" World\\\"); CompletableFuture<String> resultFuture = future1.thenCombine(future2, (result1, result2) -> result1 + result2); \"]},\"162\":{\"h\":\"4.3 allOf\",\"t\":[\"用于等待所有给定的 CompletableFuture 完成。\",\"CompletableFuture<String> future1 = CompletableFuture.supplyAsync(() -> \\\"结果1\\\"); CompletableFuture<String> future2 = CompletableFuture.supplyAsync(() -> \\\"结果2\\\"); CompletableFuture<String> future3 = CompletableFuture.supplyAsync(() -> \\\"结果3\\\"); CompletableFuture<Void> allOf = CompletableFuture.allOf(future1, future2, future3); allOf.thenAccept(v -> { try { String result1 = future1.get(); String result2 = future2.get(); String result3 = future3.get(); System.out.println(result1 + \\\", \\\" + result2 + \\\", \\\" + result3); } catch (InterruptedException | ExecutionException e) { e.printStackTrace(); } }); \"]},\"163\":{\"h\":\"5. 处理异常\"},\"164\":{\"h\":\"5.1 exceptionally\",\"t\":[\"用于在异步任务发生异常时提供一个默认值。\",\"CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> { if (Math.random() > 0.5) { throw new RuntimeException(\\\"发生异常\\\"); } return \\\"成功\\\"; }).exceptionally(ex -> \\\"默认值\\\"); \"]},\"165\":{\"h\":\"5.2 handle\",\"t\":[\"用于在异步任务完成或发生异常时对结果进行处理。\",\"CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> { if (Math.random() > 0.5) { throw new RuntimeException(\\\"发生异常\\\"); } return \\\"成功\\\"; }).handle((result, ex) -> { if (ex != null) { return \\\"异常处理后的默认值\\\"; } return result; }); \"]},\"166\":{\"h\":\"6. 超时控制\"},\"167\":{\"h\":\"6.1 orTimeout\",\"t\":[\"用于为异步操作设定超时。\",\"CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> { try { Thread.sleep(3000); } catch (InterruptedException e) { throw new IllegalStateException(e); } return \\\"结果\\\"; }).orTimeout(2, TimeUnit.SECONDS); \"]},\"168\":{\"h\":\"6.2 completeOnTimeout\",\"t\":[\"用于在超时时返回默认值。\",\"CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> { try { Thread.sleep(3000); } catch (InterruptedException e) { throw new IllegalStateException(e); } return \\\"结果\\\"; }).completeOnTimeout(\\\"超时默认值\\\", 2, TimeUnit.SECONDS); \"]},\"169\":{\"h\":\"7. 并行执行多个任务\"},\"170\":{\"h\":\"示例\",\"t\":[\"import java.util.concurrent.CompletableFuture; import java.util.concurrent.ExecutionException; import java.util.List; import java.util.stream.Collectors; public class CompletableFutureParallelExample { public static void main(String[] args) { // 定义三个异步任务 CompletableFuture<String> future1 = CompletableFuture.supplyAsync(() -> { try { Thread.sleep(1000); // 模拟耗时操作 } catch (InterruptedException e) { throw new IllegalStateException(e); } return \\\"结果1\\\"; }); CompletableFuture<String> future2 = CompletableFuture.supplyAsync(() -> { try { Thread.sleep(2000); // 模拟耗时操作 } catch (InterruptedException e) { throw new IllegalStateException(e); } return \\\"结果2\\\"; }); CompletableFuture<String> future3 = CompletableFuture.supplyAsync(() -> { try { Thread.sleep(3000); // 模拟耗时操作 } catch (InterruptedException e) { throw new IllegalStateException(e); } return \\\"结果3\\\"; }); // 创建一个包含所有异步任务的CompletableFuture CompletableFuture<Void> allOf = CompletableFuture.allOf(future1, future2, future3); // 在所有任务完成后处理结果 allOf.thenAccept(v -> { List<String> results = List.of(future1, future2, future3).stream() .map(future -> { try { return future.get(); } catch (InterruptedException | ExecutionException e) { throw new IllegalStateException(e); } }) .collect(Collectors.toList()); // 处理所有结果 results.forEach(result -> System.out.println(\\\"任务完成，结果: \\\" + result)); }).join(); // 等待所有任务完成 System.out.println(\\\"主线程继续执行其他操作...\\\"); } } \"]},\"171\":{\"h\":\"8. 真实场景应用\"},\"172\":{\"h\":\"8.1 并行获取数据\",\"t\":[\"以下示例展示如何并行获取多个远程数据源的数据，并在所有数据获取完成后进行处理。\",\"import java.util.concurrent.CompletableFuture; import java.util.concurrent.ExecutionException; import java.util.List; import java.util.stream.Collectors; public class CompletableFutureRealWorldExample { public static void main(String[] args) { CompletableFuture<String> future1 = fetchDataFromService1(); CompletableFuture<String> future2 = fetchDataFromService2(); CompletableFuture<String> future3 = fetchDataFromService3(); CompletableFuture<Void> allOf = CompletableFuture.allOf(future1, future2, future3); allOf.thenAccept(v -> { try { String result1 = future1.get(); String result2 = future2.get(); String result3 = future3.get(); // 合并结果 String finalResult = result1 + \\\", \\\" + result2 + \\\", \\\" + result3; System.out.println(\\\"最终结果: \\\" + finalResult); } catch (InterruptedException | ExecutionException e) { e.printStackTrace(); } }).join(); // 等待所有任务完成 } private static CompletableFuture<String> fetchDataFromService1() { return CompletableFuture.supplyAsync(() -> { // 模拟远程调用 try { Thread.sleep(1000); } catch (InterruptedException e) { throw new IllegalStateException(e); } return \\\"Service1数据\\\"; }); } private static CompletableFuture<String> fetchDataFromService2() { return CompletableFuture.supplyAsync(() -> { // 模拟远程调用 try { Thread.sleep(2000); } catch (InterruptedException e) { throw new IllegalStateException(e); } return \\\"Service2数据\\\"; }); } private static CompletableFuture<String> fetchDataFromService3() { return CompletableFuture.supplyAsync(() -> { // 模拟远程调用 try { Thread.sleep(3000); } catch (InterruptedException e) { throw new IllegalStateException(e); } return \\\"Service3数据\\\"; }); } } \"]},\"173\":{\"h\":\"9. 总结\",\"t\":[\"CompletableFuture 提供了一种简洁而强大的方式来处理异\"]},\"174\":{\"h\":\"CompletableFuture的线程池设置？\",\"t\":[\"CompletableFuture 使用 ForkJoinPool.commonPool() 作为默认线程池来执行异步任务，但你可以指定自定义的线程池来满足特殊需求，如提高性能或控制资源使用。以下是如何设置和使用自定义线程池的详细指南。\"]},\"175\":{\"h\":\"1. 使用默认线程池\",\"t\":[\"默认情况下，CompletableFuture 使用 ForkJoinPool.commonPool()。这对于大多数情况已经足够，但在需要更多控制或资源隔离时，可以使用自定义线程池。\",\"CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> { // 异步任务逻辑 return \\\"结果\\\"; }); \"]},\"176\":{\"h\":\"2. 指定自定义线程池\",\"t\":[\"你可以使用 CompletableFuture.supplyAsync 或 CompletableFuture.runAsync 方法的重载版本来指定自定义的线程池。\"]},\"177\":{\"h\":\"2.1 创建自定义线程池\",\"t\":[\"首先，创建一个自定义线程池。你可以使用 Executors 工具类来创建不同类型的线程池：\",\"import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; ExecutorService customThreadPool = Executors.newFixedThreadPool(10); // 创建一个固定大小的线程池 \"]},\"178\":{\"h\":\"2.2 使用自定义线程池\",\"t\":[\"然后，将自定义线程池传递给 CompletableFuture：\",\"CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> { // 异步任务逻辑 return \\\"结果\\\"; }, customThreadPool); \"]},\"179\":{\"h\":\"3. 完整示例\",\"t\":[\"以下是一个完整的示例，展示如何使用自定义线程池执行异步任务：\",\"import java.util.concurrent.CompletableFuture; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.TimeUnit; public class CustomThreadPoolExample { public static void main(String[] args) { // 创建自定义线程池 ExecutorService customThreadPool = Executors.newFixedThreadPool(10); // 提交异步任务并使用自定义线程池 CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> { try { Thread.sleep(1000); // 模拟耗时操作 } catch (InterruptedException e) { throw new IllegalStateException(e); } return \\\"结果\\\"; }, customThreadPool); // 注册回调处理结果 future.thenAccept(result -> System.out.println(\\\"异步任务完成，结果: \\\" + result)); // 主线程继续执行其他操作 System.out.println(\\\"主线程继续执行其他操作...\\\"); // 关闭线程池 customThreadPool.shutdown(); try { if (!customThreadPool.awaitTermination(800, TimeUnit.MILLISECONDS)) { customThreadPool.shutdownNow(); } } catch (InterruptedException e) { customThreadPool.shutdownNow(); } } } \"]},\"180\":{\"h\":\"4. 线程池类型\"},\"181\":{\"h\":\"4.1 固定大小线程池\",\"t\":[\"适用于已知固定数量的并发任务：\",\"ExecutorService fixedThreadPool = Executors.newFixedThreadPool(10); \"]},\"182\":{\"h\":\"4.2 缓存线程池\",\"t\":[\"适用于大量短生命周期的并发任务，线程池大小根据需要动态调整：\",\"ExecutorService cachedThreadPool = Executors.newCachedThreadPool(); \"]},\"183\":{\"h\":\"4.3 单线程池\",\"t\":[\"适用于需要顺序执行任务的场景：\",\"ExecutorService singleThreadPool = Executors.newSingleThreadExecutor(); \"]},\"184\":{\"h\":\"4.4 调度线程池\",\"t\":[\"适用于需要定期执行任务的场景：\",\"ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(5); \"]},\"185\":{\"h\":\"5. 异步任务链中的线程池\",\"t\":[\"你还可以在异步任务链中的不同部分使用不同的线程池：\",\"ExecutorService pool1 = Executors.newFixedThreadPool(5); ExecutorService pool2 = Executors.newCachedThreadPool(); CompletableFuture.supplyAsync(() -> { // 使用 pool1 执行异步任务 return \\\"任务1结果\\\"; }, pool1).thenApplyAsync(result -> { // 使用 pool2 处理结果 return result + \\\" 经过处理\\\"; }, pool2).thenAcceptAsync(result -> { System.out.println(\\\"最终结果: \\\" + result); // 可以不指定线程池，则使用默认的 ForkJoinPool.commonPool() }); \",\"通过设置自定义线程池，你可以更好地控制 CompletableFuture 的并发行为，满足不同应用场景的需求。\"]},\"186\":{\"h\":\"并发队列\"},\"187\":{\"h\":\"说说阻塞队列是怎么实现的？\",\"t\":[\"阻塞队列是一种特殊的队列数据结构，在多线程编程中起着重要作用。它允许多个线程在队列为空或者队列已满时进行阻塞等待，从而实现线程之间的同步与通信。阻塞队列的实现通常基于经典的队列数据结构，如数组或者链表，并结合了锁和条件等待机制来实现线程的阻塞和唤醒。\",\"下面是阻塞队列的基本实现原理：\",\"队列数据结构： 阻塞队列基于数组或链表等数据结构实现，用于存储元素。常见的阻塞队列有 ArrayBlockingQueue、LinkedBlockingQueue 等。\",\"锁和条件等待： 阻塞队列内部通常使用锁和条件等待来实现线程的阻塞和唤醒。当队列为空时，试图从队列中取出元素的线程会被阻塞，直到队列非空；当队列已满时，试图向队列中添加元素的线程会被阻塞，直到队列有空闲位置。\",\"线程阻塞和唤醒机制： 在队列为空或已满时，等待队列状态改变的线程会进入等待状态，释放锁并进入等待队列。当有其他线程向队列中添加或取出元素时，会触发条件变量的通知操作，唤醒等待队列中的线程。\",\"线程安全性： 阻塞队列需要保证在多线程环境下的线程安全性。因此，在对队列进行添加或移除元素的操作时，需要使用锁来保护对队列数据结构的访问，从而确保操作的原子性和线程安全性。\",\"总的来说，阻塞队列通过结合队列数据结构、锁和条件等待机制，实现了多线程环境下的线程安全、阻塞和唤醒操作，从而为多线程编程提供了便利和高效的同步与通信机制。\"]},\"188\":{\"h\":\"线程池\"},\"189\":{\"h\":\"什么是线程池？\",\"t\":[\"线程池是一种管理和控制多个线程并发执行的机制，旨在提高性能并优化资源使用。线程池通过预先创建一组线程，避免了频繁创建和销毁线程的开销，从而提高了系统效率。\"]},\"190\":{\"h\":\"1. 线程池的基本概念\",\"t\":[\"线程复用：线程池在初始化时创建一定数量的线程，这些线程在处理完一个任务后不会被销毁，而是被重用来处理下一个任务。\",\"任务队列：当所有线程都在忙碌时，新的任务会被放入一个队列中等待执行。\",\"线程管理：线程池会自动管理线程的生命周期，如创建新线程、回收空闲线程等。\"]},\"191\":{\"h\":\"2. 线程池的优势\",\"t\":[\"提高性能：减少了频繁创建和销毁线程的开销。\",\"资源控制：可以限制并发线程的数量，防止系统资源耗尽。\",\"简化编程：提供了统一的接口来管理和调度线程，简化了并发编程的复杂性。\"]},\"192\":{\"h\":\"3. Java中的线程池实现\",\"t\":[\"Java通过java.util.concurrent包提供了多种线程池实现，主要通过Executors工具类来创建。\"]},\"193\":{\"h\":\"3.1 常见的线程池类型\",\"t\":[\"FixedThreadPool：固定大小的线程池，适用于已知线程数固定的场景。\",\"ExecutorService fixedThreadPool = Executors.newFixedThreadPool(10); \",\"CachedThreadPool：根据需要创建新线程的线程池，但在空闲时会重用先前创建的线程，适用于大量短生命周期任务。\",\"ExecutorService cachedThreadPool = Executors.newCachedThreadPool(); \",\"SingleThreadExecutor：单线程线程池，适用于需要顺序执行任务的场景。\",\"ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor(); \",\"ScheduledThreadPool：定时或周期性执行任务的线程池。\",\"ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(5); \"]},\"194\":{\"h\":\"4. 线程池的使用示例\",\"t\":[\"以下是一个使用固定大小线程池执行多个任务的示例：\",\"import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.TimeUnit; public class ThreadPoolExample { public static void main(String[] args) { // 创建一个固定大小的线程池 ExecutorService executor = Executors.newFixedThreadPool(5); // 提交多个任务 for (int i = 0; i < 10; i++) { final int index = i; executor.submit(() -> { try { System.out.println(\\\"任务 \\\" + index + \\\" 由线程 \\\" + Thread.currentThread().getName() + \\\" 执行\\\"); Thread.sleep(2000); // 模拟任务执行 } catch (InterruptedException e) { Thread.currentThread().interrupt(); } }); } // 关闭线程池 executor.shutdown(); try { if (!executor.awaitTermination(60, TimeUnit.SECONDS)) { executor.shutdownNow(); } } catch (InterruptedException e) { executor.shutdownNow(); } } } \"]},\"195\":{\"h\":\"5. 线程池的配置参数\",\"t\":[\"线程池的配置参数影响其行为和性能，常见参数包括：\",\"corePoolSize：核心线程数，线程池维护的最小线程数。\",\"maximumPoolSize：最大线程数，线程池能够创建的最大线程数。\",\"keepAliveTime：空闲线程的存活时间，当线程池中的线程数超过核心线程数时，多余的空闲线程在终止前等待新任务的最长时间。\",\"workQueue：任务队列，用于保存等待执行的任务。\"]},\"196\":{\"h\":\"6. 自定义线程池\",\"t\":[\"你可以使用ThreadPoolExecutor来创建自定义线程池，以更灵活地控制线程池的行为：\",\"import java.util.concurrent.ArrayBlockingQueue; import java.util.concurrent.ThreadPoolExecutor; import java.util.concurrent.TimeUnit; public class CustomThreadPoolExample { public static void main(String[] args) { // 创建自定义线程池 ThreadPoolExecutor executor = new ThreadPoolExecutor( 5, // corePoolSize 10, // maximumPoolSize 60, // keepAliveTime TimeUnit.SECONDS, // keepAliveTime单位 new ArrayBlockingQueue<>(100) // workQueue ); // 提交多个任务 for (int i = 0; i < 10; i++) { final int index = i; executor.submit(() -> { try { System.out.println(\\\"任务 \\\" + index + \\\" 由线程 \\\" + Thread.currentThread().getName() + \\\" 执行\\\"); Thread.sleep(2000); // 模拟任务执行 } catch (InterruptedException e) { Thread.currentThread().interrupt(); } }); } // 关闭线程池 executor.shutdown(); try { if (!executor.awaitTermination(60, TimeUnit.SECONDS)) { executor.shutdownNow(); } } catch (InterruptedException e) { executor.shutdownNow(); } } } \",\"通过自定义线程池，你可以精细控制线程池的各种参数，以满足不同应用场景的需求。\"]},\"197\":{\"h\":\"为什么说频繁创建和销毁线程的开销大？\",\"t\":[\"频繁创建和销毁线程的开销大，主要是因为线程的创建和销毁涉及操作系统和JVM层面的多种资源管理和调度。具体来说，有以下几个原因：\"]},\"198\":{\"h\":\"1. 系统资源消耗\"},\"199\":{\"h\":\"1.1 内存开销\",\"t\":[\"每个线程在创建时需要分配内存，用于其堆栈空间和线程本地存储（Thread Local Storage）。默认情况下，在典型的JVM中，每个线程的堆栈大小可能是1MB或者更大。频繁创建和销毁线程会导致内存分配和释放操作的频繁发生，从而增加内存管理的开销。\"]},\"200\":{\"h\":\"1.2 操作系统资源\",\"t\":[\"操作系统为每个线程分配了一些内核对象和数据结构，这些结构用于线程调度和管理。频繁创建和销毁线程会导致操作系统不断地创建和销毁这些内核对象，增加了系统调用的开销。\"]},\"201\":{\"h\":\"2. CPU消耗\"},\"202\":{\"h\":\"2.1 线程上下文切换\",\"t\":[\"操作系统通过线程调度器在多个线程之间切换执行。每次切换执行线程时，需要保存当前线程的状态（寄存器、程序计数器等），然后恢复即将执行线程的状态。频繁的线程创建和销毁会增加上下文切换的次数，从而增加CPU的负担。\"]},\"203\":{\"h\":\"2.2 同步开销\",\"t\":[\"线程的创建和销毁需要在操作系统和JVM内部进行同步，以确保线程状态的一致性。这些同步操作会导致锁的竞争和开销，降低系统性能。\"]},\"204\":{\"h\":\"3. JVM的开销\"},\"205\":{\"h\":\"3.1 垃圾回收\",\"t\":[\"频繁创建和销毁线程会导致大量短生命周期的对象被创建，例如线程对象、任务对象等。这些短生命周期的对象会加大垃圾回收的压力，频繁的垃圾回收会导致应用程序的性能下降。\"]},\"206\":{\"h\":\"3.2 JIT优化\",\"t\":[\"JVM中的即时编译器（JIT）会对热点代码进行优化，但频繁的线程创建和销毁会导致代码路径的变化，从而影响JIT的优化效果。\"]},\"207\":{\"h\":\"能说说工作中线程池的应用吗？\",\"t\":[\"线程池在实际工作中有着广泛的应用，特别是在高并发和需要处理大量任务的场景中。以下是线程池在各种工作场景中的一些典型应用：\"]},\"208\":{\"h\":\"1. Web服务器\"},\"209\":{\"h\":\"场景描述\",\"t\":[\"Web服务器需要处理大量的客户端请求。每个请求可能涉及复杂的处理逻辑，包括数据库访问、文件操作和计算等。频繁地为每个请求创建和销毁线程将导致性能瓶颈。\"]},\"210\":{\"h\":\"解决方案\",\"t\":[\"通过使用线程池，Web服务器可以预先创建一组线程来处理请求。线程池中的线程会在处理完一个请求后立即准备处理下一个请求，从而减少了线程创建和销毁的开销。\"]},\"211\":{\"h\":\"代码示例\",\"t\":[\"以下是一个使用线程池处理HTTP请求的简单示例：\",\"import java.io.IOException; import java.net.ServerSocket; import java.net.Socket; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; public class SimpleWebServer { private final ExecutorService threadPool; public SimpleWebServer(int port, int poolSize) throws IOException { ServerSocket serverSocket = new ServerSocket(port); threadPool = Executors.newFixedThreadPool(poolSize); while (true) { Socket clientSocket = serverSocket.accept(); threadPool.submit(() -> handleRequest(clientSocket)); } } private void handleRequest(Socket clientSocket) { // 处理请求逻辑 } public static void main(String[] args) throws IOException { new SimpleWebServer(8080, 10); // 端口8080，线程池大小为10 } } \"]},\"212\":{\"h\":\"2. 数据库连接池\"},\"213\":{\"h\":\"场景描述\",\"t\":[\"数据库操作通常是IO密集型的，需要消耗较多的时间。频繁地创建和销毁数据库连接会导致性能下降和资源浪费。\"]},\"214\":{\"h\":\"解决方案\",\"t\":[\"通过使用数据库连接池，应用程序可以复用一组数据库连接，减少连接创建和销毁的开销，并提高数据库操作的效率。\"]},\"215\":{\"h\":\"代码示例\",\"t\":[\"以Apache Commons DBCP为例，使用连接池管理数据库连接：\",\"import org.apache.commons.dbcp2.BasicDataSource; import java.sql.Connection; import java.sql.PreparedStatement; import java.sql.ResultSet; import java.sql.SQLException; public class DatabaseConnectionPoolExample { public static void main(String[] args) { BasicDataSource dataSource = new BasicDataSource(); dataSource.setUrl(\\\"jdbc:mysql://localhost:3306/mydatabase\\\"); dataSource.setUsername(\\\"username\\\"); dataSource.setPassword(\\\"password\\\"); dataSource.setMinIdle(5); dataSource.setMaxIdle(10); dataSource.setMaxOpenPreparedStatements(100); try (Connection conn = dataSource.getConnection(); PreparedStatement stmt = conn.prepareStatement(\\\"SELECT * FROM mytable\\\"); ResultSet rs = stmt.executeQuery()) { while (rs.next()) { System.out.println(\\\"Column 1: \\\" + rs.getString(1)); } } catch (SQLException e) { e.printStackTrace(); } } } \"]},\"216\":{\"h\":\"3. 并行数据处理\"},\"217\":{\"h\":\"场景描述\",\"t\":[\"在大数据处理和计算任务中，数据处理通常可以并行化以提高效率。例如，处理大型数据集时，可以将数据分割成多个块，并行处理每个块。\"]},\"218\":{\"h\":\"解决方案\",\"t\":[\"通过使用线程池，可以并行处理数据块，充分利用多核CPU的优势，提高数据处理的速度。\"]},\"219\":{\"h\":\"代码示例\",\"t\":[\"以下是一个使用线程池并行处理数据块的示例：\",\"import java.util.Arrays; import java.util.List; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.TimeUnit; public class ParallelDataProcessingExample { public static void main(String[] args) { List<Integer> data = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10); ExecutorService executor = Executors.newFixedThreadPool(4); for (Integer item : data) { executor.submit(() -> process(item)); } executor.shutdown(); try { if (!executor.awaitTermination(60, TimeUnit.SECONDS)) { executor.shutdownNow(); } } catch (InterruptedException e) { executor.shutdownNow(); } } private static void process(Integer item) { System.out.println(\\\"Processing item: \\\" + item + \\\" by \\\" + Thread.currentThread().getName()); try { Thread.sleep(1000); // 模拟处理时间 } catch (InterruptedException e) { Thread.currentThread().interrupt(); } } } \"]},\"220\":{\"h\":\"4. 异步任务执行\"},\"221\":{\"h\":\"场景描述\",\"t\":[\"在许多应用中，需要执行一些异步任务，例如发送邮件、日志记录、文件上传等。这些任务不需要立即完成，可以在后台执行。\"]},\"222\":{\"h\":\"解决方案\",\"t\":[\"通过使用线程池，可以将异步任务提交到线程池中执行，主线程可以继续处理其他工作。\"]},\"223\":{\"h\":\"代码示例\",\"t\":[\"以下是一个使用线程池执行异步任务的示例：\",\"import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; public class AsyncTaskExample { public static void main(String[] args) { ExecutorService executor = Executors.newFixedThreadPool(5); // 提交异步任务 executor.submit(() -> { sendEmail(\\\"user@example.com\\\"); }); // 主线程继续执行其他操作 System.out.println(\\\"主线程继续执行其他操作...\\\"); executor.shutdown(); } private static void sendEmail(String recipient) { System.out.println(\\\"发送邮件给: \\\" + recipient); try { Thread.sleep(2000); // 模拟发送邮件时间 } catch (InterruptedException e) { Thread.currentThread().interrupt(); } System.out.println(\\\"邮件发送完成\\\"); } } \"]},\"224\":{\"h\":\"5. 定时任务\"},\"225\":{\"h\":\"场景描述\",\"t\":[\"需要定期执行一些任务，例如清理临时文件、定时备份数据库等。\"]},\"226\":{\"h\":\"解决方案\",\"t\":[\"通过使用ScheduledThreadPoolExecutor，可以调度定时任务，在指定时间或周期性执行。\"]},\"227\":{\"h\":\"代码示例\",\"t\":[\"以下是一个使用调度线程池执行定时任务的示例：\",\"import java.util.concurrent.Executors; import java.util.concurrent.ScheduledExecutorService; import java.util.concurrent.TimeUnit; public class ScheduledTaskExample { public static void main(String[] args) { ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1); // 定期执行任务，每隔5秒执行一次 scheduler.scheduleAtFixedRate(() -> { System.out.println(\\\"执行定时任务: \\\" + System.currentTimeMillis()); }, 0, 5, TimeUnit.SECONDS); // 关闭调度器 Runtime.getRuntime().addShutdownHook(new Thread(() -> { scheduler.shutdown(); try { if (!scheduler.awaitTermination(60, TimeUnit.SECONDS)) { scheduler.shutdownNow(); } } catch (InterruptedException e) { scheduler.shutdownNow(); } })); } } \"]},\"228\":{\"h\":\"能简单说一下线程池的工作流程吗？\",\"t\":[\"线程池的工作流程可以分为以下几个步骤：初始化、任务提交、任务执行和资源回收。了解这些步骤有助于理解线程池如何管理线程和任务，提高并发编程的效率和资源利用率。\"]},\"229\":{\"h\":\"1. 线程池初始化\",\"t\":[\"线程池在初始化时，会根据配置参数创建一定数量的核心线程，并准备好任务队列。这些参数通常包括核心线程数（corePoolSize）、最大线程数（maximumPoolSize）、空闲线程存活时间（keepAliveTime）和任务队列（workQueue）等。\",\"ExecutorService executor = new ThreadPoolExecutor( 5, // corePoolSize 10, // maximumPoolSize 60L, // keepAliveTime TimeUnit.SECONDS, // 时间单位 new LinkedBlockingQueue<Runnable>() // 任务队列 ); \"]},\"230\":{\"h\":\"2. 任务提交\",\"t\":[\"任务可以通过execute()或submit()方法提交到线程池。execute()方法提交的任务没有返回值，而submit()方法可以返回一个Future对象，用于获取任务的执行结果。\",\"executor.execute(() -> { // 任务逻辑 }); Future<String> future = executor.submit(() -> { // 任务逻辑 return \\\"任务结果\\\"; }); \"]},\"231\":{\"h\":\"3. 任务执行\",\"t\":[\"当一个任务被提交到线程池后，线程池按照以下顺序处理任务：\",\"空闲核心线程执行任务：如果有空闲的核心线程，则直接由核心线程执行任务。\",\"任务加入队列：如果没有空闲的核心线程且任务队列未满，则将任务放入任务队列等待执行。\",\"创建新线程执行任务：如果任务队列已满且线程数未达到最大线程数，则创建新的非核心线程执行任务。\",\"拒绝策略：如果线程数已达到最大线程数且任务队列已满，则根据设置的拒绝策略处理新任务。常见的拒绝策略包括抛出异常、丢弃任务、丢弃队列最前的任务和由调用线程执行任务。\"]},\"232\":{\"h\":\"4. 任务执行完成\",\"t\":[\"线程执行任务时，如果任务执行完成且当前线程数超过核心线程数，且空闲时间超过keepAliveTime，该线程将被终止。否则，线程将继续处于空闲状态，准备执行下一个任务。\"]},\"233\":{\"h\":\"5. 线程池关闭\",\"t\":[\"线程池可以通过调用shutdown()或shutdownNow()方法关闭：\",\"shutdown()：停止接受新任务，并在所有已提交任务执行完成后关闭线程池。\",\"shutdownNow()：立即停止所有任务，尝试终止正在执行的任务，并返回未执行的任务列表。\",\"executor.shutdown(); // 优雅关闭 try { if (!executor.awaitTermination(60, TimeUnit.SECONDS)) { executor.shutdownNow(); // 强制关闭 } } catch (InterruptedException e) { executor.shutdownNow(); } \"]},\"234\":{\"h\":\"线程池的完整工作流程\",\"t\":[\"线程池的工作流程如下图所示：\",\"初始化线程池，创建核心线程和任务队列。\",\"任务提交到线程池。\",\"空闲核心线程执行任务；如无空闲核心线程则将任务加入队列；队列已满则创建新线程；达到最大线程数则执行拒绝策略。\",\"任务执行完成，线程空闲或终止。\",\"线程池关闭，停止接受新任务，等待已提交任务完成或立即终止。\",\"这个流程保证了线程资源的高效利用和任务的有效调度，使得线程池成为并发编程中重要的工具。\"]},\"235\":{\"h\":\"线程池主要参数有哪些？\",\"t\":[\"线程池的主要参数包括：\",\"corePoolSize（核心线程数）：线程池中保持活动状态的最小线程数。即使线程处于空闲状态，也不会被回收，除非设置了allowCoreThreadTimeOut。当有新任务提交时，线程池会优先使用核心线程来处理任务。\",\"maximumPoolSize（最大线程数）：线程池中允许存在的最大线程数。当核心线程都在忙碌，并且任务队列已满时，新任务会触发创建额外的线程，直到达到最大线程数。\",\"keepAliveTime（线程空闲时间）：当线程数超过核心线程数时，空闲线程在被终止前等待新任务的最长时间。如果线程空闲时间超过该值，则线程会被终止，直到线程数量等于核心线程数。\",\"TimeUnit（时间单位）：用于指定keepAliveTime的时间单位，通常为秒、分钟等。\",\"workQueue（任务队列）：用于存储等待执行的任务的队列。常见的任务队列包括有界队列（如ArrayBlockingQueue）和无界队列（如LinkedBlockingQueue、SynchronousQueue）。\",\"ThreadFactory（线程工厂）：用于创建新线程的工厂。可以通过自定义ThreadFactory来指定线程的名称、优先级等属性。\",\"RejectedExecutionHandler（拒绝策略）：当任务无法被接受执行时的处理策略。常见的拒绝策略包括抛出异常、丢弃任务、丢弃队列最前的任务和由调用线程执行任务。\",\"这些参数可以根据应用场景的需求进行调整和配置，以优化线程池的性能和资源利用率。\"]},\"236\":{\"h\":\"线程池的拒绝策略有哪些？\",\"t\":[\"线程池的拒绝策略用于定义当线程池无法接受新任务时应该采取的操作。以下是常见的线程池拒绝策略：\",\"AbortPolicy（默认策略）：默认的拒绝策略。当任务无法被执行时，会抛出RejectedExecutionException异常。\",\"CallerRunsPolicy：调用者运行策略。如果线程池无法接受新任务，会在调用线程中直接执行被拒绝的任务。这样做可能会导致调用线程的性能下降，因为调用线程需要承担执行任务的负责。\",\"DiscardPolicy：丢弃策略。当任务无法被执行时，会默默地丢弃被拒绝的任务，不会抛出异常也不会进行任何处理。\",\"DiscardOldestPolicy：丢弃最旧策略。当任务无法被执行时，会丢弃任务队列中最旧的任务，并尝试重新提交当前任务。\",\"可以根据具体的业务需求和系统特性选择合适的拒绝策略，以保证系统的稳定性和可靠性。\"]},\"237\":{\"h\":\"线程池有哪几种工作队列？\",\"t\":[\"线程池通常使用工作队列来存储等待执行的任务。常见的线程池工作队列包括：\",\"无界队列（Unbounded Queue）：无界队列可以存储无限数量的任务，即使线程池中的线程都在忙碌，新任务也可以被放入队列等待执行。常见的无界队列包括LinkedBlockingQueue，它基于链表实现，具有高吞吐量和无限容量的特点。\",\"有界队列（Bounded Queue）：有界队列有限制存储的任务数量，当队列已满时，新任务将被拒绝。有界队列可以有效地控制线程池中任务的数量，防止任务过载。常见的有界队列包括ArrayBlockingQueue，它基于数组实现，具有固定容量的特点。\",\"同步移交队列（Synchronous Transfer Queue）：同步移交队列是一种特殊的队列，它不存储任务，而是将任务直接移交给线程池中的线程进行执行。如果没有空闲线程可用，新任务会被拒绝。常见的同步移交队列包括SynchronousQueue，它实际上不存储任何元素，只是用于线程之间的任务传递。\",\"优先级队列（Priority Queue）：优先级队列根据元素的优先级来决定元素的顺序。在线程池中，可以使用优先级队列来根据任务的优先级高低来执行任务。Java中的PriorityBlockingQueue是一个线程安全的优先级队列实现。\",\"延迟队列（Delay Queue）：延迟队列用于存储延迟执行的任务，即在指定延迟时间之后才能被消费。延迟队列通常用于实现定时任务调度。Java中的Delayed接口和DelayedWorkQueue类用于实现延迟队列。\",\"工作窃取队列（Work Stealing Queue）：工作窃取队列是一种用于并行计算的特殊队列，每个线程都有自己的工作队列，并且可以从其他线程的队列中窃取任务来执行。工作窃取队列通常用于实现任务并行化的线程池。Java中的ForkJoinPool使用工作窃取队列来实现任务的并行执行。\",\"这些不同类型的工作队列具有不同的特性和适用场景，可以根据具体的需求选择合适的队列类型来优化线程池的性能和行为。\"]},\"238\":{\"h\":\"线程池提交execute和submit有什么区别？\",\"t\":[\"在Java的线程池中，execute()和submit()方法都用于向线程池提交任务，但它们之间存在一些区别：\",\"返回值类型：\",\"execute()方法没有返回值，因为它用于提交不需要返回结果的任务。\",\"submit()方法返回一个Future对象，可以用来获取任务的执行结果或者监控任务的执行状态。这使得submit()方法更加灵活，可以处理需要返回结果的任务。\",\"异常处理：\",\"execute()方法无法处理任务执行过程中抛出的异常。如果任务抛出了未捕获的异常，线程池会将其记录下来，但不会通知调用者。\",\"submit()方法可以通过Future对象来捕获任务执行过程中抛出的异常。调用Future对象的get()方法时，如果任务抛出了异常，会将异常包装在ExecutionException中重新抛出，从而让调用者能够捕获和处理异常。\",\"参数类型：\",\"execute()方法接受Runnable接口类型的任务作为参数，这种任务不返回结果。\",\"submit()方法除了接受Runnable接口类型的任务外，还可以接受Callable接口类型的任务作为参数，这种任务可以返回结果。\",\"综上所述，execute()方法用于提交不需要返回结果的任务，而submit()方法则更加灵活，既可以提交不需要返回结果的任务，也可以提交需要返回结果的任务，并且可以处理任务执行过程中抛出的异常。\"]},\"239\":{\"h\":\"线程池怎么关闭知道吗？\",\"t\":[\"线程池的关闭可以通过调用shutdown()方法或shutdownNow()方法来实现。这两种方法都是用来关闭线程池的，但它们之间有一些细微的差别：\",\"shutdown()方法： \",\"shutdown()方法用于平缓地关闭线程池。调用shutdown()方法后，线程池将不再接受新的任务，但会继续执行已提交的任务，直到所有任务执行完毕后才会关闭。\",\"shutdown()方法不会立即停止线程池，而是等待所有已提交的任务执行完成后再关闭线程池。\",\"executor.shutdown(); \",\"shutdownNow()方法： \",\"shutdownNow()方法用于立即关闭线程池。调用shutdownNow()方法后，线程池会尝试停止所有正在执行的任务，并返回未执行的任务列表。\",\"shutdownNow()方法会尝试中断正在执行的任务，以便更快地停止线程池，但并不保证所有任务都能被成功中断。 \",\"它的原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止\",\"executor.shutdownNow(); \",\"在调用了shutdown()或shutdownNow()方法后，可以通过调用awaitTermination()方法来等待线程池关闭，或者通过轮询isTerminated()方法来检查线程池是否已经关闭。\",\"try { if (!executor.awaitTermination(60, TimeUnit.SECONDS)) { executor.shutdownNow(); } } catch (InterruptedException e) { executor.shutdownNow(); } \",\"总之，通过调用shutdown()方法或shutdownNow()方法可以安全地关闭线程池，确保所有任务得到正确处理，并释放线程池所占用的资源。\"]},\"240\":{\"h\":\"线程池的线程数应该怎么配置？\",\"t\":[\"线程池的线程数配置应该根据你的应用场景和需求来决定，需要考虑以下几个因素：\",\"任务的性质：首先要考虑的是你的任务的性质。如果你的任务是CPU密集型的（计算密集型），那么你可能需要配置较少的线程数，因为每个线程都会占用较多的CPU资源。如果你的任务是I/O密集型的（如网络请求、文件操作等），那么你可能需要配置较多的线程数，因为线程在执行任务时会阻塞等待I/O操作的完成。\",\"系统资源：其次要考虑的是你的系统资源。你需要确保你的线程池的线程数不要超过系统资源的限制，包括CPU核心数、内存等。过多的线程可能会导致系统资源的竞争和浪费，从而降低系统的性能和稳定性。\",\"任务执行时间：还需要考虑任务的执行时间。如果你的任务执行时间较长，那么可能需要更多的线程来处理任务队列中的任务，以避免任务等待时间过长。但是，如果线程数过多，可能会导致线程间上下文切换的开销增加，从而降低系统的性能。\",\"任务队列容量：线程池的任务队列也是需要考虑的因素之一。如果任务队列容量较小，那么可能需要配置更多的线程来处理任务，以避免任务被拒绝。反之，如果任务队列容量较大，那么可能可以配置较少的线程来处理任务，减少线程间的竞争。\",\"综上所述，线程池的线程数配置需要根据任务性质、系统资源、任务执行时间和任务队列容量等因素综合考虑。通常情况下，可以通过监控系统资源的使用情况和线程池的运行状态来动态调整线程数配置，以保证线程池的性能和稳定性。\"]},\"241\":{\"h\":\"线程池是怎么实现线程复用的？\",\"t\":[\"核心应该是线程池+任务队列，使线程和队列解耦\",\"在线程池中，一开始会创建一定数量的线程，并将它们放入线程池中。\",\"当有任务需要执行时，可以通过向线程池提交任务的方式，将任务放入任务队列中。\",\"线程池中的线程作为消费者，会不断地从任务队列中取出任务来执行。当线程取出任务后，会执行任务的run()方法。执行完任务后，线程并不会立即销毁，而是回线程池中，继续等待新的任务\",\"这样，线程池中的线程就实现了复用\"]},\"242\":{\"h\":\"有哪几种常见的线程池？\",\"t\":[\"常见的线程池包括以下几种：\",\"FixedThreadPool（固定大小线程池）：\",\"固定大小线程池包含固定数量的线程，线程池中的线程数量不会发生变化。\",\"当有新任务提交时，如果线程池中有空闲的线程，则将任务分配给空闲线程执行；如果线程池中的线程都在执行任务，新任务将在任务队列中等待。\",\"适用于需要限制线程数量的场景，例如并发量稳定的服务器应用。\",\"CachedThreadPool（缓存线程池）：\",\"缓存线程池可以根据需要创建新线程，线程池中的线程数量会根据任务的数量自动调整。\",\"当有新任务提交时，如果线程池中有空闲的线程，则将任务分配给空闲线程执行；如果线程池中的线程都在执行任务，将创建新的线程来处理新任务。\",\"适用于短时任务较多、任务执行时间较短的场景，可以动态调整线程数量以适应任务量的变化。\",\"SingleThreadExecutor（单线程线程池）：\",\"单线程线程池只包含一个线程，所有任务按照顺序在这个线程中执行。\",\"当有新任务提交时，如果线程池中的线程空闲，则将任务分配给该线程执行；如果线程正在执行任务，新任务将在任务队列中等待。\",\"适用于需要保证任务按照顺序执行、不需要并发执行的场景，例如任务依赖性较强的场景。\",\"ScheduledThreadPool（定时任务线程池）：\",\"定时任务线程池用于执行定时任务和周期性任务，可以在指定的时间点执行任务，也可以按照固定的时间间隔执行任务。\",\"通过调用schedule()方法或scheduleAtFixedRate()方法提交定时任务或周期性任务。\",\"适用于需要执行定时任务和周期性任务的场景，例如定时任务调度、定时数据同步等。\"]},\"243\":{\"h\":\"能说一下四种常见线程池的原理吗？\"},\"244\":{\"h\":\"1.FixedThreadPool（固定大小线程池）\",\"t\":[\"// 创建固定大小线程池 public static ExecutorService newFixedThreadPool(int nThreads) { return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>()); } \",\"线程池特点 \",\"核心线程数和最大线程数大小一样\",\"没有所谓的非空闲时间，即keepAliveTime为0\",\"阻塞队列为无界队列LinkedBlockingQueue，可能会导致OOM\",\"工作流程 \",\"提交任务\",\"如果线程数少于核心线程，创建核心线程执行任务\",\"如果线程数等于核心线程，把任务添加到LinkedBlockingQueue阻塞队列\",\"如果线程执行完任务，去阻塞队列取任务，继续执行。\",\"适用场景 \",\"FixedThreadPool 适用于处理CPU密集型的任务，确保CPU在长期被工作线程使用的情况下，尽可能的少的分配线程，即适用执行长期的任务\"]},\"245\":{\"h\":\"2.CachedThreadPool（缓存线程池）\",\"t\":[\"// 创建缓存线程池 public static ExecutorService newCachedThreadPool() { return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue<Runnable>()); } \",\"线程池特点 \",\"核心线程数为0\",\"最大线程数为Integer.MAX_VALUE，即无限大，可能会因为无限创建线程，导致OOM\",\"队列是同步移交队列SynchronousQueue\",\"非核心线程空闲存活时间为60秒\",\"工作流程 \",\"提交任务\",\"因为没有核心线程，所以任务直接加到SynchronousQueue队列\",\"判断是否有空闲线程，如果有，就去取出任务执行\",\"如果没有空闲线程，就新建一个线程执行\",\"执行完任务的线程，还可以存活60秒，如果在这期间，接到任务，可以继续活下去；否则，被销毁\",\"适用场景 \",\"用于并发执行大量短期的小任务\"]},\"246\":{\"h\":\"3.SingleThreadExecutor（单线程线程池）\",\"t\":[\"// 创建单线程线程池 public static ExecutorService newSingleThreadExecutor() { return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>())); } \",\"线程池特点 \",\"核心线程数为1\",\"最大线程数也为1\",\"阻塞队列是无界队列LinkedBlockingQueue，可能会导致OOM\",\"keepAliveTime为0\",\"工作流程 \",\"提交任务\",\"线程池是否有一条线程在，如果没有，新建线程执行任务\",\"如果有，将任务加到阻塞队列\",\"当前的唯一线程，从队列取任务，执行完一个，再继续取，一个线程执行任务\",\"适用场景 \",\"适用于串行执行任务的场景，一个任务一个任务地执行\"]},\"247\":{\"h\":\"4.ScheduledThreadPool（定时任务线程池）\",\"t\":[\"// 创建定时任务线程池 public ScheduledThreadPoolExecutor(int corePoolSize) { super(corePoolSize, Integer.MAX_VALUE, DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS, new DelayedWorkQueue()); } \",\"线程池特点 \",\"最大线程数为Integer.MAX_VALUE，也有OOM的风险\",\"阻塞队列是DelayedWorkQueue\",\"keepAliveTime默认是10\",\"工作流程 \",\"线程从DelayQueue中获取已到期的ScheduledFutureTask（DelayQueue.take()）。\",\"到期任务是指ScheduledFutureTask的time大于等于当前时间\",\"适用场景 \",\"周期性执行任务的场景，需要限制线程数量的场景\"]},\"248\":{\"h\":\"线程池异常怎么处理知道吗？\",\"t\":[\"线程池异常处理是一个常见的问题，特别是在高并发或多线程应用程序中。处理线程池中的异常可以确保程序的稳定性和可靠性。以下是一些处理线程池异常的常见方法和技巧：\"]},\"249\":{\"h\":\"1. 捕获并处理异常\",\"t\":[\"在任务（Runnable 或 Callable）内部捕获并处理异常。这可以防止异常传播到线程池外部，从而避免线程池中的线程因未处理的异常而终止。\",\"ExecutorService executor = Executors.newFixedThreadPool(10); executor.submit(() -> { try { // 任务逻辑 } catch (Exception e) { // 处理异常 e.printStackTrace(); } }); \"]},\"250\":{\"h\":\"2. 自定义线程池\",\"t\":[\"创建一个自定义的线程池，通过覆盖 afterExecute 方法来处理线程执行完毕后的异常。\",\"public class CustomThreadPool extends ThreadPoolExecutor { public CustomThreadPool(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue) { super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue); } @Override protected void afterExecute(Runnable r, Throwable t) { super.afterExecute(r, t); if (t == null && r instanceof Future<?>) { try { Future<?> future = (Future<?>) r; if (future.isDone()) { future.get(); } } catch (CancellationException ce) { t = ce; } catch (ExecutionException ee) { t = ee.getCause(); } catch (InterruptedException ie) { Thread.currentThread().interrupt(); } } if (t != null) { // 处理异常 t.printStackTrace(); } } } \"]},\"251\":{\"h\":\"3. 使用 UncaughtExceptionHandler\",\"t\":[\"设置线程的 UncaughtExceptionHandler，处理未捕获的异常。\",\"ThreadFactory threadFactory = new ThreadFactory() { @Override public Thread newThread(Runnable r) { Thread thread = new Thread(r); thread.setUncaughtExceptionHandler((t, e) -> { // 处理未捕获的异常 e.printStackTrace(); }); return thread; } }; ExecutorService executor = Executors.newFixedThreadPool(10, threadFactory); \"]},\"252\":{\"h\":\"4. 使用自定义 RejectedExecutionHandler\",\"t\":[\"如果任务被拒绝执行，可以通过自定义 RejectedExecutionHandler 来处理异常情况。\",\"RejectedExecutionHandler handler = new RejectedExecutionHandler() { @Override public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) { // 处理被拒绝的任务 System.err.println(\\\"Task rejected: \\\" + r.toString()); } }; ExecutorService executor = new ThreadPoolExecutor(10, 10, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<>(100), handler); \"]},\"253\":{\"h\":\"5. 使用 CompletableFuture 处理异步任务\",\"t\":[\"对于需要处理异步任务的情况，可以使用 CompletableFuture，它提供了更加灵活的异常处理方式。\",\"CompletableFuture.runAsync(() -> { // 任务逻辑 }).exceptionally(e -> { // 处理异常 e.printStackTrace(); return null; }); \"]},\"254\":{\"h\":\"6. 使用 Callable 和 Future\",\"t\":[\"在任务内部使用 Callable，并通过 Future 来捕获和处理异常。\",\"import java.util.concurrent.*; public class FutureExceptionHandling { public static void main(String[] args) { ExecutorService executor = Executors.newFixedThreadPool(10); Callable<Integer> task = () -> { // 任务逻辑 if (true) { throw new Exception(\\\"Callable Exception\\\"); } return 42; }; Future<Integer> future = executor.submit(task); try { Integer result = future.get(); System.out.println(\\\"Task result: \\\" + result); } catch (InterruptedException e) { Thread.currentThread().interrupt(); // 恢复中断状态 e.printStackTrace(); } catch (ExecutionException e) { // 处理任务执行期间抛出的异常 e.getCause().printStackTrace(); } executor.shutdown(); } } \",\"通过这些方法，您可以有效地处理线程池中的异常，确保程序的稳定运行。选择合适的方法取决于您的具体需求和应用场景。\"]},\"255\":{\"h\":\"能说一下线程池有几种状态吗？\",\"t\":[\"线程池（Thread Pool）在执行过程中会经历多个状态，这些状态有助于管理线程池的生命周期和行为。Java 的 ThreadPoolExecutor 类定义了五种线程池状态，每种状态都表示线程池当前的不同运行阶段。以下是详细的线程池状态：\"]},\"256\":{\"h\":\"1. RUNNING\",\"t\":[\"这是线程池的初始状态。在该状态下，线程池可以接受新任务，并处理已经在队列中的任务。\",\"RUNNING \",\"特征：\",\"可以接受新任务。\",\"可以处理队列中的任务。\"]},\"257\":{\"h\":\"2. SHUTDOWN\",\"t\":[\"当调用 shutdown() 方法时，线程池进入 SHUTDOWN 状态。在该状态下，线程池不再接受新任务，但会继续执行已提交的任务和队列中等待的任务。\",\"SHUTDOWN \",\"特征：\",\"不接受新任务。\",\"继续处理已提交和队列中的任务。\"]},\"258\":{\"h\":\"3. STOP\",\"t\":[\"当调用 shutdownNow() 方法时，线程池进入 STOP 状态。在该状态下，线程池不再接受新任务，也不处理队列中的任务，并且会尝试中断正在进行的任务。\",\"STOP \",\"特征：\",\"不接受新任务。\",\"不处理队列中的任务。\",\"尝试中断正在执行的任务。\"]},\"259\":{\"h\":\"4. TIDYING\",\"t\":[\"当线程池在 SHUTDOWN 状态下完成了所有任务，或在 STOP 状态下中断了所有任务后，会进入 TIDYING 状态。在该状态下，线程池中没有活动的线程，且任务队列为空。\",\"TIDYING \",\"特征：\",\"所有任务都已完成。\",\"线程池中没有活动的线程。\"]},\"260\":{\"h\":\"5. TERMINATED\",\"t\":[\"当线程池在 TIDYING 状态下完成终止操作后，会进入 TERMINATED 状态。这是线程池的最终状态，表示线程池已经完全终止。\",\"TERMINATED \",\"特征：\",\"线程池完全终止。\",\"不再有任何活动线程。\"]},\"261\":{\"h\":\"状态转换图\",\"t\":[\"以下是线程池状态的转换图：\"]},\"262\":{\"h\":\"线程池如何实现参数的动态修改？\",\"t\":[\"下面是对答案的一些完善和补充：\",\"使用可调整的线程池（ThreadPoolExecutor）确实是一种常见的方式。通过调用 ThreadPoolExecutor 的构造函数或者提供的方法，可以动态地调整线程池的参数。例如，可以使用 setCorePoolSize()、setMaximumPoolSize()、setQueue() 方法来修改核心线程数、最大线程数以及任务队列等参数。\",\"使用动态代理也是一种有效的方式。通过在代理类中封装线程池，并在代理类中提供方法来动态修改线程池的参数，可以实现更灵活的控制。这种方式可以通过反射机制来实现，但需要一些额外的编码工作。\",\"使用配置文件是一种常见的方式，特别适用于需要频繁调整参数的情况。将线程池的参数配置在外部的配置文件或者配置中心中，可以实现在不修改代码的情况下动态修改线程池的参数。这种方式使得参数的修改更加便捷，并且可以配合其他配置管理工具来实现自动化管理。\",\"使用管理平台是一种更高级的方式，可以提供可视化界面让用户方便地修改线程池的参数，并实时查看线程池的状态和性能指标。管理平台可以根据实际需求提供各种功能，如监控、报警、日志记录等，帮助用户更好地管理线程池。\"]},\"263\":{\"h\":\"线程池调优了解吗？\",\"t\":[\"事前评估： 在上线之前，通过对系统负载、任务类型和处理速度等进行评估，确定合适的线程池配置。这包括确定核心线程数、最大线程数、任务队列类型和大小等参数。评估的目的是为了在上线之前就能够预估系统的负载情况，并针对性地配置线程池，以满足系统的性能需求和稳定性要求。\",\"测试： 在上线之前进行充分的测试，包括功能测试、性能测试、压力测试等。通过测试可以验证线程池的配置是否合理，是否能够满足系统的性能和稳定性要求。如果测试发现线程池存在性能瓶颈或者稳定性问题，需要及时调整配置并重新测试，直到达到预期的效果。\",\"监控机制： 在上线之后建立完善的线程池监控机制，包括监控线程池的运行状态、性能指标、任务执行情况等。监控机制可以帮助及时发现线程池的问题，如线程池过载、任务堆积、线程死锁等，并采取相应的措施进行处理。\",\"告警机制： 结合监控机制建立告警机制，及时发现线程池的异常情况，并发送告警通知给相关人员进行处理。告警机制可以帮助及时发现线程池的问题，避免问题进一步恶化。\",\"事中分析优化： 结合监控告警机制，分析线程池的问题或者可优化点，根据实际情况动态调整线程池的配置。这包括调整核心线程数、最大线程数、任务队列大小等参数，以适应系统的动态变化和优化性能。\",\"事后观察调整： 在线程池上线之后，需要仔细观察线程池的运行情况，随时调整线程池的配置，以确保线程池能够始终保持良好的性能和稳定性。\",\"通过以上评估方案，可以有效地管理和调优线程池的配置，保障系统的性能和稳定性，提高系统的可靠性和可维护性。\"]},\"264\":{\"h\":\"你能设计实现一个线程池吗？\",\"t\":[\"当然可以。以下是一个简单的线程池的设计和实现，包括线程池的初始化、任务提交、线程执行任务、线程池关闭等基本功能：\",\"import java.util.concurrent.BlockingQueue; import java.util.concurrent.LinkedBlockingQueue; public class CustomThreadPool { private final int poolSize; private final WorkerThread[] workers; private final BlockingQueue<Runnable> taskQueue; public CustomThreadPool(int poolSize) { this.poolSize = poolSize; taskQueue = new LinkedBlockingQueue<>(); workers = new WorkerThread[poolSize]; for (int i = 0; i < poolSize; i++) { workers[i] = new WorkerThread(); workers[i].start(); } } public void submit(Runnable task) { try { taskQueue.put(task); } catch (InterruptedException e) { Thread.currentThread().interrupt(); } } public void shutdown() { for (WorkerThread worker : workers) { worker.stopWorker(); } } private class WorkerThread extends Thread { private volatile boolean running = true; @Override public void run() { while (running) { try { Runnable task = taskQueue.take(); task.run(); } catch (InterruptedException e) { running = false; Thread.currentThread().interrupt(); } } } public void stopWorker() { running = false; interrupt(); } } // 测试 public static void main(String[] args) { CustomThreadPool threadPool = new CustomThreadPool(3); // 提交任务 for (int i = 0; i < 5; i++) { final int taskId = i; threadPool.submit(() -> { System.out.println(\\\"Task \\\" + taskId + \\\" is running on thread: \\\" + Thread.currentThread().getName()); try { Thread.sleep(1000); } catch (InterruptedException e) { Thread.currentThread().interrupt(); } System.out.println(\\\"Task \\\" + taskId + \\\" is completed.\\\"); }); } // 关闭线程池 threadPool.shutdown(); } } \",\"这个简单的线程池实现了基本的功能，包括线程池的初始化、任务提交、线程执行任务、线程池关闭等。你可以根据实际需求和场景进一步扩展和优化这个线程池的实现。\"]},\"265\":{\"h\":\"单机线程池执行断电了应该怎么处理？\",\"t\":[\"当单机线程池执行断电时，系统无法继续执行任务，因此需要一些机制来处理这种情况，以确保任务的一致性和可靠性。以下是处理单机线程池断电情况的一般策略：\",\"持久化任务队列： 将任务队列中的任务持久化到可靠的存储介质中，例如数据库、磁盘文件等。这样即使发生断电，任务队列中的任务数据也不会丢失。\",\"事务性执行任务： 在执行任务时，确保任务操作是原子性的，即要么任务执行成功，要么任务执行失败需要回滚。可以使用事务管理的机制来实现这一点。\",\"日志记录和回滚： 在执行任务之前和之后，记录任务的执行日志。当系统发生断电时，根据任务执行日志来回滚已经执行成功但未持久化的任务，以保证任务的一致性和可靠性。\",\"系统重启后的处理： 当系统重新启动时，可以重新加载持久化的任务队列，并根据任务执行日志来恢复任务的执行状态。然后继续执行任务队列中的任务。\",\"综上所述，通过持久化任务队列、事务性执行任务、日志记录和回滚等机制，可以确保单机线程池在断电情况下的任务一致性和可靠性。\"]},\"266\":{\"h\":\"线程池并发调用api，有个调用特别耗时，怎么优化？\",\"t\":[\"当线程池中存在一个调用特别耗时的 API 时，可能会影响到整个线程池的性能和响应速度。为了优化这种情况，可以考虑以下几种策略：\",\"异步调用： 将耗时的 API 调用改为异步调用，即将任务提交到线程池后立即返回，并在后台执行耗时的操作。这样可以避免阻塞线程池中的其他任务，提高线程池的并发能力。\",\"任务拆分： 将耗时的操作拆分为多个小任务，并将这些小任务分配给线程池中的多个线程并行执行。这样可以利用多个线程同时执行任务，提高任务的并发性和执行效率。\",\"限制并发数： 对耗时的 API 调用进行限流，限制同时执行的任务数量，避免线程池中的任务过多导致资源耗尽和性能下降。可以使用信号量或者线程池的控制参数来实现并发数的限制。\",\"超时机制： 对耗时的 API 调用设置超时时间，如果调用超过预设的时间仍未返回结果，则取消调用并释放资源。这样可以避免线程被长时间阻塞，提高线程池的响应速度。\",\"缓存结果： 对于频繁调用且结果稳定的耗时 API，可以将调用结果缓存起来，避免重复调用同一个耗时操作。这样可以减少对耗时 API 的调用次数，提高系统的性能和响应速度。\",\"优化算法： 对耗时的操作进行算法上的优化，减少其执行时间。可以使用更高效的算法、数据结构或者并行计算等技术来优化耗时操作的执行效率。\",\"综上所述，通过异步调用、任务拆分、限制并发数、超时机制、缓存结果和优化算法等策略，可以有效优化线程池中调用特别耗时的 API，提高线程池的性能和响应速度。\"]},\"267\":{\"h\":\"Fork/Join框架了解吗？\",\"t\":[\"Fork/Join框架是Java7提供的一个用于并行执行任务的框架，是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。\",\"要想掌握Fork/Join框架，首先需要理解两个点，分而治之和工作窃取算法。\",\"分而治之 \",\"Fork/Join框架的定义，其实就体现了分治思想：将一个规模为N的问题分解为K个规模较小的子问题，这些子问题相互独立且与原问题性质相同。求出子问题的解，就可得到原问题的解。\",\"工作窃取算法 \",\"大任务拆成了若干个小任务，把这些小任务放到不同的队列里，各自创建单独线程来执行队列里的任务。 那么问题来了，有的线程干活块，有的线程干活慢。干完活的线程不能让它空下来，得让它去帮没干完活的线程干活。它去其它线程的队列里窃取一个任务来执行，这就是所谓的工作窃取。\",\"工作窃取发生的时候，它们会访问同一个队列，为了减少窃取任务线程和被窃取任务线程之间的竞争，通常任务会使用双端队列，被窃取任务线程永远从双端队列的头部拿，而窃取任务的线程永远从双端队列的尾部拿任务执行\",\"Fork/Join框架的工作原理如下：\",\"任务分解（Fork）： 当一个大任务到来时，Fork/Join框架会将这个大任务拆分成若干个小任务，直到拆分的任务足够小而可以被快速处理为止。这个过程是递归的，直到达到拆分任务的终止条件。\",\"任务执行（Join）： 拆分出的小任务会被分配给线程池中的工作线程执行。每个工作线程会不断地从任务队列中获取任务并执行，直到任务队列为空为止。\",\"结果合并： 当一个线程执行完一个小任务后，会将其结果合并到大任务的结果中。这个过程也是递归的，直到所有小任务的结果都被合并到大任务的结果中为止。\",\"Fork/Join框架的关键组件包括：\",\"ForkJoinPool： ForkJoinPool是Fork/Join框架的线程池实现，管理着一组工作线程，用于执行Fork/Join任务。ForkJoinPool实现了工作窃取算法，使得任务能够动态地分配给空闲的线程，提高了线程的利用率和任务的并行性。\",\"ForkJoinTask： ForkJoinTask是Fork/Join框架中表示任务的抽象类，有两个主要的子类：RecursiveTask用于表示有返回值的任务，和RecursiveAction用于表示没有返回值的任务。开发者可以继承ForkJoinTask类来定义自己的任务。\",\"下面是一个简单的示例代码，演示了如何使用Fork/Join框架来计算斐波那契数列的值：\",\"import java.util.concurrent.RecursiveTask; public class FibonacciTask extends RecursiveTask<Integer> { private final int n; public FibonacciTask(int n) { this.n = n; } @Override protected Integer compute() { if (n <= 1) { return n; } else { FibonacciTask task1 = new FibonacciTask(n - 1); FibonacciTask task2 = new FibonacciTask(n - 2); task1.fork(); int result2 = task2.compute(); int result1 = task1.join(); return result1 + result2; } } public static void main(String[] args) { FibonacciTask task = new FibonacciTask(10); int result = task.compute(); System.out.println(\\\"Fibonacci(10) = \\\" + result); } } \",\"以上代码示例演示了如何使用Fork/Join框架来计算斐波那契数列的值。下面是对代码示例的解释：\",\"FibonacciTask 类继承了 RecursiveTask<Integer> 类，表示这是一个有返回值的递归任务，返回值类型为 Integer。\",\"在 FibonacciTask 类中，有一个私有的成员变量 n，表示要计算斐波那契数列的第 n 个数。\",\"compute() 方法是 RecursiveTask 类的抽象方法，需要子类来实现。在 FibonacciTask 类中，我们重写了 compute() 方法来定义具体的任务逻辑。\",\"在 compute() 方法中，首先判断当前要计算的斐波那契数列的位置 n 是否小于等于1。如果是，直接返回 n，因为斐波那契数列的第一个数和第二个数都是1。\",\"如果 n 大于1，则将问题拆分成两个子任务，分别计算第 n-1 和第 n-2 个斐波那契数。使用 FibonacciTask 类自身的构造函数创建两个新的任务对象。\",\"调用 fork() 方法提交第一个子任务给线程池执行，并直接在当前线程中执行第二个子任务的 compute() 方法。\",\"在执行第二个子任务的过程中，如果需要继续拆分任务，则会递归调用 compute() 方法，直到计算到基本情况。\",\"使用 join() 方法等待第一个子任务的执行结果，然后将第一个子任务和第二个子任务的结果相加，得到当前位置的斐波那契数。\",\"在 main() 方法中，创建一个 FibonacciTask 对象，表示要计算斐波那契数列的第10个数。\",\"调用 compute() 方法开始执行任务，得到斐波那契数列的第10个数的值，并输出结果。\",\"在这个示例中，我们定义了一个继承自RecursiveTask<Integer>的FibonacciTask类，用于计算斐波那契数列的值。在compute()方法中，如果n的值小于等于1，则直接返回n；否则，将问题拆分成两个子任务并使用fork()方法提交给线程池执行，并通过join()方法等待子任务的完成并合并结果。\"]},\"268\":{\"h\":\"锁\"},\"269\":{\"h\":\"synchronized用过吗？怎么使用？\",\"t\":[\"修饰实例方法\",\"作用于当前对象实例加锁，进入同步代码前要获得 当前对象实例的锁\",\"synchronized void method() { //业务代码 } \",\"修饰静态方法\",\"也就是给当前类加锁，会作⽤于类的所有对象实例 ，进⼊同步代码前要获得当前 class 的锁\",\"因为静态成员不属于任何⼀个实例对象，是类成员（ static 表明这是该类的⼀个静态资源，不管 new 了多少个对象，只有⼀份）\",\"synchronized void staic method() { //业务代码 } \",\"修饰代码块\",\"指定加锁对象，对给定对象/类加锁。\",\"synchronized(this|object) 表示进⼊同步代码库前要获得给定对象的锁。\",\"synchronized(类.class) 表示进⼊同步代码前要获得 当前 class 的锁\",\"synchronized(this) { //业务代码 } \"]},\"270\":{\"h\":\"synchronized的实现原理？\"},\"271\":{\"h\":\"synchronized是怎么加锁的呢？\",\"t\":[\"synchronized修饰代码块时 \",\"JVM采用 monitorenter 、 monitorexit 两个指令来实现同步\",\"monitorenter 指令指向同步代码块的开始位置\",\"monitorexit 指令则指向同步代码块的结束位置\",\"ynchronized修饰同步方法时 \",\"JVM采用 ACC_SYNCHRONIZED 标记符来实现同步，这个标识指明了该方法是一个同步方法\"]},\"272\":{\"h\":\"synchronized锁住的是什么呢？\",\"t\":[\"monitorenter、monitorexit或者ACC_SYNCHRONIZED，其实都是基于对象的内置锁（Intrinsic Lock）或称为监视器锁（Monitor Lock）\",\"每个对象都有一个内置锁\",\"当一个线程获取了对象的内置锁时，其他线程必须等待该线程释放锁后才能获取锁\",\"这样就保证了同一时间只有一个线程能够访问该对象的同步代码块或同步方法\",\"ObjectMonitor的工作原理\",\"ObjectMonitor有两个队列： _ WaitSet、 _ EntryList，用来保存ObjectWaiter 对象列表\",\"_owner，获取 Monitor 对象的线程进入 _owner 区时， _count + 1。如果线程调用了 wait() 方法，此时会释放 Monitor 对象， _owner 恢复为空， _count - 1。同时该等待线程进入 _WaitSet 中，等待被唤醒\",\"ObjectMonitor() { _header = NULL; _count = 0; // 记录线程获取锁的次数 _waiters = 0, _recursions = 0; //锁的重入次数 _object = NULL; _owner = NULL; // 指向持有ObjectMonitor对象的线程 _WaitSet = NULL; // 处于wait状态的线程，会被加入到 _WaitSet _WaitSetLock = 0 ; _Responsible = NULL ; _succ = NULL ; _cxq = NULL ; FreeNext = NULL ; _EntryList = NULL ; // 处于等待锁block状态的线程，会被加入 到该列表 _SpinFreq = 0 ; _SpinClock = 0 ; OwnerIsThread = 0 ; } \",\"所以我们就知道了，同步是锁住的什么东西\",\"monitorenter，在判断拥有同步标识 ACC_SYNCHRONIZED 抢先进入此方法的线程会优先拥有 Monitor 的 owner ，此时计数器 +1\",\"monitorexit，当执行完退出后，计数器 -1，归 0 后被其他进入的线程获得。\"]},\"273\":{\"h\":\"除了原子性，synchronized可见性，有序性，可重入性怎么实现？\"},\"274\":{\"h\":\"synchronized怎么保证可见性？\",\"t\":[\"线程加锁前，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新读取最新的值\",\"线程加锁后，其它线程无法获取主内存中的共享变量\",\"线程解锁前，必须把共享变量的最新值刷新到主内存中\"]},\"275\":{\"h\":\"synchronized怎么保证有序性？\",\"t\":[\"synchronized同步的代码块，具有排他性，一次只能被一个线程拥有，所以synchronized保证同一时刻，代码是单线程执行的 \",\"因为as-if-serial语义的存在，单线程的程序能保证最终结果是有序的，但是不保证不会指令重排\",\"所以synchronized保证的有序是执行结果的有序性，而不是防止指令重排的有序性\"]},\"276\":{\"h\":\"synchronized怎么实现可重入的呢？\",\"t\":[\"synchronized 是可重入锁，也就是说，允许一个线程二次请求自己持有对象锁的临界资源，这种情况称为可重入锁\",\"synchronized 锁对象的时候有个计数器，他会记录下线程获取锁的次数，在执行完对应的代码块之后，计数器就会-1，直到计数器清零，就释放锁了\"]},\"277\":{\"h\":\"锁升级？synchronized优化了解吗？\",\"t\":[\"锁的状态\",\"Mark Word 标记字段记录着锁的状态\",\"Java对象头里，有一块结构，叫 Mark Word 标记字段，记录着锁的状态，这块结构会随着锁的状态变化而变化\",\"64 位虚拟机 Mark Word 是 64bit，我们来看看它的状态变化\",\"Mark Word存储对象自身的运行数据，如哈希码、GC分代年龄、锁状态标志、偏向时间戳（Epoch） 等\"]},\"278\":{\"h\":\"synchronized做了哪些优化？\",\"t\":[\"在JDK1.6之前 \",\"在JDK1.6之前synchronized的实现直接调用ObjectMonitor的enter和exit，这种锁被称之为重量级锁\",\"从JDK6开始 \",\"从JDK6开始HotSpot虚拟机开发团队对Java中的锁进行优化，如增加了适应性自旋、锁消除、锁粗化、轻量级锁和偏向锁等优化策略，提升了synchronized的性能\",\"偏向锁 \",\"在无竞争的情况下，只是在Mark Word里存储当前线程指针，CAS操作都不做\",\"在没有多线程竞争时，相对重量级锁，减少操作系统互斥量带来的性能消耗。但是，如果存在锁竞争，除了互斥量本身开销，还额外有CAS操作的开销\",\"自旋锁 \",\"减少不必要的CPU上下文切换。在轻量级锁升级为重量级锁时，就使用了自旋加锁的方式\",\"锁粗化 \",\"将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁\",\"锁消除 \",\"虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除\"]},\"279\":{\"h\":\"锁升级的过程是什么样的？\",\"t\":[\"锁升级方向：无锁-->偏向锁---> 轻量级锁---->重量级锁，这个方向基本上是不可逆的\"]},\"280\":{\"h\":\"偏向锁\",\"t\":[\"偏向锁的获取 \",\"判断是否为可偏向状态--MarkWord中锁标志是否为‘01’，偏向锁标记是否为‘1‘\",\"如果是可偏向状态，则查看线程ID是否为当前线程，如果是，则进入步骤'5'，否则进入步骤‘3’\",\"通过CAS操作竞争锁，如果竞争成功，则将MarkWord中线程ID设置为当前线程ID，然后执行‘5’；竞争失败，则执行‘4’\",\"CAS获取偏向锁失败表示有竞争。当达到safepoint时获得偏向锁的线程被挂起，偏向锁升级为轻量级锁 ，然后被阻塞在安全点的线程继续往下执行同步代码块\",\"执行同步代码\",\"偏向锁的撤销 \",\"偏向锁不会主动释放(撤销)，只有遇到其他线程竞争时才会执行撤销，由于撤销需要知道当前持有该偏向锁的线程栈状态，因此要等到safepoint时执行，此时持有该偏向锁的线程（T）有‘2’，‘3’两种情况\",\"撤销 \",\"T线程已经退出同步代码块，或者已经不再存活，则直接撤销偏向锁，变成无锁状态----该状态达到阈值20则执行批量重偏向\",\"升级 \",\"T线程还在同步代码块中，则将T线程的偏向锁 升级为轻量级锁 ，当前线程执行轻量级锁状态下的锁获取步骤----该状态达到阈值40则执行批量撤销\"]},\"281\":{\"h\":\"轻量级锁\",\"t\":[\"轻量级锁的获取\",\"进行加锁操作时，jvm会判断是否已经是重量级锁，如果不是，则会在当前线程栈帧中划出一块空间，作为该锁的锁记录，并且将锁对象MarkWord复制到该锁记录中\",\"复制成功之后，jvm使用CAS操作将对象头MarkWord更新为指向锁记录的指针，并将锁记录里的owner指针指向对象头的MarkWord。如果成功，则执行‘3’，否则执行‘4’\",\"更新成功，则当前线程持有该对象锁，并且对象MarkWord锁标志设置为‘00’，即表示此对象处于轻量级锁状态\",\"更新失败，jvm先检查对象MarkWord是否指向当前线程栈帧中的锁记录，如果是则执行‘5’，否则执行6 ’\",\"表示锁重入；然后当前线程栈帧中增加一个锁记录第一部分（Displaced Mark Word）为null，并指向Mark Word的锁对象，起到一个重入计数器的作用。\",\"表示该锁对象已经被其他线程抢占，则进行 自旋等待 （默认10次），等待次数达到阈值仍未获取到锁，则 升级为重量级锁\",\"简略的锁升级过程\",\"完整的升级过程\"]},\"282\":{\"h\":\"说说synchronized和ReentrantLock的区别？\",\"t\":[\"锁的实现 \",\"synchronized是Java语言的关键字，基于JVM实现\",\"ReentrantLock是基于JDK的API层面实现的（一般是lock()和unlock()方法配合try/finally 语句块来完成。）\",\"性能 \",\"在JDK1.6锁优化以前，synchronized的性能比ReenTrantLock差很多\",\"但是JDK6开始，增加了适应性自旋、锁消除等，两者性能就差不多了\",\"功能特点 \",\"ReentrantLock 比 synchronized 增加了一些高级功能，如等待可中断、可实现公平锁、可实现选择性通知 \",\"ReentrantLock提供了一种能够中断等待锁的线程的机制，通过lock.lockInterruptibly()来实现这个机制\",\"ReentrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。\",\"synchronized与wait()和notify()/notifyAll()方法结合实现等待/通知机制，ReentrantLock类借助Condition接口与newCondition()方法实现\",\"ReentrantLock需要手工声明来加锁和释放锁，一般跟finally配合释放锁。而synchronized不用手动释放锁\"]},\"283\":{\"h\":\"AQS了解多少？\",\"t\":[\"AbstractQueuedSynchronizer 抽象同步队列，简称 AQS ，它是Java并发包的根基，并发包中的锁就是基于AQS实现的，是Java并发面试的高频题目\",\"AQS是一个一个FIFO的双向队列，Node节点中的thread变量用来存放进入AQS队列里的线程，SHARED表示是获取共享资源时被阻塞挂起后放入AQS队列的，EXCLUSIVE表示是获取独占资源时被挂起后放入AQS队列的\",\"AQS 使用一个 volatile 修饰的 int 类型的成员变量 state 来表示同步状态，修改同步状态成功即为获得锁 ，volatile 保证了变量在多线程之间的可见性，修改 state值时通过 CAS 机制来保证修改的原子性\",\"获取state的方式分为两种，\",\"独占方式 tryAcquire() \",\"一个线程使用独占方式获取了资源，其它线程就会在获取失败后被阻塞。\",\"抽象方法，需要子类自行实现\",\"共享方式tryAcquireShared() \",\"一个线程使用共享方式获取了资源，另外一个线程还可以通过CAS的方式进行获取\",\"抽象方法，需要子类自行实现\",\"如果共享资源被占用，需要一定的阻塞等待唤醒机制来保证锁的分配，AQS 中会将竞争共享资源失败的线程添加到队列中，线程进入队列后会进行自旋，自旋一定次数后，会使用LockSupport.park()进入阻塞状态\",\"获取到锁的线程可以重入，每重入一次，state+1，释放资源的时候，会使用CAS操作将state修改为0，重入多少次，释放多少次，并使用LockSupport.unpark()唤醒处于等待状态的线程\"]},\"284\":{\"h\":\"ReentrantLock实现原理？\",\"t\":[\"ReentrantLock通过Sync类，间接继承了AQS\",\"它是可重入的独占锁，只能有一个线程可以获取该锁，其它获取该锁的线程会被阻塞而被放入该锁的阻塞队列里面\",\"new ReentrantLock() 构造函数默认创建的是非公平锁 NonfairSync\"]},\"285\":{\"h\":\"公平锁 FairSync\",\"t\":[\"公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁\",\"公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU 唤醒阻塞线程的开销比非公平锁大\"]},\"286\":{\"h\":\"非公平锁 NonfairSync\",\"t\":[\"非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁\",\"非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU 不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁\"]},\"287\":{\"h\":\"Lock()的执行过程\",\"t\":[\"如果锁当前没有被其它线程占用，并且当前线程之前没有获取过该锁，则当前线程会获取到该锁，然后设置当前锁的拥有者为当前线程，并设置 AQS 的状态值为1 ，然后直接返回。\",\"如果当前线程之前己经获取过该锁，则这次只是简单地把AQS 的状态值加1后返回。\",\"如果该锁己经被其他线程持有，非公平锁会尝试去获取锁，获取失败的话，则调用该方法线程会被放入 AQS 队列阻塞挂起。\"]},\"288\":{\"h\":\"ReentrantLock怎么实现公平锁的？\",\"t\":[\"new ReentrantLock() 构造函数默认创建的是非公平锁 NonfairSync\",\"public ReentrantLock() { sync = new NonfairSync(); } \",\"同时也可以在创建锁构造函数中传入具体参数创建公平锁 FairSync\",\"ReentrantLock lock = new ReentrantLock(true); --- ReentrantLock // true 代表公平锁，false 代表非公平锁 public ReentrantLock(boolean fair) { sync = fair ? new FairSync() : new NonfairSync(); } \",\"FairSync、NonfairSync 代表公平锁和非公平锁，两者都是 ReentrantLock 静态内部类，只不过实现不同锁语义\",\"非公平锁和公平锁的两处不同\",\"非公平锁在调用 lock 后，首先就会调用 CAS 进行一次抢锁，如果这个时候恰巧锁没有被占用，那么直接就获取到锁返回了\",\"非公平锁在 CAS 失败后，和公平锁一样都会进入到 tryAcquire 方法，在tryAcquire 方法中，如果发现锁这个时候被释放了（state == 0），非公平锁会直接 CAS 抢锁，但是公平锁会判断等待队列是否有线程处于等待状态，如果有则不去抢锁，乖乖排到后面\",\"相对来说，非公平锁会有更好的性能，因为它的吞吐量比较大。当然，非公平锁让获取锁的时间变得更加不确定，可能会导致在阻塞队列中的线程长期处于饥饿状态\"]},\"289\":{\"h\":\"什么是CAS?\",\"t\":[\"CAS（Compare And Swap）是一种原子操作，用于实现多线程环境下的同步操作\",\"CAS 操作包含三个操作数：内存位置（V）、旧的预期值（A）和新值（B）\",\"当且仅当预期值 A 和内存位置 V 的值相同时，CAS 会将内存位置 V 的值更新为新值B\",\"CAS 的操作过程如下 \",\"比较：比较内存位置 V 的当前值是否等于预期值 A \",\"如果相等，说明内存位置 V 的值没有被其他线程改变，继续执行第2步\",\"如果不相等，说明内存位置 V 的值已经被其他线程改变，CAS 操作失败，返回 false\",\"交换：将内存位置 V 的值更新为新值 B，CAS 操作成功，返回 true\"]},\"290\":{\"h\":\"CAS 有什么问题？如何解决？\",\"t\":[\"ABA 问题\",\"循环性能开销\",\"只能保证一个变量的原子操作\"]},\"291\":{\"h\":\"ABA 问题\",\"t\":[\"A ->B ->A\",\"并发环境下，假设初始条件是A，去修改数据时，发现是A就会执行修改\",\"但是看到的虽然是A，中间可能发生了A变B，B又变回A的情况\",\"此时A已经非彼A，数据即使成功修改，也可能有问题\"]},\"292\":{\"h\":\"怎么解决ABA问题？\",\"t\":[\"加版本号\",\"使用AtomicStampReference类\",\"Java提供了AtomicStampReference类，它的compareAndSet方法首先检查当前的对象引用值是否等于预期引用，并且当前印戳（Stamp）标志是否等于预期标志，如果全部相等，则以原子方式将引用值和印戳标志的值更新为给定的更新值\",\"通过native方法实现以原子方式将引用值和印戳标志的值更新为给定的更新值\",\" private boolean casPair(Pair<V> cmp, Pair<V> val) { return PAIR.compareAndSet(this, cmp, val); } \",\" public final native @MethodHandle.PolymorphicSignature @IntrinsicCandidate boolean compareAndSet(Object... args); \"]},\"293\":{\"h\":\"循环性能开销\",\"t\":[\"自旋CAS，如果一直循环执行，一直不成功，会给CPU带来非常大的执行开销\"]},\"294\":{\"h\":\"怎么解决循环性能开销问题？\",\"t\":[\"在Java中，很多使用自旋CAS的地方，会有一个自旋次数的限制，超过一定次数，就停止自旋\"]},\"295\":{\"h\":\"只能保证一个变量的原子操作\",\"t\":[\"CAS 保证的是对一个变量执行操作的原子性，如果对多个变量操作时，CAS 目前无法直接保证操作的原子性的\",\"可以考虑合并多个变量，将多个变量封装成一个对象，通过AtomicReference来保证原子性。\"]},\"296\":{\"h\":\"Java有哪些保证原子性的方法？如何保证多线程下i++ 结果正确？\",\"t\":[\"使用循环原子类，例如AtomicInteger，实现i++原子操作\",\"使用juc包下的锁，如ReentrantLock ，对i++操作加锁lock.lock()来实现原子性\",\"使用synchronized，对i++操作加锁\"]},\"297\":{\"h\":\"原子操作类了解多少？\",\"t\":[\"原子操作类是Java提供的一组线程安全的工具类，用于在多线程环境下保证共享变量的操作是原子性的\",\"原子操作类一般都是通过底层的CAS（Compare and Swap）操作来实现的\",\"Java中提供了多种原子操作类，如AtomicBoolean、AtomicInteger、AtomicLong、AtomicReference等，这些类都提供了一些原子操作方法，如getAndIncrement()、compareAndSet()、getAndSet()等，这些方法都是原子性的，可以保证对变量的操作是线程安全的\",\"原子操作类的优点在于，它们提供了一种更高效的线程安全机制，不需要像synchronized关键字那样对整个代码块进行加锁，而是只对需要进行原子操作的代码进行了保护，从而提高了程序的并发性能\"]},\"298\":{\"h\":\"AtomicInteger 的原理？\",\"t\":[\"使用自旋+CAS实现\",\"以AtomicInteger的添加方法为例\",\" public final int getAndDecrement() { return U.getAndAddInt(this, VALUE, -1); } \",\" public final int getAndAddInt(Object o, long offset, int delta) { int v; do { v = getIntVolatile(o, offset); } while (!weakCompareAndSetInt(o, offset, v, v + delta)); return v; } \",\" public final boolean weakCompareAndSetInt(Object o, long offset, int expected, int x) { return compareAndSetInt(o, offset, expected, x); } \",\" public final native boolean compareAndSetInt(Object o, long offset, int expected, int x); \",\"compareAndSetInt是个native方法，\",\"基于CAS来操作int类型变量。其它的原子操作类基本都是大同小异\"]},\"299\":{\"h\":\"线程死锁了解吗？该如何避免？\",\"t\":[\"死锁 \",\"死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的互相等待的现象，在无外力作用的情况下，这些线程会一直相互等待而无法继续运行下去\",\"死锁产生的四个条件 \",\"互斥条件 \",\"指线程对己经获取到的资源进行排它性使用，即该资源同时只由一个线程占用\",\"如果此时还有其它线程请求获取获取该资源，则请求者只能等待，直至占有资源的线程释放该资源\",\"请求并持有 \",\"持有一个资源的同时请求一个新资源\",\"指一个 线程己经持有了至少一个资源，但又提出了新的资源请求，而新资源己被其它线程占有，所以当前线程会被阻塞，但阻塞 的同时并不释放自己已经获取的资源\",\"不可剥夺条件 \",\"指线程获取到的资源在自己使用完之前不能被其它线程抢占，只有在自己使用完毕后才由自己释放该资源\",\"环路等待条件 \",\"形成了一个等待环路，使得每个线程都在等待下一个线程占有的资源，从而形成循环等待\",\"该如何避免死锁呢？ 答案是至少破坏死锁发生的一个条件 \",\"其中，互斥这个条件我们没有办法破坏，因为用锁为的就是互斥。不过其他三个条件都是有办法破坏掉的，到底如何做呢？\",\"对于“请求并持有”这个条件，可以一次性请求所有的资源\",\"对于“不可剥夺”这个条件，占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源，然后重新尝试，这样不可抢占这个条件就破坏掉了。 \",\"如何做到的？ \",\"超时机制：在获取资源时设置超时，如果超过一定时间没有获取到资源，则释放已持有的资源，并重试或采取其他措施。\",\"对于“环路等待”这个条件，可以靠按序申请资源来预防。所谓按序申请，是指资源是有线性顺序的，申请的时候可以先申请资源序号小的，再申请资源序号大的，这样线性化后就不存在环路了\"]},\"300\":{\"h\":\"死锁问题怎么排查呢？\",\"t\":[\"可以使用JDK自带的命令行工具排查 \",\"使用jps查找运行的Java进程：jps -l\",\"使用jstack查看线程堆栈信息：jstack -l 进程id\",\"还可以利用图形化工具，比如JConsole \",\"出现线程死锁以后，点击JConsole线程面板的 检测到死锁 按钮，将会看到线程的死锁信息\",\"死锁检测算法 \",\"可以使用图算法如找环算法来检测死锁\",\"死锁恢复 \",\"终止死锁进程：强制终止一个或多个进程，释放它们持有的资源。\",\"资源剥夺：从一些死锁进程中剥夺资源，将这些资源分配给其他等待进程\"]},\"301\":{\"h\":\"List\"},\"302\":{\"h\":\"ArrayList和LinkedList有什么区别？\",\"t\":[\"数据结构不同 \",\"ArrayList基于数组实现\",\"LinkedList基于双向链表实现\",\"多数情况下，ArrayList更利于查找，LinkedList更利于增删 \",\"查找速率 \",\"ArrayList基于数组实现，get(int index)可以直接通过数组下标获取，时间复杂度是O(1)\",\"LinkedList基于链表实现，get(int index)需要遍历链表，时间复杂度是O(n)\",\"get(E element)这种查找，两种集合都需要遍历，时间复杂度都是O(n)\",\"增删速率 \",\"ArrayList增删如果是数组末尾的位置，直接插入或者删除就可以了，但是如果插入中间的位置，就需要把插入位置后的元素都向前或者向后移动，甚至还有可能触发扩容\",\"双向链表的插入和删除只需要改变前驱节点、后继节点和插入节点的指向就行了，不需要移动元素\",\"是否支持随机访问 \",\"ArrayList基于数组，所以它可以根据下标查找，支持随机访问 \",\"它也实现了RandmoAccess 接口，这个接口只是用来标识是否支持随机访问\",\"LinkedList基于链表，所以它没法根据序号直接获取元素，它没有实现RandmoAccess 接口，标记不支持随机访问\",\"内存占用 \",\"ArrayList基于数组，是一块连续的内存空间 \",\"ArrayList是预先定义好的数组，可能会有空的内存空间，存在一定空间浪费\",\"LinkedList基于链表，内存空间不连续，它们在空间占用上都有一些额外的消耗 \",\"LinkedList每个节点，需要存储前驱和后继，所以每个节点会占用更多的空间\"]},\"303\":{\"h\":\"ArrayList的扩容机制了解吗？\",\"t\":[\"数组满了，再插入时，触发扩容\",\"计算新数组容量，容量大小为原数组1.5倍\",\" private int newCapacity(int minCapacity) { // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity >> 1); if (newCapacity - minCapacity <= 0) { if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) return Math.max(DEFAULT_CAPACITY, minCapacity); if (minCapacity < 0) // overflow throw new OutOfMemoryError(); return minCapacity; } return (newCapacity - MAX_ARRAY_SIZE <= 0) ? newCapacity : hugeCapacity(minCapacity); } \",\"int newCapacity = oldCapacity + (oldCapacity >> 1);\",\"复制原数组元素到新数组\"]},\"304\":{\"h\":\"ArrayList怎么序列化的知道吗？ 为什么用transient修饰数组？\",\"t\":[\"ArrayList的序列化不太一样，它使用 transient 修饰存储元素的 elementData 的数组\",\"transient 关键字的作用是让被修饰的成员属性不被序列化\"]},\"305\":{\"h\":\"为什么最ArrayList不直接序列化元素数组呢？\",\"t\":[\"出于效率的考虑 \",\"数组可能长度100，但实际只用了50，剩下的50不用其实不用序列化，这样可以提高序列化和反序列化的效率，还可以节省内存空间\"]},\"306\":{\"h\":\"那ArrayList怎么序列化呢 ？\",\"t\":[\"ArrayList通过两个方法readObject、writeObject自定义序列化和反序列化策略，实际直接使用两个流 ObjectOutputStream 和 ObjectInputStream 来进行序列化和反序列化\"]},\"307\":{\"h\":\"快速失败(fail-fast)和安全失败(fail-safe)了解吗？\",\"t\":[\"快速失败（fail—fast）：快速失败是Java集合的一种错误检测机制 \",\"触发 \",\"在用迭代器遍历一个集合对象时，如果线程A遍历过程中，线程B对集合对象的内容进行了修改（增加、删除、修改），则会抛出Concurrent Modification Exception\",\"原理 \",\"迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个modCount 变量。集合在被遍历期间如果内容发生变化，就会改变 modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测 modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。\",\"注意 \",\"这里异常的抛出条件是检测到 modCount！=expectedmodCount 这个条件。如果集合发生变化时修改modCount值刚好又设置为了expectedmodCount值，则异常不会抛出。因此，不能依赖于这个异常是否抛出而进行并发操作的编程，这个异常只建议用于检测并发修改的bug\",\"场景 \",\"java.util包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改），比如ArrayList 类。\",\"安全失败（fail—safe） \",\"策略 \",\"采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历\",\"原理 \",\"由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception\",\"缺点 \",\"基于拷贝内容的优点是避免了Concurrent Modification Exception，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的\",\"场景 \",\"java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改，比如CopyOnWriteArrayList类\"]},\"308\":{\"h\":\"实现ArrayList线程安全有哪几种方法？\",\"t\":[\"用Vector代替ArrayList \",\"Vector是一个线程安全的动态数组类，可以直接使用它来替代ArrayList\",\"Vector的所有方法都是同步的，因此在并发环境下可以安全地进行读写操作。\",\"但它的性能很低，不推荐使用。\",\"使用Collections.synchronizedList包装ArrayList \",\"可以使用Collections工具类的synchronizedList方法将ArrayList转换为线程安全的List\",\"该方法返回一个包装后的线程安全List，对该List的所有操作都会进行同步处理，确保线程安全\",\"使用CopyOnWriteArrayList代替ArrayList \",\"CopyOnWriteArrayList是一种线程安全的并发List\",\"它通过在修改时创建副本来实现并发访问\",\"由于读操作不需要加锁，因此在读多写少的场景中，CopyOnWriteArrayList具有较高的性能\",\"使用同步机制控制ArrayList的读写 \",\"在使用ArrayList时，可以通过同步机制（如使用synchronized关键字或Lock）来控制对ArrayList的读写操作，以确保线程安全\"]},\"309\":{\"h\":\"CopyOnWriteArrayList了解多少？\",\"t\":[\"CopyOnWriteArrayList就是线程安全版本的ArrayList，它的名字叫 CopyOnWrite，写时复制，已经明示了它的原理\",\"特点 \",\"线程安全性 \",\"CopyOnWriteArrayList通过创建副本的方式实现线程安全，因此可以在多线程环境下安全地进行读操作，而不需要额外的同步措施\",\"读写分离 \",\"CopyOnWriteArrayList适合在读多写少的场景中使用，因为每次写操作都会创建一个新的副本，会带来一定的内存开销。但在读操作频繁、写操作较少的情况下，可以获得较高的读取性能\",\"迭代器的弱一致性 \",\"由于CopyOnWriteArrayList在写操作时会创建副本，因此在遍历集合时使用的迭代器可能不反映最新的修改。迭代器提供的是一个一致性视图，即迭代器创建时的集合状态\",\"工作流程 \",\"将原数组拷贝一份\",\"写操作在副本上，加锁\",\"读操作在原数组上，无锁\",\"写完将元素数组指向副本\",\"缺点 \",\"由于CopyOnWriteArrayList在每次写操作时都会创建副本，因此适用于写操作较少、读操作频繁且对实时性要求不高的场景。如果写操作频繁或对实时性要求较高，可能会带来较高的内存开销和延迟。\",\"volatile修饰原数组array，保证了可见性\"]},\"310\":{\"h\":\"数据拷贝的过程中，有其它线程写入数据怎么办？\",\"t\":[\"阻塞呗，数据拷贝在add方法中进行，add方法有锁\"]},\"311\":{\"h\":\"Map\"},\"312\":{\"h\":\"能说一下HashMap的数据结构吗？\",\"t\":[\"数组 + 链表（JDK1.7）\",\"数组 + 链表 + 红黑树 （JDK1.8）\",\"数据结构示意图\",\"存储结构 \",\"HashMap内部使用一个数组（Entry[]）来存储数据\",\"数组中的每个元素称为一个桶（Bucket），每个桶存储一个键值对（Entry）\",\"哈希函数 \",\"HashMap使用键的哈希码（hash code）来计算存储位置\",\"每个键值对根据哈希函数计算得到一个桶的索引，然后将键值对存储在该桶中\",\"冲突处理 \",\"由于哈希函数的计算结果可能会出现冲突，即不同的键计算得到相同的桶索引\",\"HashMap使用链表或红黑树来解决冲突\",\"当桶中的元素较少时，使用链表存储键值对\",\"当桶中的元素较多时，将链表转换为红黑树，以提高查找、插入和删除的效率\"]},\"313\":{\"h\":\"你对红黑树了解多少？为什么不用二叉树/平衡树呢？\"},\"314\":{\"h\":\"什么是红黑树？\",\"t\":[\"红黑树是一种自平衡的二叉搜索树\",\"二叉搜索树性质\",\"左子节点的值小于等于当前节点的值，右子节点的值大于等于当前节点的值\",\"节点颜色\",\"每个节点要么是红色，要么是黑色\",\"根节点和叶子节点\",\"根节点是黑色的，叶子节点（NIL节点）是黑色的\",\"红色节点限制\",\"红色节点的子节点必须是黑色的\",\"黑色节点计数\",\"从任一节点到其每个叶子节点的路径上，黑色节点的数量是相同的\"]},\"315\":{\"h\":\"为什么不用二叉树？\",\"t\":[\"红黑树相对于普通的二叉搜索树的优势在于它能够保持良好的平衡，性能更加优秀和稳定\",\"普通的二叉搜索树在最坏情况下可能会退化成链表 ,导致插入、删除和查找操作的时间复杂度变为O(n)\",\"而红黑树通过自平衡的特性，避免了这种退化情况，保证了操作的最坏时间复杂度为O(log n)，其中n是树中节点的数量\"]},\"316\":{\"h\":\"为什么不用平衡二叉树？\",\"t\":[\"相比于平衡二叉树，红黑树在保持平衡的过程中旋转的次数较少，提高了插入和删除操作的效率\",\"红黑树通过引入节点颜色和特定性质，保证了树的相对平衡\",\"而平衡二叉树要求更严格的平衡条件，需要更多的旋转操作来保持平衡，导致插入和删除操作的效率较低\"]},\"317\":{\"h\":\"红黑树怎么保持平衡的知道吗？\",\"t\":[\"红黑树有两种方式保持平衡： 旋转 和 染色\",\"旋转 \",\"旋转分为两种，左旋和右旋\",\"染色\"]},\"318\":{\"h\":\"HashMap的put流程知道吗？\",\"t\":[\"首先进行哈希值的扰动，获取一个新的哈希值\",\"(key == null) ? 0 : (h =key.hashCode()) ^ (h >>> 16) \",\"判断tab是否位空或者长度为0，如果是则进行扩容操作\",\"if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; \",\"根据哈希值计算下标，如果对应下标正好没有存放数据，则直接插入即可，否则需要覆盖\",\"if ((p = tab[i = (n - 1) & hash]) == null) tab[i] = newNode(hash, key, value, null); else { //覆盖 } \",\"判断tab[i]是否为树节点，否则向链表中插入数据，是则向树中插入节点\",\"// 覆盖逻辑 Node<K,V> e; K k; if (p.hash == hash && ((k = p.key) == key || (key != null && key.equals(k)))) e = p; else if (p instanceof TreeNode) e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value); else { for (int binCount = 0; ; ++binCount) { if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; } if (e.hash == hash && ((k = e.key) == key || (key != null && key.equals(k)))) break; p = e; } } \",\"如果链表中插入节点的时候，链表长度大于等于8，则需要把链表转换为红黑树\",\" if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); \",\"最后所有元素处理完成后，判断是否超过阈值； threshold ，超过则扩容\",\" if (++size > threshold) resize(); \"]},\"319\":{\"h\":\"HashMap怎么查找元素的呢？\",\"t\":[\" public V get(Object key) { Node<K,V> e; return (e = getNode(hash(key), key)) == null ? null : e.value; } \",\" final Node<K,V> getNode(int hash, Object key) { Node<K,V>[] tab; Node<K,V> first, e; int n; K k; if ((tab = table) != null && (n = tab.length) > 0 && (first = tab[(n - 1) & hash]) != null) { if (first.hash == hash && // always check first node ((k = first.key) == key || (key != null && key.equals(k)))) return first; if ((e = first.next) != null) { if (first instanceof TreeNode) return ((TreeNode<K,V>)first).getTreeNode(hash, key); do { if (e.hash == hash && ((k = e.key) == key || (key != null && key.equals(k)))) return e; } while ((e = e.next) != null); } } return null; } \",\"使用扰动函数，获取新的哈希值\",\"计算数组下标，获取节点\",\"当前节点和key匹配，直接返回\",\"否则，当前节点是否为树节点，查找红黑树\",\"否则，遍历链表查找\"]},\"320\":{\"h\":\"HashMap的哈希/扰动函数是怎么设计的?\",\"t\":[\"HashMap的哈希函数是先通过 hashCode() 获取到key的哈希值\",\"哈希值是一个32位的int类型的数值，然后再将哈希值右移16位（高位），然后与哈希值本身异或，达到高位与低位混合的效果\",\"这样的设计增加了哈希值的随机性，降低了哈希冲突的概率 。\",\"异或操作使得低位的特征影响到高位，减少了相同低位的哈希值导致相同索引位置的情况\"]},\"321\":{\"h\":\"为什么哈希/扰动函数能降hash碰撞？\",\"t\":[\"因为哈希值&(数组长度 - 1)保留的是hash值的地位特征，所以对扰动函数通过对哈希值进行变换，新hash值保留了高低位的特征，这样使得哈希值的分布更加均匀，从而降低哈希碰撞的概率\"]},\"322\":{\"h\":\"为什么HashMap的容量是2的倍数呢？\",\"t\":[\"方便哈希取余 \",\"取余是去除整数倍，保留整数倍以下的数据\",\"hash值&(数组大小-1) ，也达到了取余的效果 \",\"数组大小为2的倍数，(数组大小-1) 则为一个全是1的二进制数\",\"hash值&(数组大小-1) 结果为直接保留hash值对(数组大小-1) 的低位的余数部分 \",\"因为任意数&1得任意数\",\"任意数&0得0\",\"hash值&(数组大小-1) ，将(数组大小-1)高位补0，补全到和hash值一样多的位数，那么hash值高位是与0做&运算，低位是与1做位运算，即保留了低位hash值，也是取余的效果\",\"在扩容时，利用扩容后的大小也是2的倍数，将已经产生hash碰撞的元素完美的转移到新的table中去\"]},\"323\":{\"h\":\"如果初始化HashMap，传一个17的值 new HashMap<> ，它会怎么处理？\",\"t\":[\"初始化时，传的不是2的倍数时，HashMap会向上寻找 离得最近的2的倍数 ，所以传入17，但HashMap的实际容量是32\",\"HashMap的容量必须是2的倍数\"]},\"324\":{\"h\":\"你还知道哪些哈希函数的构造方法呢？\",\"t\":[\"除留取余法 \",\"HashMap里进行了优化改造，效率更高，散列也更均衡\",\"直接定址法 \",\"直接根据 key 来映射到对应的数组位置，例如1232放到下标1232的位置\",\"数字分析法 \",\"取 key 的某些数字（例如十位和百位）作为映射的位置\",\"平方取中法 \",\"取 key 平方的中间几位作为映射的位置\",\"折叠法 \",\"将 key 分割成位数相同的几段，然后把它们的叠加和作为映射的位置\"]},\"325\":{\"h\":\"解决哈希冲突有哪些方法呢？\",\"t\":[\"链地址法 \",\"在冲突的位置拉一个链表，把冲突的元素放进去\",\"开放定址法 \",\"开放定址法就是从冲突的位置再接着往下找，给冲突元素找个空位\",\"找到空闲位置的方法也有很多 \",\"线行探查法 \",\"从冲突的位置开始，依次判断下一个位置是否空闲，直至找到空闲位置\",\"平方探查法 \",\"从冲突的位置x开始，第一次增加 1^2 个位置，第二次增加2^2 …，直至找到空闲的位置\",\"再哈希法 \",\"换种哈希函数，重新计算冲突元素的地址\",\"建立公共溢出区 \",\"再建一个数组，把冲突的元素放进去\"]},\"326\":{\"h\":\"为什么HashMap链表转红黑树的阈值为8呢？\",\"t\":[\"红黑树节点的大小大概是普通节点大小的两倍，所以转红黑树，牺牲了空间换时间，更多的是一种兜底的策略，保证极端情况下的查找效率\",\"链表转红黑树的阈值为什么要选8呢？ \",\"和统计学有关。理想情况下，使用随机哈希码，链表里的节点符合泊松分布，出现节点个数的概率是递减的，节点个数为8的情况，发生概率仅为0.00000006\",\"红黑树转回链表的阈值为什么是6，而不是8？ \",\"是因为如果这个阈值也设置成8，假如发生碰撞，节点增减刚好在8附近，会发生链表和红黑树的不断转换，导致资源浪费\"]},\"327\":{\"h\":\"扩容在什么时候呢？为什么扩容因子是0.75？\",\"t\":[\"为了减少哈希冲突发生的概率,当前HashMap的元素个数达到一个临界值的时候，就会触发扩容\",\"这个 临界值threshold 就是由加载因子和当前容器的容量大小来确定的\"]},\"328\":{\"h\":\"那么为什么选择了0.75作为HashMap的默认加载因子呢？\",\"t\":[\"这是对 空间 成本和 时间 成本平衡的考虑 \",\"假如我们设的比较大，元素比较多，空位比较少的时候才扩容，那么发生哈希冲突的概率就增加了，查找的时间成本就增加了\",\"我们设的比较小的话，元素比较少，空位比较多的时候就扩容了，发生哈希碰撞的概率就降低了，查找时间成本降低，但是就需要更多的空间去存储元素，空间成本就增加了\"]},\"329\":{\"h\":\"HashMap扩容机制了解吗？\",\"t\":[\"为了减少哈希冲突发生的概率,当前HashMap的元素个数达到一个临界值的时候，就会触发扩容\",\"链表结构扩容后 \",\"hash&老容量==0 \",\"现在位置=原先位置\",\"hash&老容量==1 \",\"现在位置=原先位置+oldCap\"]},\"330\":{\"h\":\"JDK1.8对HashMap主要做了哪些优化呢？为什么？\",\"t\":[\"数据结构 \",\"在JDK 1.8中，当哈希冲突较多时，HashMap会将链表转换为红黑树，以提高查找、插入和删除操作的效率\",\"种优化是为了解决在极端情况下链表过长导致的性能问题。\",\"红黑树的平均时间复杂度为O(log n)，相比于链表的O(n)更高效\",\"哈希碰撞优化 \",\"JDK 1.8对哈希碰撞的处理进行了优化\",\"当发生哈希碰撞时，HashMap会使用更加均匀的哈希函数来计算索引位置，减少碰撞的概率\",\"JDK 1.8还引入了\\\"树化阈值\\\"和\\\"链表转树阈值\\\"的概念，动态调整链表和红黑树的阈值，以平衡性能和空间的消耗\",\"链表插入方式 \",\"在JDK 1.8中，当插入新的键值对时，HashMap采用了尾插法（将新键值对插入链表或红黑树末尾），而不是头插法\",\"这样做可以减少链表或红黑树的重新排序次数，提高插入操作的效率\",\"扩容优化 \",\"JDK 1.8对HashMap的扩容操作进行了优化\",\"在扩容时，HashMap采用了\\\"渐进式扩容\\\"的策略，将扩容操作分散到多次进行，避免了一次性重新计算所有键的哈希值和索引位置，减少了扩容操作的时间和资源消耗\"]},\"331\":{\"h\":\"你能自己设计实现一个HashMap吗？\",\"t\":[\"散列函数 \",\"hashCode()+除留余数法\",\"冲突解决 \",\"链地址法\",\"扩容 \",\"节点重新hash获取位置\"]},\"332\":{\"h\":\"HashMap 是线程安全的吗？多线程下会有什么问题？\",\"t\":[\"不是线程安全的\",\"多线程下扩容死循环 \",\"在JDK1.7中，HashMap使用头插法插入元素，当多个线程同时进行扩容操作时，可能会导致环形链表的出现，从而形成死循环\",\"JDK1.8中的HashMap改为使用尾插法插入元素，在扩容时保持链表元素原本的顺序，避免了环形链表的问题\",\"多线程的put可能导致元素的丢失 \",\"当多个线程同时执行put操作时，如果计算出来的索引位置相同，就会导致后一个key覆盖前一个key，从而导致元素的丢失\",\"这个问题在JDK1.7和JDK1.8中都存在\",\"put和get并发时，可能导致get为null \",\"当一个线程执行put操作导致扩容时，另一个线程同时执行get操作\",\"由于扩容过程中元素迁移的不可见性，可能导致get操作返回null\",\"这个问题在JDK1.7和JDK1.8中都存在\"]},\"333\":{\"h\":\"有什么办法能解决HashMap线程不安全的问题呢？\",\"t\":[\"使用线程安全的包装类 \",\"使用 Collections.synchronizedMap() 方法将HashMap包装成线程安全的Map\",\"这个方法返回一个线程安全的Map对象，对该对象的操作会自动进行同步，从而保证线程安全\",\"使用同步机制 \",\"可以使用 synchronized 关键字或其他同步机制（如ReentrantLock ）对HashMap进行加锁\",\"使用线程安全的并发容器 \",\"可以使用 ConcurrentHashMap 代替HashMap\",\"ConcurrentHashMap 是Java提供的线程安全的哈希表实现，通过使用锁分段技术和CAS操作来实现高效的并发性能\"]},\"334\":{\"h\":\"能说一下ConcurrentHashmap的具体实现吗？\",\"t\":[\"ConcurrentHashmap线程安全在jdk1.7版本是基于 分段锁 实现\",\"在jdk1.8是基于CAS+synchronized 实现\"]},\"335\":{\"h\":\"JDK1.7：分段锁\",\"t\":[\"JDK1.7版本的ConcurrentHashMap采用分段锁机制 \",\"里面包含一个Segment数组，Segment继承于ReentrantLock，Segment则包含HashEntry的数组\",\"HashEntry本身就是一个链表的结构，具有保存key、value的能力能指向下一个节点的指针\",\"实际上就是相当于每个Segment都是一个HashMap\",\"默认的Segment长度是16，也就是支持16个线程的并发写，Segment之间相互不会受到影响\",\"put流程 \",\"计算hash，定位到segment，segment如果是空就先初始化\",\"使用ReentrantLock加锁，如果获取锁失败则尝试自旋，自旋超过次数就阻塞获取，保证一定获取锁成功\",\"遍历HashEntry，就是和HashMap一样，数组中key和hash一样就直接替换，不存在就再插入链表，链表同样操作\",\"get流程 \",\"key通过hash定位到segment，再遍历链表定位到具体的元素上\",\"需要注意的是value是volatile的，所以get是不需要加锁的\"]},\"336\":{\"h\":\"JDK1.8：CAS+synchronized\",\"t\":[\"数据结构\",\"数据结构和HashMap是一样的，数组+链表+红黑树\",\"它实现线程安全的关键点在于put流程\",\"put流程\",\"首先计算hash，遍历node数组，如果数组是空的话，就通过CAS+自旋的方式初始化数组\",\" if (tab == null || (n = tab.length) == 0) tab = initTable(); \",\"初始化数组\",\"private final Node<K,V>[] initTable() { Node<K,V>[] tab; int sc; while ((tab = table) == null || tab.length == 0) { //如果正在初始化或者扩容 if ((sc = sizeCtl) < 0) //等待(让出线程) Thread.yield(); // lost initialization race; just spin else if (U.compareAndSetInt(this, SIZECTL, sc, -1)) {//CAS操作 try { if ((tab = table) == null || tab.length == 0) { int n = (sc > 0) ? sc : DEFAULT_CAPACITY; @SuppressWarnings(\\\"unchecked\\\") Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n]; table = tab = nt; sc = n - (n >>> 2); } } finally { sizeCtl = sc; } break; } } return tab; } \",\"如果当前数组位置是空则直接通过CAS自旋写入数据\",\"else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) { if (casTabAt(tab, i, null, new Node<K,V>(hash, key, value))) break; // no lock when adding to empty bin } \",\"如果hash==MOVED，说明需要扩容，执行扩容\",\" final Node<K,V>[] helpTransfer(Node<K,V>[] tab, Node<K,V> f) { Node<K,V>[] nextTab; int sc; if (tab != null && (f instanceof ForwardingNode) && (nextTab = ((ForwardingNode<K,V>)f).nextTable) != null) { int rs = resizeStamp(tab.length) << RESIZE_STAMP_SHIFT; while (nextTab == nextTable && table == tab && (sc = sizeCtl) < 0) { if (sc == rs + MAX_RESIZERS || sc == rs + 1 || transferIndex <= 0) break; if (U.compareAndSetInt(this, SIZECTL, sc, sc + 1)) { transfer(tab, nextTab); break; } } return nextTab; } return table; } \",\"如果都不满足，就使用synchronized写入数据\",\"写入数据同样判断链表、红黑树，链表写入和HashMap的方式一样，key hash一样就覆盖，反之就尾插法，链表长度超过8就转换成红黑树\",\"get查询\",\"无锁化读取，和HashMap的get流程基本相同 \",\"头节点通过Unsafe获取\"]},\"337\":{\"h\":\"HashMap 内部节点是有序的吗？\",\"t\":[\"HashMap 内部节点的顺序是无序的\",\"因为 HashMap 使用的是哈希表的数据结构，它通过哈希函数将键映射到桶（bucket）中，而不是按照插入顺序进行存储\",\"如果需要有序的存储和遍历元素，可以考虑使用 LinkedHashMap 或者 TreeMap\"]},\"338\":{\"h\":\"讲讲 LinkedHashMap 怎么实现有序的？\",\"t\":[\"LinkedHashMap在 HashMap 的基础上维护了一个双向链表，用于记录元素的插入顺序或访问顺序\",\"通过这个链表， LinkedHashMap 可以按照插入顺序或访问顺序进行遍历。\"]},\"339\":{\"h\":\"讲讲 TreeMap 怎么实现有序的？\",\"t\":[\"TreeMap 是基于红黑树实现的，是一种有序的的集合\",\"在 TreeMap 中，元素是按照是按照 Key 的自然顺序或者 Comprator 的顺序进行排序，因此可以通过键值来遍历 集合中的元素 \",\"不是通过插入顺序遍历\"]},\"340\":{\"h\":\"Set\"},\"341\":{\"h\":\"讲讲HashSet的底层实现？\",\"t\":[\"HashSet 底层就是基于 HashMap 实现的\",\"HashSet 的源码⾮常⾮常少，因为除了clone() 、 writeObject() 、 readObject() 是 HashSet⾃⼰不得不实现之外，其他⽅法都是直接调⽤ HashMap 中的⽅法。\",\"HashSet的add方法\",\" public boolean add(E e) { return map.put(e, PRESENT)==null; } \",\"直接调用HashMap的put方法，将添加的元素作为key，new一个Object作为value\",\"会根据返回值是否为空来判断是否插入元素成功\",\"HashMap的putVal\",\"进行了一系列判断，最后的结果是，只有在key在table数组中不存在的时候，才会返回插入的值\",\"if (e != null) { // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; } \"]},\"342\":{\"h\":\"引言\"},\"343\":{\"h\":\"说说有哪些常见集合？\",\"t\":[\"List\",\"Map\",\"Set\"]},\"344\":{\"h\":\"Posts\"},\"345\":{\"h\":\"Java基础\"},\"346\":{\"h\":\"Java\"},\"347\":{\"h\":\"Java并发\"},\"348\":{\"h\":\"Java集合\"}},\"dirtCount\":0,\"index\":[[\"才会返回插入的值\",{\"1\":{\"341\":1}}],[\"才能缩写成\",{\"1\":{\"33\":1}}],[\"底层就是基于\",{\"1\":{\"341\":1}}],[\"底部设置change\",{\"1\":{\"20\":1}}],[\"讲讲hashset的底层实现\",{\"0\":{\"341\":1}}],[\"讲讲\",{\"0\":{\"338\":1,\"339\":1}}],[\"头节点通过unsafe获取\",{\"1\":{\"336\":1}}],[\"冲突解决\",{\"1\":{\"331\":1}}],[\"冲突处理\",{\"1\":{\"312\":1}}],[\"渐进式扩容\",{\"1\":{\"330\":1}}],[\"动态调整链表和红黑树的阈值\",{\"1\":{\"330\":1}}],[\"动态地替换\",{\"1\":{\"44\":1}}],[\"树化阈值\",{\"1\":{\"330\":1}}],[\"种优化是为了解决在极端情况下链表过长导致的性能问题\",{\"1\":{\"330\":1}}],[\"老容量==1\",{\"1\":{\"329\":1}}],[\"老容量==0\",{\"1\":{\"329\":1}}],[\"现在位置=原先位置+oldcap\",{\"1\":{\"329\":1}}],[\"现在位置=原先位置\",{\"1\":{\"329\":1}}],[\"现代处理器采用了指令级并行技术\",{\"1\":{\"106\":1}}],[\"空位比较多的时候就扩容了\",{\"1\":{\"328\":1}}],[\"空位比较少的时候才扩容\",{\"1\":{\"328\":1}}],[\"空间成本就增加了\",{\"1\":{\"328\":1}}],[\"空间\",{\"1\":{\"328\":1}}],[\"空闲核心线程执行任务\",{\"1\":{\"231\":1,\"234\":1}}],[\"空闲线程在被终止前等待新任务的最长时间\",{\"1\":{\"235\":1}}],[\"空闲线程存活时间\",{\"1\":{\"229\":1}}],[\"空闲线程的存活时间\",{\"1\":{\"195\":1}}],[\"临界值threshold\",{\"1\":{\"327\":1}}],[\"假如我们设的比较大\",{\"1\":{\"328\":1}}],[\"假如发生碰撞\",{\"1\":{\"326\":1}}],[\"假设初始条件是a\",{\"1\":{\"291\":1}}],[\"理想情况下\",{\"1\":{\"326\":1}}],[\"牺牲了空间换时间\",{\"1\":{\"326\":1}}],[\"建立公共溢出区\",{\"1\":{\"325\":1}}],[\"建议使用\",{\"1\":{\"32\":1}}],[\"换种哈希函数\",{\"1\":{\"325\":1}}],[\"依次判断下一个位置是否空闲\",{\"1\":{\"325\":1}}],[\"依存于类的实例\",{\"1\":{\"93\":1}}],[\"线行探查法\",{\"1\":{\"325\":1}}],[\"线程b对集合对象的内容进行了修改\",{\"1\":{\"307\":1}}],[\"线程b可以调用线程interrupt\",{\"1\":{\"131\":1}}],[\"线程己经持有了至少一个资源\",{\"1\":{\"299\":1}}],[\"线程死锁了解吗\",{\"0\":{\"299\":1}}],[\"线程死锁等\",{\"1\":{\"263\":1}}],[\"线程直接进入队列中排队\",{\"1\":{\"285\":1}}],[\"线程进入队列后会进行自旋\",{\"1\":{\"283\":1}}],[\"线程解锁前\",{\"1\":{\"274\":1}}],[\"线程加锁后\",{\"1\":{\"274\":1}}],[\"线程加锁前\",{\"1\":{\"274\":1}}],[\"线程执行任务\",{\"1\":{\"264\":2}}],[\"线程执行任务时\",{\"1\":{\"232\":1}}],[\"线程从delayqueue中获取已到期的scheduledfuturetask\",{\"1\":{\"247\":1}}],[\"线程并不会立即销毁\",{\"1\":{\"241\":1}}],[\"线程工厂\",{\"1\":{\"235\":1}}],[\"线程空闲时间\",{\"1\":{\"235\":1}}],[\"线程空闲或终止\",{\"1\":{\"234\":1}}],[\"线程将继续处于空闲状态\",{\"1\":{\"232\":1}}],[\"线程的创建和销毁需要在操作系统和jvm内部进行同步\",{\"1\":{\"203\":1}}],[\"线程管理\",{\"1\":{\"190\":1}}],[\"线程复用\",{\"1\":{\"190\":1}}],[\"线程阻塞和唤醒机制\",{\"1\":{\"187\":1}}],[\"线程池并发调用api\",{\"0\":{\"266\":1}}],[\"线程池调优了解吗\",{\"0\":{\"263\":1}}],[\"线程池如何实现参数的动态修改\",{\"0\":{\"262\":1}}],[\"线程池完全终止\",{\"1\":{\"260\":1}}],[\"线程池不再接受新任务\",{\"1\":{\"257\":1,\"258\":1}}],[\"线程池进入\",{\"1\":{\"257\":1,\"258\":1}}],[\"线程池可以接受新任务\",{\"1\":{\"256\":1}}],[\"线程池可以通过调用shutdown\",{\"1\":{\"233\":1}}],[\"线程池异常处理是一个常见的问题\",{\"1\":{\"248\":1}}],[\"线程池异常怎么处理知道吗\",{\"0\":{\"248\":1}}],[\"线程池特点\",{\"1\":{\"244\":1,\"245\":1,\"246\":1,\"247\":1}}],[\"线程池是否有一条线程在\",{\"1\":{\"246\":1}}],[\"线程池是怎么实现线程复用的\",{\"0\":{\"241\":1}}],[\"线程池是一种管理和控制多个线程并发执行的机制\",{\"1\":{\"189\":1}}],[\"线程池将不再接受新的任务\",{\"1\":{\"239\":1}}],[\"线程池怎么关闭知道吗\",{\"0\":{\"239\":1}}],[\"线程池提交execute和submit有什么区别\",{\"0\":{\"238\":1}}],[\"线程池通常使用工作队列来存储等待执行的任务\",{\"1\":{\"237\":1}}],[\"线程池通过预先创建一组线程\",{\"1\":{\"189\":1}}],[\"线程池有哪几种工作队列\",{\"0\":{\"237\":1}}],[\"线程池会尝试停止所有正在执行的任务\",{\"1\":{\"239\":1}}],[\"线程池会将其记录下来\",{\"1\":{\"238\":1}}],[\"线程池会优先使用核心线程来处理任务\",{\"1\":{\"235\":1}}],[\"线程池会自动管理线程的生命周期\",{\"1\":{\"190\":1}}],[\"线程池中没有活动的线程\",{\"1\":{\"259\":2}}],[\"线程池中的线程数量会根据任务的数量自动调整\",{\"1\":{\"242\":1}}],[\"线程池中的线程数量不会发生变化\",{\"1\":{\"242\":1}}],[\"线程池中的线程就实现了复用\",{\"1\":{\"241\":1}}],[\"线程池中的线程作为消费者\",{\"1\":{\"241\":1}}],[\"线程池中的线程会在处理完一个请求后立即准备处理下一个请求\",{\"1\":{\"210\":1}}],[\"线程池中允许存在的最大线程数\",{\"1\":{\"235\":1}}],[\"线程池中保持活动状态的最小线程数\",{\"1\":{\"235\":1}}],[\"线程池主要参数有哪些\",{\"0\":{\"235\":1}}],[\"线程池关闭等\",{\"1\":{\"264\":1}}],[\"线程池关闭等基本功能\",{\"1\":{\"264\":1}}],[\"线程池关闭\",{\"0\":{\"233\":1},\"1\":{\"234\":1}}],[\"线程池按照以下顺序处理任务\",{\"1\":{\"231\":1}}],[\"线程池初始化\",{\"0\":{\"229\":1}}],[\"线程池大小为10\",{\"1\":{\"211\":1}}],[\"线程池大小根据需要动态调整\",{\"1\":{\"182\":1}}],[\"线程池在初始化时\",{\"1\":{\"229\":1}}],[\"线程池在初始化时创建一定数量的线程\",{\"1\":{\"190\":1}}],[\"线程池在实际工作中有着广泛的应用\",{\"1\":{\"207\":1}}],[\"线程池能够创建的最大线程数\",{\"1\":{\"195\":1}}],[\"线程池维护的最小线程数\",{\"1\":{\"195\":1}}],[\"线程池的任务队列也是需要考虑的因素之一\",{\"1\":{\"240\":1}}],[\"线程池的线程数配置需要根据任务性质\",{\"1\":{\"240\":1}}],[\"线程池的线程数配置应该根据你的应用场景和需求来决定\",{\"1\":{\"240\":1}}],[\"线程池的线程数应该怎么配置\",{\"0\":{\"240\":1}}],[\"线程池的关闭可以通过调用shutdown\",{\"1\":{\"239\":1}}],[\"线程池的拒绝策略用于定义当线程池无法接受新任务时应该采取的操作\",{\"1\":{\"236\":1}}],[\"线程池的拒绝策略有哪些\",{\"0\":{\"236\":1}}],[\"线程池的主要参数包括\",{\"1\":{\"235\":1}}],[\"线程池的工作流程如下图所示\",{\"1\":{\"234\":1}}],[\"线程池的工作流程可以分为以下几个步骤\",{\"1\":{\"228\":1}}],[\"线程池的完整工作流程\",{\"0\":{\"234\":1}}],[\"线程池的配置参数影响其行为和性能\",{\"1\":{\"195\":1}}],[\"线程池的配置参数\",{\"0\":{\"195\":1}}],[\"线程池的使用示例\",{\"0\":{\"194\":1}}],[\"线程池的优势\",{\"0\":{\"191\":1}}],[\"线程池的基本概念\",{\"0\":{\"190\":1}}],[\"线程池\",{\"0\":{\"188\":1},\"1\":{\"255\":1}}],[\"线程池类型\",{\"0\":{\"180\":1}}],[\"线程调用此方法进行数据交换\",{\"1\":{\"149\":1}}],[\"线程调用这个方法释放一个许可\",{\"1\":{\"145\":1}}],[\"线程调用这个方法尝试获取一个许可\",{\"1\":{\"145\":1}}],[\"线程首先尝试获取一个许可\",{\"1\":{\"145\":1}}],[\"线程会被阻塞\",{\"1\":{\"145\":1}}],[\"线程会被自动唤醒\",{\"1\":{\"131\":1}}],[\"线程达到公共屏障点\",{\"1\":{\"142\":1}}],[\"线程内\",{\"1\":{\"138\":1}}],[\"线程thread除了提供join\",{\"1\":{\"138\":1}}],[\"线程间有哪些通信方式\",{\"0\":{\"138\":1}}],[\"线程上下文切换\",{\"0\":{\"202\":1}}],[\"线程上下文切换通常发生在以下几种情况下\",{\"0\":{\"136\":1}}],[\"线程上下文切换是一种非常耗时的操作\",{\"1\":{\"135\":1}}],[\"线程上下文切换是指在多线程环境下\",{\"1\":{\"135\":1}}],[\"线程不会再进入任何状态\",{\"1\":{\"134\":1}}],[\"线程被创建\",{\"1\":{\"132\":1}}],[\"线程共有六种状态\",{\"1\":{\"132\":1}}],[\"线程有几种状态\",{\"0\":{\"132\":1}}],[\"线程有哪些常用的调度方法\",{\"0\":{\"131\":1}}],[\"线程中断\",{\"1\":{\"131\":1,\"142\":1}}],[\"线程休眠\",{\"1\":{\"131\":1}}],[\"线程是不会继续执行的\",{\"1\":{\"131\":1}}],[\"线程是进程的一个执行路径\",{\"1\":{\"127\":1}}],[\"线程a实际并没有被中断\",{\"1\":{\"131\":1}}],[\"线程a会暂时让出指定时间的执行权\",{\"1\":{\"131\":1}}],[\"线程a会被阻塞挂起\",{\"1\":{\"131\":1}}],[\"线程a抛出interruptedexception异常返回\",{\"1\":{\"131\":1}}],[\"线程等待与通知\",{\"1\":{\"131\":1}}],[\"线程\",{\"1\":{\"127\":1,\"137\":2,\"142\":34}}],[\"线程在任何地方读取的都是它写入的变量\",{\"1\":{\"113\":1}}],[\"线程在写入变量时不会把值缓存在寄存器或者其他地方\",{\"1\":{\"110\":1}}],[\"线程可以在任何地方使用localvariable\",{\"1\":{\"113\":1}}],[\"线程之间对共享变量的修改不一定能够及时同步到主内存和其他线程的本地内存中\",{\"1\":{\"103\":1}}],[\"线程之间的共享变量存储在\",{\"1\":{\"102\":1}}],[\"线程安全\",{\"1\":{\"60\":2,\"83\":1}}],[\"线程安全性\",{\"1\":{\"60\":1,\"187\":1,\"309\":1}}],[\"找到空闲位置的方法也有很多\",{\"1\":{\"325\":1}}],[\"给冲突元素找个空位\",{\"1\":{\"325\":1}}],[\"给编译器用的\",{\"1\":{\"81\":1}}],[\"链地址法\",{\"1\":{\"325\":1,\"331\":1}}],[\"链表长度超过8就转换成红黑树\",{\"1\":{\"336\":1}}],[\"链表长度大于等于8\",{\"1\":{\"318\":1}}],[\"链表写入和hashmap的方式一样\",{\"1\":{\"336\":1}}],[\"链表同样操作\",{\"1\":{\"335\":1}}],[\"链表插入方式\",{\"1\":{\"330\":1}}],[\"链表转树阈值\",{\"1\":{\"330\":1}}],[\"链表转红黑树的阈值为什么要选8呢\",{\"1\":{\"326\":1}}],[\"链表结构扩容后\",{\"1\":{\"329\":1}}],[\"链表里的节点符合泊松分布\",{\"1\":{\"326\":1}}],[\"链表\",{\"1\":{\"312\":2}}],[\"折叠法\",{\"1\":{\"324\":1}}],[\"散列函数\",{\"1\":{\"331\":1}}],[\"散列也更均衡\",{\"1\":{\"324\":1}}],[\"散列方法重新计算位置\",{\"1\":{\"121\":1}}],[\"散列方法就是怎么把对应的key映射到table数组的相应下标\",{\"1\":{\"119\":1}}],[\"散列方法\",{\"1\":{\"119\":1}}],[\"效率更高\",{\"1\":{\"324\":1}}],[\"效果\",{\"0\":{\"13\":1}}],[\"离得最近的2的倍数\",{\"1\":{\"323\":1}}],[\"离开停车场\",{\"1\":{\"144\":1}}],[\"利用扩容后的大小也是2的倍数\",{\"1\":{\"322\":1}}],[\"补全到和hash值一样多的位数\",{\"1\":{\"322\":1}}],[\"取\",{\"1\":{\"324\":2}}],[\"取余是去除整数倍\",{\"1\":{\"322\":1}}],[\"取出key的threadlocalhashcode\",{\"1\":{\"119\":1}}],[\"扰动函数能降hash碰撞\",{\"0\":{\"321\":1}}],[\"扰动函数是怎么设计的\",{\"0\":{\"320\":1}}],[\"降低了哈希冲突的概率\",{\"1\":{\"320\":1}}],[\"降低系统性能\",{\"1\":{\"203\":1}}],[\"达到高位与低位混合的效果\",{\"1\":{\"320\":1}}],[\"达到最大线程数则执行拒绝策略\",{\"1\":{\"234\":1}}],[\"覆盖逻辑\",{\"1\":{\"318\":1}}],[\"覆盖\",{\"1\":{\"318\":1}}],[\"^\",{\"1\":{\"318\":1}}],[\"左旋和右旋\",{\"1\":{\"317\":1}}],[\"左子节点的值小于等于当前节点的值\",{\"1\":{\"314\":1}}],[\"染色\",{\"1\":{\"317\":2}}],[\"旋转分为两种\",{\"1\":{\"317\":1}}],[\"旋转\",{\"1\":{\"317\":2}}],[\"普通的二叉搜索树在最坏情况下可能会退化成链表\",{\"1\":{\"315\":1}}],[\"普通的直接引用\",{\"1\":{\"90\":1}}],[\"黑色节点的数量是相同的\",{\"1\":{\"314\":1}}],[\"黑色节点计数\",{\"1\":{\"314\":1}}],[\"红色节点的子节点必须是黑色的\",{\"1\":{\"314\":1}}],[\"红色节点限制\",{\"1\":{\"314\":1}}],[\"红黑树的平均时间复杂度为o\",{\"1\":{\"330\":1}}],[\"红黑树转回链表的阈值为什么是6\",{\"1\":{\"326\":1}}],[\"红黑树节点的大小大概是普通节点大小的两倍\",{\"1\":{\"326\":1}}],[\"红黑树有两种方式保持平衡\",{\"1\":{\"317\":1}}],[\"红黑树怎么保持平衡的知道吗\",{\"0\":{\"317\":1}}],[\"红黑树通过引入节点颜色和特定性质\",{\"1\":{\"316\":1}}],[\"红黑树在保持平衡的过程中旋转的次数较少\",{\"1\":{\"316\":1}}],[\"红黑树相对于普通的二叉搜索树的优势在于它能够保持良好的平衡\",{\"1\":{\"315\":1}}],[\"红黑树是一种自平衡的二叉搜索树\",{\"1\":{\"314\":1}}],[\"红黑树\",{\"1\":{\"312\":1,\"336\":1}}],[\"叶子节点\",{\"1\":{\"314\":1}}],[\"根节点是黑色的\",{\"1\":{\"314\":1}}],[\"根节点和叶子节点\",{\"1\":{\"314\":1}}],[\"根据哈希值计算下标\",{\"1\":{\"318\":1}}],[\"根据任务执行日志来回滚已经执行成功但未持久化的任务\",{\"1\":{\"265\":1}}],[\"根据实际情况动态调整线程池的配置\",{\"1\":{\"263\":1}}],[\"根据需要创建新线程的线程池\",{\"1\":{\"193\":1}}],[\"节点重新hash获取位置\",{\"1\":{\"331\":1}}],[\"节点增减刚好在8附近\",{\"1\":{\"326\":1}}],[\"节点个数为8的情况\",{\"1\":{\"326\":1}}],[\"节点颜色\",{\"1\":{\"314\":1}}],[\"节点流\",{\"1\":{\"28\":1}}],[\"右子节点的值大于等于当前节点的值\",{\"1\":{\"314\":1}}],[\"二叉搜索树性质\",{\"1\":{\"314\":1}}],[\"平方探查法\",{\"1\":{\"325\":1}}],[\"平方的中间几位作为映射的位置\",{\"1\":{\"324\":1}}],[\"平方取中法\",{\"1\":{\"324\":1}}],[\"平衡树呢\",{\"0\":{\"313\":1}}],[\"平台无关性\",{\"1\":{\"38\":1}}],[\"插入和删除操作的效率\",{\"1\":{\"330\":1}}],[\"插入和删除的效率\",{\"1\":{\"312\":1}}],[\"插件系统等\",{\"1\":{\"44\":1}}],[\"哈希碰撞优化\",{\"1\":{\"330\":1}}],[\"哈希值是一个32位的int类型的数值\",{\"1\":{\"320\":1}}],[\"哈希函数\",{\"1\":{\"312\":1}}],[\"哈希码常用于哈希表等数据结构的实现中\",{\"1\":{\"97\":1}}],[\"哈希码是一个整数\",{\"1\":{\"97\":1}}],[\"策略\",{\"1\":{\"307\":1}}],[\"迭代器提供的是一个一致性视图\",{\"1\":{\"309\":1}}],[\"迭代器的弱一致性\",{\"1\":{\"309\":1}}],[\"迭代器遍历的是开始遍历那一刻拿到的集合拷贝\",{\"1\":{\"307\":1}}],[\"迭代器并不能访问到修改后的内容\",{\"1\":{\"307\":1}}],[\"迭代器在遍历时直接访问集合中的内容\",{\"1\":{\"307\":1}}],[\"迭代过程中被修改\",{\"1\":{\"307\":1}}],[\"集合中的元素\",{\"1\":{\"339\":1}}],[\"集合在被遍历期间如果内容发生变化\",{\"1\":{\"307\":1}}],[\"集合基础\",{\"0\":{\"82\":1}}],[\"删除和查找操作的时间复杂度变为o\",{\"1\":{\"315\":1}}],[\"删除\",{\"1\":{\"307\":1}}],[\"删除或修改了类的属性\",{\"1\":{\"68\":1}}],[\"触发\",{\"1\":{\"307\":1}}],[\"触发扩容\",{\"1\":{\"303\":1}}],[\"快速失败是java集合的一种错误检测机制\",{\"1\":{\"307\":1}}],[\"快速失败\",{\"0\":{\"307\":1},\"1\":{\"307\":1}}],[\"剩下的50不用其实不用序列化\",{\"1\":{\"305\":1}}],[\"出于效率的考虑\",{\"1\":{\"305\":1}}],[\"出现节点个数的概率是递减的\",{\"1\":{\"326\":1}}],[\"出现线程死锁以后\",{\"1\":{\"300\":1}}],[\"出现问题\",{\"1\":{\"143\":1}}],[\"复制原数组元素到新数组\",{\"1\":{\"303\":1}}],[\"复制成功之后\",{\"1\":{\"281\":1}}],[\"容量大小为原数组1\",{\"1\":{\"303\":1}}],[\"甚至还有可能触发扩容\",{\"1\":{\"302\":1}}],[\"查找时间成本降低\",{\"1\":{\"328\":1}}],[\"查找的时间成本就增加了\",{\"1\":{\"328\":1}}],[\"查找红黑树\",{\"1\":{\"319\":1}}],[\"查找速率\",{\"1\":{\"302\":1}}],[\"查看\",{\"1\":{\"11\":1}}],[\"检测到死锁\",{\"1\":{\"300\":1}}],[\"检测当前线程是否被中断\",{\"1\":{\"131\":2}}],[\"申请的时候可以先申请资源序号小的\",{\"1\":{\"299\":1}}],[\"环路等待\",{\"1\":{\"299\":1}}],[\"环路等待条件\",{\"1\":{\"299\":1}}],[\"占用部分资源的线程进一步申请其他资源时\",{\"1\":{\"299\":1}}],[\"占个位\",{\"0\":{\"3\":1},\"1\":{\"3\":1}}],[\"互斥这个条件我们没有办法破坏\",{\"1\":{\"299\":1}}],[\"互斥条件\",{\"1\":{\"299\":1}}],[\"答案是至少破坏死锁发生的一个条件\",{\"1\":{\"299\":1}}],[\"形成了一个等待环路\",{\"1\":{\"299\":1}}],[\"形参与成员变量名字重名\",{\"1\":{\"90\":1}}],[\"形参相同\",{\"1\":{\"88\":1}}],[\"形参不同\",{\"1\":{\"88\":1}}],[\"持有一个资源的同时请求一个新资源\",{\"1\":{\"299\":1}}],[\"持久化任务队列\",{\"1\":{\"265\":1}}],[\"死锁恢复\",{\"1\":{\"300\":1}}],[\"死锁检测算法\",{\"1\":{\"300\":1}}],[\"死锁问题怎么排查呢\",{\"0\":{\"300\":1}}],[\"死锁产生的四个条件\",{\"1\":{\"299\":1}}],[\"死锁是指两个或两个以上的线程在执行过程中\",{\"1\":{\"299\":1}}],[\"死锁\",{\"1\":{\"299\":1}}],[\"很多使用自旋cas的地方\",{\"1\":{\"294\":1}}],[\"标志是否等于预期标志\",{\"1\":{\"292\":1}}],[\"标记不支持随机访问\",{\"1\":{\"302\":1}}],[\"标记字段\",{\"1\":{\"277\":1}}],[\"标记字段记录着锁的状态\",{\"1\":{\"277\":1}}],[\"标记符来实现同步\",{\"1\":{\"271\":1}}],[\"标记自身也可以设置一些值\",{\"1\":{\"81\":1}}],[\"去修改数据时\",{\"1\":{\"291\":1}}],[\"去阻塞队列取任务\",{\"1\":{\"244\":1}}],[\"循环性能开销\",{\"0\":{\"293\":1},\"1\":{\"290\":1}}],[\"循环往复的做达到屏障点\",{\"1\":{\"142\":1}}],[\"循环往复\",{\"1\":{\"142\":1}}],[\"问题\",{\"0\":{\"291\":1},\"1\":{\"290\":1}}],[\"交换\",{\"1\":{\"289\":1}}],[\"旧的预期值\",{\"1\":{\"289\":1}}],[\"乖乖排到后面\",{\"1\":{\"288\":1}}],[\"抢锁\",{\"1\":{\"288\":1}}],[\"抢先进入此方法的线程会优先拥有\",{\"1\":{\"272\":1}}],[\"失败后\",{\"1\":{\"288\":1}}],[\"整体的吞吐效率高\",{\"1\":{\"286\":1}}],[\"整数类型\",{\"1\":{\"50\":1}}],[\"公平锁的优点是等待锁的线程不会饿死\",{\"1\":{\"285\":1}}],[\"公平锁是指多个线程按照申请锁的顺序来获取锁\",{\"1\":{\"285\":1}}],[\"公平锁\",{\"0\":{\"285\":1}}],[\"公平性\",{\"1\":{\"146\":1}}],[\"构造函数默认创建的是非公平锁\",{\"1\":{\"284\":1,\"288\":1}}],[\"构造函数中传入的参数表示可以同时访问的资源数量\",{\"1\":{\"145\":1}}],[\"间接继承了aqs\",{\"1\":{\"284\":1}}],[\"唤醒阻塞线程的开销比非公平锁大\",{\"1\":{\"285\":1}}],[\"唤醒处于等待状态的线程\",{\"1\":{\"283\":1}}],[\"唤醒等待队列中的线程\",{\"1\":{\"187\":1}}],[\"另一个线程同时执行get操作\",{\"1\":{\"332\":1}}],[\"另一个线程处理任务并返回结果\",{\"1\":{\"147\":1}}],[\"另外一个线程还可以通过cas的方式进行获取\",{\"1\":{\"283\":1}}],[\"共享方式tryacquireshared\",{\"1\":{\"283\":1}}],[\"共享项目到github\",{\"0\":{\"18\":1}}],[\"独占方式\",{\"1\":{\"283\":1}}],[\"起到一个重入计数器的作用\",{\"1\":{\"281\":1}}],[\"升级为重量级锁\",{\"1\":{\"281\":1}}],[\"升级为轻量级锁\",{\"1\":{\"280\":1}}],[\"升级\",{\"1\":{\"280\":1}}],[\"变成无锁状态\",{\"1\":{\"280\":1}}],[\"变量\",{\"1\":{\"89\":2,\"91\":2,\"307\":1}}],[\"撤销\",{\"1\":{\"280\":2}}],[\"竞争失败\",{\"1\":{\"280\":1}}],[\"轻量级锁的获取\",{\"1\":{\"281\":1}}],[\"轻量级锁\",{\"0\":{\"281\":1},\"1\":{\"279\":1}}],[\"轻量级锁和偏向锁等优化策略\",{\"1\":{\"278\":1}}],[\"偏向锁不会主动释放\",{\"1\":{\"280\":1}}],[\"偏向锁的撤销\",{\"1\":{\"280\":1}}],[\"偏向锁的获取\",{\"1\":{\"280\":1}}],[\"偏向锁升级为轻量级锁\",{\"1\":{\"280\":1}}],[\"偏向锁标记是否为\",{\"1\":{\"280\":1}}],[\"偏向锁\",{\"0\":{\"280\":1},\"1\":{\"278\":1}}],[\"偏向时间戳\",{\"1\":{\"277\":1}}],[\"叫\",{\"1\":{\"277\":1}}],[\"他会记录下线程获取锁的次数\",{\"1\":{\"276\":1}}],[\"归\",{\"1\":{\"272\":1}}],[\"处于等待锁block状态的线程\",{\"1\":{\"272\":1}}],[\"处于wait状态的线程\",{\"1\":{\"272\":1}}],[\"处理任务执行期间抛出的异常\",{\"1\":{\"254\":1}}],[\"处理异步任务\",{\"0\":{\"253\":1}}],[\"处理异常\",{\"0\":{\"163\":1},\"1\":{\"249\":1,\"250\":1,\"253\":1}}],[\"处理被拒绝的任务\",{\"1\":{\"252\":1}}],[\"处理未捕获的异常\",{\"1\":{\"251\":2}}],[\"处理线程池中的异常可以确保程序的稳定性和可靠性\",{\"1\":{\"248\":1}}],[\"处理大型数据集时\",{\"1\":{\"217\":1}}],[\"处理请求逻辑\",{\"1\":{\"211\":1}}],[\"处理结果\",{\"1\":{\"185\":1}}],[\"处理所有结果\",{\"1\":{\"170\":1}}],[\"处理后数据\",{\"1\":{\"148\":1}}],[\"处理器可以改变语句对应\",{\"1\":{\"106\":1}}],[\"处理流\",{\"1\":{\"28\":1}}],[\"记录着锁的状态\",{\"1\":{\"277\":1}}],[\"记录线程获取锁的次数\",{\"1\":{\"272\":1}}],[\"记录任务的执行日志\",{\"1\":{\"265\":1}}],[\"恢复为空\",{\"1\":{\"272\":1}}],[\"恢复中断状态\",{\"1\":{\"254\":1}}],[\"区时\",{\"1\":{\"272\":1}}],[\"区别在于前者实现的是编译时的多态性\",{\"1\":{\"88\":1}}],[\"区别\",{\"0\":{\"61\":1,\"89\":1}}],[\"业务代码\",{\"1\":{\"269\":3}}],[\"得到斐波那契数列的第10个数的值\",{\"1\":{\"267\":1}}],[\"得到当前位置的斐波那契数\",{\"1\":{\"267\":1}}],[\"得让它去帮没干完活的线程干活\",{\"1\":{\"267\":1}}],[\"演示了如何使用fork\",{\"1\":{\"267\":1}}],[\"拆分出的小任务会被分配给线程池中的工作线程执行\",{\"1\":{\"267\":1}}],[\"拆箱\",{\"1\":{\"52\":1}}],[\"干完活的线程不能让它空下来\",{\"1\":{\"267\":1}}],[\"各自创建单独线程来执行队列里的任务\",{\"1\":{\"267\":1}}],[\"大于1\",{\"1\":{\"267\":1}}],[\"大任务拆成了若干个小任务\",{\"1\":{\"267\":1}}],[\"大乔\",{\"1\":{\"140\":4}}],[\"求出子问题的解\",{\"1\":{\"267\":1}}],[\"要想掌握fork\",{\"1\":{\"267\":1}}],[\"要么是黑色\",{\"1\":{\"314\":1}}],[\"要么任务执行失败需要回滚\",{\"1\":{\"265\":1}}],[\"要么不执行\",{\"1\":{\"103\":1}}],[\"要么完全执行\",{\"1\":{\"103\":1}}],[\"缓存结果和优化算法等策略\",{\"1\":{\"266\":1}}],[\"缓存结果\",{\"1\":{\"266\":1}}],[\"缓存线程池可以根据需要创建新线程\",{\"1\":{\"242\":1}}],[\"缓存线程池\",{\"0\":{\"182\":1,\"245\":1},\"1\":{\"242\":1}}],[\"怎么实现有序的\",{\"0\":{\"338\":1,\"339\":1}}],[\"怎么解决循环性能开销问题\",{\"0\":{\"294\":1}}],[\"怎么解决aba问题\",{\"0\":{\"292\":1}}],[\"怎么使用\",{\"0\":{\"269\":1}}],[\"怎么优化\",{\"0\":{\"266\":1}}],[\"怎么办\",{\"1\":{\"68\":1}}],[\"磁盘文件等\",{\"1\":{\"265\":1}}],[\"单机线程池执行断电了应该怎么处理\",{\"0\":{\"265\":1}}],[\"单线程的程序能保证最终结果是有序的\",{\"1\":{\"275\":1}}],[\"单线程的程序一定是顺序的吗\",{\"0\":{\"108\":1}}],[\"单线程线程池只包含一个线程\",{\"1\":{\"242\":1}}],[\"单线程线程池\",{\"0\":{\"246\":1},\"1\":{\"193\":1,\"242\":1}}],[\"单线程池\",{\"0\":{\"183\":1}}],[\"单线程程序的执行结果不能被改变\",{\"1\":{\"108\":1}}],[\"单线程环境下操作大量的数据\",{\"1\":{\"60\":1}}],[\"事务性执行任务\",{\"1\":{\"265\":2}}],[\"事后观察调整\",{\"1\":{\"263\":1}}],[\"事中分析优化\",{\"1\":{\"263\":1}}],[\"事前评估\",{\"1\":{\"263\":1}}],[\"避免重复调用同一个耗时操作\",{\"1\":{\"266\":1}}],[\"避免线程池中的任务过多导致资源耗尽和性能下降\",{\"1\":{\"266\":1}}],[\"避免问题进一步恶化\",{\"1\":{\"263\":1}}],[\"避免了环形链表的问题\",{\"1\":{\"332\":1}}],[\"避免了一次性重新计算所有键的哈希值和索引位置\",{\"1\":{\"330\":1}}],[\"避免了这种退化情况\",{\"1\":{\"315\":1}}],[\"避免了频繁创建和销毁线程的开销\",{\"1\":{\"189\":1}}],[\"避免了线程\",{\"1\":{\"113\":1}}],[\"及时发现线程池的异常情况\",{\"1\":{\"263\":1}}],[\"及时调用remove\",{\"1\":{\"117\":1}}],[\"告警机制可以帮助及时发现线程池的问题\",{\"1\":{\"263\":1}}],[\"告警机制\",{\"1\":{\"263\":1}}],[\"监控机制可以帮助及时发现线程池的问题\",{\"1\":{\"263\":1}}],[\"监控机制\",{\"1\":{\"263\":1}}],[\"监视器锁规则\",{\"1\":{\"107\":1}}],[\"压力测试等\",{\"1\":{\"263\":1}}],[\"测试\",{\"1\":{\"263\":1,\"264\":1}}],[\"评估的目的是为了在上线之前就能够预估系统的负载情况\",{\"1\":{\"263\":1}}],[\"帮助用户更好地管理线程池\",{\"1\":{\"262\":1}}],[\"报警\",{\"1\":{\"262\":1}}],[\"管理着一组工作线程\",{\"1\":{\"267\":1}}],[\"管理平台可以根据实际需求提供各种功能\",{\"1\":{\"262\":1}}],[\"管道输入\",{\"1\":{\"138\":3}}],[\"确定合适的线程池配置\",{\"1\":{\"263\":1}}],[\"确实是一种常见的方式\",{\"1\":{\"262\":1}}],[\"确保线程安全\",{\"1\":{\"308\":1}}],[\"确保线程按请求顺序获取许可\",{\"1\":{\"146\":1}}],[\"确保任务操作是原子性的\",{\"1\":{\"265\":1}}],[\"确保程序的稳定运行\",{\"1\":{\"254\":1}}],[\"确保cpu在长期被工作线程使用的情况下\",{\"1\":{\"244\":1}}],[\"确保所有任务得到正确处理\",{\"1\":{\"239\":1}}],[\"确保交换操作是同步和线程安全的\",{\"1\":{\"150\":1}}],[\"确保系统资源的有效利用和安全性\",{\"1\":{\"146\":1}}],[\"确保不会出现资源争用\",{\"1\":{\"144\":1}}],[\"确保子线程能够正确获取父线程最新的值\",{\"1\":{\"124\":1}}],[\"确保在屏障前的所有读操作都完成之后\",{\"1\":{\"111\":2}}],[\"确保在屏障前的所有写操作在屏障后的所有读操作\",{\"1\":{\"111\":1}}],[\"确保在屏障前的所有写操作\",{\"1\":{\"111\":1}}],[\"确保操作是不可分割的\",{\"1\":{\"105\":1}}],[\"确保这是你正在使用的分支名称\",{\"1\":{\"16\":1}}],[\"您可以有效地处理线程池中的异常\",{\"1\":{\"254\":1}}],[\"捕获并处理异常\",{\"0\":{\"249\":1}}],[\"捕获异常\",{\"1\":{\"72\":1}}],[\"周期性执行任务的场景\",{\"1\":{\"247\":1}}],[\"判断tab\",{\"1\":{\"318\":1}}],[\"判断tab是否位空或者长度为0\",{\"1\":{\"318\":1}}],[\"判断是否超过阈值\",{\"1\":{\"318\":1}}],[\"判断是否为可偏向状态\",{\"1\":{\"280\":1}}],[\"判断是否有空闲线程\",{\"1\":{\"245\":1}}],[\"判断两个对象是否相等\",{\"1\":{\"96\":1}}],[\"判断两个对象是不是同⼀个对象\",{\"1\":{\"96\":1}}],[\"导致资源浪费\",{\"1\":{\"326\":1}}],[\"导致插入和删除操作的效率较低\",{\"1\":{\"316\":1}}],[\"导致插入\",{\"1\":{\"315\":1}}],[\"导致oom\",{\"1\":{\"245\":1}}],[\"导致程序直接退出\",{\"1\":{\"73\":1}}],[\"尽可能的少的分配线程\",{\"1\":{\"244\":1}}],[\"尽管字节流可以处理所有类型的数据\",{\"1\":{\"29\":1}}],[\"适用场景\",{\"1\":{\"244\":1,\"245\":1,\"246\":1,\"247\":1}}],[\"适用于串行执行任务的场景\",{\"1\":{\"246\":1}}],[\"适用于短时任务较多\",{\"1\":{\"242\":1}}],[\"适用于大量短生命周期任务\",{\"1\":{\"193\":1}}],[\"适用于大量短生命周期的并发任务\",{\"1\":{\"182\":1}}],[\"适用于已知线程数固定的场景\",{\"1\":{\"193\":1}}],[\"适用于已知固定数量的并发任务\",{\"1\":{\"181\":1}}],[\"适用于需要执行定时任务和周期性任务的场景\",{\"1\":{\"242\":1}}],[\"适用于需要保证任务按照顺序执行\",{\"1\":{\"242\":1}}],[\"适用于需要限制线程数量的场景\",{\"1\":{\"242\":1}}],[\"适用于需要定期执行任务的场景\",{\"1\":{\"184\":1}}],[\"适用于需要顺序执行任务的场景\",{\"1\":{\"183\":1,\"193\":1}}],[\"适用于处理cpu密集型的任务\",{\"1\":{\"244\":1}}],[\"适用于处理文本数据\",{\"1\":{\"29\":1}}],[\"适用于处理二进制数据\",{\"1\":{\"29\":1}}],[\"过多的线程可能会导致系统资源的竞争和浪费\",{\"1\":{\"240\":1}}],[\"过滤\",{\"1\":{\"36\":1}}],[\"计算hash\",{\"1\":{\"335\":1}}],[\"计算数组下标\",{\"1\":{\"319\":1}}],[\"计算新数组容量\",{\"1\":{\"303\":1}}],[\"计算密集型\",{\"1\":{\"240\":1}}],[\"计数器就会\",{\"1\":{\"276\":1}}],[\"计数器\",{\"1\":{\"272\":1}}],[\"计数\",{\"1\":{\"36\":1}}],[\"既可以提交不需要返回结果的任务\",{\"1\":{\"238\":1}}],[\"既然有了字节流\",{\"0\":{\"29\":1}}],[\"综上所述\",{\"1\":{\"238\":1,\"240\":1,\"265\":1,\"266\":1}}],[\"延迟队列通常用于实现定时任务调度\",{\"1\":{\"237\":1}}],[\"延迟队列用于存储延迟执行的任务\",{\"1\":{\"237\":1}}],[\"延迟队列\",{\"1\":{\"237\":1}}],[\"具有保存key\",{\"1\":{\"335\":1}}],[\"具有排他性\",{\"1\":{\"275\":1}}],[\"具有固定容量的特点\",{\"1\":{\"237\":1}}],[\"具有高吞吐量和无限容量的特点\",{\"1\":{\"237\":1}}],[\"具体来说\",{\"1\":{\"197\":1}}],[\"具体唤醒哪个等待的线程是随机的\",{\"1\":{\"131\":1}}],[\"queue\",{\"1\":{\"237\":6}}],[\"quals\",{\"1\":{\"97\":1}}],[\"队列阻塞挂起\",{\"1\":{\"287\":1}}],[\"队列中的第一个线程才能获得锁\",{\"1\":{\"285\":1}}],[\"队列是同步移交队列synchronousqueue\",{\"1\":{\"245\":1}}],[\"队列已满则创建新线程\",{\"1\":{\"234\":1}}],[\"队列数据结构\",{\"1\":{\"187\":1}}],[\"强制终止一个或多个进程\",{\"1\":{\"300\":1}}],[\"强制关闭\",{\"1\":{\"233\":1}}],[\"强制类型转换\",{\"0\":{\"51\":1},\"1\":{\"51\":1}}],[\"优化算法\",{\"1\":{\"266\":1}}],[\"优先级队列根据元素的优先级来决定元素的顺序\",{\"1\":{\"237\":1}}],[\"优先级队列\",{\"1\":{\"237\":1}}],[\"优先级等属性\",{\"1\":{\"235\":1}}],[\"优雅关闭\",{\"1\":{\"233\":1}}],[\"优点\",{\"1\":{\"79\":1}}],[\"立即停止所有任务\",{\"1\":{\"233\":1}}],[\"停止接受新任务\",{\"1\":{\"233\":1,\"234\":1}}],[\"停车一段时间后离开\",{\"1\":{\"145\":1}}],[\"停车和离开的过程\",{\"1\":{\"145\":1}}],[\"丢弃最旧策略\",{\"1\":{\"236\":1}}],[\"丢弃策略\",{\"1\":{\"236\":1}}],[\"丢弃队列最前的任务和由调用线程执行任务\",{\"1\":{\"231\":1,\"235\":1}}],[\"丢弃任务\",{\"1\":{\"231\":1,\"235\":1}}],[\"拒绝策略\",{\"1\":{\"231\":1,\"235\":1}}],[\"初始化数组\",{\"1\":{\"336\":1}}],[\"初始化时\",{\"1\":{\"323\":1}}],[\"初始化线程池\",{\"1\":{\"234\":1}}],[\"初始化\",{\"1\":{\"228\":1}}],[\"初始状态\",{\"1\":{\"132\":1}}],[\"邮件发送完成\",{\"1\":{\"223\":1}}],[\"日志记录和回滚等机制\",{\"1\":{\"265\":1}}],[\"日志记录和回滚\",{\"1\":{\"265\":1}}],[\"日志记录等\",{\"1\":{\"262\":1}}],[\"日志记录\",{\"1\":{\"221\":1}}],[\"日志框架\",{\"1\":{\"44\":1}}],[\"充分利用多核cpu的优势\",{\"1\":{\"218\":1}}],[\"端口8080\",{\"1\":{\"211\":1}}],[\"特别适用于需要频繁调整参数的情况\",{\"1\":{\"262\":1}}],[\"特别是在高并发或多线程应用程序中\",{\"1\":{\"248\":1}}],[\"特别是在高并发和需要处理大量任务的场景中\",{\"1\":{\"207\":1}}],[\"特征\",{\"1\":{\"256\":1,\"257\":1,\"258\":1,\"259\":1,\"260\":1}}],[\"特点\",{\"1\":{\"130\":1,\"309\":1}}],[\"能说一下concurrenthashmap的具体实现吗\",{\"0\":{\"334\":1}}],[\"能说一下hashmap的数据结构吗\",{\"0\":{\"312\":1}}],[\"能说一下线程池有几种状态吗\",{\"0\":{\"255\":1}}],[\"能说一下四种常见线程池的原理吗\",{\"0\":{\"243\":1}}],[\"能说说工作中线程池的应用吗\",{\"0\":{\"207\":1}}],[\"能简单说一下线程池的工作流程吗\",{\"0\":{\"228\":1}}],[\"能够正确地工作并保持一致性\",{\"1\":{\"97\":1}}],[\"频繁地创建和销毁数据库连接会导致性能下降和资源浪费\",{\"1\":{\"213\":1}}],[\"频繁地为每个请求创建和销毁线程将导致性能瓶颈\",{\"1\":{\"209\":1}}],[\"频繁的垃圾回收会导致应用程序的性能下降\",{\"1\":{\"205\":1}}],[\"频繁的线程创建和销毁会增加上下文切换的次数\",{\"1\":{\"202\":1}}],[\"频繁创建和销毁线程会导致大量短生命周期的对象被创建\",{\"1\":{\"205\":1}}],[\"频繁创建和销毁线程会导致操作系统不断地创建和销毁这些内核对象\",{\"1\":{\"200\":1}}],[\"频繁创建和销毁线程会导致内存分配和释放操作的频繁发生\",{\"1\":{\"199\":1}}],[\"频繁创建和销毁线程的开销大\",{\"1\":{\"197\":1}}],[\"寄存器\",{\"1\":{\"202\":1}}],[\"增加\",{\"1\":{\"307\":1}}],[\"增加了一些高级功能\",{\"1\":{\"282\":1}}],[\"增加了适应性自旋\",{\"1\":{\"282\":1}}],[\"增加了系统调用的开销\",{\"1\":{\"200\":1}}],[\"增删速率\",{\"1\":{\"302\":1}}],[\"增量为\",{\"1\":{\"119\":1}}],[\"核心应该是线程池+任务队列\",{\"1\":{\"241\":1}}],[\"核心线程数为1\",{\"1\":{\"246\":1}}],[\"核心线程数为0\",{\"1\":{\"245\":1}}],[\"核心线程数和最大线程数大小一样\",{\"1\":{\"244\":1}}],[\"核心线程数\",{\"1\":{\"195\":1,\"235\":1}}],[\"核心方法await\",{\"1\":{\"142\":1}}],[\"固定大小的线程池\",{\"1\":{\"193\":1}}],[\"固定大小线程池包含固定数量的线程\",{\"1\":{\"242\":1}}],[\"固定大小线程池\",{\"0\":{\"181\":1,\"244\":1},\"1\":{\"242\":1}}],[\"防止任务过载\",{\"1\":{\"237\":1}}],[\"防止系统资源耗尽\",{\"1\":{\"191\":1}}],[\"防止过载\",{\"1\":{\"144\":1}}],[\"回收空闲线程等\",{\"1\":{\"190\":1}}],[\"回调\",{\"1\":{\"30\":1}}],[\"旨在提高性能并优化资源使用\",{\"1\":{\"189\":1}}],[\"释放它们持有的资源\",{\"1\":{\"300\":1}}],[\"释放多少次\",{\"1\":{\"283\":1}}],[\"释放资源的时候\",{\"1\":{\"283\":1}}],[\"释放锁并进入等待队列\",{\"1\":{\"187\":1}}],[\"释放许可\",{\"1\":{\"144\":1}}],[\"试图向队列中添加元素的线程会被阻塞\",{\"1\":{\"187\":1}}],[\"试图从队列中取出元素的线程会被阻塞\",{\"1\":{\"187\":1}}],[\"锁粗化\",{\"1\":{\"278\":2}}],[\"锁消除等\",{\"1\":{\"282\":1}}],[\"锁消除\",{\"1\":{\"278\":2}}],[\"锁状态标志\",{\"1\":{\"277\":1}}],[\"锁升级方向\",{\"1\":{\"279\":1}}],[\"锁升级的过程是什么样的\",{\"0\":{\"279\":1}}],[\"锁升级\",{\"0\":{\"277\":1}}],[\"锁对象的时候有个计数器\",{\"1\":{\"276\":1}}],[\"锁的实现\",{\"1\":{\"282\":1}}],[\"锁的状态\",{\"1\":{\"277\":1}}],[\"锁的重入次数\",{\"1\":{\"272\":1}}],[\"锁的释放等\",{\"1\":{\"136\":1}}],[\"锁\",{\"0\":{\"268\":1}}],[\"锁和条件等待机制\",{\"1\":{\"187\":1}}],[\"锁和条件等待\",{\"1\":{\"187\":1}}],[\"常见参数包括\",{\"1\":{\"195\":1}}],[\"常见的同步移交队列包括synchronousqueue\",{\"1\":{\"237\":1}}],[\"常见的有界队列包括arrayblockingqueue\",{\"1\":{\"237\":1}}],[\"常见的无界队列包括linkedblockingqueue\",{\"1\":{\"237\":1}}],[\"常见的线程池包括以下几种\",{\"1\":{\"242\":1}}],[\"常见的线程池工作队列包括\",{\"1\":{\"237\":1}}],[\"常见的线程池类型\",{\"0\":{\"193\":1}}],[\"常见的任务队列包括有界队列\",{\"1\":{\"235\":1}}],[\"常见的拒绝策略包括抛出异常\",{\"1\":{\"231\":1,\"235\":1}}],[\"常见的阻塞队列有\",{\"1\":{\"187\":1}}],[\"常用于web应用中\",{\"1\":{\"69\":2}}],[\"常用类\",{\"0\":{\"58\":1}}],[\"下面是对代码示例的解释\",{\"1\":{\"267\":1}}],[\"下面是对答案的一些完善和补充\",{\"1\":{\"262\":1}}],[\"下面是一个简单的示例代码\",{\"1\":{\"267\":1}}],[\"下面是阻塞队列的基本实现原理\",{\"1\":{\"187\":1}}],[\"下载地址\",{\"1\":{\"9\":1}}],[\"满足不同应用场景的需求\",{\"1\":{\"185\":1}}],[\"调度线程池\",{\"0\":{\"184\":1}}],[\"调用\",{\"1\":{\"267\":2}}],[\"调用设置超时时间\",{\"1\":{\"266\":1}}],[\"调用进行限流\",{\"1\":{\"266\":1}}],[\"调用改为异步调用\",{\"1\":{\"266\":1}}],[\"调用shutdownnow\",{\"1\":{\"239\":1}}],[\"调用shutdown\",{\"1\":{\"239\":1}}],[\"调用start\",{\"1\":{\"128\":1}}],[\"调用future对象的get\",{\"1\":{\"238\":1}}],[\"调用者运行策略\",{\"1\":{\"236\":1}}],[\"调用await方法等待其他线程\",{\"1\":{\"142\":1}}],[\"调用方法不同\",{\"1\":{\"88\":1}}],[\"调用类方法这时候就要用到反射\",{\"1\":{\"46\":1}}],[\"展示如何使用自定义线程池执行异步任务\",{\"1\":{\"179\":1}}],[\"工具类来创建不同类型的线程池\",{\"1\":{\"177\":1}}],[\"工作窃取发生的时候\",{\"1\":{\"267\":1}}],[\"工作窃取算法\",{\"1\":{\"267\":1}}],[\"工作窃取队列通常用于实现任务并行化的线程池\",{\"1\":{\"237\":1}}],[\"工作窃取队列是一种用于并行计算的特殊队列\",{\"1\":{\"237\":1}}],[\"工作窃取队列\",{\"1\":{\"237\":1}}],[\"工作流程\",{\"1\":{\"244\":1,\"245\":1,\"246\":1,\"247\":1,\"309\":1}}],[\"工作\",{\"1\":{\"143\":1}}],[\"作为映射的位置\",{\"1\":{\"324\":1}}],[\"作为该锁的锁记录\",{\"1\":{\"281\":1}}],[\"作为默认线程池来执行异步任务\",{\"1\":{\"174\":1}}],[\"作用于当前对象实例加锁\",{\"1\":{\"269\":1}}],[\"作者\",{\"1\":{\"32\":1}}],[\"总之\",{\"1\":{\"239\":1}}],[\"总的来说\",{\"1\":{\"187\":1}}],[\"总结\",{\"0\":{\"173\":1}}],[\"总不能为了某个玩家等到天荒地老\",{\"1\":{\"140\":1}}],[\"合并结果\",{\"1\":{\"172\":1}}],[\"真实场景应用\",{\"0\":{\"171\":1}}],[\"示例\",{\"0\":{\"170\":1}}],[\"示例代码\",{\"1\":{\"144\":1}}],[\"消费结果但不返回新的结果\",{\"1\":{\"157\":1}}],[\"消费者处理的数据\",{\"1\":{\"148\":1}}],[\"消费者\",{\"1\":{\"148\":1}}],[\"组合多个\",{\"0\":{\"159\":1}}],[\"组合以及异常处理等\",{\"1\":{\"152\":1}}],[\"组线程到达一个屏障\",{\"1\":{\"141\":1}}],[\"看看是否录入一致\",{\"1\":{\"150\":1}}],[\"看做是包装对象\",{\"1\":{\"35\":1}}],[\"录入到excel之后\",{\"1\":{\"150\":1}}],[\"校对工作\",{\"1\":{\"150\":1}}],[\"遗传算法里需要选出两个人作为交配对象\",{\"1\":{\"150\":1}}],[\"遗传算法\",{\"1\":{\"150\":1}}],[\"准备执行下一个任务\",{\"1\":{\"232\":1}}],[\"准备处理数据并与生产者交换\",{\"1\":{\"149\":1}}],[\"准备运行环境\",{\"0\":{\"9\":1}}],[\"双向链表的插入和删除只需要改变前驱节点\",{\"1\":{\"302\":1}}],[\"双线程数据交换\",{\"1\":{\"147\":1}}],[\"双重校验单例模式就是一个经典的指令重排的例子\",{\"1\":{\"106\":1}}],[\"专门用于在两个线程之间交换数据\",{\"1\":{\"147\":1}}],[\"尝试中断正在执行的任务\",{\"1\":{\"258\":1}}],[\"尝试终止正在执行的任务\",{\"1\":{\"233\":1}}],[\"尝试获取许可但不阻塞\",{\"1\":{\"146\":1}}],[\"尝试进入停车场\",{\"1\":{\"144\":1}}],[\"成本平衡的考虑\",{\"1\":{\"328\":1}}],[\"成本和\",{\"1\":{\"328\":1}}],[\"成对使用\",{\"1\":{\"150\":1}}],[\"成功\",{\"1\":{\"164\":1,\"165\":1}}],[\"成功后进入停车场\",{\"1\":{\"145\":1}}],[\"成功进入停车场\",{\"1\":{\"144\":1}}],[\"成员变量的默认值根据其类型而定\",{\"1\":{\"92\":1}}],[\"成员变量包括实例变量和静态变量\",{\"1\":{\"92\":1}}],[\"成员变量是在类中声明的变量\",{\"1\":{\"92\":1}}],[\"成员变量\",{\"1\":{\"92\":1,\"138\":1}}],[\"成员变量与局部变量的区别有哪些\",{\"0\":{\"92\":1}}],[\"汽车\",{\"1\":{\"144\":1}}],[\"限制同时执行的任务数量\",{\"1\":{\"266\":1}}],[\"限制同时访问数据库的连接数\",{\"1\":{\"144\":1}}],[\"限制并发数\",{\"1\":{\"266\":2}}],[\"限流控制\",{\"1\":{\"144\":1}}],[\"资源剥夺\",{\"1\":{\"300\":1}}],[\"资源控制\",{\"1\":{\"191\":1}}],[\"资源双向传递\",{\"1\":{\"147\":1}}],[\"资源池管理\",{\"1\":{\"144\":1}}],[\"资源后就可以继续运行\",{\"1\":{\"131\":1}}],[\"信号量\",{\"0\":{\"144\":1},\"1\":{\"144\":1}}],[\"受影响\",{\"1\":{\"143\":1}}],[\"受检异常\",{\"1\":{\"71\":1}}],[\"个位置\",{\"1\":{\"325\":1}}],[\"个斐波那契数\",{\"1\":{\"267\":1}}],[\"个数\",{\"1\":{\"267\":1}}],[\"个线程出现问题\",{\"1\":{\"143\":1}}],[\"个槽位中\",{\"1\":{\"120\":1}}],[\"断\",{\"1\":{\"143\":1}}],[\"务由哪些线程完成无关紧要\",{\"1\":{\"143\":1}}],[\"至于这些任\",{\"1\":{\"143\":1}}],[\"须要指定任务数\",{\"1\":{\"143\":1}}],[\"除留取余法\",{\"1\":{\"324\":1}}],[\"除了互斥量本身开销\",{\"1\":{\"278\":1}}],[\"除了原子性\",{\"0\":{\"273\":1}}],[\"除非设置了allowcorethreadtimeout\",{\"1\":{\"235\":1}}],[\"除\",{\"1\":{\"143\":1}}],[\"届时\",{\"1\":{\"143\":1}}],[\"知道最后一个线程达到屏障点\",{\"1\":{\"142\":1}}],[\"模拟发送邮件时间\",{\"1\":{\"223\":1}}],[\"模拟处理时间\",{\"1\":{\"219\":1}}],[\"模拟任务执行\",{\"1\":{\"194\":1,\"196\":1}}],[\"模拟任务执行时间\",{\"1\":{\"142\":1}}],[\"模拟远程调用\",{\"1\":{\"172\":3}}],[\"模拟耗时操作\",{\"1\":{\"170\":3,\"179\":1}}],[\"模拟消费者线程\",{\"1\":{\"149\":1}}],[\"模拟生产者线程\",{\"1\":{\"149\":1}}],[\"模拟两个线程之间的数据交换\",{\"1\":{\"148\":1}}],[\"模拟停车场\",{\"1\":{\"145\":1}}],[\"模拟停车时间\",{\"1\":{\"144\":1}}],[\"模板已成功生成\",{\"1\":{\"11\":1}}],[\"正在执行任务\",{\"1\":{\"142\":13}}],[\"往下执行\",{\"1\":{\"142\":1}}],[\"往后找一圈没找到就会从头开始找\",{\"1\":{\"120\":1}}],[\"获取节点\",{\"1\":{\"319\":1}}],[\"获取新的哈希值\",{\"1\":{\"319\":1}}],[\"获取一个新的哈希值\",{\"1\":{\"318\":1}}],[\"获取一个许可\",{\"1\":{\"144\":1}}],[\"获取失败的话\",{\"1\":{\"287\":1}}],[\"获取不到才会到等待队列的队尾等待\",{\"1\":{\"286\":1}}],[\"获取state的方式分为两种\",{\"1\":{\"283\":1}}],[\"获取\",{\"1\":{\"272\":1}}],[\"获取当前的latch数量\",{\"1\":{\"140\":1}}],[\"获取到key的哈希值\",{\"1\":{\"320\":1}}],[\"获取到锁的线程可以重入\",{\"1\":{\"283\":1}}],[\"获取到\",{\"1\":{\"131\":1}}],[\"收到消费者的数据\",{\"1\":{\"148\":1}}],[\"收到\",{\"1\":{\"140\":1}}],[\"全军出击\",{\"1\":{\"140\":1}}],[\"敌方还有5秒达到战场\",{\"1\":{\"140\":1}}],[\"统一各线程动作开始的时机\",{\"1\":{\"140\":1}}],[\"统的称作\",{\"1\":{\"132\":1}}],[\"协调子线程开始动作\",{\"1\":{\"140\":1}}],[\"协调子线程结束动作\",{\"1\":{\"140\":1}}],[\"场景\",{\"1\":{\"307\":2}}],[\"场景描述\",{\"0\":{\"209\":1,\"213\":1,\"217\":1,\"221\":1,\"225\":1}}],[\"场景2\",{\"1\":{\"140\":1}}],[\"场景1\",{\"1\":{\"140\":1}}],[\"马上到\",{\"1\":{\"140\":1}}],[\"上个卫生间\",{\"1\":{\"140\":1}}],[\"稍等\",{\"1\":{\"140\":1}}],[\"铠\",{\"1\":{\"140\":4}}],[\"哪吒\",{\"1\":{\"140\":4}}],[\"兰陵王\",{\"1\":{\"140\":4}}],[\"倒计数器\",{\"0\":{\"140\":1},\"1\":{\"140\":1}}],[\"任意数\",{\"1\":{\"322\":1}}],[\"任意对象为值的存储结构\",{\"1\":{\"138\":1}}],[\"任务分解\",{\"1\":{\"267\":1}}],[\"任务分配与结果收集\",{\"1\":{\"147\":1}}],[\"任务拆分\",{\"1\":{\"266\":2}}],[\"任务堆积\",{\"1\":{\"263\":1}}],[\"任务类型和处理速度等进行评估\",{\"1\":{\"263\":1}}],[\"任务的性质\",{\"1\":{\"240\":1}}],[\"任务加入队列\",{\"1\":{\"231\":1}}],[\"任务执行情况等\",{\"1\":{\"263\":1}}],[\"任务执行时间较短的场景\",{\"1\":{\"242\":1}}],[\"任务执行时间和任务队列容量等因素综合考虑\",{\"1\":{\"240\":1}}],[\"任务执行时间\",{\"1\":{\"240\":1}}],[\"任务执行完成\",{\"0\":{\"232\":1},\"1\":{\"234\":1}}],[\"任务执行\",{\"0\":{\"231\":1},\"1\":{\"267\":1}}],[\"任务执行和资源回收\",{\"1\":{\"228\":1}}],[\"任务结果\",{\"1\":{\"230\":1}}],[\"任务可以通过execute\",{\"1\":{\"230\":1}}],[\"任务提交到线程池\",{\"1\":{\"234\":1}}],[\"任务提交\",{\"0\":{\"230\":1},\"1\":{\"228\":1,\"264\":2}}],[\"任务对象等\",{\"1\":{\"205\":1}}],[\"任务\",{\"1\":{\"194\":1,\"196\":1}}],[\"任务队列中的任务数据也不会丢失\",{\"1\":{\"265\":1}}],[\"任务队列大小等参数\",{\"1\":{\"263\":1}}],[\"任务队列类型和大小等参数\",{\"1\":{\"263\":1}}],[\"任务队列容量\",{\"1\":{\"240\":1}}],[\"任务队列\",{\"1\":{\"190\":1,\"195\":1,\"229\":1,\"235\":1}}],[\"任务1结果\",{\"1\":{\"185\":1}}],[\"任务完成\",{\"1\":{\"158\":1,\"170\":1}}],[\"任务完成后的回调\",{\"0\":{\"155\":1}}],[\"任务逻辑\",{\"1\":{\"154\":2,\"230\":2,\"249\":1,\"253\":1,\"254\":1}}],[\"任何一个线程都能并发访问localvariable\",{\"1\":{\"113\":1}}],[\"任何对string的修改都会创建一个新的string对象\",{\"1\":{\"60\":1}}],[\"任何对\",{\"1\":{\"59\":1}}],[\"符\",{\"1\":{\"138\":1}}],[\"守护线程\",{\"1\":{\"137\":1}}],[\"守护线程了解吗\",{\"0\":{\"137\":1}}],[\"应用场景\",{\"1\":{\"144\":1,\"150\":1}}],[\"应用程序可以复用一组数据库连接\",{\"1\":{\"214\":1}}],[\"应用程序可以在不修改源代码的情况下\",{\"1\":{\"44\":1}}],[\"应用程序可以在缓冲区中读取或写入数据\",{\"1\":{\"30\":1}}],[\"应用程序定义一个接口\",{\"1\":{\"44\":1}}],[\"应用程序\",{\"1\":{\"30\":1}}],[\"应尽量减少线程上下文切换的次数\",{\"1\":{\"135\":1}}],[\"堆栈指针等信息\",{\"1\":{\"135\":1}}],[\"堆中的对象也会拷贝一份\",{\"1\":{\"99\":1}}],[\"包括线程池的初始化\",{\"1\":{\"264\":2}}],[\"包括监控线程池的运行状态\",{\"1\":{\"263\":1}}],[\"包括功能测试\",{\"1\":{\"263\":1}}],[\"包括cpu核心数\",{\"1\":{\"240\":1}}],[\"包括数据库访问\",{\"1\":{\"209\":1}}],[\"包括任务的串行执行\",{\"1\":{\"152\":1}}],[\"包括寄存器状态\",{\"1\":{\"135\":1}}],[\"包括java\",{\"1\":{\"39\":1}}],[\"无锁化读取\",{\"1\":{\"336\":1}}],[\"无锁\",{\"1\":{\"279\":1,\"309\":1}}],[\"无界队列可以存储无限数量的任务\",{\"1\":{\"237\":1}}],[\"无界队列\",{\"1\":{\"237\":1}}],[\"无法继续执行\",{\"1\":{\"133\":1}}],[\"无序\",{\"1\":{\"83\":1}}],[\"终止遍历\",{\"1\":{\"307\":1}}],[\"终止死锁进程\",{\"1\":{\"300\":1}}],[\"终止状态\",{\"1\":{\"132\":1}}],[\"终端操作会返回一个结果\",{\"1\":{\"36\":1}}],[\"终端操作\",{\"1\":{\"36\":1}}],[\"超过则扩容\",{\"1\":{\"318\":1}}],[\"超过一定次数\",{\"1\":{\"294\":1}}],[\"超过范围\",{\"1\":{\"64\":1}}],[\"超时默认值\",{\"1\":{\"168\":1}}],[\"超时控制\",{\"0\":{\"166\":1}}],[\"超时机制\",{\"1\":{\"150\":1,\"266\":2,\"299\":1}}],[\"超时等问题时\",{\"1\":{\"143\":1}}],[\"超时等待状态\",{\"1\":{\"132\":1}}],[\"程需要等待其他线程做出一些特定动作\",{\"1\":{\"132\":1}}],[\"程序计数器等\",{\"1\":{\"202\":1}}],[\"程序计数器\",{\"1\":{\"135\":1}}],[\"程序顺序规则\",{\"1\":{\"107\":1}}],[\"程序将无法继续执行\",{\"1\":{\"73\":2}}],[\"程序还没有进入try语句块就因为异常导致程序终止\",{\"1\":{\"73\":1}}],[\"程序运行中出现异常\",{\"1\":{\"71\":1}}],[\"程序返回\",{\"1\":{\"55\":1}}],[\"程序要经过先编译\",{\"1\":{\"42\":1}}],[\"程序从源代码到运行主要有三步\",{\"1\":{\"41\":1}}],[\"程序所需的所有内容的集合\",{\"1\":{\"39\":1}}],[\"阻塞呗\",{\"1\":{\"310\":1}}],[\"阻塞和唤醒操作\",{\"1\":{\"187\":1}}],[\"阻塞队列是delayedworkqueue\",{\"1\":{\"247\":1}}],[\"阻塞队列是无界队列linkedblockingqueue\",{\"1\":{\"246\":1}}],[\"阻塞队列是一种特殊的队列数据结构\",{\"1\":{\"187\":1}}],[\"阻塞队列为无界队列linkedblockingqueue\",{\"1\":{\"244\":1}}],[\"阻塞队列通过结合队列数据结构\",{\"1\":{\"187\":1}}],[\"阻塞队列需要保证在多线程环境下的线程安全性\",{\"1\":{\"187\":1}}],[\"阻塞队列内部通常使用锁和条件等待来实现线程的阻塞和唤醒\",{\"1\":{\"187\":1}}],[\"阻塞队列基于数组或链表等数据结构实现\",{\"1\":{\"187\":1}}],[\"阻塞队列的实现通常基于经典的队列数据结构\",{\"1\":{\"187\":1}}],[\"阻塞直到有可用的许可\",{\"1\":{\"144\":1}}],[\"阻塞状态\",{\"1\":{\"132\":1}}],[\"阻止实例中那些用此关键字修饰的的变量序列化\",{\"1\":{\"68\":1}}],[\"状态转换图\",{\"0\":{\"261\":1}}],[\"状态下完成终止操作后\",{\"1\":{\"260\":1}}],[\"状态下完成了所有任务\",{\"1\":{\"259\":1}}],[\"状态下中断了所有任务后\",{\"1\":{\"259\":1}}],[\"状态\",{\"1\":{\"132\":1,\"257\":1,\"258\":1,\"259\":1,\"260\":1}}],[\"让出线程\",{\"1\":{\"336\":1}}],[\"让出优先权\",{\"1\":{\"131\":1}}],[\"让一\",{\"1\":{\"141\":1}}],[\"让后统计数量\",{\"1\":{\"36\":1}}],[\"函数会唤醒被阻塞到该共享变量上的一个线程\",{\"1\":{\"131\":1}}],[\"函数\",{\"1\":{\"131\":1,\"137\":1}}],[\"函数作为参数传递到方法中\",{\"1\":{\"32\":1}}],[\"直至找到空闲的位置\",{\"1\":{\"325\":1}}],[\"直至找到空闲位置\",{\"1\":{\"325\":1}}],[\"直至占有资源的线程释放该资源\",{\"1\":{\"299\":1}}],[\"直到计数器清零\",{\"1\":{\"276\":1}}],[\"直到计数器为0\",{\"1\":{\"143\":1}}],[\"直到计算到基本情况\",{\"1\":{\"267\":1}}],[\"直到任务队列为空为止\",{\"1\":{\"267\":1}}],[\"直到拆分的任务足够小而可以被快速处理为止\",{\"1\":{\"267\":1}}],[\"直到达到拆分任务的终止条件\",{\"1\":{\"267\":1}}],[\"直到达到预期的效果\",{\"1\":{\"263\":1}}],[\"直到达到最大线程数\",{\"1\":{\"235\":1}}],[\"直到所有小任务的结果都被合并到大任务的结果中为止\",{\"1\":{\"267\":1}}],[\"直到所有任务执行完毕后才会关闭\",{\"1\":{\"239\":1}}],[\"直到所有线程都到达\",{\"1\":{\"142\":1}}],[\"直到线程数量等于核心线程数\",{\"1\":{\"235\":1}}],[\"直到队列有空闲位置\",{\"1\":{\"187\":1}}],[\"直到队列非空\",{\"1\":{\"187\":1}}],[\"直到另一个线程也调用\",{\"1\":{\"149\":1}}],[\"直到对方也到达此同步点\",{\"1\":{\"149\":1}}],[\"直到有可用许可为止\",{\"1\":{\"145\":1}}],[\"直到最后一个线程到达屏障时\",{\"1\":{\"141\":1}}],[\"直到其他线程通过\",{\"1\":{\"131\":1}}],[\"直接调用hashmap的put方法\",{\"1\":{\"341\":1}}],[\"直接根据\",{\"1\":{\"324\":1}}],[\"直接定址法\",{\"1\":{\"324\":1}}],[\"直接插入或者删除就可以了\",{\"1\":{\"302\":1}}],[\"直接\",{\"1\":{\"74\":1}}],[\"直接返回字符串常量池中的字符串\",{\"1\":{\"63\":1}}],[\"直接返回\",{\"1\":{\"55\":1,\"267\":1,\"319\":1}}],[\"灵活性\",{\"1\":{\"130\":1}}],[\"例\",{\"1\":{\"130\":2}}],[\"例如十位和百位\",{\"1\":{\"324\":1}}],[\"例如1232放到下标1232的位置\",{\"1\":{\"324\":1}}],[\"例如atomicinteger\",{\"1\":{\"296\":1}}],[\"例如数据库\",{\"1\":{\"265\":1}}],[\"例如定时任务调度\",{\"1\":{\"242\":1}}],[\"例如任务依赖性较强的场景\",{\"1\":{\"242\":1}}],[\"例如并发量稳定的服务器应用\",{\"1\":{\"242\":1}}],[\"例如清理临时文件\",{\"1\":{\"225\":1}}],[\"例如发送邮件\",{\"1\":{\"221\":1}}],[\"例如线程对象\",{\"1\":{\"205\":1}}],[\"例如读取\",{\"1\":{\"102\":1}}],[\"例如整型默认为0\",{\"1\":{\"92\":1}}],[\"例如添加\",{\"1\":{\"68\":1}}],[\"例如\",{\"1\":{\"59\":1,\"97\":1,\"131\":1,\"217\":1,\"262\":1}}],[\"例如图像\",{\"1\":{\"29\":1}}],[\"系列方法而被挂起的线程\",{\"1\":{\"131\":1}}],[\"系列方法后被挂起的线程\",{\"1\":{\"131\":1}}],[\"系\",{\"1\":{\"130\":1}}],[\"系统重启后的处理\",{\"1\":{\"265\":1}}],[\"系统无法继续执行任务\",{\"1\":{\"265\":1}}],[\"系统资源\",{\"1\":{\"240\":2}}],[\"系统资源消耗\",{\"0\":{\"198\":1}}],[\"系统需要加载这两个excel\",{\"1\":{\"150\":1}}],[\"系统自动抛异常\",{\"1\":{\"72\":1}}],[\"系统的实现\",{\"1\":{\"39\":1}}],[\"鄙人三某\",{\"1\":{\"122\":1}}],[\"鄙人张三\",{\"1\":{\"113\":1}}],[\"子线程使用countdownlatch\",{\"1\":{\"140\":2}}],[\"子线程\",{\"1\":{\"122\":1,\"123\":1}}],[\"子类可以扩大方法的访问范围\",{\"1\":{\"88\":1}}],[\"父子线程怎么共享数据\",{\"0\":{\"122\":1}}],[\"父类不希望子类出现更多的异常\",{\"1\":{\"88\":1}}],[\"遍历node数组\",{\"1\":{\"336\":1}}],[\"遍历hashentry\",{\"1\":{\"335\":1}}],[\"遍历hashmap的几种方法\",{\"0\":{\"84\":1}}],[\"遍历链表查找\",{\"1\":{\"319\":1}}],[\"遍历下一个元素之前\",{\"1\":{\"307\":1}}],[\"遍历完成之后\",{\"1\":{\"121\":1}}],[\"扩容\",{\"1\":{\"331\":1}}],[\"扩容优化\",{\"1\":{\"330\":1}}],[\"扩容在什么时候呢\",{\"0\":{\"327\":1}}],[\"扩容后的\",{\"1\":{\"121\":1}}],[\"扩展成一个范围更大的锁\",{\"1\":{\"278\":1}}],[\"扩展或定制某个功能或组件的实现\",{\"1\":{\"44\":1}}],[\"清理过期entry\",{\"1\":{\"121\":1}}],[\"逻辑\",{\"1\":{\"121\":1}}],[\"逻辑与\",{\"1\":{\"53\":1}}],[\"且任务队列为空\",{\"1\":{\"259\":1}}],[\"且空闲时间超过keepalivetime\",{\"1\":{\"232\":1}}],[\"且当前散列数组中\",{\"1\":{\"121\":1}}],[\"且b\",{\"1\":{\"107\":1}}],[\"未清理到任何数据\",{\"1\":{\"121\":1}}],[\"定位到segment\",{\"1\":{\"335\":1}}],[\"定位到table中的位置\",{\"1\":{\"120\":1}}],[\"定期执行任务\",{\"1\":{\"227\":1}}],[\"定时数据同步等\",{\"1\":{\"242\":1}}],[\"定时备份数据库等\",{\"1\":{\"225\":1}}],[\"定时任务线程池用于执行定时任务和周期性任务\",{\"1\":{\"242\":1}}],[\"定时任务线程池\",{\"0\":{\"247\":1},\"1\":{\"242\":1}}],[\"定时任务\",{\"0\":{\"224\":1}}],[\"定时或周期性执行任务的线程池\",{\"1\":{\"193\":1}}],[\"定义三个异步任务\",{\"1\":{\"170\":1}}],[\"定义\",{\"1\":{\"131\":1,\"144\":1}}],[\"定义服务接口\",{\"1\":{\"44\":1}}],[\"定义了服务的契约\",{\"1\":{\"44\":1}}],[\"已经明示了它的原理\",{\"1\":{\"309\":1}}],[\"已经有了\",{\"1\":{\"120\":1}}],[\"已经被修改为\",{\"1\":{\"74\":1}}],[\"带来的好处就是\",{\"1\":{\"119\":1}}],[\"黄金分割数\",{\"1\":{\"119\":1}}],[\"每当迭代器使用hashnext\",{\"1\":{\"307\":1}}],[\"每重入一次\",{\"1\":{\"283\":1}}],[\"每种状态都表示线程池当前的不同运行阶段\",{\"1\":{\"255\":1}}],[\"每隔5秒执行一次\",{\"1\":{\"227\":1}}],[\"每次切换执行线程时\",{\"1\":{\"202\":1}}],[\"每创建一个threadlocal对象\",{\"1\":{\"119\":1}}],[\"每个节点要么是红色\",{\"1\":{\"314\":1}}],[\"每个键值对根据哈希函数计算得到一个桶的索引\",{\"1\":{\"312\":1}}],[\"每个桶存储一个键值对\",{\"1\":{\"312\":1}}],[\"每个对象都有一个内置锁\",{\"1\":{\"272\":1}}],[\"每个工作线程会不断地从任务队列中获取任务并执行\",{\"1\":{\"267\":1}}],[\"每个请求可能涉及复杂的处理逻辑\",{\"1\":{\"209\":1}}],[\"每个threadlocal实例都对应着一个threadlocalmap对象\",{\"1\":{\"118\":1}}],[\"每个线程都有自己的工作队列\",{\"1\":{\"237\":1}}],[\"每个线程都有一个属于自己的threadlocalmap\",{\"1\":{\"115\":1}}],[\"每个线程都有一个私有的\",{\"1\":{\"102\":1}}],[\"每个线程的堆栈大小可能是1mb或者更大\",{\"1\":{\"199\":1}}],[\"每个线程在创建时需要分配内存\",{\"1\":{\"199\":1}}],[\"每个线程在往threadlocal里设置值的时候\",{\"1\":{\"115\":1}}],[\"每个线程需要创建新实\",{\"1\":{\"130\":1}}],[\"每个线程有自己的程序计数器和栈\",{\"1\":{\"127\":1}}],[\"每个entry代表一个完整的对象\",{\"1\":{\"115\":1}}],[\"每个类都有一个对应的class对象\",{\"1\":{\"48\":1}}],[\"每个服务提供者将自己的实现类配置到一个特定的配置文件中\",{\"1\":{\"44\":1}}],[\"每个实现类占据一行\",{\"1\":{\"44\":1}}],[\"元素是按照是按照\",{\"1\":{\"339\":1}}],[\"元素比较少\",{\"1\":{\"328\":1}}],[\"元素比较多\",{\"1\":{\"328\":1}}],[\"元素数组\",{\"1\":{\"119\":1}}],[\"元空间\",{\"1\":{\"92\":1}}],[\"弱引用很容易被回收\",{\"1\":{\"116\":1}}],[\"弱引用\",{\"1\":{\"116\":1}}],[\"读操作频繁且对实时性要求不高的场景\",{\"1\":{\"309\":1}}],[\"读操作在原数组上\",{\"1\":{\"309\":1}}],[\"读写分离\",{\"1\":{\"309\":1}}],[\"读也是以某个threadlocal作为引用\",{\"1\":{\"115\":1}}],[\"读取\",{\"1\":{\"113\":1}}],[\"读取或写入操作使用缓冲区\",{\"1\":{\"30\":1}}],[\"存在一定空间浪费\",{\"1\":{\"302\":1}}],[\"存放token\",{\"1\":{\"114\":1}}],[\"存储结构\",{\"1\":{\"312\":1}}],[\"存储entry类型的元素\",{\"1\":{\"119\":1}}],[\"存储操作\",{\"1\":{\"111\":1}}],[\"存储方式\",{\"1\":{\"92\":1}}],[\"存储字符串\",{\"1\":{\"60\":2}}],[\"​\",{\"1\":{\"111\":1}}],[\"都可以协调多线程的结束动作\",{\"1\":{\"141\":1}}],[\"都会检测\",{\"1\":{\"307\":1}}],[\"都会回收该对象占用的内存\",{\"1\":{\"116\":1}}],[\"都会返回一个新的\",{\"1\":{\"59\":1}}],[\"都是往自己的threadlocalmap里存\",{\"1\":{\"115\":1}}],[\"都在屏障后的写操作之前被刷新到主内存中\",{\"1\":{\"111\":1}}],[\"功能特点\",{\"1\":{\"282\":1}}],[\"功能\",{\"1\":{\"111\":3}}],[\"功能链接跳转不对问题\",{\"0\":{\"23\":1}}],[\"屏障将被拆\",{\"1\":{\"143\":1}}],[\"屏障会自动重置\",{\"1\":{\"142\":1}}],[\"屏障才会开门\",{\"1\":{\"141\":1}}],[\"屏障\",{\"1\":{\"111\":4}}],[\"屏蔽差异性\",{\"1\":{\"86\":1}}],[\"相比于链表的o\",{\"1\":{\"330\":1}}],[\"相比于平衡二叉树\",{\"1\":{\"316\":1}}],[\"相比synchronized的加锁方式来解决共享变量的内存可见性问题\",{\"1\":{\"110\":1}}],[\"相对来说\",{\"1\":{\"288\":1}}],[\"相对重量级锁\",{\"1\":{\"278\":1}}],[\"相对较高\",{\"1\":{\"130\":2}}],[\"相对较低\",{\"1\":{\"130\":2}}],[\"相反\",{\"1\":{\"131\":1}}],[\"相当于顺序执行\",{\"1\":{\"129\":1}}],[\"相当于取余\",{\"1\":{\"119\":1}}],[\"相等吗\",{\"0\":{\"64\":1}}],[\"保留整数倍以下的数据\",{\"1\":{\"322\":1}}],[\"保留的是hash值的地位特征\",{\"1\":{\"321\":1}}],[\"保证一定获取锁成功\",{\"1\":{\"335\":1}}],[\"保证极端情况下的查找效率\",{\"1\":{\"326\":1}}],[\"保证了树的相对平衡\",{\"1\":{\"316\":1}}],[\"保证了操作的最坏时间复杂度为o\",{\"1\":{\"315\":1}}],[\"保证了可见性\",{\"1\":{\"309\":1}}],[\"保证了变量在多线程之间的可见性\",{\"1\":{\"283\":1}}],[\"保证的是对一个变量执行操作的原子性\",{\"1\":{\"295\":1}}],[\"保证可见性和有序性\",{\"1\":{\"109\":1}}],[\"保障系统的性能和稳定性\",{\"1\":{\"263\":1}}],[\"保持插入顺序或访问顺序\",{\"1\":{\"83\":1}}],[\"操作来实现的\",{\"1\":{\"297\":1}}],[\"操作成功\",{\"1\":{\"289\":1}}],[\"操作成功返回\",{\"1\":{\"107\":1}}],[\"操作失败\",{\"1\":{\"289\":1}}],[\"操作包含三个操作数\",{\"1\":{\"289\":1}}],[\"操作系统通过线程调度器在多个线程之间切换执行\",{\"1\":{\"202\":1}}],[\"操作系统为每个线程分配了一些内核对象和数据结构\",{\"1\":{\"200\":1}}],[\"操作系统资源\",{\"0\":{\"200\":1}}],[\"操作系统会将\",{\"1\":{\"136\":2}}],[\"操作系统会强制进行线程上下文切换\",{\"1\":{\"136\":1}}],[\"操作系统会保存当前线程的上下文\",{\"1\":{\"135\":1}}],[\"操作happens\",{\"1\":{\"107\":1}}],[\"操作的数据量较小\",{\"1\":{\"60\":1}}],[\"规则\",{\"1\":{\"107\":2}}],[\"规定了需要提供的功能或扩展点\",{\"1\":{\"44\":1}}],[\"内部节点的顺序是无序的\",{\"1\":{\"337\":1}}],[\"内部节点是有序的吗\",{\"0\":{\"337\":1}}],[\"内部捕获并处理异常\",{\"1\":{\"249\":1}}],[\"内部同时还启动了很多守护线程\",{\"1\":{\"137\":1}}],[\"内部错误\",{\"1\":{\"71\":1}}],[\"内存空间不连续\",{\"1\":{\"302\":1}}],[\"内存占用\",{\"1\":{\"302\":1}}],[\"内存位置\",{\"1\":{\"289\":1}}],[\"内存等\",{\"1\":{\"240\":1}}],[\"内存开销\",{\"0\":{\"199\":1}}],[\"内存泄露是怎么回事\",{\"0\":{\"116\":1}}],[\"内存系统的重排序\",{\"1\":{\"106\":1}}],[\"指线程获取到的资源在自己使用完之前不能被其它线程抢占\",{\"1\":{\"299\":1}}],[\"指线程对己经获取到的资源进行排它性使用\",{\"1\":{\"299\":1}}],[\"指一个\",{\"1\":{\"299\":1}}],[\"指向持有objectmonitor对象的线程\",{\"1\":{\"272\":1}}],[\"指向对象本身的一个指针\",{\"1\":{\"90\":1}}],[\"指定加锁对象\",{\"1\":{\"269\":1}}],[\"指定自定义线程池\",{\"0\":{\"176\":1}}],[\"指定的睡眠时间到了后该函数会正常返回\",{\"1\":{\"131\":1}}],[\"指令则指向同步代码块的结束位置\",{\"1\":{\"271\":1}}],[\"指令指向同步代码块的开始位置\",{\"1\":{\"271\":1}}],[\"指令重排也是有一些限制的\",{\"1\":{\"107\":1}}],[\"指令重排有限制吗\",{\"0\":{\"107\":1}}],[\"指令级并行的重排序\",{\"1\":{\"106\":1}}],[\"那arraylist怎么序列化呢\",{\"0\":{\"306\":1}}],[\"那就重新匹配\",{\"1\":{\"140\":1}}],[\"那就接着去找空着的坑\",{\"1\":{\"120\":1}}],[\"那怎么不直接调用run\",{\"0\":{\"129\":1}}],[\"那怎么解决内存泄漏问题呢\",{\"0\":{\"117\":1}}],[\"那说说什么是指令重排\",{\"0\":{\"106\":1}}],[\"那么发生哈希冲突的概率就增加了\",{\"1\":{\"328\":1}}],[\"那么为什么选择了0\",{\"0\":{\"328\":1}}],[\"那么hash值高位是与0做\",{\"1\":{\"322\":1}}],[\"那么直接就获取到锁返回了\",{\"1\":{\"288\":1}}],[\"那么这个线程可以无需阻塞直接获取到锁\",{\"1\":{\"286\":1}}],[\"那么这种重排序并不非法\",{\"1\":{\"107\":1}}],[\"那么问题来了\",{\"1\":{\"267\":1}}],[\"那么可能可以配置较少的线程来处理任务\",{\"1\":{\"240\":1}}],[\"那么可能需要配置更多的线程来处理任务\",{\"1\":{\"240\":1}}],[\"那么可能需要更多的线程来处理任务队列中的任务\",{\"1\":{\"240\":1}}],[\"那么可以通过显式地指定serialversionuid来保持兼容性\",{\"1\":{\"68\":1}}],[\"那么你可能需要配置较多的线程数\",{\"1\":{\"240\":1}}],[\"那么你可能需要配置较少的线程数\",{\"1\":{\"240\":1}}],[\"那么它会一直阻塞\",{\"1\":{\"150\":1}}],[\"那么守护线程和用户线程有什么区别呢\",{\"1\":{\"137\":1}}],[\"那么run方法还是运行在主线程中\",{\"1\":{\"129\":1}}],[\"那么即使线程不再使用某个threadlocal实例\",{\"1\":{\"118\":1}}],[\"那么即使类的结构发生了变化\",{\"1\":{\"68\":1}}],[\"那么访问这个变量的每个线程都会有这个变量的一个本地拷贝\",{\"1\":{\"113\":1}}],[\"那么线程b中的任意操作\",{\"1\":{\"107\":1}}],[\"那么a线程的threadb\",{\"1\":{\"107\":1}}],[\"那么a\",{\"1\":{\"107\":1}}],[\"那么第一个操作的执行结果将对第二个操作可见\",{\"1\":{\"107\":1}}],[\"那么拷贝后对象\",{\"1\":{\"99\":1}}],[\"那么序列化和反序列化时可能会出现版本不一致的问题\",{\"1\":{\"68\":1}}],[\"那么自动装箱时不会new新的integer对象\",{\"1\":{\"64\":1}}],[\"那么会生成多个中间对象\",{\"1\":{\"62\":2}}],[\"两种集合都需要遍历\",{\"1\":{\"302\":1}}],[\"两种情况\",{\"1\":{\"280\":1}}],[\"两者都是\",{\"1\":{\"288\":1}}],[\"两者性能就差不多了\",{\"1\":{\"282\":1}}],[\"两步操作\",{\"1\":{\"104\":1}}],[\"两个指令来实现同步\",{\"1\":{\"271\":1}}],[\"两个线程可以交换数据\",{\"1\":{\"149\":1}}],[\"两个线程互相传递数据或资源\",{\"1\":{\"147\":1}}],[\"两个线程需要在某个点交换数据\",{\"1\":{\"147\":1}}],[\"两个线程都执行了\",{\"1\":{\"126\":1}}],[\"两个线程都在执行\",{\"1\":{\"126\":1}}],[\"两个具备超时特性的方法\",{\"1\":{\"138\":1}}],[\"两个操作之间存在happens\",{\"1\":{\"107\":1}}],[\"两个\",{\"1\":{\"61\":1}}],[\"两个语句都会去字符串常量池中检查是否已经存在\",{\"1\":{\"61\":1}}],[\"第二次增加2^2\",{\"1\":{\"325\":1}}],[\"第二步和第三步就可能会重排序\",{\"1\":{\"106\":1}}],[\"第一次增加\",{\"1\":{\"325\":1}}],[\"第3和第4句其实是等效的\",{\"1\":{\"104\":1}}],[\"第2句先读i的值\",{\"1\":{\"104\":1}}],[\"第1句是基本类型赋值\",{\"1\":{\"104\":1}}],[\"分段锁\",{\"0\":{\"335\":1},\"1\":{\"334\":1}}],[\"分割成位数相同的几段\",{\"1\":{\"324\":1}}],[\"分而治之\",{\"1\":{\"267\":1}}],[\"分而治之和工作窃取算法\",{\"1\":{\"267\":1}}],[\"分析线程池的问题或者可优化点\",{\"1\":{\"263\":1}}],[\"分析下面几行代码的原子性\",{\"0\":{\"104\":1}}],[\"分钟等\",{\"1\":{\"235\":1}}],[\"分别计算第\",{\"1\":{\"267\":1}}],[\"分别为\",{\"1\":{\"137\":1}}],[\"分别代表\",{\"1\":{\"78\":1}}],[\"分布非常均匀\",{\"1\":{\"119\":1}}],[\"分配内存空间\",{\"1\":{\"106\":1}}],[\"序性保证了程序的执行顺序与代码的顺序一致\",{\"1\":{\"103\":1}}],[\"序列化不包含静态变量\",{\"1\":{\"68\":1}}],[\"序列化\",{\"0\":{\"67\":1},\"1\":{\"68\":1,\"99\":1}}],[\"代替hashmap\",{\"1\":{\"333\":1}}],[\"代码是单线程执行的\",{\"1\":{\"275\":1}}],[\"代码示例\",{\"0\":{\"148\":1,\"211\":1,\"215\":1,\"219\":1,\"223\":1,\"227\":1}}],[\"代码复\",{\"1\":{\"130\":1}}],[\"代码的执行顺序可能与代码的编写顺序不一致\",{\"1\":{\"103\":1}}],[\"代表非公平锁\",{\"1\":{\"288\":1}}],[\"代表公平锁和非公平锁\",{\"1\":{\"288\":1}}],[\"代表公平锁\",{\"1\":{\"288\":1}}],[\"代表\",{\"1\":{\"78\":1}}],[\"原子操作类的优点在于\",{\"1\":{\"297\":1}}],[\"原子操作类一般都是通过底层的cas\",{\"1\":{\"297\":1}}],[\"原子操作类是java提供的一组线程安全的工具类\",{\"1\":{\"297\":1}}],[\"原子操作类了解多少\",{\"0\":{\"297\":1}}],[\"原子性保证了对共享变量的操作是原子的\",{\"1\":{\"103\":1}}],[\"原子性是指一个操作是不可分割的\",{\"1\":{\"103\":1}}],[\"原子性\",{\"0\":{\"105\":1},\"1\":{\"103\":2,\"105\":1}}],[\"原理很简单\",{\"1\":{\"123\":1}}],[\"原理\",{\"0\":{\"65\":1},\"1\":{\"65\":1,\"307\":2}}],[\"原理是什么\",{\"0\":{\"40\":1}}],[\"写完将元素数组指向副本\",{\"1\":{\"309\":1}}],[\"写操作在副本上\",{\"1\":{\"309\":1}}],[\"写操作较少的情况下\",{\"1\":{\"309\":1}}],[\"写时复制\",{\"1\":{\"309\":1}}],[\"写入数据同样判断链表\",{\"1\":{\"336\":1}}],[\"写入变量\",{\"1\":{\"113\":1}}],[\"写入\",{\"1\":{\"113\":1}}],[\"写入和同步操作\",{\"1\":{\"102\":1}}],[\"写缓冲区\",{\"1\":{\"106\":1}}],[\"写共享变量的副本\",{\"1\":{\"102\":1}}],[\"本地内存是jmm的\",{\"1\":{\"102\":1}}],[\"本地内存中存储了该线程以读\",{\"1\":{\"102\":1}}],[\"本地内存\",{\"1\":{\"102\":1}}],[\"或称为监视器锁\",{\"1\":{\"272\":1}}],[\"或在\",{\"1\":{\"259\":1}}],[\"或shutdownnow\",{\"1\":{\"233\":1,\"239\":1}}],[\"或submit\",{\"1\":{\"230\":1}}],[\"或\",{\"1\":{\"131\":2,\"176\":1,\"249\":1}}],[\"或者等很久才会获得锁\",{\"1\":{\"286\":1}}],[\"或者等待时间到期\",{\"1\":{\"131\":1}}],[\"或者已经不再存活\",{\"1\":{\"280\":1}}],[\"或者通过轮询isterminated\",{\"1\":{\"239\":1}}],[\"或者\",{\"1\":{\"131\":1,\"337\":1}}],[\"或者使用json序列化\",{\"1\":{\"100\":1}}],[\"或与底层设备进行通信时\",{\"1\":{\"29\":1}}],[\"采用安全失败机制的集合容器\",{\"1\":{\"307\":1}}],[\"采用ab岗两人进行录入\",{\"1\":{\"150\":1}}],[\"采用clone机制\",{\"1\":{\"100\":1}}],[\"采用字节码的好处是什么\",{\"0\":{\"41\":1}}],[\"拷贝被拷贝对象的成员变量的值\",{\"1\":{\"99\":1}}],[\"完整的升级过程\",{\"1\":{\"281\":1}}],[\"完整示例\",{\"0\":{\"179\":1}}],[\"完成\",{\"1\":{\"162\":1}}],[\"完成后\",{\"1\":{\"160\":1}}],[\"完成后才通知\",{\"1\":{\"30\":1}}],[\"完成任务\",{\"1\":{\"142\":13}}],[\"完全拷贝一个对象\",{\"1\":{\"99\":1}}],[\"深拷贝如何实现呢\",{\"1\":{\"99\":1}}],[\"深拷贝是安全的\",{\"1\":{\"99\":1}}],[\"深拷贝\",{\"1\":{\"99\":1}}],[\"仅拷贝被拷贝对象的成员变量的值\",{\"1\":{\"99\":1}}],[\"浅拷贝如何实现呢\",{\"1\":{\"99\":1}}],[\"浅拷贝的话如果有引用类型\",{\"1\":{\"99\":1}}],[\"浅拷贝\",{\"1\":{\"99\":1}}],[\"传的不是2的倍数时\",{\"1\":{\"323\":1}}],[\"传一个17的值\",{\"0\":{\"323\":1}}],[\"传递性\",{\"1\":{\"107\":1}}],[\"传递的是该引用的副本\",{\"1\":{\"98\":1}}],[\"传递的是该值的副本\",{\"1\":{\"98\":1}}],[\"传送门\",{\"1\":{\"1\":1}}],[\"主要是因为线程的创建和销毁涉及操作系统和jvm层面的多种资源管理和调度\",{\"1\":{\"197\":1}}],[\"主要通过executors工具类来创建\",{\"1\":{\"192\":1}}],[\"主要目的是确保\",{\"1\":{\"97\":1}}],[\"主线程可以继续处理其他工作\",{\"1\":{\"222\":1}}],[\"主线程继续执行其他操作\",{\"1\":{\"170\":1,\"179\":2,\"223\":2}}],[\"主线程使用countdownlatch\",{\"1\":{\"140\":2}}],[\"主线程\",{\"1\":{\"122\":1}}],[\"主内存\",{\"1\":{\"102\":1}}],[\"主页\",{\"0\":{\"5\":1}}],[\"时间\",{\"1\":{\"328\":1}}],[\"时间复杂度都是o\",{\"1\":{\"302\":1}}],[\"时间复杂度是o\",{\"1\":{\"302\":2}}],[\"时间单位\",{\"1\":{\"229\":1,\"235\":1}}],[\"时间片时\",{\"1\":{\"136\":1}}],[\"时间片分配给另一个处于就绪状态的线程\",{\"1\":{\"136\":3}}],[\"时不能再使用\",{\"1\":{\"143\":1}}],[\"时被阻塞\",{\"1\":{\"141\":1}}],[\"时机\",{\"1\":{\"121\":1}}],[\"时\",{\"1\":{\"98\":1,\"266\":1}}],[\"时必须重写\",{\"1\":{\"97\":1}}],[\"时的\",{\"0\":{\"89\":1}}],[\"比较内存位置\",{\"1\":{\"289\":1}}],[\"比较\",{\"1\":{\"289\":1}}],[\"比较这两个对象\",{\"1\":{\"96\":1}}],[\"比\",{\"1\":{\"282\":1}}],[\"比如copyonwritearraylist类\",{\"1\":{\"307\":1}}],[\"比如arraylist\",{\"1\":{\"307\":1}}],[\"比如jconsole\",{\"1\":{\"300\":1}}],[\"比如我们需要将纸制银行流水通过人工的方式录入成电子银行流水\",{\"1\":{\"150\":1}}],[\"比如我们熟悉的空指针\",{\"1\":{\"71\":1}}],[\"比如有玩家超时未确认\",{\"1\":{\"140\":1}}],[\"比如垃圾回收线程\",{\"1\":{\"137\":1}}],[\"比如锁还是持有不让出的\",{\"1\":{\"131\":1}}],[\"比如虚拟机异常\",{\"1\":{\"71\":1}}],[\"等待队列中除第一个线程以外的所有线程都会阻塞\",{\"1\":{\"285\":1}}],[\"等待队列状态改变的线程会进入等待状态\",{\"1\":{\"187\":1}}],[\"等待次数达到阈值仍未获取到锁\",{\"1\":{\"281\":1}}],[\"等待被唤醒\",{\"1\":{\"272\":1}}],[\"等待已提交任务完成或立即终止\",{\"1\":{\"234\":1}}],[\"等待所有任务完成\",{\"1\":{\"170\":1,\"172\":1}}],[\"等待所有子线程运行结束\",{\"1\":{\"140\":1}}],[\"等待其他线程\",{\"1\":{\"142\":13}}],[\"等待latch降为0\",{\"1\":{\"140\":2}}],[\"等待主线程完成\",{\"1\":{\"140\":1}}],[\"等待子线程完成\",{\"1\":{\"140\":1}}],[\"等待\",{\"1\":{\"138\":1,\"336\":1}}],[\"等待状态\",{\"1\":{\"132\":1}}],[\"等\",{\"1\":{\"97\":1,\"187\":1,\"229\":1,\"277\":1,\"297\":1}}],[\"等价于通过\",{\"1\":{\"96\":1}}],[\"等等框架中都大量使用了反射机制\",{\"1\":{\"47\":1}}],[\"⽅法\",{\"1\":{\"96\":1,\"97\":1}}],[\"⽅法名\",{\"1\":{\"93\":3}}],[\"引言\",{\"0\":{\"152\":1,\"342\":1}}],[\"引⽤数据类型==比较的是内存地址\",{\"1\":{\"96\":1}}],[\"引用类型变量单独克隆\",{\"1\":{\"99\":1}}],[\"引用类型变量修改\",{\"1\":{\"99\":1}}],[\"引用类型默认为null\",{\"1\":{\"92\":1}}],[\"引用本类的构造函数\",{\"1\":{\"90\":1}}],[\"引用数据类型\",{\"1\":{\"50\":1,\"59\":1}}],[\"经过处理\",{\"1\":{\"185\":1}}],[\"经过了编译器的指令重排序\",{\"1\":{\"106\":1}}],[\"经过拼接新生成了string对象\",{\"1\":{\"62\":1}}],[\"经常被用在需要释放资源的情况下\",{\"1\":{\"95\":1}}],[\"必须把共享变量的最新值刷新到主内存中\",{\"1\":{\"274\":1}}],[\"必须依存于某一实例\",{\"1\":{\"93\":1}}],[\"必须在由程序运⾏期间才能决定\",{\"1\":{\"87\":1}}],[\"静态内部类\",{\"1\":{\"288\":1}}],[\"静态方法里不能访问类的非静态成员变量和方法\",{\"1\":{\"93\":1}}],[\"静态方法\",{\"0\":{\"93\":1},\"1\":{\"93\":1}}],[\"静态变量可以实现让多个对象共享内存\",{\"1\":{\"93\":1}}],[\"静态变量在内存中有且仅有一个副本\",{\"1\":{\"93\":1}}],[\"静态变量在类被加载至数据区后\",{\"1\":{\"92\":1}}],[\"静态变量和实例变量的区别\",{\"0\":{\"93\":1}}],[\"静态变量存储在方法区\",{\"1\":{\"92\":1}}],[\"静态变量\",{\"1\":{\"92\":1,\"93\":1}}],[\"静态变量属于类的状态信息\",{\"1\":{\"68\":1}}],[\"非公平锁让获取锁的时间变得更加不确定\",{\"1\":{\"288\":1}}],[\"非公平锁会有更好的性能\",{\"1\":{\"288\":1}}],[\"非公平锁会直接\",{\"1\":{\"288\":1}}],[\"非公平锁会尝试去获取锁\",{\"1\":{\"287\":1}}],[\"非公平锁在\",{\"1\":{\"288\":1}}],[\"非公平锁在调用\",{\"1\":{\"288\":1}}],[\"非公平锁和公平锁的两处不同\",{\"1\":{\"288\":1}}],[\"非公平锁的优点是可以减少唤起线程的开销\",{\"1\":{\"286\":1}}],[\"非公平锁是多个线程加锁时直接尝试获取锁\",{\"1\":{\"286\":1}}],[\"非公平锁\",{\"0\":{\"286\":1}}],[\"非核心线程空闲存活时间为60秒\",{\"1\":{\"245\":1}}],[\"非常适合需要双向数据传递的场景\",{\"1\":{\"150\":1}}],[\"非final修饰的成员变量具有默认值\",{\"1\":{\"92\":1}}],[\"非线程安全\",{\"1\":{\"60\":1}}],[\"随时调整线程池的配置\",{\"1\":{\"263\":1}}],[\"随对象的销毁而销毁\",{\"1\":{\"92\":1}}],[\"随对象的创建而生\",{\"1\":{\"92\":1}}],[\"随着方法或代码块的执行而创建和销毁\",{\"1\":{\"92\":1}}],[\"生产了数据\",{\"1\":{\"148\":1}}],[\"生产的数据\",{\"1\":{\"148\":1}}],[\"生产者\",{\"1\":{\"148\":1}}],[\"生存周期\",{\"1\":{\"92\":1}}],[\"生成数据并与消费者交换\",{\"1\":{\"149\":1}}],[\"生成字节码\",{\"1\":{\"42\":1}}],[\"生成模板\",{\"1\":{\"11\":1}}],[\"生成\",{\"1\":{\"11\":1}}],[\"局部变量在使用前必须显式地进行初始化\",{\"1\":{\"92\":1}}],[\"局部变量只在方法或代码块内有效\",{\"1\":{\"92\":1}}],[\"局部变量存在栈内存中\",{\"1\":{\"92\":1}}],[\"局部变量是在方法中或代码块中声明的变量\",{\"1\":{\"92\":1}}],[\"设定为3\",{\"1\":{\"145\":1}}],[\"设定可用许可数量为3\",{\"1\":{\"144\":1}}],[\"设计层面\",{\"1\":{\"91\":1}}],[\"设置线程的\",{\"1\":{\"251\":1}}],[\"设置协议\",{\"1\":{\"11\":1}}],[\"设置应用描述\",{\"1\":{\"11\":1}}],[\"设置应用版本号\",{\"1\":{\"11\":1}}],[\"设置应用名称\",{\"1\":{\"11\":1}}],[\"抽象同步队列\",{\"1\":{\"283\":1}}],[\"抽象方法\",{\"1\":{\"283\":2}}],[\"抽象方法是为了被重写\",{\"1\":{\"91\":1}}],[\"抽象方法可以有public\",{\"1\":{\"91\":1}}],[\"抽象类是对类的抽象\",{\"1\":{\"91\":1}}],[\"抽象类\",{\"0\":{\"91\":1}}],[\"9\",{\"0\":{\"173\":1},\"1\":{\"219\":1}}],[\"9允许在接口中定义私有方法\",{\"1\":{\"91\":1}}],[\"9e\",{\"1\":{\"50\":1}}],[\"什么也不写\",{\"1\":{\"89\":1}}],[\"什么是红黑树\",{\"0\":{\"314\":1}}],[\"什么是cas\",{\"0\":{\"289\":1}}],[\"什么是线程池\",{\"0\":{\"189\":1}}],[\"什么是线程上下文切换\",{\"0\":{\"135\":1}}],[\"什么是深拷贝和浅拷贝\",{\"0\":{\"99\":1}}],[\"什么是hashcode\",{\"1\":{\"97\":1}}],[\"什么是泛型擦除\",{\"0\":{\"79\":1}}],[\"什么是泛型\",{\"0\":{\"76\":1}}],[\"什么是反序列化\",{\"0\":{\"68\":1}}],[\"什么是反射\",{\"0\":{\"46\":1}}],[\"什么是序列化\",{\"0\":{\"68\":1}}],[\"什么是integer缓存\",{\"1\":{\"64\":1}}],[\"什么是自动拆箱\",{\"0\":{\"52\":1}}],[\"什么是自动类型转换\",{\"0\":{\"51\":1}}],[\"什么是字节码\",{\"0\":{\"41\":1}}],[\"重新计算冲突元素的地址\",{\"1\":{\"325\":1}}],[\"重入多少次\",{\"1\":{\"283\":1}}],[\"重用性\",{\"1\":{\"142\":1}}],[\"重要注意事项\",{\"0\":{\"142\":1,\"146\":1,\"150\":1}}],[\"重排序可以分为编译器重排序和处理器重排序\",{\"1\":{\"111\":1}}],[\"重排序分3种类型\",{\"1\":{\"106\":1}}],[\"重写call\",{\"1\":{\"128\":1}}],[\"重写run\",{\"1\":{\"128\":2}}],[\"重写克隆方法\",{\"1\":{\"99\":2}}],[\"重写方法的访问权限可以更广\",{\"1\":{\"88\":1}}],[\"重写方法不能抛出范围更大的受控异常\",{\"1\":{\"88\":1}}],[\"重载\",{\"0\":{\"88\":1}}],[\"若为引用数据类型则返回值为被重写方法的返回值或是其子类\",{\"1\":{\"88\":1}}],[\"与消费者交换数据\",{\"1\":{\"148\":1}}],[\"与\",{\"1\":{\"131\":1}}],[\"与按happens\",{\"1\":{\"107\":1}}],[\"与异常类型更没关系\",{\"1\":{\"88\":1}}],[\"与返回值和修饰符无关\",{\"1\":{\"88\":1}}],[\"参与协作的线程数\",{\"1\":{\"143\":1}}],[\"参数顺序满足任一\",{\"1\":{\"88\":1}}],[\"参数类型\",{\"1\":{\"88\":1,\"238\":1}}],[\"参数个数\",{\"1\":{\"88\":1}}],[\"参考资料\",{\"1\":{\"9\":1}}],[\"⽽是在程序运⾏期间才确定\",{\"1\":{\"87\":1}}],[\"新hash值保留了高低位的特征\",{\"1\":{\"321\":1}}],[\"新建线程执行任务\",{\"1\":{\"246\":1}}],[\"新任务将在任务队列中等待\",{\"1\":{\"242\":2}}],[\"新任务将被拒绝\",{\"1\":{\"237\":1}}],[\"新任务会被拒绝\",{\"1\":{\"237\":1}}],[\"新任务会触发创建额外的线程\",{\"1\":{\"235\":1}}],[\"新任务也可以被放入队列等待执行\",{\"1\":{\"237\":1}}],[\"新类的定义可以增加新的属性或新的方法\",{\"1\":{\"87\":1}}],[\"新的任务会被放入一个队列中等待执行\",{\"1\":{\"190\":1}}],[\"新的api解决了旧的date和calendar类在处理日期和时间时的一些问题\",{\"1\":{\"32\":1}}],[\"新的日期和时间api\",{\"1\":{\"32\":1}}],[\"同时也可以在创建锁构造函数中传入具体参数创建公平锁\",{\"1\":{\"288\":1}}],[\"同时该等待线程进入\",{\"1\":{\"272\":1}}],[\"同时提供⼀些可以被外界访问的属性的⽅法\",{\"1\":{\"87\":1}}],[\"同步是锁住的什么东西\",{\"1\":{\"272\":1}}],[\"同步移交队列是一种特殊的队列\",{\"1\":{\"237\":1}}],[\"同步移交队列\",{\"1\":{\"237\":1}}],[\"同步开销\",{\"0\":{\"203\":1}}],[\"同步屏障\",{\"0\":{\"141\":1}}],[\"同步非阻塞io\",{\"1\":{\"30\":1}}],[\"同步阻塞io\",{\"1\":{\"30\":1}}],[\"加锁\",{\"1\":{\"309\":1}}],[\"加版本号\",{\"1\":{\"292\":1}}],[\"加载操作\",{\"1\":{\"111\":1}}],[\"加强代码的重用\",{\"1\":{\"86\":1}}],[\"加入到已注册的通道列表\",{\"1\":{\"30\":1}}],[\"目前无法直接保证操作的原子性的\",{\"1\":{\"295\":1}}],[\"目的是为了写出通用的代码\",{\"1\":{\"86\":1}}],[\"目录下的配置文件\",{\"1\":{\"44\":1}}],[\"目录下\",{\"1\":{\"44\":2}}],[\"面向过程就是分析出解决问题所需要的步骤\",{\"1\":{\"86\":1}}],[\"面向对象有哪些特性\",{\"0\":{\"87\":1}}],[\"面向对象\",{\"0\":{\"85\":1},\"1\":{\"38\":1,\"86\":1}}],[\"⾯向对象\",{\"1\":{\"86\":1}}],[\"⾯向对象和⾯向过程的区别\",{\"0\":{\"86\":1}}],[\"⾯向过程\",{\"1\":{\"86\":1}}],[\"支持随机访问\",{\"1\":{\"302\":1}}],[\"支持高并发操作\",{\"1\":{\"83\":1}}],[\"支持多线程\",{\"1\":{\"38\":1}}],[\"允许一个线程二次请求自己持有对象锁的临界资源\",{\"1\":{\"276\":1}}],[\"允许键和值为null\",{\"1\":{\"83\":1}}],[\"允许把函数作为一个方法的参数\",{\"1\":{\"32\":1}}],[\"永久保存\",{\"1\":{\"81\":1}}],[\"没找到\",{\"1\":{\"81\":1}}],[\"没有所谓的非空闲时间\",{\"1\":{\"244\":1}}],[\"没有取到才会创建新的对象\",{\"1\":{\"64\":1}}],[\"没有的话随便修改下master分支代码\",{\"1\":{\"21\":1}}],[\"属性上等\",{\"1\":{\"81\":1}}],[\"缺点是处于等待队列中的线程可能会饿死\",{\"1\":{\"286\":1}}],[\"缺点是整体吞吐效率相对非公平锁要低\",{\"1\":{\"285\":1}}],[\"缺点\",{\"1\":{\"79\":1,\"307\":1,\"309\":1}}],[\"键值中的\",{\"1\":{\"78\":1}}],[\"keepalive\",{\"1\":{\"247\":1}}],[\"keepalivetime默认是10\",{\"1\":{\"247\":1}}],[\"keepalivetime为0\",{\"1\":{\"246\":1}}],[\"keepalivetime单位\",{\"1\":{\"196\":1}}],[\"keepalivetime\",{\"1\":{\"195\":1,\"196\":1,\"229\":2,\"235\":1,\"250\":2}}],[\"key通过hash定位到segment\",{\"1\":{\"335\":1}}],[\"key设计成弱引用同样是为了防止内存泄漏问题\",{\"1\":{\"118\":1}}],[\"key是threadlocal的弱引用\",{\"1\":{\"115\":1}}],[\"key\",{\"1\":{\"78\":2,\"116\":1,\"119\":1,\"318\":12,\"319\":13,\"324\":4,\"336\":2,\"339\":1,\"341\":1}}],[\"k\",{\"1\":{\"78\":1,\"121\":3,\"318\":6,\"319\":6}}],[\"kit\",{\"1\":{\"39\":1}}],[\"<\",{\"1\":{\"194\":1,\"196\":1,\"264\":2,\"303\":1,\"336\":2}}],[\"<=\",{\"1\":{\"142\":1,\"144\":1,\"267\":1,\"303\":2,\"336\":1}}],[\"<p>defaults\",{\"1\":{\"81\":1}}],[\"<t>\",{\"1\":{\"77\":4}}],[\"<<\",{\"1\":{\"56\":1,\"336\":1}}],[\"泛型信息会被擦除\",{\"1\":{\"79\":1}}],[\"泛型主要是为了提供编译时类型检查\",{\"1\":{\"79\":1}}],[\"泛型常用的通配符有哪些\",{\"0\":{\"78\":1}}],[\"泛型方法\",{\"1\":{\"77\":1}}],[\"泛型接口\",{\"1\":{\"77\":1}}],[\"泛型类\",{\"1\":{\"77\":1}}],[\"泛型的使用方法\",{\"0\":{\"77\":1}}],[\"泛型\",{\"0\":{\"75\":1}}],[\"然后把它们的叠加和作为映射的位置\",{\"1\":{\"324\":1}}],[\"然后与哈希值本身异或\",{\"1\":{\"320\":1}}],[\"然后再将哈希值右移16位\",{\"1\":{\"320\":1}}],[\"然后将键值对存储在该桶中\",{\"1\":{\"312\":1}}],[\"然后将第一个子任务和第二个子任务的结果相加\",{\"1\":{\"267\":1}}],[\"然后重新尝试\",{\"1\":{\"299\":1}}],[\"然后直接返回\",{\"1\":{\"287\":1}}],[\"然后设置当前锁的拥有者为当前线程\",{\"1\":{\"287\":1}}],[\"然后当前线程栈帧中增加一个锁记录第一部分\",{\"1\":{\"281\":1}}],[\"然后被阻塞在安全点的线程继续往下执行同步代码块\",{\"1\":{\"280\":1}}],[\"然后执行\",{\"1\":{\"280\":1}}],[\"然后继续执行任务队列中的任务\",{\"1\":{\"265\":1}}],[\"然后逐个调用线程的interrupt方法来中断线程\",{\"1\":{\"239\":1}}],[\"然后恢复即将执行线程的状态\",{\"1\":{\"202\":1}}],[\"然后恢复下一个线程的上下文\",{\"1\":{\"135\":1}}],[\"然后又开始执行\",{\"1\":{\"142\":1}}],[\"然后进行相应的操作\",{\"1\":{\"138\":1}}],[\"然后table引用指向\",{\"1\":{\"121\":1}}],[\"然后放到新的newtab\",{\"1\":{\"121\":1}}],[\"然后遍历老的table数组\",{\"1\":{\"121\":1}}],[\"然后还要根据条件判断size\",{\"1\":{\"121\":1}}],[\"然后判断该槽位entry对象中的key是否和get的key一致\",{\"1\":{\"120\":1}}],[\"然后和table数组长度减一\",{\"1\":{\"119\":1}}],[\"然后到了真正要被回收的时候\",{\"1\":{\"95\":1}}],[\"然后用函数把这些步骤一步一步实现\",{\"1\":{\"86\":1}}],[\"然后搞一些事情\",{\"1\":{\"81\":1}}],[\"然后\",{\"1\":{\"74\":1,\"178\":1}}],[\"之前被刷新到主内存中\",{\"1\":{\"111\":1}}],[\"之前\",{\"1\":{\"74\":1}}],[\"自旋超过次数就阻塞获取\",{\"1\":{\"335\":1}}],[\"自旋cas\",{\"1\":{\"293\":1}}],[\"自旋一定次数后\",{\"1\":{\"283\":1}}],[\"自旋等待\",{\"1\":{\"281\":1}}],[\"自旋锁\",{\"1\":{\"278\":1}}],[\"自定义线程池\",{\"0\":{\"196\":1,\"250\":1}}],[\"自然也就走不到\",{\"1\":{\"74\":1}}],[\"自动装箱的时候会去缓存池里取integer对象\",{\"1\":{\"64\":1}}],[\"自动类型转换\",{\"1\":{\"51\":1}}],[\"了多少个对象\",{\"1\":{\"269\":1}}],[\"了解这些步骤有助于理解线程池如何管理线程和任务\",{\"1\":{\"228\":1}}],[\"了解吗\",{\"0\":{\"140\":1,\"141\":1,\"144\":1,\"147\":1,\"307\":1}}],[\"了\",{\"1\":{\"74\":2,\"95\":1}}],[\"里面包含一个segment数组\",{\"1\":{\"335\":1}}],[\"里面的\",{\"1\":{\"74\":1}}],[\"里定义的方法\",{\"1\":{\"95\":1}}],[\"里不按套路出牌\",{\"1\":{\"74\":1}}],[\"里的\",{\"1\":{\"74\":1}}],[\"结合监控告警机制\",{\"1\":{\"263\":1}}],[\"结合监控机制建立告警机制\",{\"1\":{\"263\":1}}],[\"结果为直接保留hash值对\",{\"1\":{\"322\":1}}],[\"结果正确\",{\"0\":{\"296\":1}}],[\"结果合并\",{\"1\":{\"267\":1}}],[\"结果3\",{\"1\":{\"162\":1,\"170\":1}}],[\"结果2\",{\"1\":{\"162\":1,\"170\":1}}],[\"结果1\",{\"1\":{\"162\":1,\"170\":1}}],[\"结果\",{\"1\":{\"74\":1,\"154\":1,\"167\":1,\"168\":1,\"170\":1,\"175\":1,\"178\":1,\"179\":2}}],[\"结束当前的方法\",{\"1\":{\"55\":1}}],[\"结束当前的循环体\",{\"1\":{\"55\":1}}],[\"结束正在执行的循环\",{\"1\":{\"55\":1}}],[\"返回值类型为\",{\"1\":{\"267\":1}}],[\"返回值类型\",{\"1\":{\"238\":1}}],[\"返回值是\",{\"1\":{\"36\":1}}],[\"返回\",{\"1\":{\"131\":1,\"138\":1,\"289\":2}}],[\"返回前先执行\",{\"1\":{\"74\":1}}],[\"按钮\",{\"1\":{\"300\":1}}],[\"按finally中return的为准\",{\"1\":{\"74\":1}}],[\"按照键的自然顺序或自定义顺序进行排序\",{\"1\":{\"83\":1}}],[\"按照流的角色划分为\",{\"1\":{\"28\":1}}],[\"按照流的流向分\",{\"1\":{\"28\":1}}],[\"按照操作单元划分\",{\"1\":{\"28\":1}}],[\"题目3\",{\"1\":{\"74\":1}}],[\"题目2\",{\"1\":{\"74\":1}}],[\"题目1\",{\"1\":{\"74\":1}}],[\"语句\",{\"1\":{\"131\":1,\"138\":1}}],[\"语句中\",{\"1\":{\"95\":1}}],[\"语句块来完成\",{\"1\":{\"282\":1}}],[\"语句块\",{\"1\":{\"74\":1}}],[\"语法形式\",{\"1\":{\"92\":1}}],[\"语言\",{\"0\":{\"42\":1}}],[\"三步操作了\",{\"1\":{\"104\":1}}],[\"三道经典异常处理代码题\",{\"0\":{\"74\":1}}],[\"三分钟搭建一个博客网站\",{\"0\":{\"7\":1,\"8\":1}}],[\"此时a已经非彼a\",{\"1\":{\"291\":1}}],[\"此时持有该偏向锁的线程\",{\"1\":{\"280\":1}}],[\"此时计数器\",{\"1\":{\"272\":1}}],[\"此时会释放\",{\"1\":{\"272\":1}}],[\"此时其他线程也会收到\",{\"1\":{\"142\":1}}],[\"此时就会线性向后查找\",{\"1\":{\"120\":1}}],[\"此时finally块中的代码不会执行\",{\"1\":{\"73\":1}}],[\"此时pages页会显示访问域名\",{\"1\":{\"21\":1}}],[\"抛出异常\",{\"1\":{\"72\":1}}],[\"异或操作使得低位的特征影响到高位\",{\"1\":{\"320\":1}}],[\"异步调用\",{\"1\":{\"266\":1}}],[\"异步任务执行\",{\"0\":{\"220\":1}}],[\"异步任务链中的线程池\",{\"0\":{\"185\":1}}],[\"异步任务完成\",{\"1\":{\"179\":1}}],[\"异步任务逻辑\",{\"1\":{\"175\":1,\"178\":1}}],[\"异步非阻塞io\",{\"1\":{\"30\":1}}],[\"异常的处理机制\",{\"0\":{\"72\":1}}],[\"异常处理后的默认值\",{\"1\":{\"165\":1}}],[\"异常处理\",{\"0\":{\"70\":1},\"1\":{\"142\":1,\"238\":1}}],[\"x\",{\"1\":{\"298\":3}}],[\"xstream等\",{\"1\":{\"69\":1}}],[\"xml\",{\"1\":{\"69\":1}}],[\"xml序列化\",{\"1\":{\"69\":1}}],[\"xml等格式\",{\"1\":{\"69\":1}}],[\"xx\",{\"1\":{\"64\":1}}],[\"被窃取任务线程永远从双端队列的头部拿\",{\"1\":{\"267\":1}}],[\"被销毁\",{\"1\":{\"245\":1}}],[\"被垃圾回收器回收了\",{\"1\":{\"116\":1}}],[\"被定义出来屏蔽各种硬件和操作系统的内存访问差异\",{\"1\":{\"102\":1}}],[\"被调用不一定会立即回收该对象\",{\"1\":{\"95\":1}}],[\"被final修饰的变量必须被显式第指定初始值\",{\"1\":{\"94\":1}}],[\"被final修饰的变量不可变\",{\"1\":{\"94\":1}}],[\"被final修饰的方法不可以被重写\",{\"1\":{\"94\":1}}],[\"被final修饰的类不可以被继承\",{\"1\":{\"94\":1}}],[\"被\",{\"1\":{\"68\":1}}],[\"被推荐使用的做法\",{\"1\":{\"35\":1}}],[\"关闭调度器\",{\"1\":{\"227\":1}}],[\"关闭线程池\",{\"1\":{\"179\":1,\"194\":1,\"196\":1,\"264\":1}}],[\"关键字或其他同步机制\",{\"1\":{\"333\":1}}],[\"关键字synchronized可以修饰方法或者以同步块的形式来进行使用\",{\"1\":{\"138\":1}}],[\"关键字volatile可以用来修饰字段\",{\"1\":{\"138\":1}}],[\"关键字的作用是让被修饰的成员属性不被序列化\",{\"1\":{\"304\":1}}],[\"关键字的作用\",{\"1\":{\"68\":1}}],[\"关键字修饰\",{\"1\":{\"68\":1}}],[\"关于作者\",{\"0\":{\"2\":1},\"1\":{\"2\":1}}],[\"关于网站\",{\"0\":{\"1\":1}}],[\"仍然可以成功反序列化之前的序列化数据\",{\"1\":{\"68\":1}}],[\"兼容性\",{\"1\":{\"68\":1}}],[\"则为一个全是1的二进制数\",{\"1\":{\"322\":1}}],[\"则需要把链表转换为红黑树\",{\"1\":{\"318\":1}}],[\"则异常不会抛出\",{\"1\":{\"307\":1}}],[\"则释放已持有的资源\",{\"1\":{\"299\":1}}],[\"则请求者只能等待\",{\"1\":{\"299\":1}}],[\"则以原子方式将引用值和印戳标志的值更新为给定的更新值\",{\"1\":{\"292\":1}}],[\"则调用该方法线程会被放入\",{\"1\":{\"287\":1}}],[\"则这次只是简单地把aqs\",{\"1\":{\"287\":1}}],[\"则当前线程会获取到该锁\",{\"1\":{\"287\":1}}],[\"则当前线程持有该对象锁\",{\"1\":{\"281\":1}}],[\"则\",{\"1\":{\"281\":1}}],[\"则进行\",{\"1\":{\"281\":1}}],[\"则进入步骤\",{\"1\":{\"280\":1}}],[\"则执行\",{\"1\":{\"280\":1,\"281\":1}}],[\"则查看线程id是否为当前线程\",{\"1\":{\"280\":1}}],[\"则直接插入即可\",{\"1\":{\"318\":1}}],[\"则直接撤销偏向锁\",{\"1\":{\"280\":1}}],[\"则直接返回n\",{\"1\":{\"267\":1}}],[\"则直接由核心线程执行任务\",{\"1\":{\"231\":1}}],[\"则将t线程的偏向锁\",{\"1\":{\"280\":1}}],[\"则将markword中线程id设置为当前线程id\",{\"1\":{\"280\":1}}],[\"则将问题拆分成两个子任务\",{\"1\":{\"267\":1}}],[\"则将任务分配给该线程执行\",{\"1\":{\"242\":1}}],[\"则将任务分配给空闲线程执行\",{\"1\":{\"242\":2}}],[\"则将任务放入任务队列等待执行\",{\"1\":{\"231\":1}}],[\"则取消调用并释放资源\",{\"1\":{\"266\":1}}],[\"则线程会被终止\",{\"1\":{\"235\":1}}],[\"则线程会被唤醒\",{\"1\":{\"131\":1}}],[\"则根据设置的拒绝策略处理新任务\",{\"1\":{\"231\":1}}],[\"则创建新的非核心线程执行任务\",{\"1\":{\"231\":1}}],[\"则使用默认的\",{\"1\":{\"185\":1}}],[\"则处于await的线程都会\",{\"1\":{\"143\":1}}],[\"则必\",{\"1\":{\"143\":1}}],[\"则必须重写方法\",{\"1\":{\"91\":1}}],[\"则阻塞\",{\"1\":{\"142\":1}}],[\"则会抛出concurrent\",{\"1\":{\"307\":1}}],[\"则会抛出invalidclassexception异常\",{\"1\":{\"68\":1}}],[\"则会在当前线程栈帧中划出一块空间\",{\"1\":{\"281\":1}}],[\"则会递归调用\",{\"1\":{\"267\":1}}],[\"则会放行\",{\"1\":{\"142\":1}}],[\"则会清除中断标志\",{\"1\":{\"131\":1}}],[\"则该class\",{\"1\":{\"97\":1}}],[\"则它们的\",{\"1\":{\"97\":1}}],[\"则视为重载\",{\"1\":{\"88\":1}}],[\"则是一个\",{\"1\":{\"61\":1}}],[\"版本控制\",{\"1\":{\"68\":1}}],[\"又有什么用\",{\"1\":{\"68\":1}}],[\"方便哈希取余\",{\"1\":{\"322\":1}}],[\"方便\",{\"1\":{\"130\":1}}],[\"方便存储和传输\",{\"1\":{\"68\":1}}],[\"方法将hashmap包装成线程安全的map\",{\"1\":{\"333\":1}}],[\"方法结合实现等待\",{\"1\":{\"282\":1}}],[\"方法配合try\",{\"1\":{\"282\":1}}],[\"方法开始执行任务\",{\"1\":{\"267\":1}}],[\"方法中\",{\"1\":{\"267\":3,\"288\":1}}],[\"方法是\",{\"1\":{\"267\":1}}],[\"方法会尝试中断正在执行的任务\",{\"1\":{\"239\":1}}],[\"方法会终止java虚拟机的运行\",{\"1\":{\"73\":1}}],[\"方法不会立即停止线程池\",{\"1\":{\"239\":1}}],[\"方法用于立即关闭线程池\",{\"1\":{\"239\":1}}],[\"方法用于平缓地关闭线程池\",{\"1\":{\"239\":1}}],[\"方法用于提交不需要返回结果的任务\",{\"1\":{\"238\":1}}],[\"方法来定义具体的任务逻辑\",{\"1\":{\"267\":1}}],[\"方法来修改核心线程数\",{\"1\":{\"262\":1}}],[\"方法来处理线程执行完毕后的异常\",{\"1\":{\"250\":1}}],[\"方法来检查线程池是否已经关闭\",{\"1\":{\"239\":1}}],[\"方法来等待线程池关闭\",{\"1\":{\"239\":1}}],[\"方法来实现\",{\"1\":{\"239\":1}}],[\"方法来设置线程的中断标志为true\",{\"1\":{\"131\":1}}],[\"方法或scheduleatfixedrate\",{\"1\":{\"242\":1}}],[\"方法或shutdownnow\",{\"1\":{\"239\":2}}],[\"方法或locksupport\",{\"1\":{\"133\":1}}],[\"方法则更加灵活\",{\"1\":{\"238\":1}}],[\"方法则会唤醒所有在该共享变量上由于调用\",{\"1\":{\"131\":1}}],[\"方法除了接受runnable接口类型的任务外\",{\"1\":{\"238\":1}}],[\"方法接受runnable接口类型的任务作为参数\",{\"1\":{\"238\":1}}],[\"方法无法处理任务执行过程中抛出的异常\",{\"1\":{\"238\":1}}],[\"方法更加灵活\",{\"1\":{\"238\":1}}],[\"方法返回一个future对象\",{\"1\":{\"238\":1}}],[\"方法没有返回值\",{\"1\":{\"238\":1}}],[\"方法都用于向线程池提交任务\",{\"1\":{\"238\":1}}],[\"方法关闭\",{\"1\":{\"233\":1}}],[\"方法可以安全地关闭线程池\",{\"1\":{\"239\":1}}],[\"方法可以通过future对象来捕获任务执行过程中抛出的异常\",{\"1\":{\"238\":1}}],[\"方法可以返回一个future对象\",{\"1\":{\"230\":1}}],[\"方法可以非常简单地实现对象的浅拷贝\",{\"1\":{\"99\":1}}],[\"方法提交给线程池执行\",{\"1\":{\"267\":1}}],[\"方法提交第一个子任务给线程池执行\",{\"1\":{\"267\":1}}],[\"方法提交定时任务或周期性任务\",{\"1\":{\"242\":1}}],[\"方法提交的任务没有返回值\",{\"1\":{\"230\":1}}],[\"方法提交到线程池\",{\"1\":{\"230\":1}}],[\"方法有带超时参数的重载形式\",{\"1\":{\"150\":1}}],[\"方法响应中断\",{\"1\":{\"146\":1}}],[\"方法模拟了汽车进入停车场\",{\"1\":{\"145\":1}}],[\"方法之外\",{\"1\":{\"138\":1}}],[\"方法主动放弃\",{\"1\":{\"136\":1}}],[\"方法后\",{\"1\":{\"131\":1,\"239\":3}}],[\"方法唤醒它\",{\"1\":{\"131\":2}}],[\"方法多了一个超时参数\",{\"1\":{\"131\":1}}],[\"方法时\",{\"1\":{\"131\":2,\"238\":1,\"257\":1,\"258\":1}}],[\"方法时会执行run\",{\"0\":{\"129\":1}}],[\"方法启动线程\",{\"1\":{\"128\":1}}],[\"方法的重载版本来指定自定义的线程池\",{\"1\":{\"176\":1}}],[\"方法的最后\",{\"1\":{\"121\":1}}],[\"方法的返回值必须相等\",{\"1\":{\"97\":1}}],[\"方法释放内存空间\",{\"1\":{\"117\":1}}],[\"方法判断相等\",{\"1\":{\"97\":1}}],[\"方法只会被调用一次\",{\"1\":{\"95\":1}}],[\"方法和类\",{\"1\":{\"95\":1}}],[\"方法修饰符\",{\"1\":{\"91\":1}}],[\"方法实现\",{\"1\":{\"91\":1,\"282\":1}}],[\"方法重写\",{\"1\":{\"88\":1}}],[\"方法重载\",{\"1\":{\"88\":1}}],[\"方法重载和方法重写都是实现多态性的方式\",{\"1\":{\"88\":1}}],[\"方法名相同\",{\"1\":{\"88\":2}}],[\"方法上\",{\"1\":{\"81\":1}}],[\"方法等待子任务的完成并合并结果\",{\"1\":{\"267\":1}}],[\"方法等待第一个子任务的执行结果\",{\"1\":{\"267\":1}}],[\"方法等\",{\"1\":{\"68\":1}}],[\"方法等信息\",{\"1\":{\"48\":1}}],[\"方法\",{\"0\":{\"129\":2},\"1\":{\"65\":2,\"73\":1,\"89\":4,\"95\":1,\"128\":3,\"129\":2,\"131\":3,\"132\":1,\"133\":2,\"142\":1,\"143\":1,\"145\":2,\"146\":1,\"149\":3,\"239\":2,\"241\":1,\"267\":2,\"272\":1,\"288\":1}}],[\"方法为true\",{\"1\":{\"63\":1}}],[\"把冲突的元素放进去\",{\"1\":{\"325\":2}}],[\"把这些小任务放到不同的队列里\",{\"1\":{\"267\":1}}],[\"把任务添加到linkedblockingqueue阻塞队列\",{\"1\":{\"244\":1}}],[\"把元素放到空的槽中\",{\"1\":{\"120\":1}}],[\"把构成问题的事务分解成各个对象\",{\"1\":{\"86\":1}}],[\"把二进制流恢复成对象\",{\"1\":{\"68\":1}}],[\"把java对象转为二进制流\",{\"1\":{\"68\":1}}],[\"把一个表数范围小的数值或变量直接赋给另一个数范围大的变量时\",{\"1\":{\"51\":1}}],[\"垃圾回收\",{\"0\":{\"205\":1},\"1\":{\"66\":1}}],[\"到底如何做呢\",{\"1\":{\"299\":1}}],[\"到该列表\",{\"1\":{\"272\":1}}],[\"到期任务是指scheduledfuturetask的time大于等于当前时间\",{\"1\":{\"247\":1}}],[\"到\",{\"1\":{\"64\":1}}],[\"搞了个缓存池\",{\"1\":{\"64\":1}}],[\"号拼接会编译成stringbuilder的append方法\",{\"1\":{\"62\":1}}],[\"其他⽅法都是直接调⽤\",{\"1\":{\"341\":1}}],[\"其他线程必须等待该线程释放锁后才能获取锁\",{\"1\":{\"272\":1}}],[\"其他线程不\",{\"1\":{\"143\":1}}],[\"其他线程调用了线程a的\",{\"1\":{\"131\":1}}],[\"其他线程调用了线程a共享对象\",{\"1\":{\"131\":1}}],[\"其他线程能够立即看到这个修改\",{\"1\":{\"103\":1}}],[\"其次要考虑的是你的系统资源\",{\"1\":{\"240\":1}}],[\"其中n是树中节点的数量\",{\"1\":{\"315\":1}}],[\"其中\",{\"1\":{\"299\":1}}],[\"其中的线程会等待\",{\"1\":{\"143\":1}}],[\"其中每个线程都有自己的控制器和运算器\",{\"1\":{\"102\":1}}],[\"其实都是基于对象的内置锁\",{\"1\":{\"272\":1}}],[\"其实就体现了分治思想\",{\"1\":{\"267\":1}}],[\"其实在jvm\",{\"1\":{\"137\":1}}],[\"其实是会生成新的对象\",{\"1\":{\"62\":1}}],[\"其含义是\",{\"1\":{\"131\":1,\"138\":1}}],[\"其内部调用的是\",{\"1\":{\"131\":1}}],[\"其它的原子操作类基本都是大同小异\",{\"1\":{\"298\":1}}],[\"其它获取该锁的线程会被阻塞而被放入该锁的阻塞队列里面\",{\"1\":{\"284\":1}}],[\"其它线程就会在获取失败后被阻塞\",{\"1\":{\"283\":1}}],[\"其它线程无法获取主内存中的共享变量\",{\"1\":{\"274\":1}}],[\"其它\",{\"0\":{\"43\":1}}],[\"否则向链表中插入数据\",{\"1\":{\"318\":1}}],[\"否则需要覆盖\",{\"1\":{\"318\":1}}],[\"否则抛出异常\",{\"1\":{\"307\":1}}],[\"否则执行6\",{\"1\":{\"281\":1}}],[\"否则执行\",{\"1\":{\"281\":1}}],[\"否则进入步骤\",{\"1\":{\"280\":1}}],[\"否则会报错\",{\"1\":{\"91\":1}}],[\"否则会有可读性等问题\",{\"1\":{\"32\":1}}],[\"否则\",{\"1\":{\"61\":1,\"63\":1,\"232\":1,\"245\":1,\"267\":1,\"319\":2}}],[\"还额外有cas操作的开销\",{\"1\":{\"278\":1}}],[\"还可以节省内存空间\",{\"1\":{\"305\":1}}],[\"还可以利用图形化工具\",{\"1\":{\"300\":1}}],[\"还可以存活60秒\",{\"1\":{\"245\":1}}],[\"还可以接受callable接口类型的任务作为参数\",{\"1\":{\"238\":1}}],[\"还需要考虑任务的执行时间\",{\"1\":{\"240\":1}}],[\"还提供了join\",{\"1\":{\"138\":1}}],[\"还有什么其它办法\",{\"0\":{\"124\":1}}],[\"还有编译器\",{\"1\":{\"39\":1}}],[\"还是引用传递\",{\"0\":{\"98\":1}}],[\"还会通过\",{\"1\":{\"61\":1}}],[\"影响性能\",{\"1\":{\"60\":1}}],[\"高位补0\",{\"1\":{\"322\":1}}],[\"高位\",{\"1\":{\"320\":1}}],[\"高\",{\"1\":{\"60\":1}}],[\"低位是与1做位运算\",{\"1\":{\"322\":1}}],[\"低\",{\"1\":{\"60\":2}}],[\"性能更加优秀和稳定\",{\"1\":{\"315\":1}}],[\"性能更好\",{\"1\":{\"60\":1}}],[\"性能指标\",{\"1\":{\"263\":1}}],[\"性能测试\",{\"1\":{\"263\":1}}],[\"性能\",{\"1\":{\"60\":1,\"282\":1}}],[\"安其拉\",{\"1\":{\"140\":4}}],[\"安全失败\",{\"1\":{\"307\":1}}],[\"安全问题\",{\"1\":{\"113\":1}}],[\"安全性和可靠性\",{\"1\":{\"59\":1}}],[\"安装依赖\",{\"1\":{\"11\":1}}],[\"安装pnpm\",{\"1\":{\"9\":1}}],[\"安装nodejs\",{\"1\":{\"9\":1}}],[\"替换等\",{\"1\":{\"59\":1}}],[\"再遍历链表定位到具体的元素上\",{\"1\":{\"335\":1}}],[\"再建一个数组\",{\"1\":{\"325\":1}}],[\"再哈希法\",{\"1\":{\"325\":1}}],[\"再插入时\",{\"1\":{\"303\":1}}],[\"再申请资源序号大的\",{\"1\":{\"299\":1}}],[\"再继续取\",{\"1\":{\"246\":1}}],[\"再次放行\",{\"1\":{\"142\":1}}],[\"再进行屏障后的写操作\",{\"1\":{\"111\":1}}],[\"再进行屏障后的读操作\",{\"1\":{\"111\":1}}],[\"再+1\",{\"1\":{\"104\":1}}],[\"再反序列化成拷贝对象\",{\"1\":{\"99\":1}}],[\"再输出\",{\"1\":{\"74\":1}}],[\"再catch中return\",{\"1\":{\"74\":1}}],[\"再自增\",{\"1\":{\"57\":1}}],[\"再赋值到j\",{\"1\":{\"104\":1}}],[\"再赋值\",{\"1\":{\"57\":1}}],[\"再由操作系统执行\",{\"1\":{\"42\":1}}],[\"减\",{\"1\":{\"57\":2}}],[\"减少碰撞的概率\",{\"1\":{\"330\":1}}],[\"减少了扩容操作的时间和资源消耗\",{\"1\":{\"330\":1}}],[\"减少了相同低位的哈希值导致相同索引位置的情况\",{\"1\":{\"320\":1}}],[\"减少了频繁创建和销毁线程的开销\",{\"1\":{\"191\":1}}],[\"减少不必要的cpu上下文切换\",{\"1\":{\"278\":1}}],[\"减少操作系统互斥量带来的性能消耗\",{\"1\":{\"278\":1}}],[\"减少其执行时间\",{\"1\":{\"266\":1}}],[\"减少线程间的竞争\",{\"1\":{\"240\":1}}],[\"减少连接创建和销毁的开销\",{\"1\":{\"214\":1}}],[\"减少\",{\"1\":{\"36\":1}}],[\"先读取i的值\",{\"1\":{\"104\":1}}],[\"先finally\",{\"1\":{\"74\":1}}],[\"先赋值\",{\"1\":{\"57\":1}}],[\"先自增\",{\"1\":{\"57\":1}}],[\"先对\",{\"1\":{\"36\":1}}],[\"运行\",{\"1\":{\"132\":1}}],[\"运行状态\",{\"1\":{\"132\":1}}],[\"运行时异常\",{\"1\":{\"71\":1}}],[\"运算\",{\"1\":{\"119\":1,\"322\":1}}],[\"运算符放在变量之前时\",{\"1\":{\"57\":1}}],[\"运算符可以放在变量之前\",{\"1\":{\"57\":1}}],[\"运⾏时环境\",{\"1\":{\"39\":1}}],[\"位虚拟机\",{\"1\":{\"277\":1}}],[\"位运算\",{\"1\":{\"56\":1}}],[\"位数\",{\"1\":{\"50\":1}}],[\"用vector代替arraylist\",{\"1\":{\"308\":1}}],[\"用户线程\",{\"1\":{\"137\":1}}],[\"用\",{\"1\":{\"130\":1,\"143\":1}}],[\"用来保存objectwaiter\",{\"1\":{\"272\":1}}],[\"用来做用户信息上下文的存储\",{\"1\":{\"114\":1}}],[\"用来表示对象的唯一标识\",{\"1\":{\"97\":1}}],[\"用this来区分\",{\"1\":{\"90\":1}}],[\"用于记录元素的插入顺序或访问顺序\",{\"1\":{\"338\":1}}],[\"用于实现多线程环境下的同步操作\",{\"1\":{\"289\":1}}],[\"用于计算斐波那契数列的值\",{\"1\":{\"267\":1}}],[\"用于并发执行大量短期的小任务\",{\"1\":{\"245\":1}}],[\"用于创建新线程的工厂\",{\"1\":{\"235\":1}}],[\"用于指定keepalivetime的时间单位\",{\"1\":{\"235\":1}}],[\"用于获取任务的执行结果\",{\"1\":{\"230\":1}}],[\"用于其堆栈空间和线程本地存储\",{\"1\":{\"199\":1}}],[\"用于保存等待执行的任务\",{\"1\":{\"195\":1}}],[\"用于存储等待执行的任务的队列\",{\"1\":{\"235\":1}}],[\"用于存储元素\",{\"1\":{\"187\":1}}],[\"用于存储线程局部变量的值\",{\"1\":{\"118\":1}}],[\"用于为异步操作设定超时\",{\"1\":{\"167\":1}}],[\"用于等待所有给定的\",{\"1\":{\"162\":1}}],[\"用于将两个独立的\",{\"1\":{\"161\":1}}],[\"用于在多线程环境下保证共享变量的操作是原子性的\",{\"1\":{\"297\":1}}],[\"用于在超时时返回默认值\",{\"1\":{\"168\":1}}],[\"用于在异步任务完成或发生异常时对结果进行处理\",{\"1\":{\"165\":1}}],[\"用于在异步任务发生异常时提供一个默认值\",{\"1\":{\"164\":1}}],[\"用于在一个\",{\"1\":{\"160\":1}}],[\"用于在任务完成后执行一个没有返回值的操作\",{\"1\":{\"158\":1}}],[\"用于在任务完成后\",{\"1\":{\"156\":1,\"157\":1}}],[\"用于在编译时期提供类型安全的参数化类型\",{\"1\":{\"76\":1}}],[\"用于执行fork\",{\"1\":{\"267\":1}}],[\"用于执行没有返回值的异步任务\",{\"1\":{\"154\":1}}],[\"用于执行有返回值的异步任务\",{\"1\":{\"154\":1}}],[\"用于处理异步任务的结果和执行流程\",{\"1\":{\"152\":1}}],[\"用于描述多线程环境下的内存访问行为\",{\"1\":{\"103\":1}}],[\"用于修饰变量\",{\"1\":{\"95\":1}}],[\"用于标识类可以被序列化\",{\"1\":{\"68\":1}}],[\"用于表示一个值可能存在或不存在\",{\"1\":{\"32\":1}}],[\"用最有效率的方法计算2乘以8\",{\"0\":{\"56\":1}}],[\"进⼊同步代码前要获得当前\",{\"1\":{\"269\":1}}],[\"进入阻塞状态\",{\"1\":{\"283\":1}}],[\"进入同步代码前要获得\",{\"1\":{\"269\":1}}],[\"进入该状态表示当前线\",{\"1\":{\"132\":1}}],[\"进入下一个循环条件\",{\"1\":{\"55\":1}}],[\"进程id\",{\"1\":{\"300\":1}}],[\"进程中的多个线程共享进程的资源\",{\"1\":{\"127\":1}}],[\"进程是代码在数据集合上的一次运行活动\",{\"1\":{\"127\":1}}],[\"进程\",{\"1\":{\"127\":1}}],[\"进而产生问题\",{\"1\":{\"95\":1}}],[\"进而用到了integercache\",{\"1\":{\"64\":1}}],[\"进行了一系列判断\",{\"1\":{\"341\":1}}],[\"进行一次抢锁\",{\"1\":{\"288\":1}}],[\"进行加锁操作时\",{\"1\":{\"281\":1}}],[\"进行阻塞\",{\"1\":{\"140\":2}}],[\"进行倒数计数\",{\"1\":{\"140\":2}}],[\"进行过滤\",{\"1\":{\"36\":1}}],[\"进行相应的处理\",{\"1\":{\"30\":1}}],[\"继续处理已提交和队列中的任务\",{\"1\":{\"257\":1}}],[\"继续等待新的任务\",{\"1\":{\"241\":1}}],[\"继续执行第2步\",{\"1\":{\"289\":1}}],[\"继续执行\",{\"1\":{\"244\":1}}],[\"继续执行后续任务\",{\"1\":{\"142\":15}}],[\"继续执行下次循环\",{\"1\":{\"55\":1}}],[\"继承关\",{\"1\":{\"130\":1}}],[\"继承thread类\",{\"1\":{\"128\":2}}],[\"继承是使⽤已存在的类的定义作为基础创建新的类\",{\"1\":{\"87\":1}}],[\"继承\",{\"1\":{\"38\":1,\"87\":2}}],[\"跳出本次循环\",{\"1\":{\"55\":1}}],[\"跳出整个循环\",{\"1\":{\"55\":1}}],[\"开发者可以继承forkjointask类来定义自己的任务\",{\"1\":{\"267\":1}}],[\"开放地址解决冲突\",{\"1\":{\"121\":1}}],[\"开放定址法就是从冲突的位置再接着往下找\",{\"1\":{\"325\":1}}],[\"开放定址法\",{\"1\":{\"120\":1,\"325\":1}}],[\"开始\",{\"1\":{\"54\":2}}],[\"开头的\",{\"1\":{\"36\":2}}],[\"5倍\",{\"1\":{\"303\":1}}],[\"5引入的一个特性\",{\"1\":{\"76\":1}}],[\"5\",{\"0\":{\"163\":1,\"164\":1,\"165\":1,\"185\":1,\"195\":1,\"224\":1,\"233\":1,\"253\":1,\"260\":1},\"1\":{\"54\":1,\"140\":1,\"164\":1,\"165\":1,\"184\":1,\"185\":1,\"193\":1,\"194\":1,\"196\":1,\"215\":1,\"219\":1,\"223\":1,\"227\":1,\"229\":1,\"264\":1,\"280\":2,\"281\":1}}],[\"只不过实现不同锁语义\",{\"1\":{\"288\":1}}],[\"只是在mark\",{\"1\":{\"278\":1}}],[\"只是用于线程之间的任务传递\",{\"1\":{\"237\":1}}],[\"只要垃圾回收机制一运行\",{\"1\":{\"116\":1}}],[\"只有在key在table数组中不存在的时候\",{\"1\":{\"341\":1}}],[\"只有在自己使用完毕后才由自己释放该资源\",{\"1\":{\"299\":1}}],[\"只有遇到其他线程竞争时才会执行撤销\",{\"1\":{\"280\":1}}],[\"只有⼀份\",{\"1\":{\"269\":1}}],[\"只有一个执行\",{\"1\":{\"126\":1}}],[\"只有当程序结束时才会被销毁\",{\"1\":{\"92\":1}}],[\"只有函数式接口\",{\"1\":{\"33\":1}}],[\"只能保证一个变量的原子操作\",{\"0\":{\"295\":1},\"1\":{\"290\":1}}],[\"只能有一个线程可以获取该锁\",{\"1\":{\"284\":1}}],[\"只能有一个线程处于方法或者同步块中\",{\"1\":{\"138\":1}}],[\"只能完成自己的任务\",{\"1\":{\"143\":1}}],[\"只能继承thread类\",{\"1\":{\"130\":1}}],[\"只能定义\",{\"1\":{\"91\":1}}],[\"只能修饰变量\",{\"1\":{\"68\":1}}],[\"只能是\",{\"1\":{\"54\":1}}],[\"短路与\",{\"1\":{\"53\":1}}],[\"将添加的元素作为key\",{\"1\":{\"341\":1}}],[\"将扩容操作分散到多次进行\",{\"1\":{\"330\":1}}],[\"将新键值对插入链表或红黑树末尾\",{\"1\":{\"330\":1}}],[\"将已经产生hash碰撞的元素完美的转移到新的table中去\",{\"1\":{\"322\":1}}],[\"将链表转换为红黑树\",{\"1\":{\"312\":1}}],[\"将原数组拷贝一份\",{\"1\":{\"309\":1}}],[\"将这些资源分配给其他等待进程\",{\"1\":{\"300\":1}}],[\"将会看到线程的死锁信息\",{\"1\":{\"300\":1}}],[\"将多个变量封装成一个对象\",{\"1\":{\"295\":1}}],[\"将多个连续的加锁\",{\"1\":{\"278\":1}}],[\"将内存位置\",{\"1\":{\"289\":1}}],[\"将清空工作内存中共享变量的值\",{\"1\":{\"274\":1}}],[\"将问题拆分成两个子任务并使用fork\",{\"1\":{\"267\":1}}],[\"将一个规模为n的问题分解为k个规模较小的子问题\",{\"1\":{\"267\":1}}],[\"将耗时的操作拆分为多个小任务\",{\"1\":{\"266\":1}}],[\"将耗时的\",{\"1\":{\"266\":1}}],[\"将线程池的参数配置在外部的配置文件或者配置中心中\",{\"1\":{\"262\":1}}],[\"将任务队列中的任务持久化到可靠的存储介质中\",{\"1\":{\"265\":1}}],[\"将任务加到阻塞队列\",{\"1\":{\"246\":1}}],[\"将任务放入任务队列中\",{\"1\":{\"241\":1}}],[\"将创建新的线程来处理新任务\",{\"1\":{\"242\":1}}],[\"将自定义线程池传递给\",{\"1\":{\"178\":1}}],[\"将\",{\"1\":{\"136\":1,\"322\":1,\"324\":1}}],[\"将对象序列化为hessian格式\",{\"1\":{\"69\":1}}],[\"将对象序列化为protobuf格式\",{\"1\":{\"69\":1}}],[\"将对象序列化为xml格式\",{\"1\":{\"69\":1}}],[\"将对象序列化为json格式\",{\"1\":{\"69\":1}}],[\"将此string对象添加到池中\",{\"1\":{\"63\":1}}],[\"将包装类型转换为基本数据类型\",{\"1\":{\"52\":1}}],[\"将基本类型用它们对应的引用类型包装起来\",{\"1\":{\"52\":1}}],[\"将通道\",{\"1\":{\"30\":1}}],[\"装箱\",{\"1\":{\"52\":1}}],[\"封箱\",{\"0\":{\"52\":1}}],[\"封装把⼀个对象的属性私有化\",{\"1\":{\"87\":1}}],[\"封装\",{\"1\":{\"38\":1,\"87\":1}}],[\"反序列化\",{\"1\":{\"68\":1}}],[\"反之就尾插法\",{\"1\":{\"336\":1}}],[\"反之\",{\"1\":{\"51\":1,\"240\":1}}],[\"反射的实现原理\",{\"0\":{\"48\":1}}],[\"反射的应用场景\",{\"0\":{\"47\":1}}],[\"反射相关类\",{\"1\":{\"46\":1}}],[\"反射\",{\"0\":{\"45\":1},\"1\":{\"46\":1,\"66\":1}}],[\"最后的结果是\",{\"1\":{\"341\":1}}],[\"最后所有元素处理完成后\",{\"1\":{\"318\":1}}],[\"最后赋值到i\",{\"1\":{\"104\":1}}],[\"最大线程数以及任务队列等参数\",{\"1\":{\"262\":1}}],[\"最大线程数也为1\",{\"1\":{\"246\":1}}],[\"最大线程数为integer\",{\"1\":{\"245\":1,\"247\":1}}],[\"最大线程数\",{\"1\":{\"195\":1,\"229\":1,\"235\":1,\"263\":2}}],[\"最大值\",{\"1\":{\"50\":1}}],[\"最终汇总每个小任务结果后得到大任务结果的框架\",{\"1\":{\"267\":1}}],[\"最终结果\",{\"1\":{\"172\":1,\"185\":1}}],[\"最终一定被执行\",{\"1\":{\"95\":1}}],[\"最终返回的还是之前暂存起来的结果\",{\"1\":{\"74\":1}}],[\"最终都调用parseint\",{\"1\":{\"65\":1}}],[\"最小值改不了\",{\"1\":{\"64\":1}}],[\"最小值\",{\"1\":{\"50\":1}}],[\"布尔型默认为false\",{\"1\":{\"92\":1}}],[\"布尔型\",{\"1\":{\"50\":1}}],[\"浮点类型\",{\"1\":{\"50\":1}}],[\"数字分析法\",{\"1\":{\"324\":1}}],[\"数字的二进制位左移三位相当于乘以2的三次方\",{\"1\":{\"56\":1}}],[\"数\",{\"1\":{\"143\":1}}],[\"数据拷贝在add方法中进行\",{\"1\":{\"310\":1}}],[\"数据拷贝的过程中\",{\"0\":{\"310\":1}}],[\"数据结构和hashmap是一样的\",{\"1\":{\"336\":1}}],[\"数据结构\",{\"1\":{\"330\":1,\"336\":1}}],[\"数据结构示意图\",{\"1\":{\"312\":1}}],[\"数据结构不同\",{\"1\":{\"302\":1}}],[\"数据结构或者并行计算等技术来优化耗时操作的执行效率\",{\"1\":{\"266\":1}}],[\"数据即使成功修改\",{\"1\":{\"291\":1}}],[\"数据处理通常可以并行化以提高效率\",{\"1\":{\"217\":1}}],[\"数据库操作通常是io密集型的\",{\"1\":{\"213\":1}}],[\"数据库连接池\",{\"0\":{\"212\":1}}],[\"数据库驱动\",{\"1\":{\"44\":1}}],[\"数据都已经放入到\",{\"1\":{\"121\":1}}],[\"数组+链表+红黑树\",{\"1\":{\"336\":1}}],[\"数组中key和hash一样就直接替换\",{\"1\":{\"335\":1}}],[\"数组中的每个元素称为一个桶\",{\"1\":{\"312\":1}}],[\"数组大小为2的倍数\",{\"1\":{\"322\":1}}],[\"数组大小\",{\"1\":{\"322\":6}}],[\"数组长度\",{\"1\":{\"321\":1}}],[\"数组可能长度100\",{\"1\":{\"305\":1}}],[\"数组满了\",{\"1\":{\"303\":1}}],[\"数组下标越界等等\",{\"1\":{\"71\":1}}],[\"数组\",{\"1\":{\"50\":1,\"312\":2}}],[\"数值型\",{\"1\":{\"50\":1}}],[\"基础\",{\"0\":{\"125\":1}}],[\"基础语法\",{\"0\":{\"49\":1}}],[\"基本概念\",{\"0\":{\"153\":1}}],[\"基本类型\",{\"1\":{\"50\":1}}],[\"基本数据类型==比较的是值\",{\"1\":{\"96\":1}}],[\"基本数据类型相同\",{\"1\":{\"88\":1}}],[\"基本数据类型吗\",{\"0\":{\"59\":1}}],[\"基本数据类型\",{\"1\":{\"50\":1}}],[\"基于拷贝内容的优点是避免了concurrent\",{\"1\":{\"307\":1}}],[\"基于cas来操作int类型变量\",{\"1\":{\"298\":1}}],[\"基于jvm实现\",{\"1\":{\"282\":1}}],[\"基于java虚拟机\",{\"1\":{\"48\":1}}],[\"基于红黑树实现的有序map\",{\"1\":{\"83\":1}}],[\"基于哈希表实现的线程安全的map\",{\"1\":{\"83\":1}}],[\"基于哈希表实现的map\",{\"1\":{\"83\":2}}],[\"基于哈希表和双向链表实现的map\",{\"1\":{\"83\":1}}],[\"基于vuepress\",{\"1\":{\"8\":1}}],[\"该如何避免死锁呢\",{\"1\":{\"299\":1}}],[\"该如何避免\",{\"0\":{\"299\":1}}],[\"该状态达到阈值40则执行批量撤销\",{\"1\":{\"280\":1}}],[\"该状态达到阈值20则执行批量重偏向\",{\"1\":{\"280\":1}}],[\"该状态不同于\",{\"1\":{\"132\":1}}],[\"该线程将被终止\",{\"1\":{\"232\":1}}],[\"该方法返回一个包装后的线程安全list\",{\"1\":{\"308\":1}}],[\"该方法会阻塞\",{\"1\":{\"149\":1}}],[\"该方法如果发现当前线程被中断\",{\"1\":{\"131\":1}}],[\"该实例也无法被垃圾回收\",{\"1\":{\"118\":1}}],[\"该对象又不需要被回收了\",{\"1\":{\"95\":1}}],[\"该对象被回收的时候被调用\",{\"1\":{\"95\":1}}],[\"该对象包含了类的名称\",{\"1\":{\"48\":1}}],[\"该引⽤变量发出的⽅法调⽤到底是哪个类中实现的⽅法\",{\"1\":{\"87\":1}}],[\"该文件位于\",{\"1\":{\"44\":1}}],[\"该文件包含了服务接口的实现类的全限定名\",{\"1\":{\"44\":1}}],[\"你能自己设计实现一个hashmap吗\",{\"0\":{\"331\":1}}],[\"你能设计实现一个线程池吗\",{\"0\":{\"264\":1}}],[\"你还知道哪些哈希函数的构造方法呢\",{\"0\":{\"324\":1}}],[\"你还可以在异步任务链中的不同部分使用不同的线程池\",{\"1\":{\"185\":1}}],[\"你还可以调用这些方法和属性\",{\"1\":{\"46\":1}}],[\"你对红黑树了解多少\",{\"0\":{\"313\":1}}],[\"你需要确保你的线程池的线程数不要超过系统资源的限制\",{\"1\":{\"240\":1}}],[\"你可以根据实际需求和场景进一步扩展和优化这个线程池的实现\",{\"1\":{\"264\":1}}],[\"你可以精细控制线程池的各种参数\",{\"1\":{\"196\":1}}],[\"你可以更好地控制\",{\"1\":{\"185\":1}}],[\"你可以使用threadpoolexecutor来创建自定义线程池\",{\"1\":{\"196\":1}}],[\"你可以使用\",{\"1\":{\"176\":1,\"177\":1}}],[\"你可以使用静态工厂方法来创建\",{\"1\":{\"154\":1}}],[\"你必须在构造中指定\",{\"1\":{\"143\":1}}],[\"你在工作中用到过threadlocal吗\",{\"0\":{\"114\":1}}],[\"你想要创建什么类型的项目\",{\"1\":{\"11\":1}}],[\"解锁操作连接在一起\",{\"1\":{\"278\":1}}],[\"解决哈希冲突有哪些方法呢\",{\"0\":{\"325\":1}}],[\"解决方案\",{\"0\":{\"210\":1,\"214\":1,\"218\":1,\"222\":1,\"226\":1}}],[\"解决了线程池等场景下inheritablethreadlocal\",{\"1\":{\"124\":1}}],[\"解析\",{\"1\":{\"74\":2}}],[\"解耦了服务的实现和调用方\",{\"1\":{\"44\":1}}],[\"解释成操作系统能识别的机器码\",{\"1\":{\"42\":1}}],[\"解释\",{\"0\":{\"145\":1,\"149\":1},\"1\":{\"41\":1}}],[\"实际上就是相当于每个segment都是一个hashmap\",{\"1\":{\"335\":1}}],[\"实际直接使用两个流\",{\"1\":{\"306\":1}}],[\"实际就是在暗示线程调度器当前线程请求让出自己的cpu\",{\"1\":{\"131\":1}}],[\"实际是操作自己本地内存里面的变量\",{\"1\":{\"113\":1}}],[\"实际的线程工作模型如下图所示\",{\"1\":{\"102\":1}}],[\"实例⽅法\",{\"1\":{\"93\":1}}],[\"实例方法呢\",{\"0\":{\"93\":1}}],[\"实例变量即对象变量\",{\"1\":{\"92\":1}}],[\"实例变量存储在堆内存中\",{\"1\":{\"92\":1}}],[\"实例变量是每个对象独有的\",{\"1\":{\"92\":1}}],[\"实例变量\",{\"1\":{\"92\":1,\"93\":1}}],[\"实例化对应的服务提供者对象\",{\"1\":{\"44\":1}}],[\"实现的\",{\"1\":{\"341\":1}}],[\"实现的原理是int\",{\"1\":{\"64\":1}}],[\"实现arraylist线程安全有哪几种方法\",{\"0\":{\"308\":1}}],[\"实现i++原子操作\",{\"1\":{\"296\":1}}],[\"实现了多线程环境下的线程安全\",{\"1\":{\"187\":1}}],[\"实现了服务接口的具体类\",{\"1\":{\"44\":1}}],[\"实现重复利用\",{\"1\":{\"143\":1}}],[\"实现一个线程修改一个对象的值\",{\"1\":{\"138\":1}}],[\"实现callable接口\",{\"1\":{\"128\":2}}],[\"实现runnable接口\",{\"1\":{\"128\":1}}],[\"实现\",{\"1\":{\"91\":1,\"128\":1,\"334\":2}}],[\"实现类和实例不能调用静态方法\",{\"1\":{\"91\":1}}],[\"实现接⼝并覆盖接⼝中同⼀⽅法\",{\"1\":{\"87\":1}}],[\"实现数据的持久化和\",{\"1\":{\"68\":1}}],[\"实现serializable接口的类可以将对象转换为字节流进行传输和存储\",{\"1\":{\"68\":1}}],[\"实现服务接口\",{\"1\":{\"44\":1}}],[\"实现原理\",{\"1\":{\"40\":1}}],[\"接到任务\",{\"1\":{\"245\":1}}],[\"接收到生产者的数据\",{\"1\":{\"148\":1}}],[\"接收生产者的数据并返回处理后的数据\",{\"1\":{\"148\":1}}],[\"接着参与\",{\"1\":{\"131\":1}}],[\"接着\",{\"1\":{\"44\":1}}],[\"接口自身可以通过extends关键字扩展多个接口\",{\"1\":{\"91\":1}}],[\"接口中只能包含静态\",{\"1\":{\"91\":1}}],[\"接口中的方法默认修饰符是public\",{\"1\":{\"91\":1}}],[\"接口中的方法默认是公开的\",{\"1\":{\"91\":1}}],[\"接口中的方法可以有默认实现\",{\"1\":{\"91\":1}}],[\"接口也可以定义静态方法\",{\"1\":{\"91\":1}}],[\"接口或方法的参数和返回值的类型\",{\"1\":{\"76\":1}}],[\"接口\",{\"1\":{\"50\":1,\"89\":2,\"128\":1,\"302\":2}}],[\"接口可以包含默认方法和静态方法\",{\"1\":{\"32\":1}}],[\"接口的默认方法和静态方法\",{\"1\":{\"32\":1}}],[\"首先计算hash\",{\"1\":{\"336\":1}}],[\"首先进行哈希值的扰动\",{\"1\":{\"318\":1}}],[\"首先就会调用\",{\"1\":{\"288\":1}}],[\"首先判断当前要计算的斐波那契数列的位置\",{\"1\":{\"267\":1}}],[\"首先需要理解两个点\",{\"1\":{\"267\":1}}],[\"首先要考虑的是你的任务的性质\",{\"1\":{\"240\":1}}],[\"首先\",{\"1\":{\"44\":1,\"177\":1}}],[\"通知机制\",{\"1\":{\"138\":2,\"282\":1}}],[\"通知或中断\",{\"1\":{\"132\":1}}],[\"通常任务会使用双端队列\",{\"1\":{\"267\":1}}],[\"通常情况下\",{\"1\":{\"240\":1}}],[\"通常为秒\",{\"1\":{\"235\":1}}],[\"通常是因为调用了wait\",{\"1\":{\"133\":1}}],[\"通常是因为等待获取锁\",{\"1\":{\"133\":1}}],[\"通常位于meta\",{\"1\":{\"44\":1}}],[\"通过这个链表\",{\"1\":{\"338\":1}}],[\"通过这些方法\",{\"1\":{\"254\":1}}],[\"通过atomicreference来保证原子性\",{\"1\":{\"295\":1}}],[\"通过native方法实现以原子方式将引用值和印戳标志的值更新为给定的更新值\",{\"1\":{\"292\":1}}],[\"通过lock\",{\"1\":{\"282\":1}}],[\"通过cas操作竞争锁\",{\"1\":{\"280\":1}}],[\"通过异步调用\",{\"1\":{\"266\":1}}],[\"通过持久化任务队列\",{\"1\":{\"265\":1}}],[\"通过以上评估方案\",{\"1\":{\"263\":1}}],[\"通过测试可以验证线程池的配置是否合理\",{\"1\":{\"263\":1}}],[\"通过对系统负载\",{\"1\":{\"263\":1}}],[\"通过调用\",{\"1\":{\"262\":1}}],[\"通过调用schedule\",{\"1\":{\"242\":1}}],[\"通过调用shutdown\",{\"1\":{\"239\":1}}],[\"通过覆盖\",{\"1\":{\"250\":1}}],[\"通过使用锁分段技术和cas操作来实现高效的并发性能\",{\"1\":{\"333\":1}}],[\"通过使用scheduledthreadpoolexecutor\",{\"1\":{\"226\":1}}],[\"通过使用数据库连接池\",{\"1\":{\"214\":1}}],[\"通过使用线程池\",{\"1\":{\"210\":1,\"218\":1,\"222\":1}}],[\"通过使用泛型\",{\"1\":{\"76\":1}}],[\"通过自定义线程池\",{\"1\":{\"196\":1}}],[\"通过设置自定义线程池\",{\"1\":{\"185\":1}}],[\"通过设置线程的中断标志并不能直接终止该线程的执行\",{\"1\":{\"131\":1}}],[\"通过在代理类中封装线程池\",{\"1\":{\"262\":1}}],[\"通过在构造函数中传入\",{\"1\":{\"146\":1}}],[\"通过在classpath中提供配置文件\",{\"1\":{\"44\":1}}],[\"通过\",{\"1\":{\"120\":1,\"149\":1}}],[\"通过禁止特定类型的编译器重排序和处理器重排序\",{\"1\":{\"106\":1}}],[\"通过序列化机制\",{\"1\":{\"100\":1}}],[\"通过继承可以很方便地进行代码复用\",{\"1\":{\"87\":1}}],[\"通过实现serializable接口和externalizable接口来实现对象的序列化和反序列化\",{\"1\":{\"69\":1}}],[\"通过反射机制\",{\"1\":{\"100\":1}}],[\"通过反射\",{\"1\":{\"48\":1}}],[\"通过反射你可以获取任意一个类的所有属性和方法\",{\"1\":{\"46\":1}}],[\"通过入参的\",{\"1\":{\"36\":1}}],[\"通过optional类\",{\"1\":{\"32\":1}}],[\"通过stream\",{\"1\":{\"32\":1}}],[\"通过选择器\",{\"1\":{\"30\":1}}],[\"描述了服务提供者需要实现的接口或抽象类\",{\"1\":{\"44\":1}}],[\"向应用程序注入实现了特定接口的服务提供者\",{\"1\":{\"44\":1}}],[\"机制来保证修改的原子性\",{\"1\":{\"283\":1}}],[\"机制是java标准库提供的一种服务发现机制\",{\"1\":{\"44\":1}}],[\"机器指令的执行顺序\",{\"1\":{\"106\":1}}],[\"机器码\",{\"1\":{\"41\":1}}],[\"说明需要扩容\",{\"1\":{\"336\":1}}],[\"说明内存位置\",{\"1\":{\"289\":2}}],[\"说明\",{\"1\":{\"132\":1}}],[\"说一下你对java内存模型\",{\"0\":{\"102\":1}}],[\"说一下你对注解的理解\",{\"0\":{\"81\":1}}],[\"说说有哪些常见集合\",{\"0\":{\"343\":1}}],[\"说说有哪些常见的序列化方式\",{\"0\":{\"69\":1}}],[\"说说synchronized和reentrantlock的区别\",{\"0\":{\"282\":1}}],[\"说说阻塞队列是怎么实现的\",{\"0\":{\"187\":1}}],[\"说说你对completablefuture的理解\",{\"0\":{\"151\":1}}],[\"说说你对原子性\",{\"0\":{\"103\":1}}],[\"说说线程有几种创建方式\",{\"0\":{\"128\":1}}],[\"说说什么是进程和线程\",{\"0\":{\"127\":1}}],[\"说说什么是跨平台性\",{\"0\":{\"40\":1}}],[\"说说自增自减运算\",{\"0\":{\"57\":1}}],[\"说下什么是java的spi机制\",{\"0\":{\"44\":1}}],[\"文件操作等\",{\"1\":{\"240\":1}}],[\"文件操作和计算等\",{\"1\":{\"209\":1}}],[\"文件上传等\",{\"1\":{\"221\":1}}],[\"文件名为服务接口的全限定名\",{\"1\":{\"44\":1}}],[\"文件\",{\"1\":{\"42\":1,\"81\":3}}],[\"文档所在分支\",{\"1\":{\"23\":1}}],[\"由线程\",{\"1\":{\"194\":1,\"196\":1}}],[\"由创建出来的新线程去执行thread的run方法\",{\"1\":{\"129\":1}}],[\"由于扩容过程中元素迁移的不可见性\",{\"1\":{\"332\":1}}],[\"由于哈希函数的计算结果可能会出现冲突\",{\"1\":{\"312\":1}}],[\"由于copyonwritearraylist在每次写操作时都会创建副本\",{\"1\":{\"309\":1}}],[\"由于copyonwritearraylist在写操作时会创建副本\",{\"1\":{\"309\":1}}],[\"由于读操作不需要加锁\",{\"1\":{\"308\":1}}],[\"由于迭代时是对原集合的拷贝进行遍历\",{\"1\":{\"307\":1}}],[\"由于撤销需要知道当前持有该偏向锁的线程栈状态\",{\"1\":{\"280\":1}}],[\"由于处理器使用缓存和读\",{\"1\":{\"106\":1}}],[\"由于指令重排序和编译器优化的存在\",{\"1\":{\"103\":1}}],[\"由于每个线程都有自己的本地内存\",{\"1\":{\"103\":1}}],[\"由于同步的开销\",{\"1\":{\"60\":1}}],[\"由于不可变性的特性\",{\"1\":{\"60\":1}}],[\"由于字符串是不可变的\",{\"1\":{\"59\":1}}],[\"由\",{\"1\":{\"42\":1}}],[\"后继节点和插入节点的指向就行了\",{\"1\":{\"302\":1}}],[\"后被其他进入的线程获得\",{\"1\":{\"272\":1}}],[\"后\",{\"1\":{\"95\":1,\"288\":1}}],[\"后缀\",{\"1\":{\"57\":1}}],[\"后解释两个步骤\",{\"1\":{\"42\":1}}],[\"后者是字符输出流\",{\"1\":{\"28\":1}}],[\"后者是字符输入流\",{\"1\":{\"28\":1}}],[\"因争夺资源而造成的互相等待的现象\",{\"1\":{\"299\":1}}],[\"因此可以通过键值来遍历\",{\"1\":{\"339\":1}}],[\"因此可以在多线程环境下安全地进行读操作\",{\"1\":{\"309\":1}}],[\"因此适用于写操作较少\",{\"1\":{\"309\":1}}],[\"因此在遍历集合时使用的迭代器可能不反映最新的修改\",{\"1\":{\"309\":1}}],[\"因此在读多写少的场景中\",{\"1\":{\"308\":1}}],[\"因此在并发环境下可以安全地进行读写操作\",{\"1\":{\"308\":1}}],[\"因此要等到safepoint时执行\",{\"1\":{\"280\":1}}],[\"因此需要一些机制来处理这种情况\",{\"1\":{\"265\":1}}],[\"因此不推荐使用\",{\"1\":{\"95\":1}}],[\"因此\",{\"1\":{\"64\":1,\"98\":1,\"135\":1,\"187\":1,\"307\":1}}],[\"因此java语言可以实现跨平\",{\"1\":{\"39\":1}}],[\"因为除了clone\",{\"1\":{\"341\":1}}],[\"因为任意数\",{\"1\":{\"322\":1}}],[\"因为哈希值\",{\"1\":{\"321\":1}}],[\"因为每次写操作都会创建一个新的副本\",{\"1\":{\"309\":1}}],[\"因为每个线程都会占用较多的cpu资源\",{\"1\":{\"240\":1}}],[\"因为用锁为的就是互斥\",{\"1\":{\"299\":1}}],[\"因为线程有几率不阻塞直接获得锁\",{\"1\":{\"286\":1}}],[\"因为线程在执行任务时会阻塞等待i\",{\"1\":{\"240\":1}}],[\"因为as\",{\"1\":{\"275\":1}}],[\"因为静态成员不属于任何⼀个实例对象\",{\"1\":{\"269\":1}}],[\"因为斐波那契数列的第一个数和第二个数都是1\",{\"1\":{\"267\":1}}],[\"因为没有核心线程\",{\"1\":{\"245\":1}}],[\"因为它用于提交不需要返回结果的任务\",{\"1\":{\"238\":1}}],[\"因为它的吞吐量比较大\",{\"1\":{\"288\":1}}],[\"因为它的不可变性保证了多个线程可以安全地共享string对象\",{\"1\":{\"60\":1}}],[\"因为它的哈希值是固定的\",{\"1\":{\"59\":1}}],[\"因为调用线程需要承担执行任务的负责\",{\"1\":{\"236\":1}}],[\"因为操作系统需要保存和恢复线程的上下文信息\",{\"1\":{\"135\":1}}],[\"因为切换的时间特别短\",{\"1\":{\"126\":1}}],[\"因为这种重排序会改变执行结果\",{\"1\":{\"108\":1}}],[\"因为前面调用过一次\",{\"1\":{\"95\":1}}],[\"因为根据实践发现大部分的数据操作都集中在值比较小的范围\",{\"1\":{\"64\":1}}],[\"因为\",{\"1\":{\"42\":1,\"337\":1}}],[\"对hashmap进行加锁\",{\"1\":{\"333\":1}}],[\"对该对象的操作会自动进行同步\",{\"1\":{\"333\":1}}],[\"对该list的所有操作都会进行同步处理\",{\"1\":{\"308\":1}}],[\"对i++操作加锁\",{\"1\":{\"296\":1}}],[\"对i++操作加锁lock\",{\"1\":{\"296\":1}}],[\"对一些代码上要求同步\",{\"1\":{\"278\":1}}],[\"对一个volatile域的写\",{\"1\":{\"107\":1}}],[\"对一个锁的解锁\",{\"1\":{\"107\":1}}],[\"对一个包含一个或多个元素的集合做各种操作\",{\"1\":{\"36\":1}}],[\"对给定对象\",{\"1\":{\"269\":1}}],[\"对耗时的操作进行算法上的优化\",{\"1\":{\"266\":1}}],[\"对耗时的\",{\"1\":{\"266\":2}}],[\"对于\",{\"1\":{\"299\":3}}],[\"对于频繁调用且结果稳定的耗时\",{\"1\":{\"266\":1}}],[\"对于频繁的字符串拼接操作\",{\"1\":{\"60\":1}}],[\"对于需要处理异步任务的情况\",{\"1\":{\"253\":1}}],[\"对结果进行处理并返回新的结果\",{\"1\":{\"156\":1}}],[\"对应的jvm指令分为三步\",{\"1\":{\"106\":1}}],[\"对应的操作系统执行二进制机器码\",{\"1\":{\"41\":1}}],[\"对形参引用的修改不会影响实参引用的指向\",{\"1\":{\"98\":1}}],[\"对形参的修改不会影响实参\",{\"1\":{\"98\":1}}],[\"对同一包内的类和所有子类可见\",{\"1\":{\"89\":1}}],[\"对所有类可见\",{\"1\":{\"89\":1}}],[\"对象的线程进入\",{\"1\":{\"272\":1}}],[\"对象的操作\",{\"1\":{\"59\":1}}],[\"对象列表\",{\"1\":{\"272\":1}}],[\"对象相等性原则\",{\"1\":{\"97\":1}}],[\"对象名\",{\"1\":{\"93\":2}}],[\"对象转字符串\",{\"1\":{\"66\":1}}],[\"对象拷贝\",{\"1\":{\"66\":1}}],[\"对象比较\",{\"1\":{\"66\":1}}],[\"对象创建过程\",{\"1\":{\"61\":1}}],[\"对象\",{\"1\":{\"46\":1,\"59\":1,\"61\":1,\"154\":1,\"267\":1,\"272\":1}}],[\"执行扩容\",{\"1\":{\"336\":1}}],[\"执行同步代码\",{\"1\":{\"280\":1}}],[\"执行完一个\",{\"1\":{\"246\":1}}],[\"执行完任务的线程\",{\"1\":{\"245\":1}}],[\"执行完任务后\",{\"1\":{\"241\":1}}],[\"执行完毕后\",{\"1\":{\"74\":1}}],[\"执行定时任务\",{\"1\":{\"227\":1}}],[\"执行异步任务\",{\"1\":{\"185\":1}}],[\"执行结果\",{\"1\":{\"74\":3}}],[\"执行顺序\",{\"1\":{\"74\":1}}],[\"执行\",{\"1\":{\"41\":1,\"95\":1,\"194\":1,\"196\":1}}],[\"从冲突的位置x开始\",{\"1\":{\"325\":1}}],[\"从冲突的位置开始\",{\"1\":{\"325\":1}}],[\"从任一节点到其每个叶子节点的路径上\",{\"1\":{\"314\":1}}],[\"从一些死锁进程中剥夺资源\",{\"1\":{\"300\":1}}],[\"从一个线程转而执行另一个线程的过程\",{\"1\":{\"135\":1}}],[\"从队列取任务\",{\"1\":{\"246\":1}}],[\"从父线程中取出inheritablethreadlocals\",{\"1\":{\"123\":1}}],[\"从jdk6开始hotspot虚拟机开发团队对java中的锁进行优化\",{\"1\":{\"278\":1}}],[\"从jdk6开始\",{\"1\":{\"278\":1}}],[\"从jdk\",{\"1\":{\"91\":1}}],[\"从而保证线程安全\",{\"1\":{\"333\":1}}],[\"从而导致元素的丢失\",{\"1\":{\"332\":1}}],[\"从而形成死循环\",{\"1\":{\"332\":1}}],[\"从而形成循环等待\",{\"1\":{\"299\":1}}],[\"从而降低哈希碰撞的概率\",{\"1\":{\"321\":1}}],[\"从而降低系统的性能\",{\"1\":{\"240\":1}}],[\"从而降低系统的性能和稳定性\",{\"1\":{\"240\":1}}],[\"从而提高了程序的并发性能\",{\"1\":{\"297\":1}}],[\"从而提高了系统效率\",{\"1\":{\"189\":1}}],[\"从而使用共享变量时需要从主内存中重新读取最新的值\",{\"1\":{\"274\":1}}],[\"从而避免线程池中的线程因未处理的异常而终止\",{\"1\":{\"249\":1}}],[\"从而让调用者能够捕获和处理异常\",{\"1\":{\"238\":1}}],[\"从而减少了线程创建和销毁的开销\",{\"1\":{\"210\":1}}],[\"从而影响jit的优化效果\",{\"1\":{\"206\":1}}],[\"从而增加cpu的负担\",{\"1\":{\"202\":1}}],[\"从而增加内存管理的开销\",{\"1\":{\"199\":1}}],[\"从而增加代码的可读性和安全性\",{\"1\":{\"76\":1}}],[\"从而为多线程编程提供了便利和高效的同步与通信机制\",{\"1\":{\"187\":1}}],[\"从而确保操作的原子性和线程安全性\",{\"1\":{\"187\":1}}],[\"从而可能导致内存泄漏\",{\"1\":{\"118\":1}}],[\"从而实现线程之间的同步与通信\",{\"1\":{\"187\":1}}],[\"从而实现了线程隔离\",{\"1\":{\"115\":1}}],[\"从而实现java程序的跨平台性\",{\"1\":{\"41\":1}}],[\"从而起到线程隔离的作用\",{\"1\":{\"113\":1}}],[\"从\",{\"1\":{\"54\":2}}],[\"从master新建分支gh\",{\"0\":{\"19\":1}}],[\"跨平台的数据交换\",{\"1\":{\"68\":1}}],[\"跨平台\",{\"1\":{\"40\":1}}],[\"如使用synchronized关键字或lock\",{\"1\":{\"308\":1}}],[\"如getandincrement\",{\"1\":{\"297\":1}}],[\"如atomicboolean\",{\"1\":{\"297\":1}}],[\"如arrayblockingqueue\",{\"1\":{\"235\":1}}],[\"如reentrantlock\",{\"1\":{\"296\":1,\"333\":1}}],[\"如何做到的\",{\"1\":{\"299\":1}}],[\"如何保证多线程下i++\",{\"0\":{\"296\":1}}],[\"如何解决\",{\"0\":{\"290\":1}}],[\"如等待可中断\",{\"1\":{\"282\":1}}],[\"如增加了适应性自旋\",{\"1\":{\"278\":1}}],[\"如哈希码\",{\"1\":{\"277\":1}}],[\"如线程池过载\",{\"1\":{\"263\":1}}],[\"如监控\",{\"1\":{\"262\":1}}],[\"如网络请求\",{\"1\":{\"240\":1}}],[\"如linkedblockingqueue\",{\"1\":{\"235\":1}}],[\"如无空闲核心线程则将任务加入队列\",{\"1\":{\"234\":1}}],[\"如创建新线程\",{\"1\":{\"190\":1}}],[\"如数组或者链表\",{\"1\":{\"187\":1}}],[\"如数据库连接池\",{\"1\":{\"144\":1}}],[\"如提高性能或控制资源使用\",{\"1\":{\"174\":1}}],[\"如双缓冲区交换\",{\"1\":{\"147\":1}}],[\"如生产者和消费者模式中的数据交换\",{\"1\":{\"147\":1}}],[\"如控制多个线程对某个资源的访问\",{\"1\":{\"144\":1}}],[\"如限制同时处理的请求数量\",{\"1\":{\"144\":1}}],[\"如再次await\",{\"1\":{\"142\":1}}],[\"如i\",{\"1\":{\"136\":1}}],[\"如int\",{\"1\":{\"98\":1}}],[\"如上图所示\",{\"1\":{\"120\":1}}],[\"如synchronized关键字\",{\"1\":{\"105\":3}}],[\"如锁\",{\"1\":{\"103\":1}}],[\"如hessian\",{\"1\":{\"69\":1}}],[\"如jaxb\",{\"1\":{\"69\":1}}],[\"如jackson\",{\"1\":{\"69\":1}}],[\"如果需要有序的存储和遍历元素\",{\"1\":{\"337\":1}}],[\"如果需要继续拆分任务\",{\"1\":{\"267\":1}}],[\"如果都不满足\",{\"1\":{\"336\":1}}],[\"如果hash==moved\",{\"1\":{\"336\":1}}],[\"如果正在初始化或者扩容\",{\"1\":{\"336\":1}}],[\"如果数组是空的话\",{\"1\":{\"336\":1}}],[\"如果获取锁失败则尝试自旋\",{\"1\":{\"335\":1}}],[\"如果计算出来的索引位置相同\",{\"1\":{\"332\":1}}],[\"如果初始化hashmap\",{\"0\":{\"323\":1}}],[\"如果链表中插入节点的时候\",{\"1\":{\"318\":1}}],[\"如果对应下标正好没有存放数据\",{\"1\":{\"318\":1}}],[\"如果对多个变量操作时\",{\"1\":{\"295\":1}}],[\"如果写操作频繁或对实时性要求较高\",{\"1\":{\"309\":1}}],[\"如果集合发生变化时修改modcount值刚好又设置为了expectedmodcount值\",{\"1\":{\"307\":1}}],[\"如果超过一定时间没有获取到资源\",{\"1\":{\"299\":1}}],[\"如果申请不到\",{\"1\":{\"299\":1}}],[\"如果此时还有其它线程请求获取获取该资源\",{\"1\":{\"299\":1}}],[\"如果一直循环执行\",{\"1\":{\"293\":1}}],[\"如果一个线程a执行了thread\",{\"1\":{\"131\":1,\"138\":1}}],[\"如果一个操作happens\",{\"1\":{\"107\":1}}],[\"如果全部相等\",{\"1\":{\"292\":1}}],[\"如果相等\",{\"1\":{\"289\":1}}],[\"如果发现锁这个时候被释放了\",{\"1\":{\"288\":1}}],[\"如果这个时候恰巧锁没有被占用\",{\"1\":{\"288\":1}}],[\"如果该锁己经被其他线程持有\",{\"1\":{\"287\":1}}],[\"如果锁当前没有被其它线程占用\",{\"1\":{\"287\":1}}],[\"如果共享资源被占用\",{\"1\":{\"283\":1}}],[\"如果成功\",{\"1\":{\"281\":1}}],[\"如果竞争成功\",{\"1\":{\"280\":1}}],[\"如果存在锁竞争\",{\"1\":{\"278\":1}}],[\"如果n的值小于等于1\",{\"1\":{\"267\":1}}],[\"如果\",{\"1\":{\"267\":1}}],[\"如果是则进行扩容操作\",{\"1\":{\"318\":1}}],[\"如果是则执行\",{\"1\":{\"281\":1}}],[\"如果是可偏向状态\",{\"1\":{\"280\":1}}],[\"如果是\",{\"1\":{\"267\":1,\"280\":1}}],[\"如果调用超过预设的时间仍未返回结果\",{\"1\":{\"266\":1}}],[\"如果测试发现线程池存在性能瓶颈或者稳定性问题\",{\"1\":{\"263\":1}}],[\"如果在这期间\",{\"1\":{\"245\":1}}],[\"如果在后续的版本中对该类进行了修改\",{\"1\":{\"68\":1}}],[\"如果你的任务执行时间较长\",{\"1\":{\"240\":1}}],[\"如果你的任务是i\",{\"1\":{\"240\":1}}],[\"如果你的任务是cpu密集型的\",{\"1\":{\"240\":1}}],[\"如果任务被拒绝执行\",{\"1\":{\"252\":1}}],[\"如果任务队列容量较大\",{\"1\":{\"240\":1}}],[\"如果任务队列容量较小\",{\"1\":{\"240\":1}}],[\"如果任务队列已满且线程数未达到最大线程数\",{\"1\":{\"231\":1}}],[\"如果任务抛出了异常\",{\"1\":{\"238\":1}}],[\"如果任务抛出了未捕获的异常\",{\"1\":{\"238\":1}}],[\"如果任务执行完成且当前线程数超过核心线程数\",{\"1\":{\"232\":1}}],[\"如果线程a遍历过程中\",{\"1\":{\"307\":1}}],[\"如果线程a执行操作threadb\",{\"1\":{\"107\":2}}],[\"如果线程调用了\",{\"1\":{\"272\":1}}],[\"如果线程执行完任务\",{\"1\":{\"244\":1}}],[\"如果线程正在执行任务\",{\"1\":{\"242\":1}}],[\"如果线程池中的线程空闲\",{\"1\":{\"242\":1}}],[\"如果线程池中的线程都在执行任务\",{\"1\":{\"242\":2}}],[\"如果线程池中有空闲的线程\",{\"1\":{\"242\":2}}],[\"如果线程池无法接受新任务\",{\"1\":{\"236\":1}}],[\"如果线程数等于核心线程\",{\"1\":{\"244\":1}}],[\"如果线程数少于核心线程\",{\"1\":{\"244\":1}}],[\"如果线程数过多\",{\"1\":{\"240\":1}}],[\"如果线程数已达到最大线程数且任务队列已满\",{\"1\":{\"231\":1}}],[\"如果线程空闲时间超过该值\",{\"1\":{\"235\":1}}],[\"如果线程在等待交换数据时被中断\",{\"1\":{\"150\":1}}],[\"如果线程在等待许可时被中断\",{\"1\":{\"146\":1}}],[\"如果某\",{\"1\":{\"143\":1}}],[\"如果某个线程遇到了中\",{\"1\":{\"143\":1}}],[\"如果某个线程在等待时被中断\",{\"1\":{\"142\":1}}],[\"如果当前数组位置是空则直接通过cas自旋写入数据\",{\"1\":{\"336\":1}}],[\"如果当前线程之前己经获取过该锁\",{\"1\":{\"287\":1}}],[\"如果当前线程是最后一个到达的线程\",{\"1\":{\"142\":1}}],[\"如果当前字符串内容存在于字符串常量池\",{\"1\":{\"63\":1}}],[\"如果使用带超时参数的\",{\"1\":{\"142\":1}}],[\"如果等待时间到期而线程没有获取到锁\",{\"1\":{\"131\":1}}],[\"如果直接调用thread的run\",{\"1\":{\"129\":1}}],[\"如果父线程的\",{\"1\":{\"123\":1}}],[\"如果执行完启发式清理工作后\",{\"1\":{\"121\":1}}],[\"如果我们插入一个value=27的数据\",{\"1\":{\"120\":1}}],[\"如果将threadlocal实例作为强引用存储在threadlocalmap中\",{\"1\":{\"118\":1}}],[\"如果threadlocal\",{\"1\":{\"116\":1}}],[\"如果try块中的代码导致了线程死锁\",{\"1\":{\"73\":1}}],[\"如果try块中的代码导致了无限循环或无限递归\",{\"1\":{\"73\":1}}],[\"如果操作之间不存在数据依赖关系\",{\"1\":{\"108\":1}}],[\"如果a\",{\"1\":{\"107\":1}}],[\"如果重排序之后的执行结果\",{\"1\":{\"107\":1}}],[\"如果不相等\",{\"1\":{\"289\":1}}],[\"如果不是\",{\"1\":{\"281\":1}}],[\"如果不存在数据依赖性\",{\"1\":{\"106\":1}}],[\"如果不一致\",{\"1\":{\"68\":1,\"120\":1}}],[\"如果没有\",{\"1\":{\"246\":1}}],[\"如果没有空闲线程\",{\"1\":{\"245\":1}}],[\"如果没有空闲线程可用\",{\"1\":{\"237\":1}}],[\"如果没有空闲的核心线程且任务队列未满\",{\"1\":{\"231\":1}}],[\"如果没有可用许可\",{\"1\":{\"145\":1}}],[\"如果没有重写\",{\"1\":{\"97\":1}}],[\"如果没有则会在常量池中创建\",{\"1\":{\"61\":1}}],[\"如果两个对象根据\",{\"1\":{\"97\":1}}],[\"如果同时实现两个接口\",{\"1\":{\"91\":1}}],[\"如果有则不去抢锁\",{\"1\":{\"288\":1}}],[\"如果有则直接使用\",{\"1\":{\"61\":1}}],[\"如果有\",{\"1\":{\"245\":1,\"246\":1}}],[\"如果有空闲的核心线程\",{\"1\":{\"231\":1}}],[\"如果有一个线程没有配对线程来交换数据\",{\"1\":{\"150\":1}}],[\"如果有些变量不想序列化\",{\"1\":{\"68\":1}}],[\"如果新版本的类和旧版本的类具有相同的serialversionuid\",{\"1\":{\"68\":1}}],[\"如果后续对该类进行了修改\",{\"1\":{\"68\":1}}],[\"如果整型字面量的值在\",{\"1\":{\"64\":1}}],[\"如果拼接多次\",{\"1\":{\"62\":1}}],[\"如果字符串常量池已经有\",{\"1\":{\"61\":1}}],[\"如拼接\",{\"1\":{\"59\":1}}],[\"如\",{\"1\":{\"39\":1}}],[\"切\",{\"1\":{\"39\":1}}],[\"命令和其他的⼀些基础构件\",{\"1\":{\"39\":1}}],[\"虚拟机即时编译器在运行时\",{\"1\":{\"278\":1}}],[\"虚拟机执行java字节码\",{\"1\":{\"41\":1}}],[\"虚拟机\",{\"1\":{\"39\":1}}],[\"台\",{\"1\":{\"39\":1}}],[\"针对不同\",{\"1\":{\"39\":1}}],[\"有其它线程写入数据怎么办\",{\"0\":{\"310\":1}}],[\"有什么办法能解决hashmap线程不安全的问题呢\",{\"0\":{\"333\":1}}],[\"有什么问题\",{\"0\":{\"290\":1}}],[\"有什么区别\",{\"0\":{\"39\":1,\"53\":1,\"91\":1}}],[\"有\",{\"1\":{\"280\":1}}],[\"有一块结构\",{\"1\":{\"277\":1}}],[\"有一个私有的成员变量\",{\"1\":{\"267\":1}}],[\"有的线程干活慢\",{\"1\":{\"267\":1}}],[\"有的线程干活块\",{\"1\":{\"267\":1}}],[\"有个调用特别耗时\",{\"0\":{\"266\":1}}],[\"有哪几种常见的线程池\",{\"0\":{\"242\":1}}],[\"有界队列可以有效地控制线程池中任务的数量\",{\"1\":{\"237\":1}}],[\"有界队列有限制存储的任务数量\",{\"1\":{\"237\":1}}],[\"有界队列\",{\"1\":{\"237\":1}}],[\"有以下几个原因\",{\"1\":{\"197\":1}}],[\"有多种重载形式\",{\"1\":{\"146\":1}}],[\"有两个主要的子类\",{\"1\":{\"267\":1}}],[\"有两个常见的应用场景\",{\"1\":{\"140\":1}}],[\"有两个规则\",{\"1\":{\"107\":1}}],[\"有序性都应该怎么保证呢\",{\"0\":{\"105\":1}}],[\"有序性\",{\"0\":{\"273\":1},\"1\":{\"103\":2,\"105\":1}}],[\"有序性的理解\",{\"0\":{\"103\":1}}],[\"有序性和原子性\",{\"1\":{\"102\":1}}],[\"有些架构还有一个共享的二级缓存\",{\"1\":{\"102\":1}}],[\"有可能调用\",{\"1\":{\"95\":1}}],[\"有了标记之后\",{\"1\":{\"81\":1}}],[\"有读或写事件时\",{\"1\":{\"30\":1}}],[\"编写服务提供者配置文件\",{\"1\":{\"44\":1}}],[\"编写服务提供者\",{\"1\":{\"44\":2}}],[\"编写的程序需要先经过编译步骤\",{\"1\":{\"42\":1}}],[\"编译器在生成字节码时\",{\"1\":{\"111\":1}}],[\"编译器在不改变单线程程序语义的前提下\",{\"1\":{\"106\":1}}],[\"编译器\",{\"1\":{\"108\":1}}],[\"编译器和处理器不会对存在数据依赖关系的操作做重排序\",{\"1\":{\"108\":1}}],[\"编译器和处理器为了提高并行度\",{\"1\":{\"108\":1}}],[\"编译器和处理器常常会对指令做重排序\",{\"1\":{\"106\":1}}],[\"编译器优化的重排序\",{\"1\":{\"106\":1}}],[\"编译器会强制检查并要求处理的异常\",{\"1\":{\"71\":1}}],[\"编译\",{\"1\":{\"41\":1}}],[\"编译与解释并存\",{\"0\":{\"42\":1},\"1\":{\"38\":1}}],[\"编辑此页\",{\"0\":{\"23\":1}}],[\"多数情况下\",{\"1\":{\"302\":1}}],[\"多余的空闲线程在终止前等待新任务的最长时间\",{\"1\":{\"195\":1}}],[\"多个线程可以共享同一实\",{\"1\":{\"130\":1}}],[\"多个线程共用进程的堆和方法区资源\",{\"1\":{\"127\":1}}],[\"多个线程操作这个变量的时候\",{\"1\":{\"113\":1}}],[\"多个⼦类对同⼀⽅法的重写\",{\"1\":{\"87\":1}}],[\"多线程的put可能导致元素的丢失\",{\"1\":{\"332\":1}}],[\"多线程下扩容死循环\",{\"1\":{\"332\":1}}],[\"多线程下会有什么问题\",{\"0\":{\"332\":1}}],[\"多线程限量操作\",{\"1\":{\"144\":1}}],[\"多线程调度\",{\"1\":{\"66\":1}}],[\"多线程环境下操作大量的数据\",{\"1\":{\"60\":1}}],[\"多操作系统运行\",{\"1\":{\"40\":1}}],[\"多态\",{\"1\":{\"38\":1,\"87\":1}}],[\"多路复用器轮询到连接有io请求就进行处理\",{\"1\":{\"30\":1}}],[\"缩小\",{\"1\":{\"36\":1}}],[\"它实现线程安全的关键点在于put流程\",{\"1\":{\"336\":1}}],[\"它实际上不存储任何元素\",{\"1\":{\"237\":1}}],[\"它会怎么处理\",{\"0\":{\"323\":1}}],[\"它会在等待队列中等待\",{\"1\":{\"131\":1}}],[\"它通过哈希函数将键映射到桶\",{\"1\":{\"337\":1}}],[\"它通过在修改时创建副本来实现并发访问\",{\"1\":{\"308\":1}}],[\"它通过协调各个线程\",{\"1\":{\"144\":1}}],[\"它使用\",{\"1\":{\"304\":1}}],[\"它没有实现randmoaccess\",{\"1\":{\"302\":1}}],[\"它没有上下文切换的额外开销成本\",{\"1\":{\"110\":1}}],[\"它也实现了randmoaccess\",{\"1\":{\"302\":1}}],[\"它们在空间占用上都有一些额外的消耗\",{\"1\":{\"302\":1}}],[\"它们提供了一种更高效的线程安全机制\",{\"1\":{\"297\":1}}],[\"它们会访问同一个队列\",{\"1\":{\"267\":1}}],[\"它们是处理数据的底层工具\",{\"1\":{\"29\":1}}],[\"它去其它线程的队列里窃取一个任务来执行\",{\"1\":{\"267\":1}}],[\"它提供了更加灵活的异常处理方式\",{\"1\":{\"253\":1}}],[\"它提供了一种简洁而强大的方式来处理异步操作\",{\"1\":{\"152\":1}}],[\"它不存储任务\",{\"1\":{\"237\":1}}],[\"它不能⽤于创建新程序\",{\"1\":{\"39\":1}}],[\"它基于数组实现\",{\"1\":{\"237\":1}}],[\"它基于链表实现\",{\"1\":{\"237\":1}}],[\"它允许多个线程在队列为空或者队列已满时进行阻塞等待\",{\"1\":{\"187\":1}}],[\"它允许第三方组件在不修改源代码的情况下\",{\"1\":{\"44\":1}}],[\"它和countdownlatch类似\",{\"1\":{\"141\":1}}],[\"它要做的事情是\",{\"1\":{\"141\":1}}],[\"它主要用于线程之间的数据传输\",{\"1\":{\"138\":1}}],[\"它主要确保多个线程在同一个时刻\",{\"1\":{\"138\":1}}],[\"它保证了线程对变量访问的可见性和排他性\",{\"1\":{\"138\":1}}],[\"它能保证所有线程对变量访问的可见性\",{\"1\":{\"138\":1}}],[\"它能够创建和编译程序\",{\"1\":{\"39\":1}}],[\"它能够统计\",{\"1\":{\"36\":1}}],[\"它还提供了自定义初始化方法和支持传递不可序列化对象的功能\",{\"1\":{\"124\":1}}],[\"它就会新增\",{\"1\":{\"119\":1}}],[\"它这时候如果不被回收\",{\"1\":{\"116\":1}}],[\"它只是作为一个key来让线程往threadlocalmap里存取值\",{\"1\":{\"115\":1}}],[\"它确保在不同的编译器和不同的处理器平台之上\",{\"1\":{\"106\":1}}],[\"它属于类\",{\"1\":{\"93\":1}}],[\"它的名字叫\",{\"1\":{\"309\":1}}],[\"它的compareandset方法首先检查当前的对象引用值是否等于预期引用\",{\"1\":{\"292\":1}}],[\"它的原理是遍历线程池中的工作线程\",{\"1\":{\"239\":1}}],[\"它的主要应用场景包括\",{\"1\":{\"147\":1}}],[\"它的生命周期与程序的生命周期相同\",{\"1\":{\"92\":1}}],[\"它的方法没有使用synchronized关键字进行同步\",{\"1\":{\"60\":1}}],[\"它的值可以被修改\",{\"1\":{\"60\":1}}],[\"它的返回类型是\",{\"1\":{\"36\":1}}],[\"它可以被用作map的键\",{\"1\":{\"59\":1}}],[\"它存储了所有字符串字面量的唯一实例\",{\"1\":{\"59\":1}}],[\"它真正的功能实现就是利用反射\",{\"1\":{\"47\":1}}],[\"它在运行时查找并加载meta\",{\"1\":{\"44\":1}}],[\"它拥有\",{\"1\":{\"39\":1}}],[\"它是可重入的独占锁\",{\"1\":{\"284\":1}}],[\"它是可以在指定\",{\"1\":{\"132\":1}}],[\"它是java并发包的根基\",{\"1\":{\"283\":1}}],[\"它是斐波那契数\",{\"1\":{\"119\":1}}],[\"它是功能⻬全的\",{\"1\":{\"39\":1}}],[\"它是运⾏已编译\",{\"1\":{\"39\":1}}],[\"z\",{\"1\":{\"36\":2}}],[\"zh\",{\"1\":{\"17\":1}}],[\"即保留了低位hash值\",{\"1\":{\"322\":1}}],[\"即保证了代码的串行语义\",{\"1\":{\"103\":1}}],[\"即不同的键计算得到相同的桶索引\",{\"1\":{\"312\":1}}],[\"即迭代器创建时的集合状态\",{\"1\":{\"309\":1}}],[\"即\",{\"1\":{\"307\":1}}],[\"即该资源同时只由一个线程占用\",{\"1\":{\"299\":1}}],[\"即表示此对象处于轻量级锁状态\",{\"1\":{\"281\":1}}],[\"即将任务提交到线程池后立即返回\",{\"1\":{\"266\":1}}],[\"即要么任务执行成功\",{\"1\":{\"265\":1}}],[\"即无限大\",{\"1\":{\"245\":1}}],[\"即适用执行长期的任务\",{\"1\":{\"244\":1}}],[\"即keepalivetime为0\",{\"1\":{\"244\":1}}],[\"即在指定延迟时间之后才能被消费\",{\"1\":{\"237\":1}}],[\"即使线程池中的线程都在忙碌\",{\"1\":{\"237\":1}}],[\"即使线程处于空闲状态\",{\"1\":{\"235\":1}}],[\"即使这两个对象指向相同的数据\",{\"1\":{\"97\":1}}],[\"即线程变量\",{\"1\":{\"138\":1}}],[\"即防止读操作重排序到写操作之后\",{\"1\":{\"111\":1}}],[\"即防止写操作重排序到读操作之后\",{\"1\":{\"111\":1}}],[\"即确保第一个加载操作的结果对后续的加载操作可见\",{\"1\":{\"111\":1}}],[\"即确保第一个存储操作的结果对后续的存储操作可见\",{\"1\":{\"111\":1}}],[\"即能够正确读取到最新的值\",{\"1\":{\"103\":1}}],[\"即默认\",{\"1\":{\"89\":1}}],[\"即⼀个引⽤变量到底会指向哪个类的实例对象\",{\"1\":{\"87\":1}}],[\"即equals\",{\"1\":{\"63\":1}}],[\"即返回\",{\"1\":{\"36\":1}}],[\"即gh\",{\"1\":{\"22\":1}}],[\"验证\",{\"1\":{\"36\":2}}],[\"匹配到第一个\",{\"1\":{\"36\":1}}],[\"匹配\",{\"1\":{\"36\":1}}],[\"转换\",{\"1\":{\"36\":1}}],[\"而平衡二叉树要求更严格的平衡条件\",{\"1\":{\"316\":1}}],[\"而红黑树通过自平衡的特性\",{\"1\":{\"315\":1}}],[\"而新资源己被其它线程占有\",{\"1\":{\"299\":1}}],[\"而synchronized不用手动释放锁\",{\"1\":{\"282\":1}}],[\"而synchronized只能是非公平锁\",{\"1\":{\"282\":1}}],[\"而submit\",{\"1\":{\"230\":1,\"238\":1}}],[\"而窃取任务的线程永远从双端队列的尾部拿任务执行\",{\"1\":{\"267\":1}}],[\"而cyclicbarrier中的各个线程可以等待其他线程\",{\"1\":{\"143\":1}}],[\"而cyclicbarrier则可以多次设置屏障\",{\"1\":{\"143\":1}}],[\"而后两种面向字\",{\"1\":{\"138\":1}}],[\"而后者实现的是运行时的多态性\",{\"1\":{\"88\":1}}],[\"而传输的媒介为内存\",{\"1\":{\"138\":1}}],[\"而另一个线程感知到了变化\",{\"1\":{\"138\":1}}],[\"而对它的改变必须同步刷新回共享内存\",{\"1\":{\"138\":1}}],[\"而对于引用类型变量指向的堆中的对象不会拷贝\",{\"1\":{\"99\":1}}],[\"而被阻塞时\",{\"1\":{\"136\":1}}],[\"而terminated状态是永久的\",{\"1\":{\"134\":1}}],[\"而terminated状态表示线程已经执行完毕\",{\"1\":{\"134\":1}}],[\"而threadlocalmap使用threadlocal实例作为键\",{\"1\":{\"118\":1}}],[\"而等待状态是等待其他线程的通知或中断\",{\"1\":{\"133\":1}}],[\"而runnable接口适合定义线程要执行的任务\",{\"1\":{\"130\":1}}],[\"而且entry数据的key和当前不相等\",{\"1\":{\"120\":1}}],[\"而且第一个操作的执行顺序排在第二个操作之前\",{\"1\":{\"107\":1}}],[\"而槽位\",{\"1\":{\"120\":1}}],[\"而局部变量没有默认值\",{\"1\":{\"92\":1}}],[\"而静态变量是类共享的\",{\"1\":{\"92\":1}}],[\"而接口是对行为的抽象\",{\"1\":{\"91\":1}}],[\"而抽象类中可以包含任意类型的变量\",{\"1\":{\"91\":1}}],[\"而抽象类可以包含非抽象的方法\",{\"1\":{\"91\":1}}],[\"而是先复制原有集合内容\",{\"1\":{\"307\":1}}],[\"而是只对需要进行原子操作的代码进行了保护\",{\"1\":{\"297\":1}}],[\"而是回线程池中\",{\"1\":{\"241\":1}}],[\"而是等待所有已提交的任务执行完成后再关闭线程池\",{\"1\":{\"239\":1}}],[\"而是将任务直接移交给线程池中的线程进行执行\",{\"1\":{\"237\":1}}],[\"而是被重用来处理下一个任务\",{\"1\":{\"190\":1}}],[\"而是被中断的线程根据中断状态自行处理\",{\"1\":{\"131\":1}}],[\"而是会把值刷新回主内存\",{\"1\":{\"110\":1}}],[\"而是为了描述某个事件在解决整个问题的过程所发生的行为\",{\"1\":{\"86\":1}}],[\"而是直接引用缓存池中的integer对象\",{\"1\":{\"64\":1}}],[\"而建立对象的目的也不是为了完成一个个步骤\",{\"1\":{\"86\":1}}],[\"而在运行时\",{\"1\":{\"79\":1}}],[\"而不需要额外的同步措施\",{\"1\":{\"309\":1}}],[\"而不管当前是否存在守护线程\",{\"1\":{\"137\":1}}],[\"而不是按照插入顺序进行存储\",{\"1\":{\"337\":1}}],[\"而不是头插法\",{\"1\":{\"330\":1}}],[\"而不是8\",{\"1\":{\"326\":1}}],[\"而不是防止指令重排的有序性\",{\"1\":{\"275\":1}}],[\"而不是使用当前线程的本地内存中的值\",{\"1\":{\"110\":1}}],[\"而不是对象本身\",{\"1\":{\"98\":1}}],[\"而不是返回\",{\"1\":{\"74\":1}}],[\"而不会修改原始对象的值\",{\"1\":{\"59\":1}}],[\"而中间操作会返回一个\",{\"1\":{\"36\":1}}],[\"而字节流则需要手动处理\",{\"1\":{\"29\":1}}],[\"亦或是\",{\"1\":{\"36\":1}}],[\"u\",{\"1\":{\"298\":1,\"336\":2}}],[\"unchecked\",{\"1\":{\"336\":1}}],[\"uncaughtexceptionhandler\",{\"0\":{\"251\":1},\"1\":{\"251\":1}}],[\"unpark\",{\"1\":{\"283\":1}}],[\"unbounded\",{\"1\":{\"237\":1}}],[\"unit\",{\"1\":{\"140\":1,\"250\":2}}],[\"username\",{\"1\":{\"215\":1}}],[\"user\",{\"1\":{\"137\":1,\"223\":1}}],[\"users\",{\"1\":{\"11\":2}}],[\"use\",{\"1\":{\"121\":1}}],[\"uffff\",{\"1\":{\"50\":1}}],[\"u0000\",{\"1\":{\"50\":2}}],[\"util包下的集合类都是快速失败的\",{\"1\":{\"307\":1}}],[\"util\",{\"1\":{\"36\":1,\"148\":1,\"170\":4,\"172\":4,\"177\":2,\"179\":4,\"192\":1,\"194\":3,\"196\":3,\"211\":2,\"219\":5,\"223\":2,\"227\":3,\"254\":1,\"264\":2,\"267\":1,\"307\":1}}],[\"简称\",{\"1\":{\"283\":1}}],[\"简略的锁升级过程\",{\"1\":{\"281\":1}}],[\"简化了并发编程的复杂性\",{\"1\":{\"191\":1}}],[\"简化编程\",{\"1\":{\"191\":1}}],[\"简单来说\",{\"1\":{\"36\":1,\"39\":1,\"120\":1}}],[\"简体中文\",{\"1\":{\"11\":1}}],[\"流中的元素总数\",{\"1\":{\"36\":1}}],[\"流\",{\"1\":{\"36\":2}}],[\"流用过吗\",{\"0\":{\"36\":1}}],[\"流分为几种\",{\"0\":{\"28\":1}}],[\"=key\",{\"1\":{\"318\":1}}],[\"=expectedmodcount\",{\"1\":{\"307\":1}}],[\"==null\",{\"1\":{\"341\":1}}],[\"==\",{\"1\":{\"96\":2,\"121\":1,\"123\":1,\"250\":1,\"288\":1,\"303\":1,\"318\":9,\"319\":5,\"336\":11,\"341\":1}}],[\"==和\",{\"0\":{\"96\":1}}],[\"=128\",{\"0\":{\"64\":1}}],[\"=serviceloader\",{\"1\":{\"44\":2}}],[\"=\",{\"0\":{\"61\":2,\"64\":1},\"1\":{\"35\":1,\"36\":6,\"61\":2,\"74\":3,\"92\":1,\"104\":3,\"113\":1,\"119\":2,\"121\":14,\"122\":2,\"123\":6,\"140\":12,\"142\":3,\"144\":3,\"146\":3,\"148\":7,\"150\":1,\"154\":2,\"156\":1,\"160\":1,\"161\":3,\"162\":7,\"164\":1,\"165\":2,\"167\":1,\"168\":1,\"170\":5,\"172\":8,\"175\":1,\"177\":1,\"178\":1,\"179\":2,\"181\":1,\"182\":1,\"183\":1,\"184\":1,\"185\":2,\"193\":4,\"194\":3,\"196\":3,\"211\":3,\"215\":4,\"219\":2,\"223\":1,\"227\":1,\"229\":1,\"230\":1,\"249\":1,\"250\":4,\"251\":3,\"252\":2,\"254\":4,\"264\":12,\"267\":8,\"272\":16,\"288\":3,\"298\":1,\"303\":3,\"318\":17,\"319\":14,\"336\":18,\"341\":3}}],[\"来映射到对应的数组位置\",{\"1\":{\"324\":1}}],[\"来计算存储位置\",{\"1\":{\"312\":1}}],[\"来存储数据\",{\"1\":{\"312\":1}}],[\"来存储字符串\",{\"1\":{\"60\":1}}],[\"来进行序列化和反序列化\",{\"1\":{\"306\":1}}],[\"来实现原子性\",{\"1\":{\"296\":1}}],[\"来实现这个机制\",{\"1\":{\"282\":1}}],[\"来表示同步状态\",{\"1\":{\"283\":1}}],[\"来捕获和处理异常\",{\"1\":{\"254\":1}}],[\"来处理异常情况\",{\"1\":{\"252\":1}}],[\"来处理数据\",{\"1\":{\"30\":1}}],[\"来决定是否需要扩容\",{\"1\":{\"121\":1}}],[\"来约束\",{\"1\":{\"107\":1}}],[\"来将多条指令重叠执行\",{\"1\":{\"106\":1}}],[\"来保证程序执行的顺序与代码的顺序一致\",{\"1\":{\"105\":1}}],[\"来保证对共享变量的修改对其他线程是可见的\",{\"1\":{\"105\":1}}],[\"来控制对arraylist的读写操作\",{\"1\":{\"308\":1}}],[\"来控制对共享变量的访问和操作\",{\"1\":{\"105\":1}}],[\"来控制线程的访问和操作\",{\"1\":{\"103\":1}}],[\"来确保多线程程序的可见性\",{\"1\":{\"102\":1}}],[\"来包装它\",{\"1\":{\"35\":1}}],[\"一直不成功\",{\"1\":{\"293\":1}}],[\"一直找到\",{\"1\":{\"120\":1}}],[\"一般跟finally配合释放锁\",{\"1\":{\"282\":1}}],[\"一般是lock\",{\"1\":{\"282\":1}}],[\"一般适用于连接数较多且连接时间较长的应用\",{\"1\":{\"30\":1}}],[\"一次只能被一个线程拥有\",{\"1\":{\"275\":1}}],[\"一次编译\",{\"1\":{\"40\":1}}],[\"一开始会创建一定数量的线程\",{\"1\":{\"241\":1}}],[\"一旦超出这个范围就不再有效\",{\"1\":{\"92\":1}}],[\"一旦创建就不能修改其值\",{\"1\":{\"60\":1}}],[\"一个任务一个任务地执行\",{\"1\":{\"246\":1}}],[\"一个用于在两个线程之间交换数据的同步点\",{\"1\":{\"149\":1}}],[\"一个共享变量上可能会有多个线程在等待\",{\"1\":{\"131\":1}}],[\"一个线程使用共享方式获取了资源\",{\"1\":{\"283\":1}}],[\"一个线程使用独占方式获取了资源\",{\"1\":{\"283\":1}}],[\"一个线程执行任务\",{\"1\":{\"246\":1}}],[\"一个线程生成任务\",{\"1\":{\"147\":1}}],[\"一个线程a调用共享对象的\",{\"1\":{\"131\":1}}],[\"一个线程中的每个操作\",{\"1\":{\"107\":1}}],[\"一个进程中至少有一个线程\",{\"1\":{\"127\":1}}],[\"一个进程中有多个线程\",{\"1\":{\"127\":1}}],[\"一个table数组\",{\"1\":{\"119\":1}}],[\"一个变量被声明为volatile时\",{\"1\":{\"110\":1}}],[\"一个抽象概念\",{\"1\":{\"102\":1}}],[\"一个对象的\",{\"1\":{\"95\":1}}],[\"一个类不管创建多少个对象\",{\"1\":{\"93\":1}}],[\"一个类可以实现多个接口\",{\"1\":{\"91\":1}}],[\"一个或两个\",{\"1\":{\"61\":1}}],[\"一个方法\",{\"1\":{\"35\":1}}],[\"也是取余的效果\",{\"1\":{\"322\":1}}],[\"也达到了取余的效果\",{\"1\":{\"322\":1}}],[\"也可能有问题\",{\"1\":{\"291\":1}}],[\"也可以按照固定的时间间隔执行任务\",{\"1\":{\"242\":1}}],[\"也可以提交需要返回结果的任务\",{\"1\":{\"238\":1}}],[\"也可以叫同步点\",{\"1\":{\"141\":1}}],[\"也可以使⽤\",{\"1\":{\"93\":1}}],[\"也可以继承父类的属性和方法\",{\"1\":{\"87\":1}}],[\"也可以将hessian格式\",{\"1\":{\"69\":1}}],[\"也可以将protobuf格式的数据反序列化为java对象\",{\"1\":{\"69\":1}}],[\"也可以将xml格式的数据反序列化为java对象\",{\"1\":{\"69\":1}}],[\"也可以将json格式的数据反序列化为java对象\",{\"1\":{\"69\":1}}],[\"也可以将对象序列化为json\",{\"1\":{\"69\":1}}],[\"也可以放在变量之后\",{\"1\":{\"57\":1}}],[\"也可以是\",{\"1\":{\"54\":1}}],[\"也可以是一段可以传递的代码\",{\"1\":{\"33\":1}}],[\"也不处理队列中的任务\",{\"1\":{\"258\":1}}],[\"也不会被回收\",{\"1\":{\"235\":1}}],[\"也有oom的风险\",{\"1\":{\"247\":1}}],[\"也有可能非空的时候\",{\"1\":{\"35\":1}}],[\"也有可能非\",{\"1\":{\"35\":1}}],[\"也会根据threadlocal对象的hash值\",{\"1\":{\"120\":1}}],[\"也叫\",{\"1\":{\"119\":1}}],[\"也被称为类方法\",{\"1\":{\"93\":1}}],[\"也称为类变量\",{\"1\":{\"93\":1}}],[\"也就是支持16个线程的并发写\",{\"1\":{\"335\":1}}],[\"也就是给当前类加锁\",{\"1\":{\"269\":1}}],[\"也就是说\",{\"1\":{\"276\":1}}],[\"也就是说一个线程可以根据一个threadlocal对象查询到绑定在这个线程上的一个值\",{\"1\":{\"138\":1}}],[\"也就是说守护线程是否结束并不影响\",{\"1\":{\"137\":1}}],[\"也就是\",{\"1\":{\"121\":1}}],[\"也就是线程本地变量\",{\"1\":{\"113\":1}}],[\"也就是基本数据类型变量的值\",{\"1\":{\"99\":1}}],[\"也就是运行的时候就没这个信息了\",{\"1\":{\"81\":1}}],[\"也就是内容一样\",{\"1\":{\"63\":1}}],[\"可实现选择性通知\",{\"1\":{\"282\":1}}],[\"可实现公平锁\",{\"1\":{\"282\":1}}],[\"可重入性怎么实现\",{\"0\":{\"273\":1}}],[\"可控性\",{\"1\":{\"130\":1}}],[\"可见性和有序性\",{\"1\":{\"103\":1}}],[\"可见性保证了共享变量的修改对其他线程是可见的\",{\"1\":{\"103\":1}}],[\"可见性是指当一个线程对共享变量进行修改后\",{\"1\":{\"103\":1}}],[\"可见性是并发编程中非常重要的基础概念\",{\"1\":{\"103\":1}}],[\"可见性\",{\"0\":{\"103\":1,\"105\":1},\"1\":{\"103\":1,\"105\":1}}],[\"可能导致get操作返回null\",{\"1\":{\"332\":1}}],[\"可能导致get为null\",{\"1\":{\"332\":1}}],[\"可能会带来较高的内存开销和延迟\",{\"1\":{\"309\":1}}],[\"可能会有空的内存空间\",{\"1\":{\"302\":1}}],[\"可能会影响到整个线程池的性能和响应速度\",{\"1\":{\"266\":1}}],[\"可能会因为无限创建线程\",{\"1\":{\"245\":1}}],[\"可能会导致环形链表的出现\",{\"1\":{\"332\":1}}],[\"可能会导致在阻塞队列中的线程长期处于饥饿状态\",{\"1\":{\"288\":1}}],[\"可能会导致oom\",{\"1\":{\"244\":1,\"246\":1}}],[\"可能会导致线程间上下文切换的开销增加\",{\"1\":{\"240\":1}}],[\"可能不会执行的情况\",{\"1\":{\"73\":1}}],[\"可能是\",{\"1\":{\"35\":1}}],[\"可变\",{\"1\":{\"60\":2}}],[\"可变性\",{\"1\":{\"60\":1}}],[\"可以按照插入顺序或访问顺序进行遍历\",{\"1\":{\"338\":1}}],[\"可以获得较高的读取性能\",{\"1\":{\"309\":1}}],[\"可以直接使用它来替代arraylist\",{\"1\":{\"308\":1}}],[\"可以直接通过数组下标获取\",{\"1\":{\"302\":1}}],[\"可以靠按序申请资源来预防\",{\"1\":{\"299\":1}}],[\"可以主动释放它占有的资源\",{\"1\":{\"299\":1}}],[\"可以一次性请求所有的资源\",{\"1\":{\"299\":1}}],[\"可以保证对变量的操作是线程安全的\",{\"1\":{\"297\":1}}],[\"可以考虑使用\",{\"1\":{\"337\":1}}],[\"可以考虑合并多个变量\",{\"1\":{\"295\":1}}],[\"可以考虑以下几种策略\",{\"1\":{\"266\":1}}],[\"可以确保单机线程池在断电情况下的任务一致性和可靠性\",{\"1\":{\"265\":1}}],[\"可以有效优化线程池中调用特别耗时的\",{\"1\":{\"266\":1}}],[\"可以有效地管理和调优线程池的配置\",{\"1\":{\"263\":1}}],[\"可以有效控制对资源的并发访问\",{\"1\":{\"146\":1}}],[\"可以提供可视化界面让用户方便地修改线程池的参数\",{\"1\":{\"262\":1}}],[\"可以实现在不修改代码的情况下动态修改线程池的参数\",{\"1\":{\"262\":1}}],[\"可以实现更灵活的控制\",{\"1\":{\"262\":1}}],[\"可以动态地调整线程池的参数\",{\"1\":{\"262\":1}}],[\"可以动态调整线程数量以适应任务量的变化\",{\"1\":{\"242\":1}}],[\"可以处理队列中的任务\",{\"1\":{\"256\":1}}],[\"可以处理需要返回结果的任务\",{\"1\":{\"238\":1}}],[\"可以接受新任务\",{\"1\":{\"256\":1}}],[\"可以继续活下去\",{\"1\":{\"245\":1}}],[\"可以用来获取任务的执行结果或者监控任务的执行状态\",{\"1\":{\"238\":1}}],[\"可以根据具体的需求选择合适的队列类型来优化线程池的性能和行为\",{\"1\":{\"237\":1}}],[\"可以根据具体的业务需求和系统特性选择合适的拒绝策略\",{\"1\":{\"236\":1}}],[\"可以根据通过设置\",{\"1\":{\"64\":1}}],[\"可以调度定时任务\",{\"1\":{\"226\":1}}],[\"可以并行处理数据块\",{\"1\":{\"218\":1}}],[\"可以限制并发线程的数量\",{\"1\":{\"191\":1}}],[\"可以不指定线程池\",{\"1\":{\"185\":1}}],[\"可以简化两个线程之间的数据交换逻辑\",{\"1\":{\"150\":1}}],[\"可以指定最大等待时间\",{\"1\":{\"150\":1}}],[\"可以再次使用\",{\"1\":{\"142\":1}}],[\"可以再次进入runnable状态\",{\"1\":{\"134\":1}}],[\"可以重新加载持久化的任务队列\",{\"1\":{\"265\":1}}],[\"可以重新安排语句的执行顺序\",{\"1\":{\"106\":1}}],[\"可以重复使用\",{\"1\":{\"142\":1}}],[\"可以通过同步机制\",{\"1\":{\"308\":1}}],[\"可以通过自定义\",{\"1\":{\"252\":1}}],[\"可以通过自定义threadfactory来指定线程的名称\",{\"1\":{\"235\":1}}],[\"可以通过向线程池提交任务的方式\",{\"1\":{\"241\":1}}],[\"可以通过监控系统资源的使用情况和线程池的运行状态来动态调整线程数配置\",{\"1\":{\"240\":1}}],[\"可以通过调用awaittermination\",{\"1\":{\"239\":1}}],[\"可以通过java内置的等待\",{\"1\":{\"138\":1}}],[\"可以通过线程池管理\",{\"1\":{\"130\":1}}],[\"可以通过反射获取注解信息\",{\"1\":{\"81\":1}}],[\"可以与其他接口组合\",{\"1\":{\"130\":1}}],[\"可以先讲原对象序列化\",{\"1\":{\"99\":1}}],[\"可以快速定位对象\",{\"1\":{\"97\":1}}],[\"可以阻断\",{\"1\":{\"95\":1}}],[\"可以访问类的所有成员变量和方法\",{\"1\":{\"93\":1}}],[\"可以使⽤\",{\"1\":{\"93\":1}}],[\"可以使用collections工具类的synchronizedlist方法将arraylist转换为线程安全的list\",{\"1\":{\"308\":1}}],[\"可以使用图算法如找环算法来检测死锁\",{\"1\":{\"300\":1}}],[\"可以使用jdk自带的命令行工具排查\",{\"1\":{\"300\":1}}],[\"可以使用更高效的算法\",{\"1\":{\"266\":1}}],[\"可以使用信号量或者线程池的控制参数来实现并发数的限制\",{\"1\":{\"266\":1}}],[\"可以使用事务管理的机制来实现这一点\",{\"1\":{\"265\":1}}],[\"可以使用\",{\"1\":{\"253\":1,\"262\":1,\"333\":2}}],[\"可以使用优先级队列来根据任务的优先级高低来执行任务\",{\"1\":{\"237\":1}}],[\"可以使用自定义线程池\",{\"1\":{\"175\":1}}],[\"可以使用stringbuilder类以\",{\"1\":{\"60\":1}}],[\"可以使用stringbuffer类\",{\"1\":{\"60\":1}}],[\"可以使用string类\",{\"1\":{\"60\":1}}],[\"可以使用连接池优化\",{\"1\":{\"30\":1}}],[\"可以被public\",{\"1\":{\"92\":1}}],[\"可以被继承吗\",{\"0\":{\"59\":1}}],[\"可以修饰类\",{\"1\":{\"89\":1}}],[\"可以修饰变量\",{\"1\":{\"89\":2}}],[\"可以修饰在类\",{\"1\":{\"89\":1}}],[\"可以在多线程下并发使用\",{\"1\":{\"307\":1}}],[\"可以在指定的时间点执行任务\",{\"1\":{\"242\":1}}],[\"可以在后台执行\",{\"1\":{\"221\":1}}],[\"可以在编写代码时指定类\",{\"1\":{\"76\":1}}],[\"可以在类中显式地定义serialversionuid字段\",{\"1\":{\"68\":1}}],[\"可以将调用结果缓存起来\",{\"1\":{\"266\":1}}],[\"可以将异步任务提交到线程池中执行\",{\"1\":{\"222\":1}}],[\"可以将数据分割成多个块\",{\"1\":{\"217\":1}}],[\"可以将java对象序列化为二进制格式\",{\"1\":{\"69\":1}}],[\"可以将结构化的数据序列化为紧凑的二进制格式\",{\"1\":{\"69\":1}}],[\"可以将\",{\"1\":{\"35\":1}}],[\"可以传递一段代码\",{\"1\":{\"32\":1}}],[\"可以划分为\",{\"1\":{\"28\":1}}],[\"可以分为\",{\"1\":{\"28\":1}}],[\"可以看提交记录\",{\"1\":{\"24\":1}}],[\"注意\",{\"1\":{\"89\":2,\"307\":1}}],[\"注解生命周期\",{\"1\":{\"81\":1}}],[\"注解可以标记在类上\",{\"1\":{\"81\":1}}],[\"注解\",{\"0\":{\"80\":1}}],[\"注解的接口\",{\"1\":{\"34\":1}}],[\"注册回调处理结果\",{\"1\":{\"179\":1}}],[\"注册\",{\"1\":{\"30\":1}}],[\"添加了\",{\"1\":{\"34\":1}}],[\"表明这是该类的⼀个静态资源\",{\"1\":{\"269\":1}}],[\"表示该锁对象已经被其他线程抢占\",{\"1\":{\"281\":1}}],[\"表示锁重入\",{\"1\":{\"281\":1}}],[\"表示进⼊同步代码前要获得\",{\"1\":{\"269\":1}}],[\"表示进⼊同步代码库前要获得给定对象的锁\",{\"1\":{\"269\":1}}],[\"表示要计算斐波那契数列的第10个数\",{\"1\":{\"267\":1}}],[\"表示要计算斐波那契数列的第\",{\"1\":{\"267\":1}}],[\"表示这是一个有返回值的递归任务\",{\"1\":{\"267\":1}}],[\"表示有3个停车位\",{\"1\":{\"144\":1,\"145\":1}}],[\"表示当前线程已经执行完毕\",{\"1\":{\"132\":1}}],[\"表示线程池已经完全终止\",{\"1\":{\"260\":1}}],[\"表示线程进入等待状态\",{\"1\":{\"132\":1}}],[\"表示线程阻塞于锁\",{\"1\":{\"132\":1}}],[\"表示具体的一个\",{\"1\":{\"78\":1}}],[\"表示不确定的\",{\"1\":{\"78\":1}}],[\"表示式\",{\"1\":{\"33\":1}}],[\"表达式了解多少\",{\"0\":{\"33\":1}}],[\"表达式最好不要超过3行\",{\"1\":{\"32\":1}}],[\"表达式使代码更加简洁\",{\"1\":{\"32\":1}}],[\"表达式本质上是一段匿名内部类\",{\"1\":{\"32\":1,\"33\":1}}],[\"表达式和函数式接口\",{\"1\":{\"32\":1}}],[\"类加锁\",{\"1\":{\"269\":1}}],[\"类自身的构造函数创建两个新的任务对象\",{\"1\":{\"267\":1}}],[\"类的抽象方法\",{\"1\":{\"267\":1}}],[\"类的常见方法\",{\"0\":{\"66\":1}}],[\"类中\",{\"1\":{\"267\":2}}],[\"类中的\",{\"1\":{\"145\":1}}],[\"类继承了\",{\"1\":{\"267\":1}}],[\"类定义了五种线程池状态\",{\"1\":{\"255\":1}}],[\"类变量\",{\"1\":{\"92\":2}}],[\"类名\",{\"1\":{\"60\":1,\"93\":1}}],[\"类可以继承吗\",{\"1\":{\"59\":1}}],[\"类库\",{\"1\":{\"39\":1}}],[\"类型的成员变量\",{\"1\":{\"283\":1}}],[\"类型\",{\"1\":{\"36\":1,\"54\":1,\"78\":2}}],[\"类\",{\"1\":{\"32\":1,\"50\":1,\"149\":2,\"267\":1,\"269\":1,\"307\":1}}],[\"提升了synchronized的性能\",{\"1\":{\"278\":1}}],[\"提交任务\",{\"1\":{\"244\":1,\"245\":1,\"246\":1,\"264\":1}}],[\"提交异步任务\",{\"1\":{\"223\":1}}],[\"提交异步任务并使用自定义线程池\",{\"1\":{\"179\":1}}],[\"提交多个任务\",{\"1\":{\"194\":1,\"196\":1}}],[\"提高插入操作的效率\",{\"1\":{\"330\":1}}],[\"提高了插入和删除操作的效率\",{\"1\":{\"316\":1}}],[\"提高了线程的利用率和任务的并行性\",{\"1\":{\"267\":1}}],[\"提高了代码的运行效率和与旧版本\",{\"1\":{\"79\":1}}],[\"提高了代码的可读性和简洁性\",{\"1\":{\"32\":1}}],[\"提高系统的性能和响应速度\",{\"1\":{\"266\":1}}],[\"提高系统的可靠性和可维护性\",{\"1\":{\"263\":1}}],[\"提高线程池的性能和响应速度\",{\"1\":{\"266\":1}}],[\"提高线程池的响应速度\",{\"1\":{\"266\":1}}],[\"提高线程池的并发能力\",{\"1\":{\"266\":1}}],[\"提高任务的并发性和执行效率\",{\"1\":{\"266\":1}}],[\"提高并发编程的效率和资源利用率\",{\"1\":{\"228\":1}}],[\"提高数据处理的速度\",{\"1\":{\"218\":1}}],[\"提高性能\",{\"1\":{\"191\":1}}],[\"提供了统一的接口来管理和调度线程\",{\"1\":{\"191\":1}}],[\"提供了一种简洁而强大的方式来处理异\",{\"1\":{\"173\":1}}],[\"提供了更好的日期和时间处理方式\",{\"1\":{\"32\":1}}],[\"提供了最基本的输入输出操作\",{\"1\":{\"29\":1}}],[\"聚合等操作\",{\"1\":{\"32\":1}}],[\"排序\",{\"1\":{\"32\":1,\"36\":1}}],[\"映射\",{\"1\":{\"32\":1}}],[\"我们设的比较小的话\",{\"1\":{\"328\":1}}],[\"我们来看看它的状态变化\",{\"1\":{\"277\":1}}],[\"我们定义了一个继承自recursivetask<integer>的fibonaccitask类\",{\"1\":{\"267\":1}}],[\"我们重写了\",{\"1\":{\"267\":1}}],[\"我们就可以在编译或者运行阶段去识别这些标记\",{\"1\":{\"81\":1}}],[\"我们就可以考虑用\",{\"1\":{\"35\":1}}],[\"我们能够将\",{\"1\":{\"36\":1}}],[\"我们可以使用同步机制\",{\"1\":{\"103\":1}}],[\"我们可以获取到class对象信息\",{\"1\":{\"48\":1}}],[\"我们可以避免空指针异常\",{\"1\":{\"32\":1}}],[\"我们可以对集合进行过滤\",{\"1\":{\"32\":1}}],[\"我们无法正确输出子进程的进度条\",{\"1\":{\"11\":1}}],[\"更高效\",{\"1\":{\"330\":1}}],[\"更多的是一种兜底的策略\",{\"1\":{\"326\":1}}],[\"更新失败\",{\"1\":{\"281\":1}}],[\"更新成功\",{\"1\":{\"281\":1}}],[\"更新博客只在master分支上改\",{\"0\":{\"22\":1}}],[\"更易于并行处理数据集合的方式\",{\"1\":{\"32\":1}}],[\"但hashmap的实际容量是32\",{\"1\":{\"323\":1}}],[\"但它的性能很低\",{\"1\":{\"308\":1}}],[\"但它们之间有一些细微的差别\",{\"1\":{\"239\":1}}],[\"但它们之间存在一些区别\",{\"1\":{\"238\":1}}],[\"但同样地\",{\"1\":{\"307\":1}}],[\"但实际只用了50\",{\"1\":{\"305\":1}}],[\"但阻塞\",{\"1\":{\"299\":1}}],[\"但又提出了新的资源请求\",{\"1\":{\"299\":1}}],[\"但如果此时锁刚好可用\",{\"1\":{\"286\":1}}],[\"但需要一些额外的编码工作\",{\"1\":{\"262\":1}}],[\"但并不保证所有任务都能被成功中断\",{\"1\":{\"239\":1}}],[\"但会继续执行已提交的任务和队列中等待的任务\",{\"1\":{\"257\":1}}],[\"但会继续执行已提交的任务\",{\"1\":{\"239\":1}}],[\"但不会通知调用者\",{\"1\":{\"238\":1}}],[\"但频繁的线程创建和销毁会导致代码路径的变化\",{\"1\":{\"206\":1}}],[\"但在读操作频繁\",{\"1\":{\"309\":1}}],[\"但在空闲时会重用先前创建的线程\",{\"1\":{\"193\":1}}],[\"但在需要更多控制或资源隔离时\",{\"1\":{\"175\":1}}],[\"但你可以指定自定义的线程池来满足特殊需求\",{\"1\":{\"174\":1}}],[\"但还没有调用start\",{\"1\":{\"132\":1}}],[\"但可以通过引用修改对象的状态\",{\"1\":{\"98\":1}}],[\"但只能继承一个抽象类\",{\"1\":{\"91\":1}}],[\"但是就需要更多的空间去存储元素\",{\"1\":{\"328\":1}}],[\"但是如果插入中间的位置\",{\"1\":{\"302\":1}}],[\"但是看到的虽然是a\",{\"1\":{\"291\":1}}],[\"但是公平锁会判断等待队列是否有线程处于等待状态\",{\"1\":{\"288\":1}}],[\"但是jdk6开始\",{\"1\":{\"282\":1}}],[\"但是被检测到不可能存在共享数据竞争的锁进行消除\",{\"1\":{\"278\":1}}],[\"但是不保证不会指令重排\",{\"1\":{\"275\":1}}],[\"但是可以设置超时时间\",{\"1\":{\"140\":1}}],[\"但是线程调度器可以无条件忽略这个暗示\",{\"1\":{\"131\":1}}],[\"但是线程a所拥有的监视器资源\",{\"1\":{\"131\":1}}],[\"但是它不会重新尝试获取锁\",{\"1\":{\"131\":1}}],[\"但是一个时间段内\",{\"1\":{\"126\":1}}],[\"但是threadlocalmap生命周期和thread是一样的\",{\"1\":{\"116\":1}}],[\"但是仍然希望能够反序列化之前的序列化数据\",{\"1\":{\"68\":1}}],[\"但是长整型\",{\"1\":{\"54\":1}}],[\"但是\",{\"1\":{\"39\":1,\"240\":1,\"278\":1}}],[\"但是也不要滥用\",{\"1\":{\"32\":1}}],[\"但为了更方便地处理文本数据\",{\"1\":{\"29\":1}}],[\"使得每个线程都在等待下一个线程占有的资源\",{\"1\":{\"299\":1}}],[\"使得任务能够动态地分配给空闲的线程\",{\"1\":{\"267\":1}}],[\"使得线程池成为并发编程中重要的工具\",{\"1\":{\"234\":1}}],[\"使线程和队列解耦\",{\"1\":{\"241\":1}}],[\"使线程在屏障点等待\",{\"1\":{\"142\":1}}],[\"使其他被阻塞的线程可以继续执行\",{\"1\":{\"145\":1}}],[\"使其成为监视对象\",{\"1\":{\"30\":1}}],[\"使用的是哈希表的数据结构\",{\"1\":{\"337\":1}}],[\"使用的时候再一个一个的一次调用就可以\",{\"1\":{\"86\":1}}],[\"使用reentrantlock加锁\",{\"1\":{\"335\":1}}],[\"使用线程安全的并发容器\",{\"1\":{\"333\":1}}],[\"使用线程安全的包装类\",{\"1\":{\"333\":1}}],[\"使用随机哈希码\",{\"1\":{\"326\":1}}],[\"使用扰动函数\",{\"1\":{\"319\":1}}],[\"使用链表存储键值对\",{\"1\":{\"312\":1}}],[\"使用copyonwritearraylist代替arraylist\",{\"1\":{\"308\":1}}],[\"使用collections\",{\"1\":{\"308\":1}}],[\"使用countdownlatch时\",{\"1\":{\"143\":1}}],[\"使用自旋+cas实现\",{\"1\":{\"298\":1}}],[\"使用自定义\",{\"0\":{\"252\":1}}],[\"使用自定义线程池\",{\"0\":{\"178\":1}}],[\"使用synchronized\",{\"1\":{\"296\":1}}],[\"使用stringbuilder可以获得更好的性能\",{\"1\":{\"60\":1}}],[\"使用stringbuffer可以保证线程安全\",{\"1\":{\"60\":1}}],[\"使用jstack查看线程堆栈信息\",{\"1\":{\"300\":1}}],[\"使用jps查找运行的java进程\",{\"1\":{\"300\":1}}],[\"使用juc包下的锁\",{\"1\":{\"296\":1}}],[\"使用java\",{\"1\":{\"84\":1}}],[\"使用循环原子类\",{\"1\":{\"296\":1}}],[\"使用atomicstampreference类\",{\"1\":{\"292\":1}}],[\"使用一个\",{\"1\":{\"283\":1}}],[\"使用管理平台是一种更高级的方式\",{\"1\":{\"262\":1}}],[\"使用配置文件是一种常见的方式\",{\"1\":{\"262\":1}}],[\"使用动态代理也是一种有效的方式\",{\"1\":{\"262\":1}}],[\"使用可调整的线程池\",{\"1\":{\"262\":1}}],[\"使用连接池管理数据库连接\",{\"1\":{\"215\":1}}],[\"使用默认线程池\",{\"0\":{\"175\":1}}],[\"使用示例\",{\"1\":{\"148\":1}}],[\"使用threadlocal\",{\"1\":{\"138\":1}}],[\"使用thread\",{\"1\":{\"138\":1}}],[\"使用完threadlocal后\",{\"1\":{\"117\":1}}],[\"使用volatile关键字或者同步机制\",{\"1\":{\"105\":2}}],[\"使用同步机制控制arraylist的读写\",{\"1\":{\"308\":1}}],[\"使用同步机制\",{\"1\":{\"105\":1,\"333\":1}}],[\"使用for\",{\"1\":{\"84\":2}}],[\"使用迭代器遍历\",{\"1\":{\"84\":1}}],[\"使用注解作为切点就是运行期注解的应用\",{\"1\":{\"81\":1}}],[\"使用建议\",{\"1\":{\"60\":1}}],[\"使用\",{\"0\":{\"251\":1,\"253\":1,\"254\":1},\"1\":{\"32\":1,\"36\":1,\"60\":2,\"68\":1,\"146\":1,\"174\":1,\"175\":1,\"185\":2,\"267\":2,\"333\":1}}],[\"在冲突的位置拉一个链表\",{\"1\":{\"325\":1}}],[\"在扩容时保持链表元素原本的顺序\",{\"1\":{\"332\":1}}],[\"在扩容时\",{\"1\":{\"322\":1,\"330\":1}}],[\"在使用arraylist时\",{\"1\":{\"308\":1}}],[\"在使用cyclicbarrier时\",{\"1\":{\"143\":1}}],[\"在遍历期间原集合发生的修改迭代器是不知道的\",{\"1\":{\"307\":1}}],[\"在遍历时不是直接在集合内容上访问的\",{\"1\":{\"307\":1}}],[\"在拷贝的集合上进行遍历\",{\"1\":{\"307\":1}}],[\"在用迭代器遍历一个集合对象时\",{\"1\":{\"307\":1}}],[\"在获取资源时设置超时\",{\"1\":{\"299\":1}}],[\"在无外力作用的情况下\",{\"1\":{\"299\":1}}],[\"在无竞争的情况下\",{\"1\":{\"278\":1}}],[\"在轻量级锁升级为重量级锁时\",{\"1\":{\"278\":1}}],[\"在没有多线程竞争时\",{\"1\":{\"278\":1}}],[\"在判断拥有同步标识\",{\"1\":{\"272\":1}}],[\"在线程池上线之后\",{\"1\":{\"263\":1}}],[\"在线程池中\",{\"1\":{\"237\":1,\"241\":1}}],[\"在上线之后建立完善的线程池监控机制\",{\"1\":{\"263\":1}}],[\"在上线之前进行充分的测试\",{\"1\":{\"263\":1}}],[\"在上线之前\",{\"1\":{\"263\":1}}],[\"在该状态下\",{\"1\":{\"256\":1,\"257\":1,\"258\":1,\"259\":1}}],[\"在任务内部使用\",{\"1\":{\"254\":1}}],[\"在任务\",{\"1\":{\"249\":1}}],[\"在调用了shutdown\",{\"1\":{\"239\":1}}],[\"在指定时间或周期性执行\",{\"1\":{\"226\":1}}],[\"在许多应用中\",{\"1\":{\"221\":1}}],[\"在大数据处理和计算任务中\",{\"1\":{\"217\":1}}],[\"在典型的jvm中\",{\"1\":{\"199\":1}}],[\"在对队列进行添加或移除元素的操作时\",{\"1\":{\"187\":1}}],[\"在队列为空或已满时\",{\"1\":{\"187\":1}}],[\"在多线程编程中起着重要作用\",{\"1\":{\"187\":1}}],[\"在多线程环境下使用stringbuilder\",{\"1\":{\"60\":1}}],[\"在多线程环境下\",{\"1\":{\"60\":1,\"103\":3}}],[\"在所有任务完成后处理结果\",{\"1\":{\"170\":1}}],[\"在这个示例中\",{\"1\":{\"267\":1}}],[\"在这个例子中\",{\"1\":{\"145\":1}}],[\"在这个过程中\",{\"1\":{\"135\":1}}],[\"在compute\",{\"1\":{\"267\":1}}],[\"在countdownlatch中\",{\"1\":{\"143\":1}}],[\"在cyclicbarrier中\",{\"1\":{\"143\":1}}],[\"在它们结束后都可以执行特定动作\",{\"1\":{\"141\":1}}],[\"在此等待信号再继续\",{\"1\":{\"140\":1}}],[\"在编写多线程应用程序时\",{\"1\":{\"135\":1}}],[\"在编译时候就确定了类型信息\",{\"1\":{\"46\":1}}],[\"在等待时间内没有其他线程调用相同对象的\",{\"1\":{\"131\":1}}],[\"在子线程中就可以拿到了\",{\"1\":{\"122\":1}}],[\"在主线程的inheritablethreadlocal实例设置值\",{\"1\":{\"122\":1}}],[\"在get的时候\",{\"1\":{\"120\":1}}],[\"在tryacquire\",{\"1\":{\"288\":1}}],[\"在try块中发生了线程死锁\",{\"1\":{\"73\":1}}],[\"在try块中发生了死循环或无限递归\",{\"1\":{\"73\":1}}],[\"在try块中调用了system\",{\"1\":{\"73\":1}}],[\"在thread的构造函数中\",{\"1\":{\"123\":1}}],[\"在thread类里还有另外一个变量\",{\"1\":{\"123\":1}}],[\"在threadlocalmap\",{\"1\":{\"121\":1}}],[\"在threadlocal中\",{\"1\":{\"118\":1}}],[\"在自己的map里找对应的key\",{\"1\":{\"115\":1}}],[\"在自动装箱的时候会调用integer\",{\"1\":{\"64\":1}}],[\"在每个volatile读操作的后面插入一个\",{\"1\":{\"111\":2}}],[\"在每个volatile写操作的后面插入一个\",{\"1\":{\"111\":1}}],[\"在每个volatile写操作的前面插入一个\",{\"1\":{\"111\":1}}],[\"在外部调⽤静态⽅法时\",{\"1\":{\"93\":1}}],[\"在同一类内可见\",{\"1\":{\"89\":1}}],[\"在同一包内可见\",{\"1\":{\"89\":1}}],[\"在类加载阶段丢弃\",{\"1\":{\"81\":1}}],[\"在运行时获取泛型类型信息\",{\"1\":{\"79\":1}}],[\"在运行时动态地获取类信息\",{\"1\":{\"46\":1}}],[\"在执行完对应的代码块之后\",{\"1\":{\"276\":1}}],[\"在执行第二个子任务的过程中\",{\"1\":{\"267\":1}}],[\"在执行任务之前和之后\",{\"1\":{\"265\":1}}],[\"在执行任务时\",{\"1\":{\"265\":1}}],[\"在执行过程中会经历多个状态\",{\"1\":{\"255\":1}}],[\"在执行程序时\",{\"1\":{\"106\":1}}],[\"在执行\",{\"1\":{\"74\":1}}],[\"在\",{\"1\":{\"74\":1,\"87\":1,\"95\":1,\"267\":4,\"339\":1}}],[\"在序列化时不需要保存\",{\"1\":{\"68\":1}}],[\"在静态块中会初始化好缓存值\",{\"1\":{\"64\":1}}],[\"在jvm\",{\"1\":{\"137\":1}}],[\"在jdk\",{\"1\":{\"91\":1,\"330\":2}}],[\"在jdk1\",{\"1\":{\"62\":1,\"278\":2,\"282\":1,\"332\":1,\"334\":1}}],[\"在java的线程池中\",{\"1\":{\"238\":1}}],[\"在java8时jdk对\",{\"1\":{\"62\":1}}],[\"在java中\",{\"1\":{\"48\":1,\"294\":1}}],[\"在java\",{\"1\":{\"32\":1}}],[\"在堆里创建一个\",{\"1\":{\"61\":1}}],[\"在单线程环境下\",{\"1\":{\"60\":1}}],[\"在目前所有的版本中都是不可以的\",{\"1\":{\"54\":1}}],[\"在应用程序运行时\",{\"1\":{\"44\":1}}],[\"在actions菜单栏中应该会触发自动发布\",{\"1\":{\"21\":1}}],[\"服务使用\",{\"1\":{\"44\":1}}],[\"服务加载\",{\"1\":{\"44\":1}}],[\"服务加载器\",{\"1\":{\"44\":1}}],[\"服务提供者配置文件\",{\"1\":{\"44\":1}}],[\"服务提供者\",{\"1\":{\"44\":1}}],[\"服务接口\",{\"1\":{\"44\":1}}],[\"服务端程序启动线程去处理\",{\"1\":{\"30\":1}}],[\"服务器端得到通知\",{\"1\":{\"30\":1}}],[\"服务器端用一个线程处理多个连接\",{\"1\":{\"30\":1}}],[\"就使用synchronized写入数据\",{\"1\":{\"336\":1}}],[\"就使用了自旋加锁的方式\",{\"1\":{\"278\":1}}],[\"就通过cas+自旋的方式初始化数组\",{\"1\":{\"336\":1}}],[\"就需要把插入位置后的元素都向前或者向后移动\",{\"1\":{\"302\":1}}],[\"就停止自旋\",{\"1\":{\"294\":1}}],[\"就释放锁了\",{\"1\":{\"276\":1}}],[\"就可得到原问题的解\",{\"1\":{\"267\":1}}],[\"就新建一个线程执行\",{\"1\":{\"245\":1}}],[\"就去取出任务执行\",{\"1\":{\"245\":1}}],[\"就起不到多线程的效果\",{\"1\":{\"129\":1}}],[\"就把它赋给当前线程\",{\"1\":{\"123\":1}}],[\"就开始执行\",{\"1\":{\"121\":1}}],[\"就判断下一个位置\",{\"1\":{\"120\":1}}],[\"就会导致后一个key覆盖前一个key\",{\"1\":{\"332\":1}}],[\"就会触发扩容\",{\"1\":{\"327\":1,\"329\":1}}],[\"就会触发自动发布\",{\"1\":{\"21\":1}}],[\"就会改变\",{\"1\":{\"307\":1}}],[\"就会造成了内存泄漏问题\",{\"1\":{\"116\":1}}],[\"就会出现这种情况\",{\"1\":{\"116\":1}}],[\"就是和hashmap一样\",{\"1\":{\"335\":1}}],[\"就是由加载因子和当前容器的容量大小来确定的\",{\"1\":{\"327\":1}}],[\"就是告知程序任何对该变量的访问均需要从共享内存中获取\",{\"1\":{\"138\":1}}],[\"就是这个坑被人占了\",{\"1\":{\"120\":1}}],[\"就是通过分别限制这两种类型的重排序\",{\"1\":{\"111\":1}}],[\"就是注解在编译期的运行\",{\"1\":{\"81\":1}}],[\"就是\",{\"1\":{\"30\":1}}],[\"并重试或采取其他措施\",{\"1\":{\"299\":1}}],[\"并设置\",{\"1\":{\"287\":1}}],[\"并设置屏障点操作\",{\"1\":{\"142\":1}}],[\"并使用locksupport\",{\"1\":{\"283\":1}}],[\"并使用交叉规则得出2个交配结果\",{\"1\":{\"150\":1}}],[\"并指向mark\",{\"1\":{\"281\":1}}],[\"并输出结果\",{\"1\":{\"267\":1}}],[\"并直接在当前线程中执行第二个子任务的\",{\"1\":{\"267\":1}}],[\"并采取相应的措施进行处理\",{\"1\":{\"263\":1}}],[\"并针对性地配置线程池\",{\"1\":{\"263\":1}}],[\"并实时查看线程池的状态和性能指标\",{\"1\":{\"262\":1}}],[\"并处理已经在队列中的任务\",{\"1\":{\"256\":1}}],[\"并将锁记录里的owner指针指向对象头的markword\",{\"1\":{\"281\":1}}],[\"并将这些小任务分配给线程池中的多个线程并行执行\",{\"1\":{\"266\":1}}],[\"并将它们放入线程池中\",{\"1\":{\"241\":1}}],[\"并将新的通道\",{\"1\":{\"30\":1}}],[\"并释放线程池所占用的资源\",{\"1\":{\"239\":1}}],[\"并释放许可\",{\"1\":{\"145\":1}}],[\"并尝试重新提交当前任务\",{\"1\":{\"236\":1}}],[\"并返回未执行的任务列表\",{\"1\":{\"233\":1,\"239\":1}}],[\"并返回string对象的引用\",{\"1\":{\"63\":1}}],[\"并准备好任务队列\",{\"1\":{\"229\":1}}],[\"并提高数据库操作的效率\",{\"1\":{\"214\":1}}],[\"并提供了具体的功能实现\",{\"1\":{\"44\":1}}],[\"并提供了更多的功能和灵活性\",{\"1\":{\"32\":1}}],[\"并结合了锁和条件等待机制来实现线程的阻塞和唤醒\",{\"1\":{\"187\":1}}],[\"并在后台执行耗时的操作\",{\"1\":{\"266\":1}}],[\"并在代理类中提供方法来动态修改线程池的参数\",{\"1\":{\"262\":1}}],[\"并在所有已提交任务执行完成后关闭线程池\",{\"1\":{\"233\":1}}],[\"并在所有数据获取完成后进行处理\",{\"1\":{\"172\":1}}],[\"并在运行时动态地操作类和对象\",{\"1\":{\"48\":1}}],[\"并对两个excel数据进行校对\",{\"1\":{\"150\":1}}],[\"并可以选择性地做一些特定的动作\",{\"1\":{\"143\":1}}],[\"并可以与其他接口组合使用\",{\"1\":{\"130\":1}}],[\"并继续执行\",{\"1\":{\"142\":1}}],[\"并立即返回\",{\"1\":{\"131\":1}}],[\"并发修改\",{\"1\":{\"307\":1}}],[\"并发环境下\",{\"1\":{\"291\":1}}],[\"并发包中的锁就是基于aqs实现的\",{\"1\":{\"283\":1}}],[\"并发送告警通知给相关人员进行处理\",{\"1\":{\"263\":1}}],[\"并发队列\",{\"0\":{\"186\":1}}],[\"并发工具类\",{\"0\":{\"139\":1}}],[\"并发的实现依赖于cpu切换线程\",{\"1\":{\"126\":1}}],[\"并发就是同一时刻\",{\"1\":{\"126\":1}}],[\"并行处理每个块\",{\"1\":{\"217\":1}}],[\"并行数据处理\",{\"0\":{\"216\":1}}],[\"并行获取数据\",{\"0\":{\"172\":1}}],[\"并行执行多个任务\",{\"0\":{\"169\":1}}],[\"并行执行\",{\"1\":{\"152\":1}}],[\"并行就是同一时刻\",{\"1\":{\"126\":1}}],[\"并行跟并发有什么区别\",{\"0\":{\"126\":1}}],[\"并成功返回\",{\"1\":{\"107\":1}}],[\"并不意味着java平台的具体实现必须要按照\",{\"1\":{\"107\":1}}],[\"并不真实存在\",{\"1\":{\"102\":1}}],[\"并且在遍历过程中使用一个modcount\",{\"1\":{\"307\":1}}],[\"并且在获取锁之前\",{\"1\":{\"131\":1}}],[\"并且当前印戳\",{\"1\":{\"292\":1}}],[\"并且当前线程之前没有获取过该锁\",{\"1\":{\"287\":1}}],[\"并且对象markword锁标志设置为\",{\"1\":{\"281\":1}}],[\"并且将锁对象markword复制到该锁记录中\",{\"1\":{\"281\":1}}],[\"并且会尝试中断正在进行的任务\",{\"1\":{\"258\":1}}],[\"并且可以配合其他配置管理工具来实现自动化管理\",{\"1\":{\"262\":1}}],[\"并且可以处理任务执行过程中抛出的异常\",{\"1\":{\"238\":1}}],[\"并且可以从其他线程的队列中窃取任务来执行\",{\"1\":{\"237\":1}}],[\"并且可以直接使用接口名调用\",{\"1\":{\"91\":1}}],[\"并且任务队列已满时\",{\"1\":{\"235\":1}}],[\"并且这两个线程在此方法处阻塞\",{\"1\":{\"149\":1}}],[\"并且重新尝试获取对象的锁\",{\"1\":{\"131\":1}}],[\"并且接口中定义了相同的默认方法\",{\"1\":{\"91\":1}}],[\"并通过join\",{\"1\":{\"267\":1}}],[\"并通过\",{\"1\":{\"254\":1}}],[\"并通过http协议进行传输\",{\"1\":{\"69\":1}}],[\"并通过配置文件等方式注册到spi框架中\",{\"1\":{\"44\":1}}],[\"并确保在类的修改后\",{\"1\":{\"68\":1}}],[\"并根据任务执行日志来恢复任务的执行状态\",{\"1\":{\"265\":1}}],[\"并根据文件中指定的实现类\",{\"1\":{\"44\":1}}],[\"并根据配置文件中指定的实现类实例化相应的对象\",{\"1\":{\"44\":1}}],[\"并更好地处理可能为空的值\",{\"1\":{\"32\":1}}],[\"并执行相应的读取或写入操作\",{\"1\":{\"30\":1}}],[\"会根据返回值是否为空来判断是否插入元素成功\",{\"1\":{\"341\":1}}],[\"会根据配置参数创建一定数量的核心线程\",{\"1\":{\"229\":1}}],[\"会发生链表和红黑树的不断转换\",{\"1\":{\"326\":1}}],[\"会带来一定的内存开销\",{\"1\":{\"309\":1}}],[\"会有一个自旋次数的限制\",{\"1\":{\"294\":1}}],[\"会给cpu带来非常大的执行开销\",{\"1\":{\"293\":1}}],[\"会使用cas操作将state修改为0\",{\"1\":{\"283\":1}}],[\"会使用locksupport\",{\"1\":{\"283\":1}}],[\"会被加入\",{\"1\":{\"272\":1}}],[\"会被加入到\",{\"1\":{\"272\":1}}],[\"会作⽤于类的所有对象实例\",{\"1\":{\"269\":1}}],[\"会进入\",{\"1\":{\"259\":1,\"260\":1}}],[\"会执行任务的run\",{\"1\":{\"241\":1}}],[\"会不断地从任务队列中取出任务来执行\",{\"1\":{\"241\":1}}],[\"会将内存位置\",{\"1\":{\"289\":1}}],[\"会将其结果合并到大任务的结果中\",{\"1\":{\"267\":1}}],[\"会将异常包装在executionexception中重新抛出\",{\"1\":{\"238\":1}}],[\"会将该通道标记为就绪状态\",{\"1\":{\"30\":1}}],[\"会丢弃任务队列中最旧的任务\",{\"1\":{\"236\":1}}],[\"会默默地丢弃被拒绝的任务\",{\"1\":{\"236\":1}}],[\"会在调用线程中直接执行被拒绝的任务\",{\"1\":{\"236\":1}}],[\"会在指令序列中插入内存屏障来禁止特定类型的处理器重排序\",{\"1\":{\"111\":1}}],[\"会对热点代码进行优化\",{\"1\":{\"206\":1}}],[\"会触发条件变量的通知操作\",{\"1\":{\"187\":1}}],[\"会抛出rejectedexecutionexception异常\",{\"1\":{\"236\":1}}],[\"会抛出\",{\"1\":{\"142\":1,\"146\":1,\"150\":1}}],[\"会继续往下执行\",{\"1\":{\"131\":1}}],[\"会唤醒一个在这个共享变量上调用\",{\"1\":{\"131\":1}}],[\"会先创建一条线程\",{\"1\":{\"129\":1}}],[\"会先去清理过期的entry\",{\"1\":{\"121\":1}}],[\"会先将\",{\"1\":{\"74\":1}}],[\"会从主内存重新获取最新值\",{\"1\":{\"110\":1}}],[\"会影响原对象\",{\"1\":{\"99\":1}}],[\"会写入\",{\"1\":{\"81\":2}}],[\"会返回之前暂存的结果\",{\"1\":{\"74\":1}}],[\"会比较序列化类的版本号和当前类的版本号是否一致\",{\"1\":{\"68\":1}}],[\"会产生大量的临时对象\",{\"1\":{\"60\":1}}],[\"会处理这个事件\",{\"1\":{\"30\":1}}],[\"当多个线程同时执行put操作时\",{\"1\":{\"332\":1}}],[\"当多个线程同时进行扩容操作时\",{\"1\":{\"332\":1}}],[\"当插入新的键值对时\",{\"1\":{\"330\":1}}],[\"当发生哈希碰撞时\",{\"1\":{\"330\":1}}],[\"当哈希冲突较多时\",{\"1\":{\"330\":1}}],[\"当桶中的元素较多时\",{\"1\":{\"312\":1}}],[\"当桶中的元素较少时\",{\"1\":{\"312\":1}}],[\"当且仅当预期值\",{\"1\":{\"289\":1}}],[\"当然\",{\"1\":{\"288\":1}}],[\"当然可以\",{\"1\":{\"264\":1}}],[\"当达到safepoint时获得偏向锁的线程被挂起\",{\"1\":{\"280\":1}}],[\"当执行完退出后\",{\"1\":{\"272\":1}}],[\"当系统重新启动时\",{\"1\":{\"265\":1}}],[\"当系统发生断电时\",{\"1\":{\"265\":1}}],[\"当单机线程池执行断电时\",{\"1\":{\"265\":1}}],[\"当调用\",{\"1\":{\"257\":1,\"258\":1}}],[\"当前hashmap的元素个数达到一个临界值的时候\",{\"1\":{\"327\":1,\"329\":1}}],[\"当前节点是否为树节点\",{\"1\":{\"319\":1}}],[\"当前节点和key匹配\",{\"1\":{\"319\":1}}],[\"当前\",{\"1\":{\"269\":1}}],[\"当前对象实例的锁\",{\"1\":{\"269\":1}}],[\"当前的唯一线程\",{\"1\":{\"246\":1}}],[\"当前线程执行轻量级锁状态下的锁获取步骤\",{\"1\":{\"280\":1}}],[\"当前线程是最后一个到达的线程await时\",{\"1\":{\"142\":1}}],[\"当前线程a等待thread线程终止之后才从thread\",{\"1\":{\"138\":1}}],[\"当前线程a等待thread线程终止之后从thread\",{\"1\":{\"131\":1}}],[\"当任务无法被执行时\",{\"1\":{\"236\":3}}],[\"当任务无法被接受执行时的处理策略\",{\"1\":{\"235\":1}}],[\"当核心线程都在忙碌\",{\"1\":{\"235\":1}}],[\"当线程池中存在一个调用特别耗时的\",{\"1\":{\"266\":1}}],[\"当线程池中的线程数超过核心线程数时\",{\"1\":{\"195\":1}}],[\"当线程池在\",{\"1\":{\"259\":1,\"260\":1}}],[\"当线程取出任务后\",{\"1\":{\"241\":1}}],[\"当线程数超过核心线程数时\",{\"1\":{\"235\":1}}],[\"当线程a运行时\",{\"1\":{\"131\":1}}],[\"当所有线程都在忙碌时\",{\"1\":{\"190\":1}}],[\"当所有等待线程都被释放后\",{\"1\":{\"142\":1}}],[\"当队列已满时\",{\"1\":{\"187\":1,\"237\":1}}],[\"当队列为空时\",{\"1\":{\"187\":1}}],[\"当一个大任务到来时\",{\"1\":{\"267\":1}}],[\"当一个任务被提交到线程池后\",{\"1\":{\"231\":1}}],[\"当一个线程执行put操作导致扩容时\",{\"1\":{\"332\":1}}],[\"当一个线程执行完一个小任务后\",{\"1\":{\"267\":1}}],[\"当一个线程获取了对象的内置锁时\",{\"1\":{\"272\":1}}],[\"当一个线程因为等待某些事件\",{\"1\":{\"136\":1}}],[\"当一个线程的时间片用完时\",{\"1\":{\"136\":1}}],[\"当一个线程调用了\",{\"1\":{\"136\":1}}],[\"当一个线程调用\",{\"1\":{\"131\":1}}],[\"当一个线程a调用一个共享变量的\",{\"1\":{\"131\":1}}],[\"当一个执行中的线程a调用了thread的sleep方法后\",{\"1\":{\"131\":1}}],[\"当一个类的实例被序列化后\",{\"1\":{\"68\":1}}],[\"当一个类被序列化后\",{\"1\":{\"68\":1}}],[\"当其它线程读取该共享变量\",{\"1\":{\"110\":1}}],[\"当传递对象引用时\",{\"1\":{\"98\":1}}],[\"当传递基本数据类型\",{\"1\":{\"98\":1}}],[\"当对象被反序列化时\",{\"1\":{\"68\":1}}],[\"当反序列化时\",{\"1\":{\"68\":1}}],[\"当运算符放在变量之后时\",{\"1\":{\"57\":1}}],[\"当我们定义了\",{\"1\":{\"35\":1}}],[\"当有任务需要执行时\",{\"1\":{\"241\":1}}],[\"当有新任务提交时\",{\"1\":{\"235\":1,\"242\":3}}],[\"当有新的连接请求到达时\",{\"1\":{\"30\":1}}],[\"当有其他线程向队列中添加或取出元素时\",{\"1\":{\"187\":1}}],[\"当有事件触发时\",{\"1\":{\"30\":1}}],[\"当某个通道\",{\"1\":{\"30\":1}}],[\"不存在就再插入链表\",{\"1\":{\"335\":1}}],[\"不过其他三个条件都是有办法破坏掉的\",{\"1\":{\"299\":1}}],[\"不可剥夺\",{\"1\":{\"299\":1}}],[\"不可剥夺条件\",{\"1\":{\"299\":1}}],[\"不可变\",{\"1\":{\"60\":1}}],[\"不需要移动元素\",{\"1\":{\"302\":1}}],[\"不需要像synchronized关键字那样对整个代码块进行加锁\",{\"1\":{\"297\":1}}],[\"不需要并发执行的场景\",{\"1\":{\"242\":1}}],[\"不必唤醒所有线程\",{\"1\":{\"286\":1}}],[\"不再有任何活动线程\",{\"1\":{\"260\":1}}],[\"不再执行任何代码\",{\"1\":{\"134\":1}}],[\"不再执行下面的代码\",{\"1\":{\"55\":1}}],[\"不再执行循环\",{\"1\":{\"55\":1}}],[\"不处理队列中的任务\",{\"1\":{\"258\":1}}],[\"不接受新任务\",{\"1\":{\"257\":1,\"258\":1}}],[\"不方便\",{\"1\":{\"130\":1}}],[\"不为空\",{\"1\":{\"123\":1}}],[\"不擅技术\",{\"1\":{\"122\":1}}],[\"不管\",{\"1\":{\"269\":1}}],[\"不管jvm的内存空间是否充足\",{\"1\":{\"116\":1}}],[\"不管怎么重排序\",{\"1\":{\"108\":1}}],[\"不推荐使用\",{\"1\":{\"95\":1,\"308\":1}}],[\"不属于类的任何一个对象\",{\"1\":{\"93\":1}}],[\"不能在多线程下发生并发修改\",{\"1\":{\"307\":1}}],[\"不能依赖于这个异常是否抛出而进行并发操作的编程\",{\"1\":{\"307\":1}}],[\"不能保证原子性\",{\"1\":{\"104\":2}}],[\"不能被访问控制修饰符及static所修饰\",{\"1\":{\"92\":1}}],[\"不能有其他类型的变量\",{\"1\":{\"91\":1}}],[\"不能实现\",{\"1\":{\"91\":1}}],[\"不能修饰外部类\",{\"1\":{\"89\":2}}],[\"不能修饰类和方法\",{\"1\":{\"68\":1}}],[\"不使用任何修饰符\",{\"1\":{\"89\":1}}],[\"不允许键和值为null\",{\"1\":{\"83\":1}}],[\"不会抛出异常也不会进行任何处理\",{\"1\":{\"236\":1}}],[\"不会被其他线程中断\",{\"1\":{\"103\":1}}],[\"不会写入\",{\"1\":{\"81\":1}}],[\"不会出现线程安全问题\",{\"1\":{\"59\":1}}],[\"不包含静态变量\",{\"1\":{\"68\":1}}],[\"不行\",{\"1\":{\"59\":1}}],[\"不是通过插入顺序遍历\",{\"1\":{\"339\":1}}],[\"不是线程安全的\",{\"1\":{\"332\":1}}],[\"不是引用指向的内容的不可变\",{\"1\":{\"94\":1}}],[\"不是\",{\"1\":{\"59\":1}}],[\"不同的线程在同一个计数器上\",{\"1\":{\"143\":1}}],[\"不同的是\",{\"1\":{\"131\":1}}],[\"不同的jvm\",{\"1\":{\"39\":1}}],[\"不同于在共享变量上调用\",{\"1\":{\"131\":1}}],[\"不同系统安装不同java虚拟机\",{\"1\":{\"40\":1}}],[\"不断监听通道列表\",{\"1\":{\"30\":1}}],[\"不要动gh\",{\"0\":{\"22\":1}}],[\"以平衡性能和空间的消耗\",{\"1\":{\"330\":1}}],[\"以atomicinteger的添加方法为例\",{\"1\":{\"298\":1}}],[\"以apache\",{\"1\":{\"215\":1}}],[\"以上代码示例演示了如何使用fork\",{\"1\":{\"267\":1}}],[\"以确保任务的一致性和可靠性\",{\"1\":{\"265\":1}}],[\"以确保线程安全\",{\"1\":{\"308\":1}}],[\"以确保线程池能够始终保持良好的性能和稳定性\",{\"1\":{\"263\":1}}],[\"以确保线程状态的一致性\",{\"1\":{\"203\":1}}],[\"以适应系统的动态变化和优化性能\",{\"1\":{\"263\":1}}],[\"以满足系统的性能需求和稳定性要求\",{\"1\":{\"263\":1}}],[\"以满足不同应用场景的需求\",{\"1\":{\"196\":1}}],[\"以避免任务被拒绝\",{\"1\":{\"240\":1}}],[\"以避免任务等待时间过长\",{\"1\":{\"240\":1}}],[\"以保证任务的一致性和可靠性\",{\"1\":{\"265\":1}}],[\"以保证线程池的性能和稳定性\",{\"1\":{\"240\":1}}],[\"以保证系统的稳定性和可靠性\",{\"1\":{\"236\":1}}],[\"以保证合理的使用公共资源\",{\"1\":{\"144\":1}}],[\"以优化线程池的性能和资源利用率\",{\"1\":{\"235\":1}}],[\"以更灵活地控制线程池的行为\",{\"1\":{\"196\":1}}],[\"以下是处理单机线程池断电情况的一般策略\",{\"1\":{\"265\":1}}],[\"以下是线程池状态的转换图\",{\"1\":{\"261\":1}}],[\"以下是线程池在各种工作场景中的一些典型应用\",{\"1\":{\"207\":1}}],[\"以下是详细的线程池状态\",{\"1\":{\"255\":1}}],[\"以下是一些处理线程池异常的常见方法和技巧\",{\"1\":{\"248\":1}}],[\"以下是一个使用调度线程池执行定时任务的示例\",{\"1\":{\"227\":1}}],[\"以下是一个使用线程池执行异步任务的示例\",{\"1\":{\"223\":1}}],[\"以下是一个使用线程池并行处理数据块的示例\",{\"1\":{\"219\":1}}],[\"以下是一个使用线程池处理http请求的简单示例\",{\"1\":{\"211\":1}}],[\"以下是一个使用固定大小线程池执行多个任务的示例\",{\"1\":{\"194\":1}}],[\"以下是一个完整的示例\",{\"1\":{\"179\":1}}],[\"以下是一个简单的线程池的设计和实现\",{\"1\":{\"264\":1}}],[\"以下是一个简单的\",{\"1\":{\"148\":1}}],[\"以下是常见的线程池拒绝策略\",{\"1\":{\"236\":1}}],[\"以下是如何设置和使用自定义线程池的详细指南\",{\"1\":{\"174\":1}}],[\"以下示例展示如何并行获取多个远程数据源的数据\",{\"1\":{\"172\":1}}],[\"以提高查找\",{\"1\":{\"312\":1,\"330\":1}}],[\"以提高系统的性能和效率\",{\"1\":{\"135\":1}}],[\"以提高性能和节省内存\",{\"1\":{\"59\":1}}],[\"以便更快地停止线程池\",{\"1\":{\"239\":1}}],[\"以便该线程可以继续执行\",{\"1\":{\"135\":1}}],[\"以便选择器可以监听多个通道的事件\",{\"1\":{\"30\":1}}],[\"以及一级缓存\",{\"1\":{\"102\":1}}],[\"以及不写\",{\"0\":{\"89\":1}}],[\"以及无法使用基本类型作为泛型参数等\",{\"1\":{\"79\":1}}],[\"以前\",{\"1\":{\"54\":1}}],[\"以接口的全限定名命名\",{\"1\":{\"44\":1}}],[\"以备后续操作\",{\"1\":{\"30\":1}}],[\"发现是a就会执行修改\",{\"1\":{\"291\":1}}],[\"发送邮件给\",{\"1\":{\"223\":1}}],[\"发起进攻\",{\"1\":{\"140\":1}}],[\"发起连接请求\",{\"1\":{\"30\":1}}],[\"发生哈希碰撞的概率就降低了\",{\"1\":{\"328\":1}}],[\"发生概率仅为0\",{\"1\":{\"326\":1}}],[\"发生异常\",{\"1\":{\"164\":1,\"165\":1}}],[\"发生下面几种情况才会返回\",{\"1\":{\"131\":1}}],[\"发生在具有继承关系的父子类中\",{\"1\":{\"88\":1}}],[\"发生在同一个类中\",{\"1\":{\"88\":1}}],[\"发布完成后\",{\"1\":{\"21\":1}}],[\"发布到github\",{\"0\":{\"15\":1}}],[\"客户端发送的连接请求会注册到多路复用器上\",{\"1\":{\"30\":1}}],[\"客户端有连接请求时服务器端就需要启动一个线程进行处理\",{\"1\":{\"30\":1}}],[\"尤其是当涉及到国际化和本地化时\",{\"1\":{\"29\":1}}],[\"这块结构会随着锁的状态变化而变化\",{\"1\":{\"277\":1}}],[\"这包括调整核心线程数\",{\"1\":{\"263\":1}}],[\"这包括确定核心线程数\",{\"1\":{\"263\":1}}],[\"这是对\",{\"1\":{\"328\":1}}],[\"这是线程池的最终状态\",{\"1\":{\"260\":1}}],[\"这是线程池的初始状态\",{\"1\":{\"256\":1}}],[\"这是java的规定\",{\"1\":{\"97\":1}}],[\"这可以防止异常传播到线程池外部\",{\"1\":{\"249\":1}}],[\"这可能需要数分钟\",{\"1\":{\"11\":1}}],[\"这两种方法都是用来关闭线程池的\",{\"1\":{\"239\":1}}],[\"这两种状态的区别在于阻塞状态是等待获取锁\",{\"1\":{\"133\":1}}],[\"这样做可以减少链表或红黑树的重新排序次数\",{\"1\":{\"330\":1}}],[\"这样做可能会导致调用线程的性能下降\",{\"1\":{\"236\":1}}],[\"这样使得哈希值的分布更加均匀\",{\"1\":{\"321\":1}}],[\"这样的设计增加了哈希值的随机性\",{\"1\":{\"320\":1}}],[\"这样线性化后就不存在环路了\",{\"1\":{\"299\":1}}],[\"这样不可抢占这个条件就破坏掉了\",{\"1\":{\"299\":1}}],[\"这样就保证了同一时间只有一个线程能够访问该对象的同步代码块或同步方法\",{\"1\":{\"272\":1}}],[\"这样可以提高序列化和反序列化的效率\",{\"1\":{\"305\":1}}],[\"这样可以减少对耗时\",{\"1\":{\"266\":1}}],[\"这样可以避免线程被长时间阻塞\",{\"1\":{\"266\":1}}],[\"这样可以避免阻塞线程池中的其他任务\",{\"1\":{\"266\":1}}],[\"这样可以利用多个线程同时执行任务\",{\"1\":{\"266\":1}}],[\"这样即使发生断电\",{\"1\":{\"265\":1}}],[\"这样\",{\"1\":{\"241\":1}}],[\"这样设计的原因\",{\"1\":{\"59\":1}}],[\"这对于大多数情况已经足够\",{\"1\":{\"175\":1}}],[\"这时候会交换两人的数据\",{\"1\":{\"150\":1}}],[\"这才起到多线程的效果\",{\"1\":{\"129\":1}}],[\"这种查找\",{\"1\":{\"302\":1}}],[\"这种锁被称之为重量级锁\",{\"1\":{\"278\":1}}],[\"这种情况称为可重入锁\",{\"1\":{\"276\":1}}],[\"这种方式使得参数的修改更加便捷\",{\"1\":{\"262\":1}}],[\"这种方式可以通过反射机制来实现\",{\"1\":{\"262\":1}}],[\"这种方式可以通过futuretask获取任务执行的返回值\",{\"1\":{\"128\":1}}],[\"这种任务可以返回结果\",{\"1\":{\"238\":1}}],[\"这种任务不返回结果\",{\"1\":{\"238\":1}}],[\"这种字节码必须再经过jvm\",{\"1\":{\"42\":1}}],[\"这就要求有两个cpu去分别执行两个线程\",{\"1\":{\"126\":1}}],[\"这就是所谓的工作窃取\",{\"1\":{\"267\":1}}],[\"这就是注解的用处\",{\"1\":{\"81\":1}}],[\"这就是泛型擦除\",{\"1\":{\"79\":1}}],[\"这就是通过字符串常量池来实现的\",{\"1\":{\"59\":1}}],[\"这\",{\"1\":{\"116\":1}}],[\"这使得submit\",{\"1\":{\"238\":1}}],[\"这使得加载和存储操作看上去可能是在乱序执行\",{\"1\":{\"106\":1}}],[\"这使得字符流在处理文本数据时更方便和高效\",{\"1\":{\"29\":1}}],[\"这些方法都是原子性的\",{\"1\":{\"297\":1}}],[\"这些类都提供了一些原子操作方法\",{\"1\":{\"297\":1}}],[\"这些子问题相互独立且与原问题性质相同\",{\"1\":{\"267\":1}}],[\"这些状态有助于管理线程池的生命周期和行为\",{\"1\":{\"255\":1}}],[\"这些不同类型的工作队列具有不同的特性和适用场景\",{\"1\":{\"237\":1}}],[\"这些参数可以根据应用场景的需求进行调整和配置\",{\"1\":{\"235\":1}}],[\"这些参数通常包括核心线程数\",{\"1\":{\"229\":1}}],[\"这些任务不需要立即完成\",{\"1\":{\"221\":1}}],[\"这些短生命周期的对象会加大垃圾回收的压力\",{\"1\":{\"205\":1}}],[\"这些同步操作会导致锁的竞争和开销\",{\"1\":{\"203\":1}}],[\"这些结构用于线程调度和管理\",{\"1\":{\"200\":1}}],[\"这些线程会一直相互等待而无法继续运行下去\",{\"1\":{\"299\":1}}],[\"这些线程在处理完一个任务后不会被销毁\",{\"1\":{\"190\":1}}],[\"这些线程必须调用await\",{\"1\":{\"143\":1}}],[\"这些操作就可能被编译器和处理器重排序\",{\"1\":{\"108\":1}}],[\"这些操作可能是\",{\"1\":{\"36\":1}}],[\"这些硬件组件对应着jmm中的工作内存\",{\"1\":{\"102\":1}}],[\"这里异常的抛出条件是检测到\",{\"1\":{\"307\":1}}],[\"这里的threadlocalhashcode计算有点东西\",{\"1\":{\"119\":1}}],[\"这里的不可变指的是变量的引用不可变\",{\"1\":{\"94\":1}}],[\"这里可能会涉及多层递归\",{\"1\":{\"99\":1}}],[\"这意味着它不能被继承\",{\"1\":{\"59\":1}}],[\"这个问题在jdk1\",{\"1\":{\"332\":2}}],[\"这个\",{\"1\":{\"327\":1}}],[\"这个异常只建议用于检测并发修改的bug\",{\"1\":{\"307\":1}}],[\"这个接口只是用来标识是否支持随机访问\",{\"1\":{\"302\":1}}],[\"这个接口是服务的契约\",{\"1\":{\"44\":1}}],[\"这个条件\",{\"1\":{\"299\":3,\"307\":1}}],[\"这个方向基本上是不可逆的\",{\"1\":{\"279\":1}}],[\"这个方法返回一个线程安全的map对象\",{\"1\":{\"333\":1}}],[\"这个方法返回的对象可能是空\",{\"1\":{\"35\":1}}],[\"这个方法相比\",{\"1\":{\"131\":1}}],[\"这个方法在\",{\"1\":{\"95\":1}}],[\"这个标识指明了该方法是一个同步方法\",{\"1\":{\"271\":1}}],[\"这个过程也是递归的\",{\"1\":{\"267\":1}}],[\"这个过程是递归的\",{\"1\":{\"267\":1}}],[\"这个简单的线程池实现了基本的功能\",{\"1\":{\"264\":1}}],[\"这个流程保证了线程资源的高效利用和任务的有效调度\",{\"1\":{\"234\":1}}],[\"这个结构被附带在线程上\",{\"1\":{\"138\":1}}],[\"这个数字\",{\"1\":{\"119\":1}}],[\"这个值很特殊\",{\"1\":{\"119\":1}}],[\"这也是在\",{\"1\":{\"35\":1}}],[\"视频等\",{\"1\":{\"29\":1}}],[\"音频\",{\"1\":{\"29\":1}}],[\"为null\",{\"1\":{\"281\":1}}],[\"为\",{\"1\":{\"116\":1}}],[\"为程序员提供一致的内存可见性保证\",{\"1\":{\"106\":1}}],[\"为了减少哈希冲突发生的概率\",{\"1\":{\"327\":1,\"329\":1}}],[\"为了减少窃取任务线程和被窃取任务线程之间的竞争\",{\"1\":{\"267\":1}}],[\"为了优化这种情况\",{\"1\":{\"266\":1}}],[\"为了避免错误\",{\"1\":{\"150\":1}}],[\"为了避免这种问题\",{\"1\":{\"68\":1}}],[\"为了实现volatile的内存语义\",{\"1\":{\"111\":1}}],[\"为了遵守as\",{\"1\":{\"108\":1}}],[\"为了提高性能\",{\"1\":{\"106\":1}}],[\"为了保证原子性\",{\"1\":{\"103\":1}}],[\"为了保证线程安全性\",{\"1\":{\"60\":1}}],[\"为什么\",{\"0\":{\"330\":1}}],[\"为什么扩容因子是0\",{\"0\":{\"327\":1}}],[\"为什么hashmap链表转红黑树的阈值为8呢\",{\"0\":{\"326\":1}}],[\"为什么hashmap的容量是2的倍数呢\",{\"0\":{\"322\":1}}],[\"为什么哈希\",{\"0\":{\"321\":1}}],[\"为什么不用平衡二叉树\",{\"0\":{\"316\":1}}],[\"为什么不用二叉树\",{\"0\":{\"313\":1,\"315\":1}}],[\"为什么最arraylist不直接序列化元素数组呢\",{\"0\":{\"305\":1}}],[\"为什么用transient修饰数组\",{\"0\":{\"304\":1}}],[\"为什么我们不能直接调用run\",{\"1\":{\"129\":1}}],[\"为什么调用start\",{\"0\":{\"129\":1}}],[\"为什么key还要设计成弱引用\",{\"0\":{\"118\":1}}],[\"为什么重写\",{\"1\":{\"97\":1}}],[\"为什么说频繁创建和销毁线程的开销大\",{\"0\":{\"197\":1}}],[\"为什么说\",{\"0\":{\"42\":1}}],[\"为什么还要有字符流\",{\"0\":{\"29\":1}}],[\"为change\",{\"1\":{\"20\":1}}],[\"字符串拼接是如何实现的\",{\"0\":{\"62\":1}}],[\"字符串对象实例\",{\"1\":{\"61\":1}}],[\"字符串常量池的优化\",{\"1\":{\"59\":1}}],[\"字符串的不可变性\",{\"1\":{\"59\":1}}],[\"字符型\",{\"1\":{\"50\":1}}],[\"字符流会自动处理字符编码和解码\",{\"1\":{\"29\":1}}],[\"字符流以字符为单位进行输入输出\",{\"1\":{\"29\":1}}],[\"字符流更适合读取和写入文本文件\",{\"1\":{\"29\":1}}],[\"字符流\",{\"1\":{\"28\":1,\"29\":1}}],[\"字段\",{\"1\":{\"48\":1}}],[\"字节\",{\"1\":{\"50\":1}}],[\"字节码能够被虚拟机识别\",{\"1\":{\"41\":1}}],[\"字节流通常用于处理文件和网络连接中的数据传输\",{\"1\":{\"29\":1}}],[\"字节流以字节为单位进行输入输出\",{\"1\":{\"29\":1}}],[\"字节流则更适合处理二进制数据\",{\"1\":{\"29\":1}}],[\"字节流\",{\"1\":{\"28\":1,\"29\":1}}],[\"前阻塞\",{\"1\":{\"142\":1}}],[\"前两种面向字节\",{\"1\":{\"138\":1}}],[\"前会先执行\",{\"1\":{\"74\":1}}],[\"前缀\",{\"1\":{\"57\":1}}],[\"前者是字节输出流\",{\"1\":{\"28\":1}}],[\"前者是字节输入流\",{\"1\":{\"28\":1}}],[\"前端\",{\"2\":{\"25\":1}}],[\"所谓按序申请\",{\"1\":{\"299\":1}}],[\"所谓的公平锁就是先等待的线程先获得锁\",{\"1\":{\"282\":1}}],[\"所谓多态就是指程序中定义的引⽤变量所指向的具体类型和通过该引⽤变量发出的⽅法调⽤在编程时并不确定\",{\"1\":{\"87\":1}}],[\"所以get是不需要加锁的\",{\"1\":{\"335\":1}}],[\"所以转红黑树\",{\"1\":{\"326\":1}}],[\"所以传入17\",{\"1\":{\"323\":1}}],[\"所以对扰动函数通过对哈希值进行变换\",{\"1\":{\"321\":1}}],[\"所以在遍历过程中对原集合所作的修改并不能被迭代器检测到\",{\"1\":{\"307\":1}}],[\"所以每个节点会占用更多的空间\",{\"1\":{\"302\":1}}],[\"所以它没法根据序号直接获取元素\",{\"1\":{\"302\":1}}],[\"所以它可以根据下标查找\",{\"1\":{\"302\":1}}],[\"所以当前线程会被阻塞\",{\"1\":{\"299\":1}}],[\"所以synchronized保证的有序是执行结果的有序性\",{\"1\":{\"275\":1}}],[\"所以synchronized保证同一时刻\",{\"1\":{\"275\":1}}],[\"所以我们就知道了\",{\"1\":{\"272\":1}}],[\"所以任务直接加到synchronousqueue队列\",{\"1\":{\"245\":1}}],[\"所以无法响应中断的任务可能永远无法终止\",{\"1\":{\"239\":1}}],[\"所以基本对于用户是无感知的\",{\"1\":{\"126\":1}}],[\"所以不会触发concurrent\",{\"1\":{\"307\":1}}],[\"所以不会再次调用\",{\"1\":{\"95\":1}}],[\"所以不能使用private修饰符\",{\"1\":{\"91\":1}}],[\"所以即使\",{\"1\":{\"74\":1}}],[\"所以是先输出\",{\"1\":{\"74\":1}}],[\"所以进程可能会看似未响应\",{\"1\":{\"11\":1}}],[\"所拥有的⼀\",{\"1\":{\"39\":1}}],[\"所有任务都已完成\",{\"1\":{\"259\":1}}],[\"所有任务按照顺序在这个线程中执行\",{\"1\":{\"242\":1}}],[\"所有的线程完成任务\",{\"1\":{\"143\":1}}],[\"所有的输入流的基类\",{\"1\":{\"28\":1}}],[\"所有线程到达屏障点后执行的代码\",{\"1\":{\"142\":1}}],[\"所有线程到达屏障点时执行\",{\"1\":{\"142\":1}}],[\"所有线程已到达屏障点\",{\"1\":{\"142\":5}}],[\"所有被屏障拦截的线程才会继续运行\",{\"1\":{\"141\":1}}],[\"所有玩家已经就位\",{\"1\":{\"140\":1}}],[\"所有对象共享同一份静态变量的拷贝\",{\"1\":{\"92\":1}}],[\"所有输出流的基类\",{\"1\":{\"28\":1}}],[\"输出流主要包括了如下4种具体实现\",{\"1\":{\"138\":1}}],[\"输出流不同之处在于\",{\"1\":{\"138\":1}}],[\"输出流或者网络输入\",{\"1\":{\"138\":1}}],[\"输出流和普通的文件输入\",{\"1\":{\"138\":1}}],[\"输出流\",{\"1\":{\"28\":1,\"138\":1}}],[\"输入流\",{\"1\":{\"28\":1}}],[\"中间可能发生了a变b\",{\"1\":{\"291\":1}}],[\"中间操作\",{\"1\":{\"36\":1}}],[\"中会将竞争共享资源失败的线程添加到队列中\",{\"1\":{\"283\":1}}],[\"中断处理\",{\"1\":{\"150\":1}}],[\"中断\",{\"1\":{\"146\":1}}],[\"中断线程\",{\"1\":{\"131\":1}}],[\"中的⽅法\",{\"1\":{\"341\":1}}],[\"中的一个同步辅助类\",{\"1\":{\"147\":1}}],[\"中的线程中断是一种线程间的协作模式\",{\"1\":{\"131\":1}}],[\"中的集合类\",{\"1\":{\"97\":1}}],[\"中了\",{\"1\":{\"121\":1}}],[\"中所有的\",{\"1\":{\"121\":1}}],[\"中有两种形式可以实现多态\",{\"1\":{\"87\":1}}],[\"中异常层级结构\",{\"0\":{\"71\":1}}],[\"中引入了枚举类型\",{\"1\":{\"54\":1}}],[\"中文翻译为\",{\"1\":{\"36\":1}}],[\"中字符串开头为\",{\"1\":{\"36\":1}}],[\"中通道的读写事件\",{\"1\":{\"30\":1}}],[\"中\",{\"0\":{\"28\":1},\"1\":{\"30\":1,\"36\":2,\"54\":1,\"102\":1,\"272\":1,\"337\":1,\"339\":1}}],[\"just\",{\"1\":{\"336\":1}}],[\"jstack\",{\"1\":{\"300\":1}}],[\"json序列化\",{\"1\":{\"69\":1}}],[\"json\",{\"1\":{\"11\":1}}],[\"jps\",{\"1\":{\"300\":1}}],[\"jit\",{\"1\":{\"206\":1}}],[\"jit优化\",{\"0\":{\"206\":1}}],[\"join任务\",{\"1\":{\"267\":1}}],[\"join框架来计算斐波那契数列的值\",{\"1\":{\"267\":2}}],[\"join框架中表示任务的抽象类\",{\"1\":{\"267\":1}}],[\"join框架会将这个大任务拆分成若干个小任务\",{\"1\":{\"267\":1}}],[\"join框架的线程池实现\",{\"1\":{\"267\":1}}],[\"join框架的关键组件包括\",{\"1\":{\"267\":1}}],[\"join框架的工作原理如下\",{\"1\":{\"267\":1}}],[\"join框架的定义\",{\"1\":{\"267\":1}}],[\"join框架\",{\"1\":{\"267\":1}}],[\"join框架是java7提供的一个用于并行执行任务的框架\",{\"1\":{\"267\":1}}],[\"join框架了解吗\",{\"0\":{\"267\":1}}],[\"join\",{\"1\":{\"107\":3,\"131\":3,\"133\":1,\"138\":3,\"170\":1,\"172\":1,\"267\":3}}],[\"josh\",{\"1\":{\"32\":1}}],[\"j\",{\"1\":{\"104\":1}}],[\"jmm属于语言级的内存模型\",{\"1\":{\"106\":1}}],[\"jmm的很多技术都是围绕着这三大特性展开\",{\"1\":{\"103\":1}}],[\"jmm定义了线程和主内存之间的抽象关系\",{\"1\":{\"102\":1}}],[\"jmm\",{\"0\":{\"102\":1},\"1\":{\"102\":1}}],[\"jdbc\",{\"1\":{\"215\":1}}],[\"jdb\",{\"1\":{\"39\":1}}],[\"jdk5之前是没有泛型\",{\"1\":{\"79\":1}}],[\"jdk包含jre\",{\"1\":{\"39\":1}}],[\"jdk\",{\"0\":{\"39\":1},\"1\":{\"39\":1,\"91\":1,\"330\":3}}],[\"jdk11使用byte\",{\"1\":{\"60\":1}}],[\"jdk1\",{\"0\":{\"31\":1,\"32\":1,\"330\":1,\"335\":1,\"336\":1},\"1\":{\"30\":1,\"312\":2,\"332\":1,\"335\":1}}],[\"jre包含jvm\",{\"1\":{\"39\":1}}],[\"jre\",{\"0\":{\"39\":1},\"1\":{\"39\":2}}],[\"jvm先检查对象markword是否指向当前线程栈帧中的锁记录\",{\"1\":{\"281\":1}}],[\"jvm使用cas操作将对象头markword更新为指向锁记录的指针\",{\"1\":{\"281\":1}}],[\"jvm会判断是否已经是重量级锁\",{\"1\":{\"281\":1}}],[\"jvm会正常退出\",{\"1\":{\"137\":1}}],[\"jvm采用\",{\"1\":{\"271\":2}}],[\"jvm中的即时编译器\",{\"1\":{\"206\":1}}],[\"jvm的开销\",{\"0\":{\"204\":1}}],[\"jvm退出\",{\"1\":{\"137\":1}}],[\"jvm执行start方法\",{\"1\":{\"129\":1}}],[\"jvm\",{\"0\":{\"39\":1},\"1\":{\"39\":2,\"48\":1,\"64\":1,\"74\":1}}],[\"java集合\",{\"0\":{\"348\":1}}],[\"java并发\",{\"0\":{\"347\":1}}],[\"java基础\",{\"0\":{\"345\":1}}],[\"java有哪些保证原子性的方法\",{\"0\":{\"296\":1}}],[\"java有哪些数据类型\",{\"0\":{\"50\":1}}],[\"java提供了atomicstampreference类\",{\"1\":{\"292\":1}}],[\"java提供了字符流\",{\"1\":{\"29\":1}}],[\"java对象头里\",{\"1\":{\"277\":1}}],[\"java对象流序列化是java标准库提供的一种序列化方式\",{\"1\":{\"69\":1}}],[\"java对象流序列化\",{\"1\":{\"69\":1}}],[\"java通过java\",{\"1\":{\"192\":1}}],[\"java线程将操作系统中的就绪和运行两种状态笼\",{\"1\":{\"132\":1}}],[\"java内存模型通过定义内存间的交互操作规则\",{\"1\":{\"102\":1}}],[\"java内存模型的抽象图\",{\"1\":{\"102\":1}}],[\"java内存模型\",{\"0\":{\"101\":1},\"1\":{\"102\":1}}],[\"java语言是值传递\",{\"1\":{\"98\":1}}],[\"java语言有哪些特点\",{\"0\":{\"38\":1}}],[\"java是值传递\",{\"0\":{\"98\":1}}],[\"java中提供了多种原子操作类\",{\"1\":{\"297\":1}}],[\"java中的forkjoinpool使用工作窃取队列来实现任务的并行执行\",{\"1\":{\"237\":1}}],[\"java中的delayed接口和delayedworkqueue类用于实现延迟队列\",{\"1\":{\"237\":1}}],[\"java中的priorityblockingqueue是一个线程安全的优先级队列实现\",{\"1\":{\"237\":1}}],[\"java中的线程池实现\",{\"0\":{\"192\":1}}],[\"java中的线程分为两类\",{\"1\":{\"137\":1}}],[\"java中序列化可以通过实现externalizable或者serializable来实现\",{\"1\":{\"100\":1}}],[\"java中实现map接口的有哪些类\",{\"0\":{\"83\":1}}],[\"java中可以使用google提供的protobuf\",{\"1\":{\"69\":1}}],[\"java中可以使用第三方库\",{\"1\":{\"69\":3}}],[\"java注解本质上是一个标记\",{\"1\":{\"81\":1}}],[\"java泛型是java\",{\"1\":{\"76\":1}}],[\"java库\",{\"1\":{\"69\":1}}],[\"java序列化可以将对象序列化为字节流\",{\"1\":{\"69\":1}}],[\"java序列化只会保存对象的非静态成员变量\",{\"1\":{\"68\":1}}],[\"java可以对字符串进行缓存和共享\",{\"1\":{\"59\":1}}],[\"java5\",{\"1\":{\"54\":1}}],[\"java的spi机制会使用服务加载器加载这些配置文件\",{\"1\":{\"44\":1}}],[\"java的spi\",{\"1\":{\"44\":1}}],[\"javadoc\",{\"1\":{\"39\":1}}],[\"javac\",{\"1\":{\"39\":1}}],[\"java程序运行在java虚拟机上\",{\"1\":{\"39\":1}}],[\"java虚拟机\",{\"1\":{\"39\":1}}],[\"java概述\",{\"0\":{\"37\":1}}],[\"java8有哪些内置函数式接口\",{\"0\":{\"34\":1}}],[\"java\",{\"0\":{\"28\":1,\"42\":1,\"59\":1,\"71\":1,\"100\":1,\"346\":1},\"1\":{\"30\":1,\"32\":3,\"35\":1,\"36\":1,\"39\":7,\"41\":2,\"42\":2,\"54\":3,\"68\":1,\"78\":3,\"79\":1,\"87\":1,\"95\":1,\"97\":1,\"102\":1,\"131\":1,\"147\":1,\"148\":1,\"170\":4,\"172\":4,\"177\":2,\"179\":4,\"194\":3,\"196\":3,\"211\":5,\"215\":4,\"219\":5,\"223\":2,\"227\":3,\"254\":1,\"255\":1,\"264\":2,\"267\":1,\"307\":2}}],[\"javascript\",{\"2\":{\"26\":1}}],[\"踩了一些坑\",{\"1\":{\"24\":1}}],[\"踩坑\",{\"0\":{\"24\":1}}],[\"默认的segment长度是16\",{\"1\":{\"335\":1}}],[\"默认的拒绝策略\",{\"1\":{\"236\":1}}],[\"默认10次\",{\"1\":{\"281\":1}}],[\"默认策略\",{\"1\":{\"236\":1}}],[\"默认情况下\",{\"1\":{\"175\":1,\"199\":1}}],[\"默认情况类没有覆盖\",{\"1\":{\"96\":1}}],[\"默认\",{\"0\":{\"89\":1}}],[\"默认范围是\",{\"1\":{\"64\":1}}],[\"默认值\",{\"1\":{\"23\":1,\"50\":1,\"92\":1,\"164\":1}}],[\"默认为\",{\"1\":{\"11\":1}}],[\"修饰存储元素的\",{\"1\":{\"304\":1}}],[\"修饰代码块\",{\"1\":{\"269\":1}}],[\"修饰静态方法\",{\"1\":{\"269\":1}}],[\"修饰实例方法\",{\"1\":{\"269\":1}}],[\"修饰的\",{\"1\":{\"283\":1}}],[\"修饰的变量不可变\",{\"1\":{\"95\":1}}],[\"修饰的变量值不会被持久化和恢复\",{\"1\":{\"68\":1}}],[\"修饰的方法不可被重写\",{\"1\":{\"95\":1}}],[\"修饰符修饰的变量\",{\"1\":{\"93\":1}}],[\"修复\",{\"0\":{\"23\":1}}],[\"修改同步状态成功即为获得锁\",{\"1\":{\"283\":1}}],[\"修改是无效的\",{\"1\":{\"74\":1}}],[\"修改theme\",{\"1\":{\"23\":1}}],[\"修改\",{\"0\":{\"16\":1,\"17\":1},\"1\":{\"283\":1,\"307\":1}}],[\"需要注意的是value是volatile的\",{\"1\":{\"335\":1}}],[\"需要更多的旋转操作来保持平衡\",{\"1\":{\"316\":1}}],[\"需要存储前驱和后继\",{\"1\":{\"302\":1}}],[\"需要遍历链表\",{\"1\":{\"302\":1}}],[\"需要一定的阻塞等待唤醒机制来保证锁的分配\",{\"1\":{\"283\":1}}],[\"需要子类自行实现\",{\"1\":{\"283\":2}}],[\"需要子类来实现\",{\"1\":{\"267\":1}}],[\"需要仔细观察线程池的运行情况\",{\"1\":{\"263\":1}}],[\"需要及时调整配置并重新测试\",{\"1\":{\"263\":1}}],[\"需要限制线程数量的场景\",{\"1\":{\"247\":1}}],[\"需要考虑以下几个因素\",{\"1\":{\"240\":1}}],[\"需要定期执行一些任务\",{\"1\":{\"225\":1}}],[\"需要执行一些异步任务\",{\"1\":{\"221\":1}}],[\"需要消耗较多的时间\",{\"1\":{\"213\":1}}],[\"需要保存当前线程的状态\",{\"1\":{\"202\":1}}],[\"需要保证线程安全\",{\"1\":{\"60\":1}}],[\"需要处理可能的\",{\"1\":{\"142\":1}}],[\"需要手动管理线程\",{\"1\":{\"130\":1}}],[\"需要使用锁来保护对队列数据结构的访问\",{\"1\":{\"187\":1}}],[\"需要使用\",{\"1\":{\"93\":1}}],[\"需要先创建对象然后通过对象才能访问到它\",{\"1\":{\"93\":1}}],[\"需要先进入项目目录\",{\"1\":{\"14\":1}}],[\"需要自行保证线程安全\",{\"1\":{\"60\":1}}],[\"需要强制转换\",{\"1\":{\"51\":1}}],[\"需要build成html文件和js才行\",{\"1\":{\"22\":1}}],[\"gc分代年龄\",{\"1\":{\"277\":1}}],[\"gc\",{\"1\":{\"95\":1,\"121\":1}}],[\"gson等\",{\"1\":{\"69\":1}}],[\"get查询\",{\"1\":{\"336\":1}}],[\"get流程\",{\"1\":{\"335\":1}}],[\"gettreenode\",{\"1\":{\"319\":1}}],[\"getnode\",{\"1\":{\"319\":2}}],[\"getname\",{\"1\":{\"142\":3,\"144\":3,\"148\":4,\"194\":1,\"196\":1,\"219\":1,\"264\":1}}],[\"getintvolatile\",{\"1\":{\"298\":1}}],[\"getanddecrement\",{\"1\":{\"298\":1}}],[\"getandset\",{\"1\":{\"297\":1}}],[\"getandaddint\",{\"1\":{\"298\":2}}],[\"getandadd\",{\"1\":{\"119\":1}}],[\"getruntime\",{\"1\":{\"227\":1}}],[\"getstring\",{\"1\":{\"215\":1}}],[\"getsystemclassloader\",{\"1\":{\"123\":1}}],[\"getcause\",{\"1\":{\"250\":1,\"254\":1}}],[\"getconnection\",{\"1\":{\"215\":1}}],[\"getcount\",{\"1\":{\"140\":1}}],[\"getclass\",{\"1\":{\"66\":1}}],[\"get\",{\"1\":{\"35\":1,\"113\":1,\"121\":1,\"122\":1,\"162\":3,\"170\":1,\"172\":3,\"250\":1,\"254\":1,\"302\":3,\"319\":1}}],[\"gh\",{\"1\":{\"22\":1}}],[\"git\",{\"1\":{\"11\":1}}],[\"gitee\",{\"1\":{\"1\":1}}],[\"github上开源\",{\"0\":{\"20\":1}}],[\"github\",{\"1\":{\"1\":1,\"8\":1,\"11\":1}}],[\"是基于红黑树实现的\",{\"1\":{\"339\":1}}],[\"是线程安全的吗\",{\"0\":{\"332\":1}}],[\"是因为如果这个阈值也设置成8\",{\"1\":{\"326\":1}}],[\"是则向树中插入节点\",{\"1\":{\"318\":1}}],[\"是黑色的\",{\"1\":{\"314\":1}}],[\"是的话就返回遍历\",{\"1\":{\"307\":1}}],[\"是指资源是有线性顺序的\",{\"1\":{\"299\":1}}],[\"是指程序执行的顺序与代码的顺序一致\",{\"1\":{\"103\":1}}],[\"是可重入锁\",{\"1\":{\"276\":1}}],[\"是类成员\",{\"1\":{\"269\":1}}],[\"是java提供的线程安全的哈希表实现\",{\"1\":{\"333\":1}}],[\"是java并发面试的高频题目\",{\"1\":{\"283\":1}}],[\"是java\",{\"1\":{\"152\":1}}],[\"是为成对线程设计的\",{\"1\":{\"150\":1}}],[\"是当最后一个非守护线程束时\",{\"1\":{\"137\":1}}],[\"是系统进行资源分配和调度的基本单位\",{\"1\":{\"127\":1}}],[\"是阿里巴巴开源的基于\",{\"1\":{\"124\":1}}],[\"是原子性操作\",{\"1\":{\"104\":1}}],[\"是在\",{\"1\":{\"95\":1}}],[\"是被\",{\"1\":{\"93\":1}}],[\"是程序无法处理的\",{\"1\":{\"71\":1}}],[\"是google开发的一种高效的序列化协议\",{\"1\":{\"69\":1}}],[\"是用来控制同时访问特定资源的线程数量\",{\"1\":{\"144\":1}}],[\"是用到了integer自动装箱的机制\",{\"1\":{\"64\":1}}],[\"是用于加载和实例化服务提供者的api\",{\"1\":{\"44\":1}}],[\"是用于防范\",{\"1\":{\"35\":1}}],[\"是a和b相等\",{\"1\":{\"64\":1}}],[\"是\",{\"0\":{\"59\":1},\"1\":{\"147\":1,\"277\":1,\"341\":1}}],[\"是一块连续的内存空间\",{\"1\":{\"302\":1}}],[\"是一个把大任务分割成若干个小任务\",{\"1\":{\"267\":1}}],[\"是一个以threadlocal对象为键\",{\"1\":{\"138\":1}}],[\"是一个接口\",{\"1\":{\"130\":1}}],[\"是一个类\",{\"1\":{\"130\":1}}],[\"是一个终端操作\",{\"1\":{\"36\":1}}],[\"是一种有序的的集合\",{\"1\":{\"339\":1}}],[\"是一种原子操作\",{\"1\":{\"289\":1}}],[\"是一种抽象的模型\",{\"1\":{\"102\":1}}],[\"是一种行为规范\",{\"1\":{\"91\":1}}],[\"是一种模板设计\",{\"1\":{\"91\":1}}],[\"是一种标记语言\",{\"1\":{\"69\":1}}],[\"是一种轻量级的数据交换格式\",{\"1\":{\"69\":1}}],[\"是一种元数据文件\",{\"1\":{\"44\":1}}],[\"是源码分支\",{\"1\":{\"22\":1}}],[\"是否为树节点\",{\"1\":{\"318\":1}}],[\"是否支持随机访问\",{\"1\":{\"302\":1}}],[\"是否小于等于1\",{\"1\":{\"267\":1}}],[\"是否能够满足系统的性能和稳定性要求\",{\"1\":{\"263\":1}}],[\"是否能作用在\",{\"0\":{\"54\":1}}],[\"是否都不是以\",{\"1\":{\"36\":1}}],[\"是否有以\",{\"1\":{\"36\":1}}],[\"是否想要现在启动\",{\"1\":{\"11\":1}}],[\"是否初始化\",{\"1\":{\"11\":1}}],[\"是否需要一个自动部署文档到\",{\"1\":{\"11\":1}}],[\"点击jconsole线程面板的\",{\"1\":{\"300\":1}}],[\"点击访问即可\",{\"1\":{\"21\":1}}],[\"点击save\",{\"1\":{\"21\":1}}],[\"配置部署分支为gh\",{\"1\":{\"21\":1}}],[\"配置github\",{\"0\":{\"21\":1}}],[\"选中侧边栏pages\",{\"1\":{\"21\":1}}],[\"选择合适的方法取决于您的具体需求和应用场景\",{\"1\":{\"254\":1}}],[\"选择器\",{\"1\":{\"30\":4}}],[\"选择包管理器\",{\"1\":{\"11\":1}}],[\"选择显示语言\",{\"1\":{\"11\":1}}],[\"打开settings\",{\"1\":{\"20\":1}}],[\"打开仓库my\",{\"1\":{\"20\":1,\"21\":1}}],[\"打开http\",{\"1\":{\"12\":1}}],[\"推送新分支到github\",{\"0\":{\"19\":1}}],[\"fast\",{\"0\":{\"307\":1},\"1\":{\"307\":1}}],[\"fail\",{\"0\":{\"307\":2},\"1\":{\"307\":2}}],[\"fair\",{\"1\":{\"288\":2}}],[\"fairsync\",{\"0\":{\"285\":1},\"1\":{\"288\":3}}],[\"fallback\",{\"1\":{\"35\":1}}],[\"false\",{\"1\":{\"17\":1,\"36\":1,\"50\":1,\"264\":2,\"288\":1,\"289\":1}}],[\"freenext\",{\"1\":{\"272\":1}}],[\"from\",{\"1\":{\"44\":1,\"215\":1}}],[\"fetchdatafromservice3\",{\"1\":{\"172\":2}}],[\"fetchdatafromservice2\",{\"1\":{\"172\":2}}],[\"fetchdatafromservice1\",{\"1\":{\"172\":2}}],[\"futureexceptionhandling\",{\"1\":{\"254\":1}}],[\"future<integer>\",{\"1\":{\"254\":1}}],[\"future<\",{\"1\":{\"250\":3}}],[\"future<string>\",{\"1\":{\"230\":1}}],[\"future3\",{\"1\":{\"162\":3,\"170\":3,\"172\":3}}],[\"future2\",{\"1\":{\"161\":2,\"162\":3,\"170\":3,\"172\":3}}],[\"future1\",{\"1\":{\"161\":2,\"162\":3,\"170\":3,\"172\":3}}],[\"future\",{\"0\":{\"254\":1},\"1\":{\"154\":2,\"156\":1,\"160\":1,\"164\":1,\"165\":1,\"167\":1,\"168\":1,\"170\":2,\"175\":1,\"178\":1,\"179\":2,\"230\":1,\"250\":3,\"254\":3}}],[\"functionname\",{\"1\":{\"77\":2}}],[\"function\",{\"1\":{\"34\":1,\"36\":1}}],[\"functionalinterface\",{\"1\":{\"33\":1,\"34\":1}}],[\"float\",{\"1\":{\"50\":2,\"98\":1}}],[\"first\",{\"1\":{\"319\":9}}],[\"fibonacci\",{\"1\":{\"267\":1}}],[\"fibonaccitask\",{\"1\":{\"267\":13}}],[\"fixedthreadpool\",{\"0\":{\"244\":1},\"1\":{\"181\":1,\"193\":2,\"242\":1,\"244\":1}}],[\"fifo\",{\"1\":{\"146\":1}}],[\"finalizabledelegatedexecutorservice\",{\"1\":{\"246\":1}}],[\"finalize的区别\",{\"0\":{\"95\":1}}],[\"finalize\",{\"1\":{\"66\":1,\"95\":6}}],[\"finalresult\",{\"1\":{\"172\":2}}],[\"final修饰的类不可被继承\",{\"1\":{\"95\":1}}],[\"final关键字有什么作用\",{\"0\":{\"94\":1}}],[\"finally中修改try中return的值\",{\"1\":{\"74\":1}}],[\"finally中return\",{\"1\":{\"74\":1}}],[\"finally中正常执行\",{\"1\":{\"74\":1}}],[\"finally\",{\"0\":{\"95\":1},\"1\":{\"74\":10,\"95\":1,\"282\":1,\"336\":1}}],[\"finally块中的代码也无法执行\",{\"1\":{\"73\":2}}],[\"finally一定会执行吗\",{\"0\":{\"73\":1}}],[\"final\",{\"0\":{\"95\":1},\"1\":{\"60\":1,\"91\":1,\"95\":1,\"119\":1,\"122\":1,\"194\":1,\"196\":1,\"211\":1,\"264\":4,\"267\":1,\"292\":1,\"298\":4,\"319\":1,\"336\":2}}],[\"field\",{\"1\":{\"46\":1,\"81\":1}}],[\"file\",{\"1\":{\"44\":1}}],[\"filter\",{\"1\":{\"36\":4}}],[\"forwardingnode<k\",{\"1\":{\"336\":1}}],[\"forwardingnode\",{\"1\":{\"336\":1}}],[\"forkjointask是fork\",{\"1\":{\"267\":1}}],[\"forkjointask\",{\"1\":{\"267\":1}}],[\"forkjoinpool实现了工作窃取算法\",{\"1\":{\"267\":1}}],[\"forkjoinpool是fork\",{\"1\":{\"267\":1}}],[\"forkjoinpool\",{\"1\":{\"174\":1,\"175\":1,\"185\":1,\"267\":1}}],[\"fork\",{\"0\":{\"267\":1},\"1\":{\"267\":8}}],[\"for\",{\"1\":{\"44\":1,\"121\":2,\"142\":1,\"144\":1,\"194\":1,\"196\":1,\"219\":1,\"264\":3,\"318\":3,\"341\":1}}],[\"foreach\",{\"1\":{\"36\":3,\"170\":1}}],[\"found\",{\"1\":{\"11\":1}}],[\"f\",{\"1\":{\"30\":1,\"336\":4}}],[\"writeobject\",{\"1\":{\"341\":1}}],[\"writeobject自定义序列化和反序列化策略\",{\"1\":{\"306\":1}}],[\"writer\",{\"1\":{\"28\":1}}],[\"weakcompareandsetint\",{\"1\":{\"298\":2}}],[\"web服务器可以预先创建一组线程来处理请求\",{\"1\":{\"210\":1}}],[\"web服务器需要处理大量的客户端请求\",{\"1\":{\"209\":1}}],[\"web服务器\",{\"0\":{\"208\":1}}],[\"word的锁对象\",{\"1\":{\"281\":1}}],[\"word里存储当前线程指针\",{\"1\":{\"278\":1}}],[\"word存储对象自身的运行数据\",{\"1\":{\"277\":1}}],[\"word\",{\"1\":{\"277\":3,\"281\":1}}],[\"worker\",{\"1\":{\"264\":2}}],[\"workers\",{\"1\":{\"264\":5}}],[\"workerthread\",{\"1\":{\"264\":5}}],[\"work\",{\"1\":{\"237\":1}}],[\"workqueue\",{\"1\":{\"195\":1,\"196\":1,\"229\":1,\"235\":1,\"250\":2}}],[\"world\",{\"1\":{\"156\":1,\"160\":1,\"161\":1}}],[\"when\",{\"1\":{\"123\":1,\"336\":1}}],[\"whether\",{\"1\":{\"81\":1}}],[\"while\",{\"1\":{\"121\":1,\"142\":1,\"211\":1,\"215\":1,\"264\":1,\"298\":1,\"319\":1,\"336\":2}}],[\"windows\",{\"1\":{\"39\":1}}],[\"with\",{\"1\":{\"17\":1}}],[\"waiters\",{\"1\":{\"272\":1}}],[\"waitsetlock\",{\"1\":{\"272\":1}}],[\"waitset\",{\"1\":{\"272\":4}}],[\"waittofight\",{\"1\":{\"140\":6}}],[\"waitind\",{\"1\":{\"132\":1}}],[\"waiting状态是暂时的\",{\"1\":{\"134\":1}}],[\"waiting状态表示线程在等待其他线程的通知或中断\",{\"1\":{\"134\":1}}],[\"waiting状态表示线程正在等待其他线程的通知\",{\"1\":{\"133\":1}}],[\"waiting和terminated有什么区别\",{\"0\":{\"134\":1}}],[\"waiting\",{\"1\":{\"132\":2}}],[\"wait\",{\"1\":{\"66\":3,\"131\":8,\"138\":1,\"272\":1}}],[\"want\",{\"1\":{\"11\":1}}],[\"was\",{\"1\":{\"11\":1}}],[\"warn\",{\"1\":{\"11\":1}}],[\"的源码⾮常⾮常少\",{\"1\":{\"341\":1}}],[\"的顺序进行排序\",{\"1\":{\"339\":1}}],[\"的自然顺序或者\",{\"1\":{\"339\":1}}],[\"的基础上维护了一个双向链表\",{\"1\":{\"338\":1}}],[\"的基础用法\",{\"1\":{\"74\":1}}],[\"的策略\",{\"1\":{\"330\":1}}],[\"的概念\",{\"1\":{\"330\":1}}],[\"的某些数字\",{\"1\":{\"324\":1}}],[\"的低位的余数部分\",{\"1\":{\"322\":1}}],[\"的同时并不释放自己已经获取的资源\",{\"1\":{\"299\":1}}],[\"的原理\",{\"0\":{\"298\":1}}],[\"的当前值是否等于预期值\",{\"1\":{\"289\":1}}],[\"的操作过程如下\",{\"1\":{\"289\":1}}],[\"的值更新为新值\",{\"1\":{\"289\":1}}],[\"的值更新为新值b\",{\"1\":{\"289\":1}}],[\"的值已经被其他线程改变\",{\"1\":{\"289\":1}}],[\"的值没有被其他线程改变\",{\"1\":{\"289\":1}}],[\"的值相同时\",{\"1\":{\"289\":1}}],[\"的值传递问题\",{\"1\":{\"124\":1}}],[\"的状态值加1后返回\",{\"1\":{\"287\":1}}],[\"的状态值为1\",{\"1\":{\"287\":1}}],[\"的执行过程\",{\"0\":{\"287\":1}}],[\"的锁\",{\"1\":{\"269\":2}}],[\"的调用次数\",{\"1\":{\"266\":1}}],[\"的调度\",{\"1\":{\"131\":1}}],[\"的构造函数或者提供的方法\",{\"1\":{\"262\":1}}],[\"的并发行为\",{\"1\":{\"185\":1}}],[\"的结果进行合并\",{\"1\":{\"161\":1}}],[\"的结果暂存起来\",{\"1\":{\"74\":1}}],[\"的屏障\",{\"1\":{\"141\":1}}],[\"的时间自行返回的\",{\"1\":{\"132\":1}}],[\"的方法和使用特定的数据结构\",{\"1\":{\"124\":1}}],[\"的增强版\",{\"1\":{\"124\":1}}],[\"的大小为老数组的两倍\",{\"1\":{\"121\":1}}],[\"的数组\",{\"1\":{\"304\":1}}],[\"的数量已经达到了列表的扩容阈值\",{\"1\":{\"121\":1}}],[\"的数据反序列化为java对象\",{\"1\":{\"69\":1}}],[\"的弱引用\",{\"1\":{\"116\":1}}],[\"的理解\",{\"0\":{\"102\":1}}],[\"的两个对象⽆论如何都不会相等\",{\"1\":{\"97\":1}}],[\"的默认⾏为是对堆上的对象产⽣独特值\",{\"1\":{\"97\":1}}],[\"的⽅式调用\",{\"1\":{\"93\":1}}],[\"的⽅式\",{\"1\":{\"93\":2}}],[\"的静态存储区\",{\"1\":{\"92\":1}}],[\"的区别\",{\"0\":{\"88\":1,\"96\":1}}],[\"的区别及作用\",{\"0\":{\"55\":1}}],[\"的兼容性\",{\"1\":{\"79\":1}}],[\"的拼接操作\",{\"1\":{\"62\":1}}],[\"的类加载机制和类对象模型\",{\"1\":{\"48\":1}}],[\"的容器\",{\"1\":{\"35\":1}}],[\"的\",{\"1\":{\"30\":1,\"74\":1,\"123\":1,\"255\":1,\"272\":1}}],[\"的博客演示\",{\"1\":{\"17\":1}}],[\"的工作流\",{\"1\":{\"11\":1}}],[\"博客演示\",{\"1\":{\"17\":1}}],[\"empty\",{\"1\":{\"303\":1,\"336\":1}}],[\"epoch\",{\"1\":{\"277\":1}}],[\"err\",{\"1\":{\"252\":1}}],[\"error\",{\"1\":{\"71\":1}}],[\"ee\",{\"1\":{\"250\":2}}],[\"else\",{\"1\":{\"121\":1,\"123\":1,\"267\":1,\"318\":3,\"336\":2}}],[\"elementdata\",{\"1\":{\"303\":3,\"304\":1}}],[\"elementtype\",{\"1\":{\"81\":6}}],[\"element\",{\"1\":{\"78\":2,\"302\":1}}],[\"each循环遍历键值对\",{\"1\":{\"84\":1}}],[\"each循环遍历键集合或值集合\",{\"1\":{\"84\":1}}],[\"equals\",{\"0\":{\"96\":1,\"97\":1},\"1\":{\"66\":1,\"96\":2,\"97\":1,\"318\":2,\"319\":2}}],[\"entrylist\",{\"1\":{\"272\":2}}],[\"entry为\",{\"1\":{\"120\":1}}],[\"entry数据\",{\"1\":{\"120\":1}}],[\"entry\",{\"1\":{\"119\":1,\"121\":6,\"312\":2}}],[\"entry是threalocal弱引用作为key\",{\"1\":{\"119\":1}}],[\"enum\",{\"1\":{\"54\":1}}],[\"enable\",{\"1\":{\"17\":1}}],[\"existing\",{\"1\":{\"341\":1}}],[\"exit\",{\"1\":{\"73\":2,\"95\":1}}],[\"extends\",{\"1\":{\"250\":1,\"264\":1,\"267\":1}}],[\"extensible\",{\"1\":{\"69\":1}}],[\"execute\",{\"1\":{\"230\":2,\"238\":5}}],[\"executequery\",{\"1\":{\"215\":1}}],[\"executor\",{\"1\":{\"194\":6,\"196\":6,\"219\":6,\"223\":3,\"229\":1,\"230\":2,\"233\":4,\"239\":5,\"249\":2,\"251\":1,\"252\":2,\"254\":3}}],[\"executorservice\",{\"1\":{\"177\":2,\"179\":2,\"181\":1,\"182\":1,\"183\":1,\"185\":2,\"193\":3,\"194\":2,\"211\":2,\"219\":2,\"223\":2,\"229\":1,\"244\":1,\"245\":1,\"246\":1,\"249\":1,\"251\":1,\"252\":1,\"254\":1}}],[\"executors\",{\"1\":{\"177\":3,\"179\":2,\"181\":1,\"182\":1,\"183\":1,\"184\":1,\"185\":2,\"193\":4,\"194\":2,\"211\":2,\"219\":2,\"223\":2,\"227\":2,\"249\":1,\"251\":1,\"254\":1}}],[\"executionexception\",{\"1\":{\"162\":1,\"170\":2,\"172\":2,\"250\":1,\"254\":1}}],[\"ex\",{\"1\":{\"164\":1,\"165\":2}}],[\"exclusive表示是获取独占资源时被挂起后放入aqs队列的\",{\"1\":{\"283\":1}}],[\"exchange\",{\"1\":{\"148\":2,\"149\":3,\"150\":2}}],[\"exchanger也可以用于校对工作\",{\"1\":{\"150\":1}}],[\"exchanger可以用于遗传算法\",{\"1\":{\"150\":1}}],[\"exchanger<>\",{\"1\":{\"148\":1}}],[\"exchanger<string>\",{\"1\":{\"148\":5}}],[\"exchangerexample\",{\"1\":{\"148\":1}}],[\"exchanger\",{\"0\":{\"147\":1},\"1\":{\"147\":1,\"148\":15,\"149\":1,\"150\":3}}],[\"exceptionally\",{\"0\":{\"164\":1},\"1\":{\"164\":1,\"253\":1}}],[\"exception\",{\"1\":{\"71\":2,\"74\":1,\"249\":1,\"254\":2,\"307\":3}}],[\"expected\",{\"1\":{\"298\":3}}],[\"expungestaleentries\",{\"1\":{\"121\":1}}],[\"expr还可以是字符串\",{\"1\":{\"54\":1}}],[\"expr\",{\"1\":{\"54\":3}}],[\"export\",{\"1\":{\"17\":1}}],[\"example\",{\"1\":{\"44\":2,\"223\":1}}],[\"effective\",{\"1\":{\"32\":1}}],[\"e\",{\"1\":{\"30\":1,\"74\":1,\"78\":1,\"121\":5,\"140\":2,\"142\":2,\"144\":2,\"148\":4,\"162\":2,\"167\":2,\"168\":2,\"170\":8,\"172\":8,\"179\":3,\"194\":2,\"196\":2,\"215\":2,\"219\":2,\"223\":1,\"227\":1,\"233\":1,\"239\":1,\"249\":2,\"251\":2,\"253\":2,\"254\":4,\"264\":3,\"302\":1,\"318\":7,\"319\":10,\"341\":7}}],[\"esbuild\",{\"1\":{\"11\":2}}],[\"访问修饰符public\",{\"0\":{\"89\":1}}],[\"访问\",{\"0\":{\"12\":1},\"1\":{\"12\":1}}],[\"nt\",{\"1\":{\"336\":2}}],[\"nthreads\",{\"1\":{\"244\":3}}],[\"nil节点\",{\"1\":{\"314\":1}}],[\"nio工作原理\",{\"1\":{\"30\":1}}],[\"nio\",{\"0\":{\"30\":1},\"1\":{\"30\":2}}],[\"native\",{\"1\":{\"292\":1,\"298\":1}}],[\"nanos\",{\"1\":{\"66\":1,\"131\":1,\"138\":1}}],[\"n\",{\"1\":{\"267\":15,\"302\":2,\"315\":2,\"318\":3,\"319\":3,\"330\":2,\"336\":6}}],[\"net\",{\"1\":{\"211\":2}}],[\"network\",{\"1\":{\"11\":1}}],[\"nexttable\",{\"1\":{\"336\":2}}],[\"nexttab\",{\"1\":{\"336\":5}}],[\"next\",{\"1\":{\"215\":1,\"307\":1,\"318\":2,\"319\":2}}],[\"nextindex\",{\"1\":{\"121\":1}}],[\"nexthashcode\",{\"1\":{\"119\":2}}],[\"new一个object作为value\",{\"1\":{\"341\":1}}],[\"newnode\",{\"1\":{\"318\":2}}],[\"newcapacity\",{\"1\":{\"303\":6}}],[\"newcachedthreadpool\",{\"1\":{\"182\":1,\"185\":1,\"193\":1,\"245\":1}}],[\"newthread\",{\"1\":{\"251\":1}}],[\"newtab\",{\"1\":{\"121\":7}}],[\"newscheduledthreadpool\",{\"1\":{\"184\":1,\"193\":1,\"227\":1}}],[\"newsinglethreadexecutor\",{\"1\":{\"183\":1,\"193\":1,\"246\":1}}],[\"newfixedthreadpool\",{\"1\":{\"177\":1,\"179\":1,\"181\":1,\"185\":1,\"193\":1,\"194\":1,\"211\":1,\"219\":1,\"223\":1,\"244\":1,\"249\":1,\"251\":1,\"254\":1}}],[\"newlen\",{\"1\":{\"121\":5}}],[\"new创建新对象\",{\"1\":{\"100\":1}}],[\"new\",{\"0\":{\"61\":1,\"323\":1},\"1\":{\"36\":1,\"46\":1,\"61\":3,\"113\":1,\"121\":1,\"122\":2,\"132\":1,\"140\":12,\"142\":4,\"144\":3,\"146\":1,\"148\":5,\"164\":1,\"165\":1,\"167\":1,\"168\":1,\"170\":4,\"172\":3,\"179\":1,\"196\":2,\"211\":2,\"215\":1,\"227\":1,\"229\":2,\"244\":2,\"245\":2,\"246\":3,\"247\":1,\"251\":2,\"252\":3,\"254\":1,\"264\":4,\"267\":3,\"269\":1,\"284\":1,\"288\":5,\"303\":1,\"336\":2}}],[\"null的槽位才会停止查找\",{\"1\":{\"120\":1}}],[\"null\",{\"1\":{\"35\":2,\"121\":4,\"123\":2,\"165\":1,\"250\":2,\"253\":1,\"272\":9,\"318\":8,\"319\":9,\"336\":7,\"341\":2}}],[\"nullpointerexception\",{\"1\":{\"35\":1}}],[\"npm\",{\"1\":{\"14\":1}}],[\"nonfairsync\",{\"0\":{\"286\":1},\"1\":{\"284\":1,\"288\":4}}],[\"nonematch\",{\"1\":{\"36\":1}}],[\"nonestartswithz\",{\"1\":{\"36\":1}}],[\"not\",{\"1\":{\"123\":1}}],[\"notifyall\",{\"1\":{\"66\":1,\"131\":5,\"282\":1}}],[\"notify\",{\"1\":{\"66\":1,\"131\":6,\"138\":1}}],[\"node<\",{\"1\":{\"336\":1}}],[\"node<k\",{\"1\":{\"318\":1,\"319\":4,\"336\":9}}],[\"node节点中的thread变量用来存放进入aqs队列里的线程\",{\"1\":{\"283\":1}}],[\"node\",{\"1\":{\"11\":2,\"319\":1}}],[\"no\",{\"1\":{\"11\":1,\"123\":1,\"336\":1}}],[\"hugecapacity\",{\"1\":{\"303\":1}}],[\"h\",{\"1\":{\"121\":5,\"318\":2}}],[\"hysteresis\",{\"1\":{\"121\":1}}],[\"handler\",{\"1\":{\"252\":2}}],[\"handlerequest\",{\"1\":{\"211\":2}}],[\"handle\",{\"0\":{\"165\":1},\"1\":{\"165\":1}}],[\"happens\",{\"0\":{\"107\":1},\"1\":{\"107\":11}}],[\"hash一样就覆盖\",{\"1\":{\"336\":1}}],[\"hashentry本身就是一个链表的结构\",{\"1\":{\"335\":1}}],[\"hash值\",{\"1\":{\"322\":3}}],[\"hash计算后应该落入第\",{\"1\":{\"120\":1}}],[\"hash\",{\"1\":{\"119\":4,\"312\":1,\"318\":10,\"319\":8,\"329\":2,\"336\":2}}],[\"hashset的add方法\",{\"1\":{\"341\":1}}],[\"hashset⾃⼰不得不实现之外\",{\"1\":{\"341\":1}}],[\"hashset\",{\"1\":{\"97\":1,\"341\":2}}],[\"hashtable\",{\"1\":{\"83\":1}}],[\"hashmap采用了\",{\"1\":{\"330\":1}}],[\"hashmap采用了尾插法\",{\"1\":{\"330\":1}}],[\"hashmap会使用更加均匀的哈希函数来计算索引位置\",{\"1\":{\"330\":1}}],[\"hashmap会将链表转换为红黑树\",{\"1\":{\"330\":1}}],[\"hashmap会向上寻找\",{\"1\":{\"323\":1}}],[\"hashmap扩容机制了解吗\",{\"0\":{\"329\":1}}],[\"hashmap里进行了优化改造\",{\"1\":{\"324\":1}}],[\"hashmap<>\",{\"0\":{\"323\":1}}],[\"hashmap的putval\",{\"1\":{\"341\":1}}],[\"hashmap的put流程知道吗\",{\"0\":{\"318\":1}}],[\"hashmap的容量必须是2的倍数\",{\"1\":{\"323\":1}}],[\"hashmap的哈希函数是先通过\",{\"1\":{\"320\":1}}],[\"hashmap的哈希\",{\"0\":{\"320\":1}}],[\"hashmap怎么查找元素的呢\",{\"0\":{\"319\":1}}],[\"hashmap使用头插法插入元素\",{\"1\":{\"332\":1}}],[\"hashmap使用链表或红黑树来解决冲突\",{\"1\":{\"312\":1}}],[\"hashmap使用键的哈希码\",{\"1\":{\"312\":1}}],[\"hashmap内部使用一个数组\",{\"1\":{\"312\":1}}],[\"hashmap\",{\"0\":{\"332\":1,\"337\":1},\"1\":{\"83\":1,\"97\":1,\"337\":2,\"338\":1,\"341\":2}}],[\"hashcode方法用于获取对象的哈希码\",{\"1\":{\"97\":1}}],[\"hashcode与\",{\"0\":{\"97\":1}}],[\"hashcode\",{\"1\":{\"66\":1,\"97\":4,\"318\":1,\"320\":1,\"331\":1}}],[\"header\",{\"1\":{\"272\":1}}],[\"helptransfer\",{\"1\":{\"336\":1}}],[\"help\",{\"1\":{\"121\":1}}],[\"hello\",{\"1\":{\"44\":1,\"156\":1,\"157\":1,\"158\":1,\"160\":1,\"161\":1}}],[\"helloserviceimpl2\",{\"1\":{\"44\":1}}],[\"helloserviceimpl\",{\"1\":{\"44\":3}}],[\"helloservice\",{\"1\":{\"44\":5}}],[\"hessian是一种基于http的轻量级二进制序列化协议\",{\"1\":{\"69\":1}}],[\"hessian序列化\",{\"1\":{\"69\":1}}],[\"http\",{\"1\":{\"11\":2}}],[\"hope\",{\"1\":{\"8\":1,\"10\":1,\"11\":5,\"17\":1}}],[\"➜\",{\"1\":{\"11\":2}}],[\">>>\",{\"1\":{\"318\":1,\"336\":1}}],[\">>\",{\"1\":{\"303\":2}}],[\">a\",{\"1\":{\"291\":1}}],[\">b\",{\"1\":{\"291\":1}}],[\">重量级锁\",{\"1\":{\"279\":1}}],[\">偏向锁\",{\"1\":{\"279\":1}}],[\">达到屏障点\",{\"1\":{\"142\":1}}],[\">放行\",{\"1\":{\"142\":2}}],[\">=\",{\"1\":{\"121\":4,\"318\":2}}],[\">对象指向分配的内存空间\",{\"1\":{\"106\":1}}],[\">初始化对象\",{\"1\":{\"106\":1}}],[\">\",{\"1\":{\"11\":2,\"35\":1,\"36\":8,\"41\":1,\"121\":1,\"123\":1,\"140\":6,\"154\":2,\"156\":2,\"157\":2,\"158\":2,\"160\":3,\"161\":3,\"162\":4,\"164\":3,\"165\":3,\"167\":1,\"168\":1,\"170\":6,\"172\":4,\"175\":1,\"178\":1,\"179\":2,\"185\":3,\"194\":1,\"196\":1,\"211\":1,\"219\":1,\"223\":1,\"227\":2,\"230\":2,\"249\":1,\"250\":3,\"251\":1,\"253\":2,\"254\":1,\"264\":1,\"279\":1,\"318\":1,\"319\":1,\"336\":2}}],[\"请求并持有\",{\"1\":{\"299\":2}}],[\"请在浏览器输入给出的开发服务器地址\",{\"1\":{\"11\":1}}],[\"请耐心等待\",{\"1\":{\"11\":1}}],[\"启动另一个\",{\"1\":{\"160\":1}}],[\"启动时会调用\",{\"1\":{\"137\":1}}],[\"启动线程b\",{\"1\":{\"107\":1}}],[\"启动\",{\"1\":{\"95\":1}}],[\"启动成功后\",{\"1\":{\"11\":1}}],[\"启动开发服务器\",{\"1\":{\"11\":1}}],[\"ynchronized修饰同步方法时\",{\"1\":{\"271\":1}}],[\"yield\",{\"1\":{\"131\":2,\"136\":1,\"336\":1}}],[\"yml\",{\"0\":{\"16\":1}}],[\"you\",{\"1\":{\"11\":1}}],[\"yes\",{\"1\":{\"11\":3}}],[\"ie\",{\"1\":{\"250\":1}}],[\"illegalstateexception\",{\"1\":{\"167\":1,\"168\":1,\"170\":4,\"172\":3,\"179\":1}}],[\"ilp\",{\"1\":{\"106\":1}}],[\"import\",{\"1\":{\"148\":1,\"170\":4,\"172\":4,\"177\":2,\"179\":4,\"194\":3,\"196\":3,\"211\":5,\"215\":5,\"219\":5,\"223\":2,\"227\":3,\"254\":1,\"264\":2,\"267\":1}}],[\"implements\",{\"1\":{\"44\":1,\"142\":1,\"144\":1,\"148\":2}}],[\"ignored\",{\"1\":{\"140\":1}}],[\"i++\",{\"1\":{\"104\":1,\"142\":1,\"144\":1,\"194\":1,\"196\":1,\"264\":2}}],[\"isdone\",{\"1\":{\"250\":1}}],[\"isinterrupted\",{\"1\":{\"131\":2}}],[\"isbooted\",{\"1\":{\"123\":2}}],[\"is\",{\"1\":{\"81\":1,\"264\":2}}],[\"ispresent\",{\"1\":{\"35\":1}}],[\"i\",{\"1\":{\"74\":7,\"104\":4,\"119\":1,\"121\":1,\"142\":3,\"144\":3,\"194\":3,\"196\":3,\"264\":7,\"318\":3,\"336\":2}}],[\"ioexception\",{\"1\":{\"211\":3}}],[\"io\",{\"0\":{\"27\":1,\"28\":1},\"1\":{\"211\":1}}],[\"item\",{\"1\":{\"219\":5}}],[\"it\",{\"1\":{\"11\":2,\"17\":1}}],[\"ifpresent\",{\"1\":{\"35\":1}}],[\"if\",{\"0\":{\"108\":1},\"1\":{\"11\":1,\"107\":1,\"108\":3,\"121\":4,\"123\":5,\"164\":1,\"165\":2,\"179\":1,\"194\":1,\"196\":1,\"219\":1,\"227\":1,\"233\":1,\"239\":1,\"250\":3,\"254\":1,\"267\":1,\"275\":1,\"303\":3,\"318\":9,\"319\":5,\"336\":9,\"341\":2}}],[\"initialization\",{\"1\":{\"336\":1}}],[\"inittable\",{\"1\":{\"336\":2}}],[\"index\",{\"1\":{\"194\":2,\"196\":2,\"302\":2}}],[\"inheriting\",{\"1\":{\"123\":1}}],[\"inherit\",{\"1\":{\"123\":1}}],[\"inheritablethreadlocals\",{\"1\":{\"123\":5}}],[\"inheritablethreadlocal原理是什么呢\",{\"0\":{\"123\":1}}],[\"inheritablethreadlocaltest\",{\"1\":{\"122\":1}}],[\"inheritablethreadlocal\",{\"1\":{\"122\":2,\"124\":1}}],[\"increment\",{\"1\":{\"119\":2}}],[\"instanceof\",{\"1\":{\"250\":1,\"318\":1,\"319\":1,\"336\":1}}],[\"instance=new\",{\"1\":{\"106\":1}}],[\"instruction\",{\"1\":{\"106\":1}}],[\"intrinsiccandidate\",{\"1\":{\"292\":1}}],[\"intrinsic\",{\"1\":{\"272\":1}}],[\"integercache是一个静态内部类\",{\"1\":{\"64\":1}}],[\"integer\",{\"0\":{\"64\":4},\"1\":{\"64\":2,\"65\":2,\"219\":2,\"245\":1,\"247\":1,\"254\":1,\"267\":2}}],[\"interruptedexception\",{\"1\":{\"140\":4,\"142\":2,\"144\":1,\"146\":1,\"148\":2,\"150\":1,\"162\":1,\"167\":1,\"168\":1,\"170\":4,\"172\":4,\"179\":2,\"194\":2,\"196\":2,\"219\":2,\"223\":1,\"227\":1,\"233\":1,\"239\":1,\"250\":1,\"254\":1,\"264\":3}}],[\"interrupted\",{\"1\":{\"131\":1}}],[\"interrupt\",{\"1\":{\"131\":2,\"194\":1,\"196\":1,\"219\":1,\"223\":1,\"250\":1,\"254\":1,\"264\":4}}],[\"intern方法有什么作用\",{\"0\":{\"63\":1}}],[\"interfacename\",{\"1\":{\"77\":1}}],[\"interface\",{\"0\":{\"91\":1},\"1\":{\"44\":3,\"50\":1,\"77\":1,\"81\":2}}],[\"int\",{\"1\":{\"50\":2,\"54\":1,\"65\":1,\"66\":1,\"74\":4,\"104\":2,\"119\":3,\"121\":4,\"131\":1,\"138\":1,\"142\":1,\"144\":1,\"194\":2,\"196\":2,\"211\":2,\"244\":1,\"247\":1,\"250\":2,\"264\":5,\"267\":5,\"283\":1,\"298\":8,\"302\":2,\"303\":5,\"318\":1,\"319\":2,\"336\":4}}],[\"inf\",{\"1\":{\"44\":3}}],[\"inputstream\",{\"1\":{\"28\":1}}],[\"in\",{\"1\":{\"11\":3}}],[\"3306\",{\"1\":{\"215\":1}}],[\"3000\",{\"1\":{\"167\":1,\"168\":1,\"170\":1,\"172\":1}}],[\"31\",{\"1\":{\"74\":1}}],[\"324\",{\"1\":{\"50\":1}}],[\"32\",{\"1\":{\"50\":2}}],[\"3s\",{\"1\":{\"11\":1}}],[\"3\",{\"0\":{\"155\":1,\"156\":1,\"157\":1,\"158\":2,\"162\":1,\"179\":1,\"183\":1,\"192\":1,\"193\":1,\"204\":1,\"205\":1,\"206\":1,\"216\":1,\"231\":1,\"246\":1,\"251\":1,\"258\":1},\"1\":{\"11\":2,\"50\":1,\"56\":1,\"74\":6,\"121\":2,\"142\":13,\"144\":1,\"146\":1,\"219\":1,\"264\":1,\"280\":2,\"281\":1}}],[\"6锁优化以前\",{\"1\":{\"282\":1}}],[\"6之前synchronized的实现直接调用objectmonitor的enter和exit\",{\"1\":{\"278\":1}}],[\"6之前\",{\"1\":{\"278\":1}}],[\"60l\",{\"1\":{\"229\":1,\"245\":1}}],[\"60\",{\"1\":{\"194\":1,\"196\":2,\"219\":1,\"227\":1,\"233\":1,\"239\":1}}],[\"606\",{\"1\":{\"11\":1}}],[\"64bit\",{\"1\":{\"277\":1}}],[\"64\",{\"1\":{\"50\":2,\"277\":1}}],[\"6\",{\"0\":{\"166\":1,\"167\":1,\"168\":1,\"196\":1,\"254\":1},\"1\":{\"11\":1,\"144\":1,\"219\":1}}],[\"639\",{\"1\":{\"11\":1}}],[\"61\",{\"1\":{\"11\":1}}],[\"8是基于cas+synchronized\",{\"1\":{\"334\":1}}],[\"8还引入了\",{\"1\":{\"330\":1}}],[\"8对hashmap的扩容操作进行了优化\",{\"1\":{\"330\":1}}],[\"8对hashmap主要做了哪些优化呢\",{\"0\":{\"330\":1}}],[\"8对哈希碰撞的处理进行了优化\",{\"1\":{\"330\":1}}],[\"800\",{\"1\":{\"179\":1}}],[\"8080\",{\"1\":{\"11\":3,\"12\":1,\"211\":1}}],[\"8引入的一个异步编程工具类\",{\"1\":{\"152\":1}}],[\"8引入了新的日期和时间api\",{\"1\":{\"32\":1}}],[\"8开始\",{\"1\":{\"91\":1}}],[\"8的stream\",{\"1\":{\"84\":1}}],[\"8之前\",{\"1\":{\"62\":1}}],[\"8中都存在\",{\"1\":{\"332\":2}}],[\"8中的hashmap改为使用尾插法插入元素\",{\"1\":{\"332\":1}}],[\"8中\",{\"1\":{\"32\":1,\"91\":1,\"330\":2}}],[\"8都有哪些新特性\",{\"0\":{\"32\":1}}],[\"8新特性\",{\"0\":{\"31\":1}}],[\"84\",{\"1\":{\"11\":1}}],[\"825ms\",{\"1\":{\"11\":1}}],[\"8\",{\"0\":{\"171\":1,\"172\":1,\"336\":1},\"1\":{\"11\":2,\"35\":1,\"50\":3,\"219\":1,\"312\":1}}],[\"83\",{\"1\":{\"11\":2}}],[\"1^2\",{\"1\":{\"325\":1}}],[\"1得任意数\",{\"1\":{\"322\":1}}],[\"1st\",{\"1\":{\"318\":2}}],[\"1500\",{\"1\":{\"140\":1}}],[\"127这种赋值\",{\"1\":{\"64\":1}}],[\"127\",{\"0\":{\"64\":2},\"1\":{\"50\":1,\"64\":1}}],[\"128到127之间\",{\"1\":{\"64\":1}}],[\"128\",{\"0\":{\"64\":1},\"1\":{\"11\":1,\"50\":1,\"64\":1}}],[\"16\",{\"1\":{\"50\":2,\"318\":1}}],[\"100\",{\"1\":{\"196\":1,\"215\":1,\"252\":1}}],[\"10000\",{\"1\":{\"144\":1}}],[\"1000\",{\"1\":{\"140\":1,\"142\":1,\"170\":1,\"172\":1,\"179\":1,\"219\":1,\"264\":1}}],[\"10\",{\"1\":{\"11\":2,\"177\":1,\"179\":1,\"181\":1,\"193\":1,\"194\":1,\"196\":2,\"211\":1,\"215\":1,\"219\":1,\"229\":1,\"249\":1,\"251\":1,\"252\":2,\"254\":1,\"267\":2}}],[\"19\",{\"1\":{\"11\":1}}],[\"197\",{\"1\":{\"11\":1}}],[\"1\",{\"0\":{\"152\":1,\"154\":1,\"156\":1,\"160\":1,\"164\":1,\"167\":1,\"172\":1,\"175\":1,\"177\":1,\"181\":1,\"190\":1,\"193\":1,\"198\":1,\"199\":2,\"200\":1,\"202\":1,\"205\":1,\"208\":1,\"229\":1,\"244\":1,\"249\":1,\"256\":1},\"1\":{\"11\":1,\"50\":7,\"74\":2,\"104\":1,\"119\":1,\"121\":1,\"140\":1,\"142\":12,\"144\":1,\"146\":1,\"150\":1,\"215\":2,\"219\":1,\"227\":1,\"246\":2,\"267\":3,\"272\":3,\"276\":1,\"280\":1,\"298\":1,\"302\":1,\"303\":2,\"318\":5,\"319\":1,\"321\":1,\"322\":6,\"330\":5,\"336\":4}}],[\"r\",{\"1\":{\"250\":4,\"251\":2,\"252\":2}}],[\"rs\",{\"1\":{\"215\":3,\"336\":3}}],[\"race\",{\"1\":{\"336\":1}}],[\"random\",{\"1\":{\"142\":1,\"144\":1,\"164\":1,\"165\":1}}],[\"radix\",{\"1\":{\"65\":1}}],[\"runasync\",{\"1\":{\"154\":2,\"176\":1,\"253\":1}}],[\"runtime和处理器都必须遵守as\",{\"1\":{\"108\":1}}],[\"runtime\",{\"1\":{\"81\":2,\"227\":1}}],[\"runtimeexception\",{\"1\":{\"71\":1,\"164\":1,\"165\":1}}],[\"runnable\",{\"1\":{\"34\":1,\"128\":1,\"130\":1,\"132\":1,\"142\":2,\"144\":1,\"148\":2,\"249\":1,\"250\":1,\"251\":1,\"252\":1,\"264\":2}}],[\"running\",{\"0\":{\"256\":1},\"1\":{\"11\":2,\"256\":1,\"264\":5}}],[\"run\",{\"1\":{\"14\":1,\"122\":2,\"142\":2,\"144\":1,\"145\":1,\"148\":2,\"264\":2}}],[\"rc\",{\"1\":{\"11\":3}}],[\"rollup\",{\"1\":{\"11\":1}}],[\"reentrantlock怎么实现公平锁的\",{\"0\":{\"288\":1}}],[\"reentrantlock通过sync类\",{\"1\":{\"284\":1}}],[\"reentrantlock实现原理\",{\"0\":{\"284\":1}}],[\"reentrantlock需要手工声明来加锁和释放锁\",{\"1\":{\"282\":1}}],[\"reentrantlock类借助condition接口与newcondition\",{\"1\":{\"282\":1}}],[\"reentrantlock可以指定是公平锁还是非公平锁\",{\"1\":{\"282\":1}}],[\"reentrantlock提供了一种能够中断等待锁的线程的机制\",{\"1\":{\"282\":1}}],[\"reentrantlock\",{\"1\":{\"282\":1,\"284\":1,\"288\":7}}],[\"reentrantlock是基于jdk的api层面实现的\",{\"1\":{\"282\":1}}],[\"rejected\",{\"1\":{\"252\":1}}],[\"rejectedexecution\",{\"1\":{\"252\":1}}],[\"rejectedexecutionhandler\",{\"0\":{\"252\":1},\"1\":{\"235\":1,\"252\":3}}],[\"recursions\",{\"1\":{\"272\":1}}],[\"recursivetask<integer>\",{\"1\":{\"267\":2}}],[\"recursivetask\",{\"1\":{\"267\":2}}],[\"recursivetask用于表示有返回值的任务\",{\"1\":{\"267\":1}}],[\"recipient\",{\"1\":{\"223\":2}}],[\"received\",{\"1\":{\"148\":2}}],[\"release\",{\"1\":{\"144\":1,\"145\":1}}],[\"responsible\",{\"1\":{\"272\":1}}],[\"response\",{\"1\":{\"148\":2,\"150\":1}}],[\"resultset\",{\"1\":{\"215\":2}}],[\"results\",{\"1\":{\"170\":2}}],[\"result3\",{\"1\":{\"162\":2,\"172\":2}}],[\"result2\",{\"1\":{\"161\":2,\"162\":2,\"172\":2,\"267\":2}}],[\"result1\",{\"1\":{\"161\":2,\"162\":2,\"172\":2,\"267\":2}}],[\"resultfuture\",{\"1\":{\"161\":1}}],[\"result\",{\"1\":{\"156\":2,\"157\":2,\"160\":2,\"165\":2,\"170\":2,\"179\":2,\"185\":4,\"254\":3,\"267\":2}}],[\"resizers\",{\"1\":{\"336\":1}}],[\"resizestamp\",{\"1\":{\"336\":1}}],[\"resize\",{\"1\":{\"121\":3,\"318\":2,\"336\":1}}],[\"resolved\",{\"1\":{\"11\":2}}],[\"rehash\",{\"1\":{\"121\":5}}],[\"required\",{\"1\":{\"81\":2}}],[\"retention\",{\"1\":{\"81\":2}}],[\"retentionpolicy\",{\"1\":{\"81\":5}}],[\"returntype\",{\"1\":{\"77\":2}}],[\"return\",{\"0\":{\"55\":1},\"1\":{\"55\":1,\"74\":9,\"119\":1,\"154\":1,\"164\":1,\"165\":3,\"167\":1,\"168\":1,\"170\":4,\"172\":6,\"175\":1,\"178\":1,\"179\":1,\"185\":2,\"230\":1,\"244\":1,\"245\":1,\"246\":1,\"251\":1,\"253\":1,\"254\":1,\"267\":2,\"292\":1,\"298\":3,\"303\":3,\"319\":5,\"336\":3,\"341\":2}}],[\"reduce\",{\"1\":{\"36\":2}}],[\"reduced\",{\"1\":{\"36\":1}}],[\"reduce归约\",{\"1\":{\"36\":1}}],[\"readobject\",{\"1\":{\"341\":1}}],[\"reader\",{\"1\":{\"28\":1}}],[\"reactor\",{\"1\":{\"30\":1}}],[\"reused\",{\"1\":{\"11\":2}}],[\"仓库\",{\"1\":{\"11\":1}}],[\"项目启动命令\",{\"0\":{\"14\":1}}],[\"项目需要用到多语言么\",{\"1\":{\"11\":1}}],[\"项目介绍\",{\"1\":{\"1\":1}}],[\"mincapacity\",{\"1\":{\"303\":6}}],[\"milliseconds\",{\"1\":{\"179\":1,\"244\":1,\"246\":1,\"247\":1,\"252\":1}}],[\"millis\",{\"1\":{\"131\":1,\"138\":2,\"247\":1}}],[\"mit\",{\"1\":{\"11\":1}}],[\"memory\",{\"1\":{\"102\":3}}],[\"methodhandle\",{\"1\":{\"292\":1}}],[\"method\",{\"1\":{\"46\":1,\"81\":2,\"269\":2}}],[\"meta\",{\"1\":{\"44\":1}}],[\"markword中锁标志是否为\",{\"1\":{\"280\":1}}],[\"mark\",{\"1\":{\"277\":4,\"281\":1}}],[\"markup\",{\"1\":{\"69\":1}}],[\"max\",{\"1\":{\"245\":2,\"247\":2,\"303\":2,\"336\":1}}],[\"maximumpoolsize\",{\"1\":{\"195\":1,\"196\":1,\"229\":2,\"235\":1,\"250\":2}}],[\"math\",{\"1\":{\"142\":1,\"144\":1,\"164\":1,\"165\":1,\"303\":1}}],[\"match\",{\"1\":{\"36\":1}}],[\"macos\",{\"1\":{\"39\":1}}],[\"machine\",{\"1\":{\"39\":1}}],[\"mapping\",{\"1\":{\"341\":1}}],[\"map\",{\"0\":{\"311\":1},\"1\":{\"36\":2,\"170\":1,\"341\":1,\"343\":1}}],[\"main函数所在的钱程就是一个用户线程\",{\"1\":{\"137\":1}}],[\"main\",{\"1\":{\"23\":1,\"74\":3,\"102\":1,\"122\":1,\"137\":1,\"140\":2,\"142\":1,\"144\":1,\"148\":1,\"170\":1,\"172\":1,\"179\":1,\"194\":1,\"196\":1,\"211\":1,\"215\":1,\"219\":1,\"223\":1,\"227\":1,\"254\":1,\"264\":1,\"267\":2}}],[\"master的代码都是ts和一些markdown文件\",{\"1\":{\"22\":1}}],[\"master\",{\"1\":{\"16\":1,\"22\":1}}],[\"manually\",{\"1\":{\"11\":1}}],[\"make\",{\"1\":{\"11\":1}}],[\"monitor\",{\"1\":{\"272\":4}}],[\"monitorexit或者acc\",{\"1\":{\"272\":1}}],[\"monitorexit\",{\"1\":{\"271\":2,\"272\":1}}],[\"monitorenter\",{\"1\":{\"271\":2,\"272\":2}}],[\"modcount\",{\"1\":{\"307\":1}}],[\"modcount变量是否为expectedmodcount值\",{\"1\":{\"307\":1}}],[\"modcount的值\",{\"1\":{\"307\":1}}],[\"modification\",{\"1\":{\"307\":3}}],[\"model\",{\"1\":{\"102\":1}}],[\"modules\",{\"1\":{\"11\":2}}],[\"move\",{\"1\":{\"11\":1}}],[\"mytable\",{\"1\":{\"215\":1}}],[\"mydatabase\",{\"1\":{\"215\":1}}],[\"mysql\",{\"1\":{\"215\":1}}],[\"mybatis\",{\"1\":{\"47\":1}}],[\"my\",{\"1\":{\"10\":1,\"11\":2,\"14\":1,\"17\":1}}],[\"o\",{\"1\":{\"298\":6}}],[\"owneristhread\",{\"1\":{\"272\":1}}],[\"owner\",{\"1\":{\"272\":5}}],[\"o密集型的\",{\"1\":{\"240\":1}}],[\"o操作的完成\",{\"1\":{\"240\":1}}],[\"o操作\",{\"1\":{\"136\":1}}],[\"oldvalue\",{\"1\":{\"341\":3}}],[\"oldcapacity\",{\"1\":{\"303\":5}}],[\"oldlen\",{\"1\":{\"121\":2}}],[\"oldtab\",{\"1\":{\"121\":4}}],[\"org\",{\"1\":{\"215\":1}}],[\"ortimeout\",{\"0\":{\"167\":1},\"1\":{\"167\":1}}],[\"ordering\",{\"1\":{\"103\":1}}],[\"orelse\",{\"1\":{\"35\":1}}],[\"overflow\",{\"1\":{\"303\":2}}],[\"overload\",{\"0\":{\"88\":1}}],[\"override\",{\"0\":{\"88\":1},\"1\":{\"44\":1,\"81\":1,\"122\":1,\"142\":2,\"144\":1,\"148\":2,\"250\":1,\"251\":1,\"252\":1,\"264\":1,\"267\":1}}],[\"outofmemoryerror\",{\"1\":{\"303\":1}}],[\"out\",{\"1\":{\"35\":1,\"36\":4,\"44\":1,\"74\":4,\"122\":1,\"140\":3,\"142\":4,\"144\":3,\"148\":4,\"157\":1,\"158\":1,\"162\":1,\"170\":2,\"172\":1,\"179\":2,\"185\":1,\"194\":1,\"196\":1,\"215\":1,\"219\":1,\"223\":3,\"227\":1,\"254\":1,\"264\":2,\"267\":1}}],[\"outputstream\",{\"1\":{\"28\":1}}],[\"optional<string>\",{\"1\":{\"35\":1,\"36\":1}}],[\"optional了解吗\",{\"0\":{\"35\":1}}],[\"optional类是一个容器类\",{\"1\":{\"32\":1}}],[\"optional\",{\"1\":{\"32\":1,\"35\":9,\"36\":1}}],[\"onlyifabsent\",{\"1\":{\"341\":1}}],[\"on\",{\"1\":{\"16\":1,\"264\":1}}],[\"offset\",{\"1\":{\"298\":6}}],[\"of\",{\"1\":{\"11\":1,\"35\":1,\"170\":1}}],[\"obj\",{\"1\":{\"66\":1}}],[\"objectinputstream\",{\"1\":{\"306\":1}}],[\"objectoutputstream\",{\"1\":{\"306\":1}}],[\"objectmonitor\",{\"1\":{\"272\":1}}],[\"objectmonitor有两个队列\",{\"1\":{\"272\":1}}],[\"objectmonitor的工作原理\",{\"1\":{\"272\":1}}],[\"object类方法\",{\"1\":{\"131\":1}}],[\"object类提供的clone\",{\"1\":{\"99\":1}}],[\"object作为value的结构\",{\"1\":{\"119\":1}}],[\"object\",{\"0\":{\"66\":1},\"1\":{\"66\":1,\"95\":1,\"272\":1,\"292\":1,\"298\":3,\"319\":2}}],[\"ob\",{\"1\":{\"11\":4}}],[\"2000\",{\"1\":{\"170\":1,\"172\":1,\"194\":1,\"196\":1,\"223\":1}}],[\"2^63\",{\"1\":{\"50\":2}}],[\"2^15\",{\"1\":{\"50\":2}}],[\"2^31\",{\"1\":{\"50\":2}}],[\"246\",{\"1\":{\"11\":1}}],[\"25\",{\"1\":{\"11\":1}}],[\"2\",{\"0\":{\"153\":1,\"154\":1,\"157\":1,\"161\":1,\"165\":1,\"168\":1,\"176\":1,\"177\":1,\"178\":2,\"182\":1,\"191\":1,\"200\":1,\"201\":1,\"202\":1,\"203\":2,\"206\":1,\"212\":1,\"230\":1,\"245\":1,\"250\":1,\"257\":1},\"1\":{\"11\":8,\"50\":2,\"56\":1,\"74\":5,\"104\":1,\"121\":2,\"142\":11,\"167\":1,\"168\":1,\"219\":1,\"267\":2,\"280\":1,\"336\":1}}],[\"22\",{\"1\":{\"11\":1}}],[\"l\",{\"1\":{\"300\":2}}],[\"len\",{\"1\":{\"121\":1}}],[\"length\",{\"1\":{\"119\":1,\"121\":1,\"303\":1,\"318\":2,\"319\":1,\"336\":4}}],[\"level\",{\"1\":{\"106\":1}}],[\"linkedlist每个节点\",{\"1\":{\"302\":1}}],[\"linkedlist基于链表\",{\"1\":{\"302\":2}}],[\"linkedlist基于链表实现\",{\"1\":{\"302\":1}}],[\"linkedlist基于双向链表实现\",{\"1\":{\"302\":1}}],[\"linkedlist更利于增删\",{\"1\":{\"302\":1}}],[\"linkedblockingqueue<>\",{\"1\":{\"252\":1,\"264\":1}}],[\"linkedblockingqueue<runnable>\",{\"1\":{\"229\":1,\"244\":1,\"246\":1}}],[\"linkedblockingqueue\",{\"1\":{\"187\":1,\"264\":1}}],[\"linkedhashmap在\",{\"1\":{\"338\":1}}],[\"linkedhashmap\",{\"0\":{\"338\":1},\"1\":{\"83\":1,\"337\":1,\"338\":1}}],[\"linux\",{\"1\":{\"39\":1}}],[\"list<integer>\",{\"1\":{\"219\":1}}],[\"list<string>\",{\"1\":{\"36\":1,\"170\":1}}],[\"list归约成一个值\",{\"1\":{\"36\":1}}],[\"list\",{\"0\":{\"301\":1},\"1\":{\"36\":3,\"170\":2,\"172\":1,\"219\":1,\"343\":1}}],[\"listed\",{\"1\":{\"11\":1}}],[\"lost\",{\"1\":{\"336\":1}}],[\"log\",{\"1\":{\"315\":1,\"330\":1}}],[\"lower\",{\"1\":{\"121\":1}}],[\"lockinterruptibly\",{\"1\":{\"282\":1}}],[\"lock\",{\"0\":{\"287\":1},\"1\":{\"272\":2,\"288\":2,\"296\":1,\"336\":1}}],[\"lock接口等\",{\"1\":{\"105\":2}}],[\"lock接口\",{\"1\":{\"105\":1}}],[\"locals\",{\"1\":{\"123\":2}}],[\"localvariable\",{\"1\":{\"113\":3}}],[\"localhost\",{\"1\":{\"11\":2,\"12\":1,\"215\":1}}],[\"local\",{\"1\":{\"11\":3,\"102\":1,\"199\":1}}],[\"lombok\",{\"1\":{\"81\":1}}],[\"loadstore\",{\"1\":{\"111\":1}}],[\"loadload\",{\"1\":{\"111\":1}}],[\"load\",{\"1\":{\"44\":2}}],[\"loader\",{\"1\":{\"44\":4,\"123\":1}}],[\"long类型\",{\"1\":{\"36\":1}}],[\"long\",{\"0\":{\"54\":1},\"1\":{\"36\":1,\"50\":2,\"54\":1,\"66\":2,\"131\":4,\"138\":2,\"140\":1,\"142\":1,\"144\":1,\"250\":1,\"298\":3}}],[\"latch数量减1\",{\"1\":{\"140\":1}}],[\"lambda\",{\"0\":{\"33\":1},\"1\":{\"32\":5,\"33\":2}}],[\"lang\",{\"1\":{\"17\":1,\"95\":1}}],[\"language\",{\"1\":{\"11\":1,\"69\":1}}],[\"afternodeaccess\",{\"1\":{\"341\":1}}],[\"afterexecute\",{\"1\":{\"250\":3}}],[\"aqs是一个一个fifo的双向队列\",{\"1\":{\"283\":1}}],[\"aqs\",{\"1\":{\"283\":3,\"287\":2}}],[\"aqs了解多少\",{\"0\":{\"283\":1}}],[\"apache\",{\"1\":{\"215\":1}}],[\"api遍历\",{\"1\":{\"84\":1}}],[\"api提供了一种更简洁\",{\"1\":{\"32\":1}}],[\"api\",{\"1\":{\"32\":2,\"266\":7}}],[\"acc\",{\"1\":{\"271\":1,\"272\":1}}],[\"accept\",{\"1\":{\"211\":1}}],[\"acquiredwithtimeout\",{\"1\":{\"146\":1}}],[\"acquired\",{\"1\":{\"146\":1}}],[\"acquire\",{\"1\":{\"144\":1,\"145\":1,\"146\":1}}],[\"awaittermination\",{\"1\":{\"179\":1,\"194\":1,\"196\":1,\"219\":1,\"227\":1,\"233\":1,\"239\":1}}],[\"await\",{\"1\":{\"140\":6,\"142\":2}}],[\"avoid\",{\"1\":{\"121\":1}}],[\"asynctaskexample\",{\"1\":{\"223\":1}}],[\"aslist\",{\"1\":{\"219\":1}}],[\"as\",{\"0\":{\"108\":1},\"1\":{\"107\":1,\"108\":1}}],[\"aba\",{\"0\":{\"291\":1},\"1\":{\"290\":1}}],[\"abortpolicy\",{\"1\":{\"236\":1}}],[\"abstractqueuedsynchronizer\",{\"1\":{\"283\":1}}],[\"abstract\",{\"0\":{\"91\":1}}],[\"abc\",{\"0\":{\"61\":2},\"1\":{\"61\":6}}],[\"autowired\",{\"1\":{\"81\":1}}],[\"autoboxcachemax=来修改缓存的最大值\",{\"1\":{\"64\":1}}],[\"and\",{\"1\":{\"289\":1,\"297\":1}}],[\"annotated\",{\"1\":{\"81\":1}}],[\"annotation\",{\"1\":{\"81\":1}}],[\"anymatch\",{\"1\":{\"36\":1}}],[\"anystartswitha\",{\"1\":{\"36\":1}}],[\"aop\",{\"1\":{\"81\":1}}],[\"array\",{\"1\":{\"303\":1}}],[\"arraylist通过两个方法readobject\",{\"1\":{\"306\":1}}],[\"arraylist的序列化不太一样\",{\"1\":{\"304\":1}}],[\"arraylist的扩容机制了解吗\",{\"0\":{\"303\":1}}],[\"arraylist怎么序列化的知道吗\",{\"0\":{\"304\":1}}],[\"arraylist是预先定义好的数组\",{\"1\":{\"302\":1}}],[\"arraylist基于数组\",{\"1\":{\"302\":2}}],[\"arraylist基于数组实现\",{\"1\":{\"302\":2}}],[\"arraylist增删如果是数组末尾的位置\",{\"1\":{\"302\":1}}],[\"arraylist更利于查找\",{\"1\":{\"302\":1}}],[\"arraylist和linkedlist有什么区别\",{\"0\":{\"302\":1}}],[\"arraylist<>\",{\"1\":{\"36\":1}}],[\"arrays\",{\"1\":{\"219\":2}}],[\"arrayblockingqueue<>\",{\"1\":{\"196\":1}}],[\"arrayblockingqueue\",{\"1\":{\"187\":1,\"196\":1}}],[\"arg\",{\"1\":{\"77\":1}}],[\"args\",{\"1\":{\"74\":3,\"122\":1,\"140\":2,\"142\":1,\"144\":1,\"148\":1,\"170\":1,\"172\":1,\"179\":1,\"194\":1,\"196\":1,\"211\":1,\"215\":1,\"219\":1,\"223\":1,\"227\":1,\"254\":1,\"264\":1,\"267\":1,\"292\":1}}],[\"a1==b1的结果是false\",{\"1\":{\"64\":1}}],[\"a=\",{\"0\":{\"64\":1},\"1\":{\"64\":1}}],[\"a+b拼接后的对象位于堆中\",{\"1\":{\"62\":1}}],[\"a和b初始化时位于字符串常量池\",{\"1\":{\"62\":1}}],[\"always\",{\"1\":{\"319\":1}}],[\"allof\",{\"0\":{\"162\":1},\"1\":{\"162\":3,\"170\":3,\"172\":3}}],[\"allmatch\",{\"1\":{\"36\":1}}],[\"allstartswitha\",{\"1\":{\"36\":2}}],[\"already\",{\"1\":{\"11\":1}}],[\"aaa1\",{\"1\":{\"36\":1}}],[\"aaa2\",{\"1\":{\"36\":1}}],[\"adding\",{\"1\":{\"336\":1}}],[\"add方法有锁\",{\"1\":{\"310\":1}}],[\"addshutdownhook\",{\"1\":{\"227\":1}}],[\"add\",{\"1\":{\"36\":8,\"341\":1}}],[\"added\",{\"1\":{\"11\":2}}],[\"aio\",{\"0\":{\"30\":1},\"1\":{\"30\":1}}],[\"attached\",{\"1\":{\"123\":1}}],[\"atomicreference等\",{\"1\":{\"297\":1}}],[\"atomiclong\",{\"1\":{\"297\":1}}],[\"atomicinteger\",{\"0\":{\"298\":1},\"1\":{\"297\":1}}],[\"atomicity\",{\"1\":{\"103\":1}}],[\"atomic类等\",{\"1\":{\"105\":1}}],[\"at\",{\"1\":{\"11\":1}}],[\"a\",{\"1\":{\"11\":3,\"30\":1,\"36\":7,\"289\":3,\"291\":1}}],[\"safe\",{\"0\":{\"307\":1},\"1\":{\"307\":1}}],[\"sayhello\",{\"1\":{\"44\":3}}],[\"swap\",{\"1\":{\"289\":1,\"297\":1}}],[\"switch\",{\"0\":{\"54\":1},\"1\":{\"54\":1}}],[\"sqlexception\",{\"1\":{\"215\":2}}],[\"sql\",{\"1\":{\"215\":4}}],[\"sc\",{\"1\":{\"336\":13}}],[\"scheduleatfixedrate\",{\"1\":{\"227\":1}}],[\"scheduler\",{\"1\":{\"227\":6}}],[\"scheduledtaskexample\",{\"1\":{\"227\":1}}],[\"scheduledthreadpoolexecutor\",{\"1\":{\"247\":1}}],[\"scheduledthreadpool\",{\"0\":{\"247\":1},\"1\":{\"184\":1,\"193\":2,\"242\":1}}],[\"scheduledexecutorservice\",{\"1\":{\"184\":1,\"193\":1,\"227\":2}}],[\"script\",{\"1\":{\"11\":1}}],[\"shift\",{\"1\":{\"336\":1}}],[\"shared表示是获取共享资源时被阻塞挂起后放入aqs队列的\",{\"1\":{\"283\":1}}],[\"shutdownnow\",{\"1\":{\"179\":2,\"194\":2,\"196\":2,\"219\":2,\"227\":2,\"233\":3,\"239\":6,\"258\":1}}],[\"shutdown\",{\"0\":{\"257\":1},\"1\":{\"179\":1,\"194\":1,\"196\":1,\"219\":1,\"223\":1,\"227\":1,\"233\":2,\"239\":4,\"254\":1,\"257\":3,\"259\":1,\"264\":2}}],[\"short\",{\"1\":{\"50\":2,\"54\":1}}],[\"shouldprefetch\",{\"1\":{\"17\":1}}],[\"sleep\",{\"1\":{\"131\":1,\"140\":2,\"142\":1,\"144\":1,\"167\":1,\"168\":1,\"170\":3,\"172\":3,\"179\":1,\"194\":1,\"196\":1,\"219\":1,\"223\":1,\"264\":1}}],[\"simplewebserver\",{\"1\":{\"211\":3}}],[\"singlethreadexecutor\",{\"0\":{\"246\":1},\"1\":{\"193\":2,\"242\":1}}],[\"singlethreadpool\",{\"1\":{\"183\":1}}],[\"singleton\",{\"1\":{\"106\":2}}],[\"sizectl\",{\"1\":{\"336\":5}}],[\"size\",{\"1\":{\"121\":3,\"123\":1,\"303\":1}}],[\"sz\",{\"1\":{\"121\":2}}],[\"sync\",{\"1\":{\"288\":2}}],[\"synchronizedmap\",{\"1\":{\"333\":1}}],[\"synchronizedlist包装arraylist\",{\"1\":{\"308\":1}}],[\"synchronized与wait\",{\"1\":{\"282\":1}}],[\"synchronized的性能比reentrantlock差很多\",{\"1\":{\"282\":1}}],[\"synchronized的实现原理\",{\"0\":{\"270\":1}}],[\"synchronized是java语言的关键字\",{\"1\":{\"282\":1}}],[\"synchronized是怎么加锁的呢\",{\"0\":{\"271\":1}}],[\"synchronized做了哪些优化\",{\"0\":{\"278\":1}}],[\"synchronized优化了解吗\",{\"0\":{\"277\":1}}],[\"synchronized怎么实现可重入的呢\",{\"0\":{\"276\":1}}],[\"synchronized怎么保证有序性\",{\"0\":{\"275\":1}}],[\"synchronized怎么保证可见性\",{\"0\":{\"274\":1}}],[\"synchronized同步的代码块\",{\"1\":{\"275\":1}}],[\"synchronized可见性\",{\"0\":{\"273\":1}}],[\"synchronized锁住的是什么呢\",{\"0\":{\"272\":1}}],[\"synchronized修饰代码块时\",{\"1\":{\"271\":1}}],[\"synchronized\",{\"1\":{\"269\":5,\"271\":1,\"272\":2,\"276\":2,\"282\":1,\"333\":1}}],[\"synchronized用过吗\",{\"0\":{\"269\":1}}],[\"synchronized关键字等\",{\"1\":{\"103\":1}}],[\"synchronous\",{\"1\":{\"237\":1}}],[\"synchronousqueue<runnable>\",{\"1\":{\"245\":1}}],[\"synchronousqueue\",{\"1\":{\"235\":1}}],[\"system\",{\"1\":{\"35\":1,\"36\":4,\"44\":1,\"73\":1,\"74\":4,\"95\":1,\"122\":1,\"123\":1,\"140\":3,\"142\":4,\"144\":3,\"148\":4,\"157\":1,\"158\":1,\"162\":1,\"170\":2,\"172\":1,\"179\":2,\"185\":1,\"194\":1,\"196\":1,\"215\":1,\"219\":1,\"223\":3,\"227\":2,\"252\":1,\"254\":1,\"264\":2,\"267\":1}}],[\"spring里的很多注解\",{\"1\":{\"47\":1}}],[\"spring\",{\"1\":{\"47\":2}}],[\"spin\",{\"1\":{\"336\":1}}],[\"spinclock\",{\"1\":{\"272\":1}}],[\"spinfreq\",{\"1\":{\"272\":1}}],[\"spi机制的应用场景\",{\"1\":{\"44\":1}}],[\"spi机制的优势\",{\"1\":{\"44\":1}}],[\"spi机制的工作原理如下\",{\"1\":{\"44\":1}}],[\"spi中的几个关键元素\",{\"1\":{\"44\":1}}],[\"sdk\",{\"1\":{\"39\":1}}],[\"s2\",{\"1\":{\"36\":2}}],[\"s1\",{\"1\":{\"36\":2}}],[\"socket\",{\"1\":{\"211\":3}}],[\"source\",{\"1\":{\"81\":2}}],[\"sourcemap\",{\"1\":{\"11\":1}}],[\"sorted\",{\"1\":{\"36\":4}}],[\"s\",{\"1\":{\"35\":2,\"36\":12,\"61\":1,\"65\":3}}],[\"succ\",{\"1\":{\"272\":1}}],[\"submit\",{\"1\":{\"194\":1,\"196\":1,\"211\":1,\"219\":1,\"223\":1,\"230\":1,\"238\":3,\"249\":1,\"254\":1,\"264\":2}}],[\"subdependencies\",{\"1\":{\"11\":1}}],[\"suppresswarnings\",{\"1\":{\"336\":1}}],[\"supplyasync\",{\"1\":{\"154\":2,\"156\":1,\"157\":1,\"158\":1,\"160\":2,\"161\":2,\"162\":3,\"164\":1,\"165\":1,\"167\":1,\"168\":1,\"170\":3,\"172\":3,\"175\":1,\"176\":1,\"178\":1,\"179\":1,\"185\":1}}],[\"supplier\",{\"1\":{\"34\":1}}],[\"super\",{\"1\":{\"122\":1,\"247\":1,\"250\":2}}],[\"segment如果是空就先初始化\",{\"1\":{\"335\":1}}],[\"segment之间相互不会受到影响\",{\"1\":{\"335\":1}}],[\"segment则包含hashentry的数组\",{\"1\":{\"335\":1}}],[\"segment继承于reentrantlock\",{\"1\":{\"335\":1}}],[\"sendemail\",{\"1\":{\"223\":2}}],[\"seconds\",{\"1\":{\"146\":1,\"150\":1,\"167\":1,\"168\":1,\"194\":1,\"196\":2,\"219\":1,\"227\":2,\"229\":1,\"233\":1,\"239\":1,\"245\":1}}],[\"semaphore可以设置为公平模式\",{\"1\":{\"146\":1}}],[\"semaphoreexample\",{\"1\":{\"144\":1}}],[\"semaphore\",{\"0\":{\"144\":1},\"1\":{\"144\":5,\"145\":1,\"146\":3}}],[\"setqueue\",{\"1\":{\"262\":1}}],[\"setcorepoolsize\",{\"1\":{\"262\":1}}],[\"setmaximumpoolsize\",{\"1\":{\"262\":1}}],[\"setmaxidle\",{\"1\":{\"215\":1}}],[\"setmaxopenpreparedstatements\",{\"1\":{\"215\":1}}],[\"setminidle\",{\"1\":{\"215\":1}}],[\"setpassword\",{\"1\":{\"215\":1}}],[\"setuncaughtexceptionhandler\",{\"1\":{\"251\":1}}],[\"setusername\",{\"1\":{\"215\":1}}],[\"seturl\",{\"1\":{\"215\":1}}],[\"setthreshold\",{\"1\":{\"121\":1}}],[\"set\",{\"0\":{\"340\":1},\"1\":{\"113\":1,\"121\":1,\"122\":1,\"343\":1}}],[\"serial语义的存在\",{\"1\":{\"275\":1}}],[\"serial语义的意思是\",{\"1\":{\"108\":1}}],[\"serial语义\",{\"1\":{\"108\":2}}],[\"serial又是什么\",{\"0\":{\"108\":1}}],[\"serial\",{\"1\":{\"107\":1}}],[\"serialversionuid的值保持不变\",{\"1\":{\"68\":1}}],[\"serialversionuid\",{\"1\":{\"68\":1}}],[\"serializable接口有什么用\",{\"1\":{\"68\":1}}],[\"service3数据\",{\"1\":{\"172\":1}}],[\"service2数据\",{\"1\":{\"172\":1}}],[\"service1数据\",{\"1\":{\"172\":1}}],[\"serviceloader<helloservice>\",{\"1\":{\"44\":2}}],[\"services\",{\"1\":{\"44\":3}}],[\"service\",{\"1\":{\"44\":9}}],[\"serversocket\",{\"1\":{\"211\":5}}],[\"server\",{\"1\":{\"11\":1}}],[\"select\",{\"1\":{\"11\":1,\"215\":1}}],[\"src\",{\"1\":{\"11\":1}}],[\"stopworker\",{\"1\":{\"264\":2}}],[\"stop\",{\"0\":{\"258\":1},\"1\":{\"258\":2,\"259\":1}}],[\"storage\",{\"1\":{\"199\":1}}],[\"storeload\",{\"1\":{\"111\":1}}],[\"storestore\",{\"1\":{\"111\":1}}],[\"store\",{\"1\":{\"11\":2}}],[\"stealing\",{\"1\":{\"237\":1}}],[\"stmt\",{\"1\":{\"215\":2}}],[\"stamp\",{\"1\":{\"292\":1,\"336\":1}}],[\"state+1\",{\"1\":{\"283\":1}}],[\"state值时通过\",{\"1\":{\"283\":1}}],[\"state\",{\"1\":{\"283\":1,\"288\":1}}],[\"static修饰的方法\",{\"1\":{\"93\":1}}],[\"static等修饰符所修饰\",{\"1\":{\"92\":1}}],[\"static\",{\"1\":{\"74\":6,\"77\":1,\"91\":1,\"93\":1,\"113\":1,\"119\":2,\"122\":1,\"140\":3,\"142\":2,\"144\":2,\"148\":3,\"170\":1,\"172\":4,\"179\":1,\"194\":1,\"196\":1,\"211\":1,\"215\":1,\"219\":2,\"223\":2,\"227\":1,\"244\":1,\"245\":1,\"246\":1,\"254\":1,\"264\":1,\"267\":1,\"269\":1}}],[\"staic\",{\"1\":{\"269\":1}}],[\"start\",{\"1\":{\"107\":3,\"122\":1,\"140\":10,\"142\":1,\"144\":1,\"148\":2,\"264\":1}}],[\"startswithb\",{\"1\":{\"36\":1}}],[\"startswith\",{\"1\":{\"36\":6}}],[\"stars\",{\"1\":{\"4\":1}}],[\"star\",{\"0\":{\"4\":1}}],[\"str2\",{\"0\":{\"61\":1}}],[\"str1\",{\"0\":{\"61\":1},\"1\":{\"61\":1}}],[\"string怎么转成integer的\",{\"0\":{\"65\":1}}],[\"string的确是不可变的\",{\"1\":{\"62\":1}}],[\"string不是不可变类吗\",{\"0\":{\"62\":1}}],[\"string是不可变的\",{\"1\":{\"60\":1}}],[\"string是java基本数据类型吗\",{\"1\":{\"59\":1}}],[\"stringbuilder是stringbuffer的非线程安全版本\",{\"1\":{\"60\":1}}],[\"stringbuilder类\",{\"1\":{\"60\":1}}],[\"stringbuilder\",{\"1\":{\"60\":1}}],[\"stringbuffer的性能相对较低\",{\"1\":{\"60\":1}}],[\"stringbuffer的方法都使用synchronized关键字进行同步\",{\"1\":{\"60\":1}}],[\"stringbuffer是可变的\",{\"1\":{\"60\":1}}],[\"stringbuffer类\",{\"1\":{\"60\":1}}],[\"stringbuffer\",{\"0\":{\"60\":1},\"1\":{\"60\":1}}],[\"string和stringbuilder\",{\"0\":{\"60\":1}}],[\"string类是线程安全的\",{\"1\":{\"60\":1}}],[\"string类\",{\"1\":{\"60\":1}}],[\"string类的不可变性使得它在安全性和可靠性方面更加可靠\",{\"1\":{\"59\":1}}],[\"string类的不可变性使得它可以被安全地用于多线程环境下\",{\"1\":{\"59\":1}}],[\"string类在java中被声明为final类\",{\"1\":{\"59\":1}}],[\"string上\",{\"0\":{\"54\":1}}],[\"string\",{\"0\":{\"59\":1,\"61\":2},\"1\":{\"36\":3,\"54\":1,\"59\":3,\"60\":1,\"61\":5,\"65\":3,\"74\":3,\"122\":1,\"140\":2,\"142\":1,\"144\":1,\"148\":5,\"150\":1,\"162\":3,\"170\":1,\"172\":5,\"179\":1,\"194\":1,\"196\":1,\"211\":1,\"215\":1,\"219\":1,\"223\":2,\"227\":1,\"254\":1,\"264\":1,\"267\":1}}],[\"stringcollection\",{\"1\":{\"36\":17}}],[\"stream的常用api\",{\"1\":{\"36\":1}}],[\"stream的常用操作有\",{\"1\":{\"36\":1}}],[\"stream流一般用于集合\",{\"1\":{\"36\":1}}],[\"stream\",{\"0\":{\"36\":1},\"1\":{\"32\":2,\"36\":12,\"170\":2,\"172\":1}}],[\"+除留余数法\",{\"1\":{\"331\":1}}],[\"+1\",{\"1\":{\"272\":1}}],[\"++size\",{\"1\":{\"318\":1}}],[\"++bincount\",{\"1\":{\"318\":1}}],[\"++和\",{\"1\":{\"57\":1}}],[\"++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\",{\"1\":{\"11\":1}}],[\"++++++++\",{\"1\":{\"11\":1}}],[\"+\",{\"1\":{\"11\":4,\"36\":2,\"62\":2,\"92\":1,\"104\":1,\"122\":1,\"142\":4,\"144\":4,\"148\":8,\"156\":1,\"160\":1,\"161\":1,\"162\":4,\"170\":1,\"172\":5,\"179\":1,\"185\":2,\"194\":4,\"196\":4,\"215\":1,\"219\":3,\"223\":1,\"227\":1,\"252\":1,\"254\":1,\"264\":5,\"267\":2,\"272\":1,\"298\":1,\"303\":2,\"312\":3,\"336\":3}}],[\"+606\",{\"1\":{\"11\":1}}],[\"+83\",{\"1\":{\"11\":1}}],[\"t线程还在同步代码块中\",{\"1\":{\"280\":1}}],[\"t线程已经退出同步代码块\",{\"1\":{\"280\":1}}],[\"ttl通过重写\",{\"1\":{\"124\":1}}],[\"ttl\",{\"0\":{\"124\":1},\"1\":{\"124\":1}}],[\"tabat\",{\"1\":{\"336\":1}}],[\"tab\",{\"1\":{\"318\":8,\"319\":4,\"336\":17}}],[\"table\",{\"1\":{\"119\":2,\"121\":2,\"318\":1,\"319\":1,\"336\":5}}],[\"take\",{\"1\":{\"247\":1,\"264\":1}}],[\"task2\",{\"1\":{\"267\":2}}],[\"task1\",{\"1\":{\"267\":3}}],[\"taskid\",{\"1\":{\"264\":3}}],[\"taskqueue\",{\"1\":{\"264\":4}}],[\"task\",{\"1\":{\"142\":3,\"252\":1,\"254\":3,\"264\":6,\"267\":2}}],[\"target\",{\"1\":{\"81\":2}}],[\"type\",{\"1\":{\"78\":1,\"81\":1}}],[\"t\",{\"1\":{\"77\":1,\"78\":1,\"122\":2,\"250\":7,\"251\":1,\"280\":1}}],[\"threshold\",{\"1\":{\"121\":7,\"318\":4}}],[\"threadfactory\",{\"1\":{\"235\":1,\"251\":4}}],[\"threadpool\",{\"1\":{\"211\":3,\"264\":3}}],[\"threadpoolexecutor\",{\"1\":{\"196\":3,\"229\":1,\"244\":1,\"245\":1,\"246\":1,\"250\":1,\"252\":2,\"255\":1,\"262\":2}}],[\"threadpoolexample\",{\"1\":{\"194\":1}}],[\"thread类中的静态方法\",{\"1\":{\"131\":2}}],[\"thread类的方法\",{\"1\":{\"131\":1}}],[\"thread类适合直接创建新线程\",{\"1\":{\"130\":1}}],[\"thread类有一个类型为threadlocal\",{\"1\":{\"115\":1}}],[\"thread和runnable有什么区别\",{\"0\":{\"130\":1}}],[\"thread\",{\"1\":{\"122\":2,\"123\":2,\"130\":1,\"140\":22,\"142\":5,\"144\":5,\"148\":6,\"167\":1,\"168\":1,\"170\":3,\"172\":3,\"179\":1,\"194\":3,\"196\":3,\"199\":1,\"219\":3,\"223\":2,\"227\":1,\"250\":1,\"251\":6,\"254\":1,\"255\":1,\"264\":7,\"336\":1}}],[\"threadlocalhashcode\",{\"1\":{\"119\":1,\"121\":1}}],[\"threadlocal本身不存储值\",{\"1\":{\"115\":1}}],[\"threadlocalmap\",{\"1\":{\"123\":2}}],[\"threadlocalmap扩容机制了解吗\",{\"0\":{\"121\":1}}],[\"threadlocalmap怎么解决hash冲突的\",{\"0\":{\"120\":1}}],[\"threadlocalmap用的是哈希取余法\",{\"1\":{\"119\":1}}],[\"threadlocalmap的结构了解吗\",{\"0\":{\"119\":1}}],[\"threadlocalmap的key没了\",{\"1\":{\"116\":1}}],[\"threadlocalmap的key\",{\"1\":{\"116\":1}}],[\"threadlocalmap的实例变量threadlocals\",{\"1\":{\"115\":1}}],[\"threadlocalmap中使用的\",{\"1\":{\"116\":1}}],[\"threadlocalmap内部维护着entry数组\",{\"1\":{\"115\":1}}],[\"threadlocal怎么实现的呢\",{\"0\":{\"115\":1}}],[\"threadlocal<\",{\"1\":{\"121\":1}}],[\"threadlocal<>\",{\"1\":{\"113\":1}}],[\"threadlocal<string>\",{\"1\":{\"113\":1}}],[\"threadlocal是什么\",{\"0\":{\"113\":1}}],[\"threadlocal\",{\"0\":{\"112\":1,\"116\":1},\"1\":{\"113\":1,\"116\":1,\"122\":4,\"123\":3,\"124\":1,\"138\":1}}],[\"throws\",{\"1\":{\"72\":1,\"140\":2,\"211\":2}}],[\"throw\",{\"1\":{\"72\":1,\"164\":1,\"165\":1,\"167\":1,\"168\":1,\"170\":4,\"172\":3,\"179\":1,\"254\":1,\"303\":1}}],[\"throwable\",{\"1\":{\"71\":1,\"250\":1}}],[\"this|object\",{\"1\":{\"269\":1}}],[\"this\",{\"1\":{\"123\":3,\"142\":1,\"144\":1,\"148\":2,\"264\":1,\"267\":1,\"269\":1,\"292\":1,\"298\":1,\"318\":1,\"336\":2}}],[\"this相当于是指向当前对象本身\",{\"1\":{\"90\":1}}],[\"this的用法在java中大体可以分为3种\",{\"1\":{\"90\":1}}],[\"this关键字有什么作用\",{\"0\":{\"90\":1}}],[\"thencombine\",{\"0\":{\"161\":1},\"1\":{\"161\":1}}],[\"thencompose\",{\"0\":{\"160\":1},\"1\":{\"160\":1}}],[\"thenrun\",{\"0\":{\"158\":1},\"1\":{\"158\":1}}],[\"thenacceptasync\",{\"1\":{\"185\":1}}],[\"thenaccept\",{\"0\":{\"157\":1},\"1\":{\"157\":1,\"162\":1,\"170\":1,\"172\":1,\"179\":1}}],[\"thenapplyasync\",{\"1\":{\"185\":1}}],[\"thenapply\",{\"0\":{\"156\":1},\"1\":{\"156\":1}}],[\"then\",{\"1\":{\"11\":1}}],[\"the\",{\"1\":{\"11\":1,\"81\":1,\"121\":1,\"123\":1}}],[\"theme\",{\"1\":{\"8\":1,\"10\":1,\"11\":5,\"17\":2}}],[\"treeifybin\",{\"1\":{\"318\":2}}],[\"treeify\",{\"1\":{\"318\":2}}],[\"treenode<k\",{\"1\":{\"318\":1,\"319\":1}}],[\"treenode\",{\"1\":{\"318\":1,\"319\":1}}],[\"treemap\",{\"0\":{\"339\":1},\"1\":{\"83\":1,\"337\":1,\"339\":2}}],[\"transferindex\",{\"1\":{\"336\":1}}],[\"transfer\",{\"1\":{\"237\":1,\"336\":1}}],[\"transmittablethreadlocal\",{\"1\":{\"124\":1}}],[\"transient\",{\"1\":{\"68\":4,\"304\":2}}],[\"tryacquire\",{\"1\":{\"146\":3,\"283\":1,\"288\":1}}],[\"try\",{\"1\":{\"72\":1,\"74\":6,\"95\":1,\"140\":2,\"142\":1,\"144\":1,\"148\":2,\"162\":1,\"167\":1,\"168\":1,\"170\":4,\"172\":4,\"179\":2,\"194\":2,\"196\":2,\"215\":1,\"219\":2,\"223\":1,\"227\":1,\"233\":1,\"239\":1,\"249\":1,\"250\":1,\"254\":1,\"264\":3,\"336\":1}}],[\"true\",{\"1\":{\"35\":1,\"36\":1,\"81\":2,\"142\":1,\"146\":2,\"211\":1,\"254\":1,\"264\":1,\"288\":2,\"289\":1}}],[\"tidying\",{\"0\":{\"259\":1},\"1\":{\"259\":2,\"260\":1}}],[\"timout\",{\"1\":{\"131\":1}}],[\"timeunit\",{\"1\":{\"140\":1,\"146\":1,\"150\":1,\"167\":1,\"168\":1,\"179\":2,\"194\":2,\"196\":3,\"219\":2,\"227\":3,\"229\":1,\"233\":1,\"235\":1,\"239\":1,\"244\":1,\"245\":1,\"246\":1,\"250\":1,\"252\":1}}],[\"time\",{\"1\":{\"132\":1}}],[\"timeoutexception\",{\"1\":{\"142\":1}}],[\"timeout\",{\"1\":{\"66\":2,\"131\":2,\"140\":1}}],[\"time包\",{\"1\":{\"32\":1}}],[\"title\",{\"1\":{\"17\":1}}],[\"ts\",{\"0\":{\"17\":1},\"1\":{\"23\":1}}],[\"terminated\",{\"0\":{\"260\":1},\"1\":{\"132\":1,\"260\":2}}],[\"terser\",{\"1\":{\"11\":1}}],[\"test\",{\"1\":{\"74\":6}}],[\"template\",{\"1\":{\"11\":2}}],[\"tolist\",{\"1\":{\"170\":1}}],[\"tostring\",{\"1\":{\"66\":1,\"252\":1}}],[\"touppercase\",{\"1\":{\"36\":1}}],[\"to\",{\"1\":{\"11\":2,\"20\":1,\"81\":1,\"121\":1,\"123\":1,\"336\":1}}],[\"tmp\",{\"1\":{\"11\":2}}],[\"v>\",{\"1\":{\"318\":2,\"319\":5,\"336\":10}}],[\"vector的所有方法都是同步的\",{\"1\":{\"308\":1}}],[\"vector是一个线程安全的动态数组类\",{\"1\":{\"308\":1}}],[\"vm\",{\"1\":{\"123\":2}}],[\"val\",{\"1\":{\"292\":2}}],[\"valatile保证有序性\",{\"1\":{\"111\":1}}],[\"value的能力能指向下一个节点的指针\",{\"1\":{\"335\":1}}],[\"value还在\",{\"1\":{\"116\":1}}],[\"value是threadlocal的泛型值\",{\"1\":{\"115\":1}}],[\"valueof\",{\"1\":{\"64\":1,\"65\":1}}],[\"value\",{\"1\":{\"47\":1,\"60\":2,\"78\":2,\"121\":1,\"245\":2,\"247\":2,\"298\":1,\"318\":3,\"319\":1,\"336\":1,\"341\":3}}],[\"volatile修饰原数组array\",{\"1\":{\"309\":1}}],[\"volatile\",{\"1\":{\"264\":1,\"283\":2}}],[\"volatile和synchronized关键字\",{\"1\":{\"138\":1}}],[\"volatile怎么保证有序性的呢\",{\"0\":{\"111\":1}}],[\"volatile怎么保证可见性的呢\",{\"0\":{\"110\":1}}],[\"volatile可以确保对某个变量的更新对其他线程马上可见\",{\"1\":{\"110\":1}}],[\"volatile就是更轻量的选择\",{\"1\":{\"110\":1}}],[\"volatile有两个作用\",{\"1\":{\"109\":1}}],[\"volatile实现原理了解吗\",{\"0\":{\"109\":1}}],[\"volatile变量规则\",{\"1\":{\"107\":1}}],[\"volatile关键字\",{\"1\":{\"103\":1}}],[\"void\",{\"1\":{\"44\":2,\"74\":3,\"121\":2,\"122\":2,\"131\":1,\"140\":3,\"142\":3,\"144\":2,\"148\":3,\"170\":1,\"172\":1,\"179\":1,\"194\":1,\"196\":1,\"211\":2,\"215\":1,\"219\":2,\"223\":2,\"227\":1,\"250\":1,\"252\":1,\"254\":1,\"264\":5,\"267\":1,\"269\":2}}],[\"v\",{\"1\":{\"78\":1,\"162\":1,\"170\":1,\"172\":1,\"289\":7,\"298\":5,\"319\":1,\"341\":1}}],[\"virtual\",{\"1\":{\"39\":1}}],[\"visibility\",{\"1\":{\"20\":1,\"103\":1}}],[\"vite\",{\"1\":{\"11\":1}}],[\"v5\",{\"1\":{\"11\":1}}],[\"vue\",{\"1\":{\"11\":1}}],[\"vuepress\",{\"1\":{\"10\":1,\"11\":8,\"17\":1}}],[\"v3\",{\"1\":{\"11\":2}}],[\"bin\",{\"1\":{\"336\":1}}],[\"bincount\",{\"1\":{\"318\":3}}],[\"bio\",{\"0\":{\"30\":1},\"1\":{\"30\":1}}],[\"bucket\",{\"1\":{\"312\":1,\"337\":1}}],[\"buffers\",{\"1\":{\"69\":1}}],[\"b又变回a的情况\",{\"1\":{\"291\":1}}],[\"bounded\",{\"1\":{\"237\":1}}],[\"boot\",{\"1\":{\"47\":1}}],[\"boolean等\",{\"1\":{\"98\":1}}],[\"boolean\",{\"1\":{\"36\":3,\"50\":2,\"81\":1,\"131\":2,\"140\":1,\"146\":2,\"264\":1,\"288\":1,\"292\":2,\"298\":2,\"341\":1}}],[\"by\",{\"1\":{\"219\":1}}],[\"byte\",{\"0\":{\"54\":1},\"1\":{\"50\":2,\"54\":1}}],[\"beforec\",{\"1\":{\"107\":1}}],[\"before于线程a从threadb\",{\"1\":{\"107\":1}}],[\"before于线程b中的任意操作\",{\"1\":{\"107\":1}}],[\"before于任意后续对这个volatile域的读\",{\"1\":{\"107\":1}}],[\"before于随后对这个锁的加锁\",{\"1\":{\"107\":1}}],[\"before于该线程中的任意后续操作\",{\"1\":{\"107\":1}}],[\"before和我们息息相关的有六大规则\",{\"1\":{\"107\":1}}],[\"before关系来执行的结果一致\",{\"1\":{\"107\":1}}],[\"before关系指定的顺序来执行\",{\"1\":{\"107\":1}}],[\"before关系\",{\"1\":{\"107\":1}}],[\"before另一个操作\",{\"1\":{\"107\":1}}],[\"before的定义\",{\"1\":{\"107\":1}}],[\"before\",{\"1\":{\"107\":3}}],[\"before了解吗\",{\"0\":{\"107\":1}}],[\"brokenbarrierexception\",{\"1\":{\"142\":3}}],[\"break\",{\"0\":{\"55\":1},\"1\":{\"55\":1,\"318\":2,\"336\":4}}],[\"branches\",{\"1\":{\"16\":1}}],[\"bbb2\",{\"1\":{\"36\":1}}],[\"bbb3\",{\"1\":{\"36\":1}}],[\"bbb1\",{\"1\":{\"36\":1}}],[\"blockingqueue\",{\"1\":{\"264\":1}}],[\"blockingqueue<runnable>\",{\"1\":{\"250\":1,\"264\":1}}],[\"blocked状态表示线程被阻塞\",{\"1\":{\"133\":1}}],[\"blocked和waiting有什么区别\",{\"0\":{\"133\":1}}],[\"blocked\",{\"1\":{\"132\":1}}],[\"bloch\",{\"1\":{\"32\":1}}],[\"blogs\",{\"1\":{\"11\":1}}],[\"blogs>\",{\"1\":{\"11\":1}}],[\"blog\",{\"1\":{\"11\":1}}],[\"b\",{\"0\":{\"64\":1},\"1\":{\"30\":5,\"36\":4,\"107\":1,\"289\":2}}],[\"basicdatasource\",{\"1\":{\"215\":3}}],[\"base\",{\"1\":{\"17\":1}}],[\"barrier\",{\"1\":{\"141\":1,\"142\":8}}],[\"bam\",{\"1\":{\"35\":3}}],[\"baidusyncdisk\",{\"1\":{\"11\":2}}],[\"displaced\",{\"1\":{\"281\":1}}],[\"display\",{\"1\":{\"11\":1}}],[\"discardoldestpolicy\",{\"1\":{\"236\":1}}],[\"discardpolicy\",{\"1\":{\"236\":1}}],[\"dbcp2\",{\"1\":{\"215\":1}}],[\"dbcp为例\",{\"1\":{\"215\":1}}],[\"datasource\",{\"1\":{\"215\":8}}],[\"databaseconnectionpoolexample\",{\"1\":{\"215\":1}}],[\"data\",{\"1\":{\"148\":6,\"150\":1,\"219\":2}}],[\"daemon\",{\"1\":{\"137\":1}}],[\"daiwencheng\",{\"1\":{\"11\":2}}],[\"dubbo等\",{\"1\":{\"69\":1}}],[\"ddd1\",{\"1\":{\"36\":1}}],[\"ddd2\",{\"1\":{\"36\":1}}],[\"d\",{\"0\":{\"64\":1},\"1\":{\"30\":2}}],[\"delta\",{\"1\":{\"298\":2}}],[\"delayqueue\",{\"1\":{\"247\":1}}],[\"delayedworkqueue\",{\"1\":{\"247\":1}}],[\"delay\",{\"1\":{\"237\":1}}],[\"declares\",{\"1\":{\"81\":1}}],[\"description\",{\"1\":{\"17\":1}}],[\"defineuserconfig\",{\"1\":{\"17\":1}}],[\"defaultcapacity\",{\"1\":{\"303\":1}}],[\"default\",{\"1\":{\"17\":1,\"81\":1,\"89\":1,\"123\":1,\"247\":1,\"303\":1,\"336\":1}}],[\"development\",{\"1\":{\"39\":1}}],[\"dev\",{\"1\":{\"11\":3,\"14\":1}}],[\"devdependencies\",{\"1\":{\"11\":2}}],[\"demo\",{\"1\":{\"11\":1}}],[\"deploy\",{\"0\":{\"16\":1}}],[\"dependency\",{\"1\":{\"11\":2,\"81\":1}}],[\"deprecated\",{\"1\":{\"11\":1}}],[\"do\",{\"1\":{\"298\":1,\"319\":1}}],[\"doubling\",{\"1\":{\"121\":1}}],[\"double\",{\"1\":{\"50\":2}}],[\"done\",{\"1\":{\"11\":4}}],[\"downloaded\",{\"1\":{\"11\":2}}],[\"documented\",{\"1\":{\"81\":1}}],[\"documents\",{\"1\":{\"11\":2}}],[\"docsbranch\",{\"1\":{\"23\":1}}],[\"docs的settings项\",{\"1\":{\"21\":1}}],[\"docs\",{\"0\":{\"16\":1},\"1\":{\"10\":1,\"11\":3,\"14\":2,\"17\":1,\"20\":1}}],[\"dlx\",{\"1\":{\"11\":2}}],[\"cmp\",{\"1\":{\"292\":2}}],[\"cxq\",{\"1\":{\"272\":1}}],[\"ce\",{\"1\":{\"250\":2}}],[\"currenttimemillis\",{\"1\":{\"227\":1}}],[\"currentthread\",{\"1\":{\"142\":3,\"144\":3,\"148\":4,\"194\":2,\"196\":2,\"219\":2,\"223\":1,\"250\":1,\"254\":1,\"264\":4}}],[\"customthreadpoolexample\",{\"1\":{\"179\":1,\"196\":1}}],[\"customthreadpool\",{\"1\":{\"177\":1,\"178\":1,\"179\":6,\"250\":2,\"264\":4}}],[\"cyclic\",{\"1\":{\"141\":1}}],[\"cyclicbarrier可以在所有的线程释放后重新使\",{\"1\":{\"143\":1}}],[\"cyclicbarrier面向的是线程数\",{\"1\":{\"143\":1}}],[\"cyclicbarrier是可重用的\",{\"1\":{\"143\":1}}],[\"cyclicbarrier和countdownlatch有什么区别\",{\"0\":{\"143\":1}}],[\"cyclicbarrierexample\",{\"1\":{\"142\":1}}],[\"cyclicbarrier的字面意思是可循环使用\",{\"1\":{\"141\":1}}],[\"cyclicbarrier\",{\"0\":{\"141\":1},\"1\":{\"142\":5,\"143\":1}}],[\"cpu消耗\",{\"0\":{\"201\":1}}],[\"cpu\",{\"1\":{\"131\":2,\"135\":1,\"136\":4,\"285\":1,\"286\":1}}],[\"ccl\",{\"1\":{\"123\":1}}],[\"ccc\",{\"1\":{\"36\":1}}],[\"capacity\",{\"1\":{\"303\":1,\"336\":1}}],[\"castabat\",{\"1\":{\"336\":1}}],[\"cas操作\",{\"1\":{\"336\":1}}],[\"cas操作都不做\",{\"1\":{\"278\":1}}],[\"cas+synchronized\",{\"0\":{\"336\":1}}],[\"caspair\",{\"1\":{\"292\":1}}],[\"cas\",{\"0\":{\"290\":1},\"1\":{\"283\":1,\"288\":3,\"289\":6,\"295\":2}}],[\"cas获取偏向锁失败表示有竞争\",{\"1\":{\"280\":1}}],[\"cancellationexception\",{\"1\":{\"250\":1}}],[\"callerrunspolicy\",{\"1\":{\"236\":1}}],[\"callable<integer>\",{\"1\":{\"254\":1}}],[\"callable\",{\"0\":{\"254\":1},\"1\":{\"34\":1,\"249\":1,\"254\":2}}],[\"cachedthreadpool\",{\"0\":{\"245\":1},\"1\":{\"182\":1,\"193\":2,\"242\":1}}],[\"car\",{\"1\":{\"144\":3,\"145\":1}}],[\"catch\",{\"1\":{\"72\":1,\"74\":2,\"95\":1,\"140\":2,\"142\":1,\"144\":1,\"148\":2,\"162\":1,\"167\":1,\"168\":1,\"170\":4,\"172\":4,\"179\":2,\"194\":2,\"196\":2,\"215\":1,\"219\":2,\"223\":1,\"227\":1,\"233\":1,\"239\":1,\"249\":1,\"250\":3,\"254\":2,\"264\":3}}],[\"check\",{\"1\":{\"319\":1}}],[\"checkedexception\",{\"1\":{\"71\":1}}],[\"characteristics\",{\"1\":{\"123\":1}}],[\"charat\",{\"1\":{\"35\":1}}],[\"char\",{\"1\":{\"50\":2,\"54\":1,\"60\":2}}],[\"channel代表了服务端与客户端的连接\",{\"1\":{\"30\":1}}],[\"c和d不相等\",{\"1\":{\"64\":1}}],[\"c=\",{\"0\":{\"64\":1}}],[\"cleansomeslots\",{\"1\":{\"121\":1}}],[\"clone\",{\"1\":{\"66\":1}}],[\"classloader\",{\"1\":{\"123\":1}}],[\"classname\",{\"1\":{\"77\":1}}],[\"class\",{\"0\":{\"91\":1},\"1\":{\"41\":2,\"42\":1,\"44\":3,\"46\":1,\"50\":1,\"77\":1,\"81\":4,\"122\":1,\"123\":1,\"142\":2,\"144\":2,\"148\":3,\"170\":1,\"172\":1,\"179\":1,\"194\":1,\"196\":1,\"211\":1,\"215\":1,\"219\":1,\"223\":1,\"227\":1,\"250\":1,\"254\":1,\"264\":2,\"267\":1,\"269\":3}}],[\"class文件\",{\"1\":{\"41\":1}}],[\"clientsocket\",{\"1\":{\"211\":3}}],[\"client\",{\"1\":{\"11\":1}}],[\"cn\",{\"1\":{\"17\":1}}],[\"copyonwrite\",{\"1\":{\"309\":1}}],[\"copyonwritearraylist适合在读多写少的场景中使用\",{\"1\":{\"309\":1}}],[\"copyonwritearraylist通过创建副本的方式实现线程安全\",{\"1\":{\"309\":1}}],[\"copyonwritearraylist就是线程安全版本的arraylist\",{\"1\":{\"309\":1}}],[\"copyonwritearraylist了解多少\",{\"0\":{\"309\":1}}],[\"copyonwritearraylist具有较高的性能\",{\"1\":{\"308\":1}}],[\"copyonwritearraylist是一种线程安全的并发list\",{\"1\":{\"308\":1}}],[\"column\",{\"1\":{\"215\":1}}],[\"collections\",{\"1\":{\"333\":1}}],[\"collect\",{\"1\":{\"170\":1}}],[\"collectors\",{\"1\":{\"170\":2,\"172\":1}}],[\"corepoolsize\",{\"1\":{\"195\":1,\"196\":1,\"229\":2,\"235\":1,\"247\":2,\"250\":2}}],[\"code\",{\"1\":{\"81\":1,\"303\":1,\"312\":1}}],[\"codec\",{\"1\":{\"11\":1}}],[\"commons\",{\"1\":{\"215\":2}}],[\"commonpool\",{\"1\":{\"174\":1,\"175\":1,\"185\":1}}],[\"comprator\",{\"1\":{\"339\":1}}],[\"compute\",{\"1\":{\"267\":9}}],[\"completed\",{\"1\":{\"264\":1}}],[\"completeontimeout\",{\"0\":{\"168\":1},\"1\":{\"168\":1}}],[\"completablefuture的线程池设置\",{\"0\":{\"174\":1}}],[\"completablefuturerealworldexample\",{\"1\":{\"172\":1}}],[\"completablefutureparallelexample\",{\"1\":{\"170\":1}}],[\"completablefuture<void>\",{\"1\":{\"154\":1,\"162\":1,\"170\":1,\"172\":1}}],[\"completablefuture<string>\",{\"1\":{\"154\":1,\"156\":1,\"160\":1,\"161\":3,\"162\":3,\"164\":1,\"165\":1,\"167\":1,\"168\":1,\"170\":3,\"172\":6,\"175\":1,\"178\":1,\"179\":1}}],[\"completablefuture\",{\"0\":{\"154\":1,\"159\":1,\"253\":1},\"1\":{\"152\":1,\"154\":3,\"156\":1,\"157\":1,\"158\":1,\"160\":4,\"161\":3,\"162\":5,\"164\":1,\"165\":1,\"167\":1,\"168\":1,\"170\":5,\"172\":5,\"173\":1,\"174\":1,\"175\":2,\"176\":2,\"178\":2,\"179\":2,\"185\":2,\"253\":2}}],[\"component\",{\"1\":{\"47\":1}}],[\"compareandsetint是个native方法\",{\"1\":{\"298\":1}}],[\"compareandsetint\",{\"1\":{\"298\":2,\"336\":2}}],[\"compareandset\",{\"1\":{\"292\":2,\"297\":1}}],[\"compare\",{\"1\":{\"289\":1,\"297\":1}}],[\"compareto\",{\"1\":{\"36\":1}}],[\"comparator\",{\"1\":{\"34\":1}}],[\"com\",{\"1\":{\"44\":2,\"223\":1}}],[\"countdown\",{\"1\":{\"140\":9}}],[\"countdownlatch在计数器为0\",{\"1\":{\"143\":1}}],[\"countdownlatch面向的是任务\",{\"1\":{\"143\":1}}],[\"countdownlatch中的各个子线程不可以等待其他线程\",{\"1\":{\"143\":1}}],[\"countdownlatch是一次性的\",{\"1\":{\"143\":2}}],[\"countdownlatch的核心方法\",{\"1\":{\"140\":1}}],[\"countdownlatch\",{\"0\":{\"140\":1},\"1\":{\"140\":22,\"143\":1}}],[\"count++\",{\"1\":{\"121\":1}}],[\"count\",{\"1\":{\"36\":3,\"121\":2,\"272\":3}}],[\"conn\",{\"1\":{\"215\":2}}],[\"connection\",{\"1\":{\"215\":2}}],[\"concurrent包下的容器都是安全失败\",{\"1\":{\"307\":1}}],[\"concurrent包提供了多种线程池实现\",{\"1\":{\"192\":1}}],[\"concurrent\",{\"1\":{\"148\":1,\"170\":2,\"172\":2,\"177\":2,\"179\":4,\"194\":3,\"196\":3,\"211\":2,\"219\":3,\"223\":2,\"227\":3,\"254\":1,\"264\":2,\"267\":1}}],[\"concurrenthashmap线程安全在jdk1\",{\"1\":{\"334\":1}}],[\"concurrenthashmap\",{\"1\":{\"83\":1,\"333\":2}}],[\"contextclassloader\",{\"1\":{\"123\":3}}],[\"continue\",{\"0\":{\"55\":1},\"1\":{\"55\":1}}],[\"conscious\",{\"1\":{\"303\":1}}],[\"constructor\",{\"1\":{\"46\":1,\"81\":1}}],[\"consumer\",{\"1\":{\"34\":1,\"148\":3,\"149\":1}}],[\"configuration\",{\"1\":{\"44\":1}}],[\"config\",{\"0\":{\"17\":1}}],[\"c\",{\"1\":{\"11\":2,\"30\":1,\"107\":1}}],[\"createinheritedmap\",{\"1\":{\"123\":1}}],[\"create\",{\"1\":{\"10\":1,\"11\":1}}],[\"0得0\",{\"1\":{\"322\":1}}],[\"00000006\",{\"1\":{\"326\":1}}],[\"00\",{\"1\":{\"281\":1}}],[\"01\",{\"1\":{\"280\":1}}],[\"0x61c88647\",{\"1\":{\"119\":2}}],[\"0d\",{\"1\":{\"50\":1}}],[\"0f\",{\"1\":{\"50\":1}}],[\"0l\",{\"1\":{\"50\":1,\"244\":1,\"246\":1,\"252\":1}}],[\"0\",{\"1\":{\"11\":16,\"35\":1,\"50\":5,\"74\":1,\"95\":1,\"121\":1,\"123\":2,\"164\":1,\"165\":1,\"194\":1,\"196\":1,\"227\":1,\"245\":1,\"264\":2,\"272\":8,\"288\":1,\"303\":3,\"318\":3,\"319\":1,\"336\":7}}],[\"42\",{\"1\":{\"254\":1}}],[\"4028235e38\",{\"1\":{\"50\":1}}],[\"409\",{\"1\":{\"11\":1}}],[\"45\",{\"1\":{\"50\":1}}],[\"4e\",{\"1\":{\"50\":1}}],[\"4之前的选择\",{\"1\":{\"30\":1}}],[\"4\",{\"0\":{\"159\":1,\"160\":1,\"161\":1,\"162\":1,\"180\":1,\"181\":1,\"182\":1,\"183\":1,\"184\":2,\"194\":1,\"220\":1,\"232\":1,\"247\":1,\"252\":1,\"259\":1},\"1\":{\"11\":2,\"50\":3,\"120\":2,\"121\":3,\"219\":2,\"280\":1,\"281\":1}}],[\"7版本的concurrenthashmap采用分段锁机制\",{\"1\":{\"335\":1}}],[\"7版本是基于\",{\"1\":{\"334\":1}}],[\"7和jdk1\",{\"1\":{\"332\":2}}],[\"7中\",{\"1\":{\"332\":1}}],[\"75作为hashmap的默认加载因子呢\",{\"0\":{\"328\":1}}],[\"75\",{\"0\":{\"327\":1}}],[\"7976931348623157e308\",{\"1\":{\"50\":1}}],[\"7428\",{\"1\":{\"11\":2}}],[\"7\",{\"0\":{\"169\":1,\"335\":1},\"1\":{\"11\":2,\"54\":1,\"219\":1,\"312\":1}}],[\"创建定时任务线程池\",{\"1\":{\"247\":1}}],[\"创建单线程线程池\",{\"1\":{\"246\":1}}],[\"创建缓存线程池\",{\"1\":{\"245\":1}}],[\"创建核心线程执行任务\",{\"1\":{\"244\":1}}],[\"创建核心线程和任务队列\",{\"1\":{\"234\":1}}],[\"创建固定大小线程池\",{\"1\":{\"244\":1}}],[\"创建新线程执行任务\",{\"1\":{\"231\":1}}],[\"创建自定义线程池\",{\"0\":{\"177\":1},\"1\":{\"179\":1,\"196\":1}}],[\"创建并启动两个线程\",{\"1\":{\"148\":1}}],[\"创建并启动六个线程模拟汽车\",{\"1\":{\"144\":1}}],[\"创建并启动三个线程\",{\"1\":{\"142\":1}}],[\"创建一个\",{\"1\":{\"267\":1}}],[\"创建一个自定义的线程池\",{\"1\":{\"250\":1}}],[\"创建一个自定义线程池\",{\"1\":{\"177\":1}}],[\"创建一个固定大小的线程池\",{\"1\":{\"177\":1,\"194\":1}}],[\"创建一个包含所有异步任务的completablefuture\",{\"1\":{\"170\":1}}],[\"创建一个exchanger实例\",{\"1\":{\"148\":1}}],[\"创建一个semaphore实例\",{\"1\":{\"144\":1}}],[\"创建一个threadlocal变量\",{\"1\":{\"113\":1}}],[\"创建cyclicbarrier实例\",{\"1\":{\"142\":1}}],[\"创建\",{\"0\":{\"154\":1},\"1\":{\"113\":1}}],[\"创建了一个threadloca变量localvariable\",{\"1\":{\"113\":1}}],[\"创建了一个threadlocal变量\",{\"1\":{\"113\":1}}],[\"创建了几个对象\",{\"1\":{\"61\":1}}],[\"创建对象有哪几种方式\",{\"0\":{\"100\":1}}],[\"创建对象实例的方式\",{\"1\":{\"46\":1}}],[\"创建类实例\",{\"1\":{\"46\":1}}],[\"创建过程\",{\"0\":{\"11\":1}}],[\"创建项目模板\",{\"0\":{\"10\":1}}],[\"p\",{\"1\":{\"318\":9}}],[\"pipedreader和pipedwriter\",{\"1\":{\"138\":1}}],[\"pipedinputstream\",{\"1\":{\"138\":1}}],[\"pipedoutputstream\",{\"1\":{\"138\":1}}],[\"present\",{\"1\":{\"341\":1}}],[\"preparestatement\",{\"1\":{\"215\":1}}],[\"preparedstatement\",{\"1\":{\"215\":2}}],[\"predicate\",{\"1\":{\"34\":1}}],[\"priority\",{\"1\":{\"237\":1}}],[\"printstacktrace\",{\"1\":{\"140\":1,\"142\":1,\"144\":1,\"148\":2,\"162\":1,\"172\":1,\"215\":1,\"249\":1,\"250\":1,\"251\":1,\"253\":1,\"254\":2}}],[\"print\",{\"1\":{\"74\":1}}],[\"println\",{\"1\":{\"35\":1,\"36\":4,\"44\":1,\"74\":3,\"122\":1,\"140\":3,\"142\":4,\"144\":3,\"148\":4,\"157\":1,\"158\":1,\"162\":1,\"170\":2,\"172\":1,\"179\":2,\"185\":1,\"194\":1,\"196\":1,\"215\":1,\"219\":1,\"223\":3,\"227\":1,\"252\":1,\"254\":1,\"264\":2,\"267\":1}}],[\"private\",{\"0\":{\"89\":1},\"1\":{\"60\":1,\"89\":1,\"92\":1,\"119\":3,\"121\":2,\"140\":1,\"142\":1,\"144\":1,\"148\":2,\"172\":3,\"211\":2,\"219\":1,\"223\":1,\"264\":5,\"267\":1,\"292\":1,\"303\":1,\"336\":1}}],[\"processing\",{\"1\":{\"219\":1}}],[\"process\",{\"1\":{\"219\":2}}],[\"protected和default修饰符\",{\"1\":{\"91\":1}}],[\"protected\",{\"0\":{\"89\":1},\"1\":{\"89\":1,\"250\":1,\"267\":1}}],[\"protocol\",{\"1\":{\"69\":1}}],[\"protobuf\",{\"1\":{\"69\":1}}],[\"protobuf序列化\",{\"1\":{\"69\":1}}],[\"provider\",{\"1\":{\"44\":3}}],[\"producer\",{\"1\":{\"148\":3,\"149\":1}}],[\"prod\",{\"1\":{\"11\":1}}],[\"project\",{\"1\":{\"11\":1}}],[\"progress\",{\"1\":{\"11\":2}}],[\"put流程\",{\"1\":{\"335\":1,\"336\":1}}],[\"put和get并发时\",{\"1\":{\"332\":1}}],[\"puttreeval\",{\"1\":{\"318\":1}}],[\"put\",{\"1\":{\"264\":1,\"341\":1}}],[\"public\",{\"1\":{\"20\":1,\"44\":3,\"74\":6,\"77\":4,\"81\":2,\"89\":1,\"91\":1,\"113\":1,\"122\":3,\"140\":2,\"142\":5,\"144\":4,\"148\":6,\"170\":2,\"172\":2,\"179\":2,\"194\":2,\"196\":2,\"211\":3,\"215\":2,\"219\":2,\"223\":2,\"227\":2,\"244\":1,\"245\":1,\"246\":1,\"247\":1,\"250\":2,\"251\":1,\"252\":1,\"254\":2,\"264\":7,\"267\":3,\"288\":2,\"292\":1,\"298\":4,\"319\":1,\"341\":1}}],[\"push\",{\"1\":{\"16\":1}}],[\"pwa\",{\"1\":{\"17\":1}}],[\"posts\",{\"0\":{\"344\":1}}],[\"postinstall\",{\"1\":{\"11\":1}}],[\"polymorphicsignature\",{\"1\":{\"292\":1}}],[\"port\",{\"1\":{\"211\":2}}],[\"pool\",{\"1\":{\"255\":1}}],[\"poolsize\",{\"1\":{\"211\":2,\"264\":6}}],[\"pool2\",{\"1\":{\"185\":3}}],[\"pool1\",{\"1\":{\"185\":3}}],[\"powershell\",{\"1\":{\"11\":1}}],[\"plugin\",{\"1\":{\"11\":1}}],[\"pair\",{\"1\":{\"292\":1}}],[\"pair<v>\",{\"1\":{\"292\":2}}],[\"password\",{\"1\":{\"215\":1}}],[\"parkinglot\",{\"1\":{\"144\":8,\"146\":3}}],[\"park\",{\"1\":{\"133\":1,\"283\":1}}],[\"parent\",{\"1\":{\"123\":2}}],[\"parentmap\",{\"1\":{\"123\":4}}],[\"paralleldataprocessingexample\",{\"1\":{\"219\":1}}],[\"parallelism\",{\"1\":{\"106\":1}}],[\"parameter\",{\"1\":{\"81\":1}}],[\"parseint\",{\"1\":{\"65\":1}}],[\"pages是发布分支\",{\"1\":{\"22\":1}}],[\"pages分支\",{\"0\":{\"22\":1}}],[\"pages\",{\"0\":{\"19\":1,\"21\":1},\"1\":{\"11\":1,\"21\":1,\"22\":1}}],[\"pages搭建\",{\"1\":{\"8\":1}}],[\"packages\",{\"1\":{\"11\":1}}],[\"package\",{\"1\":{\"11\":1}}],[\"ps\",{\"1\":{\"11\":1}}],[\"pnpm\",{\"1\":{\"10\":1,\"11\":5}}],[\"和hashmap的get流程基本相同\",{\"1\":{\"336\":1}}],[\"和统计学有关\",{\"1\":{\"326\":1}}],[\"和安全失败\",{\"0\":{\"307\":1}}],[\"和内存位置\",{\"1\":{\"289\":1}}],[\"和新值\",{\"1\":{\"289\":1}}],[\"和公平锁一样都会进入到\",{\"1\":{\"288\":1}}],[\"和notify\",{\"1\":{\"282\":1}}],[\"和unlock\",{\"1\":{\"282\":1}}],[\"和第\",{\"1\":{\"267\":1}}],[\"和recursiveaction用于表示没有返回值的任务\",{\"1\":{\"267\":1}}],[\"和submit\",{\"1\":{\"238\":1}}],[\"和string\",{\"0\":{\"61\":1}}],[\"和无界队列\",{\"1\":{\"235\":1}}],[\"和任务队列\",{\"1\":{\"229\":1}}],[\"和join\",{\"1\":{\"138\":1}}],[\"和引用数据类型变量的地址值\",{\"1\":{\"99\":1}}],[\"和常量\",{\"1\":{\"91\":1}}],[\"和接口\",{\"0\":{\"91\":1}}],[\"和接⼝\",{\"1\":{\"87\":1}}],[\"和重写\",{\"0\":{\"88\":1}}],[\"和⼯具\",{\"1\":{\"39\":1}}],[\"和\",{\"0\":{\"39\":1,\"53\":1,\"61\":1,\"254\":1},\"1\":{\"8\":1,\"28\":3,\"39\":1,\"107\":1,\"137\":1,\"142\":1,\"306\":1,\"317\":1,\"330\":1}}],[\"幻灯片页\",{\"0\":{\"6\":1}}],[\"趋势\",{\"0\":{\"4\":1}}],[\"||\",{\"1\":{\"318\":3,\"319\":2,\"336\":5,\"341\":1}}],[\"|\",{\"1\":{\"1\":1,\"11\":2,\"142\":1,\"162\":1,\"170\":1,\"172\":1}}],[\"欢迎来到鱼塘\",{\"1\":{\"1\":1}}],[\"鱼塘\",{\"0\":{\"0\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n}})=>{e==="suggest"?self.postMessage(st(t,v[s],n)):e==="search"?self.postMessage(et(t,v[s],n)):self.postMessage({suggestions:st(t,v[s],n),results:et(t,v[s],n)})};
//# sourceMappingURL=index.js.map
