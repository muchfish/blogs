const nt="ENTRIES",V="KEYS",T="VALUES",F="";class D{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===F)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==F).join("")}value(){return E(this._path).node.get(F)}result(){switch(this._type){case T:return this.value();case V:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],ot=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return W(e,t,s,n,i,1,o,""),n},W=(e,t,s,n,o,u,i,r)=>{const h=u*i;t:for(const c of e.keys())if(c===F){const d=o[h-1];d<=s&&n.set(r,[e.get(c),d])}else{let d=u;for(let l=0;l<c.length;++l,++d){const p=c[l],f=i*d,g=f-i;let a=o[f];const m=Math.max(0,d-s-1),y=Math.min(i-1,d+s);for(let _=m;_<y;++_){const b=p!==t[_],z=o[g+_]+ +b,A=o[g+_+1]+1,w=o[f+_]+1,L=o[f+_+1]=Math.min(z,A,w);L<a&&(a=L)}if(a>s)continue t}W(e.get(c),t,s,n,o,d,i,r+c)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=O(n);for(const i of o.keys())if(i!==F&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ut(this._tree,t)}entries(){return new D(this,nt)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return ot(this._tree,t,s)}get(t){const s=I(this._tree,t);return s!==void 0?s.get(F):void 0}has(t){const s=I(this._tree,t);return s!==void 0&&s.has(F)}keys(){return new D(this,V)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,M(this._tree,t).set(F,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=M(this._tree,t);return n.set(F,s(n.get(F))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=M(this._tree,t);let o=n.get(F);return o===void 0&&n.set(F,o=s()),o}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==F&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},I=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==F&&t.startsWith(s))return I(e.get(s),t.slice(s.length))},M=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==F&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const h=e.get(u);if(r===u.length)e=h;else{const c=new Map;c.set(u.slice(r),h),e.set(t.slice(n,n+r),c),e.delete(u),e=c}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ut=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(F),s.size===0)R(n);else if(s.size===1){const[o,u]=s.entries().next().value;$(n,o,u)}}},R=e=>{if(e.length===0)return;const[t,s]=O(e);if(t.delete(s),t.size===0)R(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==F&&$(e.slice(0,-1),n,o)}},$=(e,t,s)=>{if(e.length===0)return;const[n,o]=O(e);n.set(o+t,s),n.delete(o)},O=e=>e[e.length-1],it=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},rt=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,S="or",q="and",ct="and_not",lt=(e,t)=>{e.includes(t)||e.push(t)},P=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},G=({score:e},{score:t})=>t-e,ht=()=>new Map,k=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},N=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,dt={[S]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),P(n.terms,u)}}return e},[q]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);P(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[ct]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},at=(e,t,s,n,o,u)=>{const{k:i,b:r,d:h}=u;return Math.log(1+(s-t+.5)/(t+.5))*(h+e*(i+1)/(e+i*(1-r+r*n/o)))},ft=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},H=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},gt=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const o=e._index.fetch(n,ht),u=o.get(t);u==null||u.get(s)==null?H(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},mt={k:1.2,b:.7,d:.5},pt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(rt),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof(console==null?void 0:console[e])=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:S,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:mt},Ft={combineWith:q,prefix:(e,t,s)=>t===s.length-1},_t={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},yt={..._t,...U},Y=(e,t=S)=>{if(e.length===0)return new Map;const s=t.toLowerCase();return e.reduce(dt[s])||new Map},B=(e,t,s,n,o,u,i,r,h=new Map)=>{if(o==null)return h;for(const c of Object.keys(u)){const d=u[c],l=e._fieldIds[c],p=o.get(l);if(p==null)continue;let f=p.size;const g=e._avgFieldLength[l];for(const a of p.keys()){if(!e._documentIds.has(a)){gt(e,l,a,s),f-=1;continue}const m=i?i(e._documentIds.get(a),s,e._storedFields.get(a)):1;if(!m)continue;const y=p.get(a),_=e._fieldLength.get(a)[l],b=at(y,f,e._documentCount,_,g,r),z=n*d*m*b,A=h.get(a);if(A){A.score+=z,lt(A.terms,t);const w=N(A.match,s);w?w.push(c):A.match[s]=[c]}else h.set(a,{score:z,terms:[t],match:{[s]:[c]}})}}return h},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((a,m)=>({...a,[m]:N(n.boost,m)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:h}=n,{fuzzy:c,prefix:d}={...J.weights,...i},l=e._index.get(t.term),p=B(e,t.term,t.term,1,l,o,u,h);let f,g;if(t.prefix&&(f=e._index.atPrefix(t.term)),t.fuzzy){const a=t.fuzzy===!0?.2:t.fuzzy,m=a<1?Math.min(r,Math.round(t.term.length*a)):a;m&&(g=e._index.fuzzyGet(t.term,m))}if(f)for(const[a,m]of f){const y=a.length-t.term.length;if(!y)continue;g==null||g.delete(a);const _=d*a.length/(a.length+.3*y);B(e,t.term,a,_,m,o,u,h,p)}if(g)for(const a of g.keys()){const[m,y]=g.get(a);if(!y)continue;const _=c*a.length/(a.length+y);B(e,t.term,a,_,m,o,u,h,p)}return p},X=(e,t,s={})=>{if(typeof t!="string"){const d={...s,...t,queries:void 0},l=t.queries.map(p=>X(e,p,d));return Y(l,d.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:h}=i,c=r(t).flatMap(d=>h(d)).filter(d=>!!d).map(ft(i)).map(d=>At(e,d,i));return Y(c,i.combineWith)},K=(e,t,s={})=>{const n=X(e,t,s),o=[];for(const[u,{score:i,terms:r,match:h}]of n){const c=r.length,d={id:e._documentIds.get(u),score:i*c,terms:Object.keys(h),match:h};Object.assign(d,e._storedFields.get(u)),(s.filter==null||s.filter(d))&&o.push(d)}return o.sort(G),o},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of K(e,t,s)){const r=i.join(" "),h=n.get(r);h!=null?(h.score+=u,h.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:h}]of n)o.push({suggestion:u,terms:r,score:i/h});return o.sort(G),o};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if((t==null?void 0:t.fields)==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?yt:t.autoVacuum;this._options={...pt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...Ft,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:h,serializationVersion:c},d)=>{if(c!==1&&c!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const l=new Et(d);l._documentCount=t,l._nextId=s,l._documentIds=k(n),l._idToShortId=new Map,l._fieldIds=o,l._fieldLength=k(u),l._avgFieldLength=i,l._storedFields=k(r),l._dirtCount=h||0,l._index=new C;for(const[p,f]of l._documentIds)l._idToShortId.set(f,p);for(const[p,f]of e){const g=new Map;for(const a of Object.keys(f)){let m=f[a];c===1&&(m=m.ds),g.set(parseInt(a,10),k(m))}l._index.set(p,g)}return l},Q=Object.entries,wt=Object.fromEntries,j=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(c,d=!1)=>{let l="";i===0?l=c.length>20?`… ${c.slice(-20)}`:c:d?l=c.length+i>100?`${c.slice(0,100-i)}… `:c:l=c.length>20?`${c.slice(0,20)} … ${c.slice(-20)}`:c,l&&o.push(l),i+=l.length,d||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let h=s.indexOf(n,u);if(h===-1)return null;for(;h>=0;){const c=h+n.length;if(r(e.slice(u,h)),u=c,i>100)break;h=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},Z=/[\u4e00-\u9fa5]/g,tt=(e={})=>({fuzzy:.2,prefix:!0,processTerm:t=>{const s=t.match(Z)||[],n=t.replace(Z,"").toLowerCase();return n?[n,...s]:[...s]},...e}),xt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),kt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),et=(e,t,s={})=>{const n={};return K(t,e,tt({boost:{h:2,t:1,c:4},...s})).forEach(o=>{const{id:u,terms:i,score:r}=o,h=u.includes("@"),c=u.includes("#"),[d,l]=u.split(/[#@]/),{contents:p}=n[d]??={title:"",contents:[]};if(h)p.push([{type:"customField",key:d,index:l,display:i.map(f=>o.c.map(g=>j(g,f))).flat().filter(f=>f!==null)},r]);else{const f=i.map(g=>j(o.h,g)).filter(g=>g!==null);if(f.length&&p.push([{type:c?"heading":"title",key:d,...c&&{anchor:l},display:f},r]),"t"in o)for(const g of o.t){const a=i.map(m=>j(g,m)).filter(m=>m!==null);a.length&&p.push([{type:"text",key:d,...c&&{anchor:l},display:a},r])}}}),Q(n).sort(([,o],[,u])=>"max"==="total"?xt(o,u):kt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=it(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},st=(e,t,s={})=>Ct(t,e,tt(s)).map(({suggestion:n})=>n),v=wt(Q(JSON.parse("{\"/\":{\"documentCount\":459,\"nextId\":459,\"documentIds\":{\"0\":\"v-8daa1a0e\",\"1\":\"v-8daa1a0e#关于网站\",\"2\":\"v-8daa1a0e#关于作者\",\"3\":\"v-8daa1a0e#占个位\",\"4\":\"v-8daa1a0e#star-趋势\",\"5\":\"v-184f4da6\",\"6\":\"v-2e3eac9e\",\"7\":\"v-4bc4557f\",\"8\":\"v-4bc4557f#三分钟搭建一个博客网站\",\"9\":\"v-4bc4557f#准备运行环境\",\"10\":\"v-4bc4557f#创建项目模板\",\"11\":\"v-4bc4557f#创建过程\",\"12\":\"v-4bc4557f#访问\",\"13\":\"v-4bc4557f#效果\",\"14\":\"v-4bc4557f#项目启动命令\",\"15\":\"v-4bc4557f#发布到github\",\"16\":\"v-4bc4557f#修改deploy-docs-yml\",\"17\":\"v-4bc4557f#修改config-ts\",\"18\":\"v-4bc4557f#共享项目到github\",\"19\":\"v-4bc4557f#从master新建分支gh-pages-推送新分支到github\",\"20\":\"v-4bc4557f#github上开源\",\"21\":\"v-4bc4557f#配置github-pages\",\"22\":\"v-4bc4557f#更新博客只在master分支上改-不要动gh-pages分支\",\"23\":\"v-4bc4557f#修复-编辑此页-功能链接跳转不对问题\",\"24\":\"v-4bc4557f#踩坑\",\"25\":\"v-4bc4557f@0\",\"26\":\"v-4bc4557f@1\",\"27\":\"v-e287e936\",\"28\":\"v-e287e936#_1-流程图\",\"29\":\"v-e287e936#_2-序列图\",\"30\":\"v-e287e936#_3-类图\",\"31\":\"v-e287e936#_4-状态图\",\"32\":\"v-e287e936#_5-实体关系图\",\"33\":\"v-e287e936#_6-用户旅程图\",\"34\":\"v-e287e936#_7-甘特图\",\"35\":\"v-e287e936#_8-饼图\",\"36\":\"v-e287e936#_9-象限图\",\"37\":\"v-e287e936#_10-需求图\",\"38\":\"v-e287e936#_11-gitgraph-git-图表\",\"39\":\"v-e287e936#_12-c4-图\",\"40\":\"v-e287e936#c4-系统上下文图-c4context\",\"41\":\"v-e287e936#c4-容器图-c4container\",\"42\":\"v-e287e936#c4-组件图-c4component\",\"43\":\"v-e287e936#c4-动态图-c4dynamic\",\"44\":\"v-e287e936#c4-部署图-c4deployment\",\"45\":\"v-e287e936#_13思维导图\",\"46\":\"v-e287e936#_14-时间线图\",\"47\":\"v-e287e936#_15zenuml\",\"48\":\"v-e287e936#_16-桑基图\",\"49\":\"v-e287e936#_17-xy-图表\",\"50\":\"v-e287e936#_18-框图文档\",\"51\":\"v-e287e936#_19-数据包图\",\"52\":\"v-308fde42\",\"53\":\"v-308fde42#能说一下jvm的内存区域吗\",\"54\":\"v-308fde42#说一下jdk1-6、1-7、1-8内存区域的变化\",\"55\":\"v-308fde42#jdk-1-6\",\"56\":\"v-308fde42#jdk-1-7\",\"57\":\"v-308fde42#jdk-1-8\",\"58\":\"v-308fde42#详细变化对比\",\"59\":\"v-308fde42#永久代-permgen-与元空间-metaspace\",\"60\":\"v-308fde42#字符串常量池\",\"61\":\"v-308fde42#运行时常量池\",\"62\":\"v-308fde42#总结\",\"63\":\"v-308fde42#字符串常量池和运行时常量池有啥区别\",\"64\":\"v-308fde42#字符串常量池-1\",\"65\":\"v-308fde42#运行时常量池-1\",\"66\":\"v-308fde42#区别总结\",\"67\":\"v-308fde42#上面的代码示例中int-a-10不应该存放在栈中吗\",\"68\":\"v-308fde42#运行时常量池和栈中的局部变量\",\"69\":\"v-308fde42#解释-int-a-10\",\"70\":\"v-308fde42#修正后的解释和示例代码\",\"71\":\"v-308fde42#总结-1\",\"72\":\"v-308fde42#为什么使用元空间替代永久代作为方法区的实现\",\"73\":\"v-308fde42#使用元空间替代永久代的原因\",\"74\":\"v-308fde42#客观原因\",\"75\":\"v-308fde42#主观原因\",\"76\":\"v-308fde42#元空间的优势\",\"77\":\"v-308fde42#总结-2\",\"78\":\"v-308fde42#对象创建的过程了解吗\",\"79\":\"v-308fde42#什么是指针碰撞-什么是空闲列表\",\"80\":\"v-308fde42#什么是tlab-thread-local-allocation-buffer\",\"81\":\"v-308fde42#jvm-里-new-对象时-堆会发生抢占吗-jvm是怎么设计来保证线程安全的\",\"82\":\"v-308fde42#能说一下对象的内存布局吗\",\"83\":\"v-308fde42#对象怎么访问定位\",\"84\":\"v-308fde42#什么是内存溢出、内存泄漏\",\"85\":\"v-308fde42#能手写内存溢出的例子吗\",\"86\":\"v-308fde42#内存泄漏可能由哪些原因导致呢\",\"87\":\"v-308fde42#如何判断对象仍然存活\",\"88\":\"v-308fde42#java中可作为gc-roots的对象有哪几种\",\"89\":\"v-308fde42#说一下对象有哪几种引用\",\"90\":\"v-308fde42#finalize-方法了解吗-有什么作用\",\"91\":\"v-308fde42#java堆的内存分区了解吗\",\"92\":\"v-308fde42#垃圾收集算法了解吗\",\"93\":\"v-308fde42#说一下新生代的区域划分\",\"94\":\"v-308fde42#minor-gc-young-gc、major-gc-old-gc、mixed-gc、full-gc都是什么意思\",\"95\":\"v-308fde42#minor-gc-young-gc什么时候触发\",\"96\":\"v-308fde42#什么时候会触发full-gc\",\"97\":\"v-308fde42#对象什么时候会进入老年代\",\"98\":\"v-308fde42#知道有哪些垃圾收集器吗\",\"99\":\"v-308fde42#什么是stop-the-world-什么是-oopmap-什么是安全点\",\"100\":\"v-308fde42#能详细说一下cms收集器的垃圾收集过程吗\",\"101\":\"v-308fde42#g1垃圾收集器了解吗\",\"102\":\"v-308fde42#g1垃圾收集器的关键特点\",\"103\":\"v-308fde42#g1垃圾收集器的工作阶段\",\"104\":\"v-308fde42#g1垃圾收集器的优势\",\"105\":\"v-308fde42#g1垃圾收集器的配置参数\",\"106\":\"v-308fde42#总结-3\",\"107\":\"v-308fde42#有了cms-为什么还要引入g1\",\"108\":\"v-308fde42#cms的局限性\",\"109\":\"v-308fde42#g1垃圾收集器的优势-1\",\"110\":\"v-308fde42#总结-4\",\"111\":\"v-308fde42#你们线上用的什么垃圾收集器-为什么要用它\",\"112\":\"v-308fde42#常见的垃圾收集器\",\"113\":\"v-308fde42#为什么选择某种垃圾收集器\",\"114\":\"v-308fde42#使用g1的理由\",\"115\":\"v-308fde42#使用zgc的理由\",\"116\":\"v-308fde42#大公司和常见应用中的选择\",\"117\":\"v-308fde42#总结-5\",\"118\":\"v-308fde42#垃圾收集器应该如何选择\",\"119\":\"v-308fde42#关键考虑因素\",\"120\":\"v-308fde42#常见垃圾收集器选项\",\"121\":\"v-308fde42#选择垃圾收集器的步骤\",\"122\":\"v-308fde42#总结-6\",\"123\":\"v-308fde42#对象一定分配在堆中吗-有没有了解逃逸分析技术\",\"124\":\"v-308fde42#对象分配的基本概念\",\"125\":\"v-308fde42#逃逸分析-escape-analysis\",\"126\":\"v-308fde42#逃逸分析的应用示例\",\"127\":\"v-308fde42#jvm参数和逃逸分析\",\"128\":\"v-308fde42#逃逸分析的优势\",\"129\":\"v-308fde42#总结-7\",\"130\":\"v-1ea3b38e\",\"131\":\"v-1ea3b38e#什么是jvm\",\"132\":\"v-1ea3b38e#jvm的主要功能\",\"133\":\"v-1ea3b38e#jvm的结构\",\"134\":\"v-1ea3b38e#jvm的工作过程\",\"135\":\"v-1ea3b38e#jvm的跨平台特性\",\"136\":\"v-20738152\",\"137\":\"v-20738152#java-中-io-流分为几种\",\"138\":\"v-20738152#既然有了字节流-为什么还要有字符流\",\"139\":\"v-20738152#bio、nio、aio\",\"140\":\"v-fc32ae94\",\"141\":\"v-fc32ae94#jdk1-8都有哪些新特性\",\"142\":\"v-fc32ae94#lambda-表达式了解多少\",\"143\":\"v-fc32ae94#java8有哪些内置函数式接口\",\"144\":\"v-fc32ae94#optional了解吗\",\"145\":\"v-fc32ae94#stream-流用过吗\",\"146\":\"v-1cf004e2\",\"147\":\"v-1cf004e2#java语言有哪些特点\",\"148\":\"v-1cf004e2#jvm、jdk-和-jre-有什么区别\",\"149\":\"v-1cf004e2#说说什么是跨平台性-原理是什么\",\"150\":\"v-1cf004e2#什么是字节码-采用字节码的好处是什么\",\"151\":\"v-1cf004e2#为什么说-java-语言-编译与解释并存\",\"152\":\"v-5982fa10\",\"153\":\"v-5982fa10#说下什么是java的spi机制\",\"154\":\"v-70c64af0\",\"155\":\"v-70c64af0#什么是反射\",\"156\":\"v-70c64af0#反射的应用场景\",\"157\":\"v-70c64af0#反射的实现原理\",\"158\":\"v-1e829856\",\"159\":\"v-1e829856#java有哪些数据类型\",\"160\":\"v-1e829856#什么是自动类型转换、强制类型转换\",\"161\":\"v-1e829856#什么是自动拆箱-封箱\",\"162\":\"v-1e829856#和-有什么区别\",\"163\":\"v-1e829856#switch-是否能作用在-byte-long-string上\",\"164\":\"v-1e829856#break-continue-return-的区别及作用\",\"165\":\"v-1e829856#用最有效率的方法计算2乘以8\",\"166\":\"v-1e829856#说说自增自减运算\",\"167\":\"v-63c28b90\",\"168\":\"v-63c28b90#string-是-java-基本数据类型吗-可以被继承吗\",\"169\":\"v-63c28b90#string和stringbuilder、stringbuffer\",\"170\":\"v-63c28b90#string-str1-new-string-abc-和string-str2-abc-和-区别\",\"171\":\"v-63c28b90#string不是不可变类吗-字符串拼接是如何实现的\",\"172\":\"v-63c28b90#intern方法有什么作用\",\"173\":\"v-63c28b90#integer-a-127-integer-b-127-integer-c-128-integer-d-128-相等吗\",\"174\":\"v-63c28b90#string怎么转成integer的-原理\",\"175\":\"v-63c28b90#object-类的常见方法\",\"176\":\"v-a668a33c\",\"177\":\"v-a668a33c#什么是序列化-什么是反序列化\",\"178\":\"v-a668a33c#说说有哪些常见的序列化方式\",\"179\":\"v-09de2f71\",\"180\":\"v-09de2f71#java-中异常层级结构\",\"181\":\"v-09de2f71#异常的处理机制\",\"182\":\"v-09de2f71#finally一定会执行吗\",\"183\":\"v-09de2f71#三道经典异常处理代码题\",\"184\":\"v-1ed0dc53\",\"185\":\"v-1ed0dc53#什么是泛型\",\"186\":\"v-1ed0dc53#泛型的使用方法\",\"187\":\"v-1ed0dc53#泛型常用的通配符有哪些\",\"188\":\"v-1ed0dc53#什么是泛型擦除\",\"189\":\"v-08ef6fc0\",\"190\":\"v-08ef6fc0#说一下你对注解的理解\",\"191\":\"v-f52152e0\",\"192\":\"v-f52152e0#java中实现map接口的有哪些类\",\"193\":\"v-f52152e0#遍历hashmap的几种方法\",\"194\":\"v-95dc3ca2\",\"195\":\"v-95dc3ca2#面向对象和面向过程的区别\",\"196\":\"v-95dc3ca2#面向对象有哪些特性\",\"197\":\"v-95dc3ca2#重载-overload-和重写-override-的区别\",\"198\":\"v-95dc3ca2#访问修饰符public、private、protected、以及不写-默认-时的-区别\",\"199\":\"v-95dc3ca2#this关键字有什么作用\",\"200\":\"v-95dc3ca2#抽象类-abstract-class-和接口-interface-有什么区别\",\"201\":\"v-95dc3ca2#成员变量与局部变量的区别有哪些\",\"202\":\"v-95dc3ca2#静态变量和实例变量的区别-静态方法、实例方法呢\",\"203\":\"v-95dc3ca2#final关键字有什么作用\",\"204\":\"v-95dc3ca2#final、finally、finalize的区别\",\"205\":\"v-95dc3ca2#和-equals-的区别\",\"206\":\"v-95dc3ca2#hashcode与-equals\",\"207\":\"v-95dc3ca2#java是值传递-还是引用传递\",\"208\":\"v-95dc3ca2#什么是深拷贝和浅拷贝\",\"209\":\"v-95dc3ca2#java-创建对象有哪几种方式\",\"210\":\"v-fdfaa92c\",\"211\":\"v-fdfaa92c#说一下你对java内存模型-jmm-的理解\",\"212\":\"v-fdfaa92c#说说你对原子性、可见性、有序性的理解\",\"213\":\"v-fdfaa92c#分析下面几行代码的原子性\",\"214\":\"v-fdfaa92c#原子性、可见性、有序性都应该怎么保证呢\",\"215\":\"v-fdfaa92c#那说说什么是指令重排\",\"216\":\"v-fdfaa92c#指令重排有限制吗-happens-before了解吗\",\"217\":\"v-fdfaa92c#as-if-serial又是什么-单线程的程序一定是顺序的吗\",\"218\":\"v-fdfaa92c#volatile实现原理了解吗\",\"219\":\"v-fdfaa92c#volatile怎么保证可见性的呢\",\"220\":\"v-fdfaa92c#volatile怎么保证有序性的呢\",\"221\":\"v-b1bf17b8\",\"222\":\"v-b1bf17b8#threadlocal是什么\",\"223\":\"v-b1bf17b8#你在工作中用到过threadlocal吗\",\"224\":\"v-b1bf17b8#threadlocal怎么实现的呢\",\"225\":\"v-b1bf17b8#threadlocal-内存泄露是怎么回事\",\"226\":\"v-b1bf17b8#那怎么解决内存泄漏问题呢\",\"227\":\"v-b1bf17b8#为什么key还要设计成弱引用\",\"228\":\"v-b1bf17b8#threadlocalmap的结构了解吗\",\"229\":\"v-b1bf17b8#threadlocalmap怎么解决hash冲突的\",\"230\":\"v-b1bf17b8#threadlocalmap扩容机制了解吗\",\"231\":\"v-b1bf17b8#父子线程怎么共享数据\",\"232\":\"v-b1bf17b8#inheritablethreadlocal原理是什么呢\",\"233\":\"v-b1bf17b8#还有什么其它办法-ttl\",\"234\":\"v-758586f5\",\"235\":\"v-758586f5#并行跟并发有什么区别\",\"236\":\"v-758586f5#说说什么是进程和线程\",\"237\":\"v-758586f5#说说线程有几种创建方式\",\"238\":\"v-758586f5#为什么调用start-方法时会执行run-方法-那怎么不直接调用run-方法\",\"239\":\"v-758586f5#thread和runnable有什么区别\",\"240\":\"v-758586f5#线程有哪些常用的调度方法\",\"241\":\"v-758586f5#线程有几种状态\",\"242\":\"v-758586f5#blocked和waiting有什么区别\",\"243\":\"v-758586f5#waiting和terminated有什么区别\",\"244\":\"v-758586f5#什么是线程上下文切换\",\"245\":\"v-758586f5#线程上下文切换通常发生在以下几种情况下\",\"246\":\"v-758586f5#守护线程了解吗\",\"247\":\"v-758586f5#线程间有哪些通信方式\",\"248\":\"v-4cbedf23\",\"249\":\"v-4cbedf23#countdownlatch-倒计数器-了解吗\",\"250\":\"v-4cbedf23#cyclicbarrier-同步屏障-了解吗\",\"251\":\"v-4cbedf23#重要注意事项\",\"252\":\"v-4cbedf23#cyclicbarrier和countdownlatch有什么区别\",\"253\":\"v-4cbedf23#semaphore-信号量-了解吗\",\"254\":\"v-4cbedf23#解释\",\"255\":\"v-4cbedf23#重要注意事项-1\",\"256\":\"v-4cbedf23#exchanger-了解吗\",\"257\":\"v-4cbedf23#代码示例\",\"258\":\"v-4cbedf23#解释-1\",\"259\":\"v-4cbedf23#重要注意事项-2\",\"260\":\"v-4cbedf23#说说你对completablefuture的理解\",\"261\":\"v-4cbedf23#_1-引言\",\"262\":\"v-4cbedf23#_2-基本概念\",\"263\":\"v-4cbedf23#_2-1-创建-completablefuture\",\"264\":\"v-4cbedf23#_3-任务完成后的回调\",\"265\":\"v-4cbedf23#_3-1-thenapply\",\"266\":\"v-4cbedf23#_3-2-thenaccept\",\"267\":\"v-4cbedf23#_3-3-thenrun\",\"268\":\"v-4cbedf23#_4-组合多个-completablefuture\",\"269\":\"v-4cbedf23#_4-1-thencompose\",\"270\":\"v-4cbedf23#_4-2-thencombine\",\"271\":\"v-4cbedf23#_4-3-allof\",\"272\":\"v-4cbedf23#_5-处理异常\",\"273\":\"v-4cbedf23#_5-1-exceptionally\",\"274\":\"v-4cbedf23#_5-2-handle\",\"275\":\"v-4cbedf23#_6-超时控制\",\"276\":\"v-4cbedf23#_6-1-ortimeout\",\"277\":\"v-4cbedf23#_6-2-completeontimeout\",\"278\":\"v-4cbedf23#_7-并行执行多个任务\",\"279\":\"v-4cbedf23#示例\",\"280\":\"v-4cbedf23#_8-真实场景应用\",\"281\":\"v-4cbedf23#_8-1-并行获取数据\",\"282\":\"v-4cbedf23#_9-总结\",\"283\":\"v-4cbedf23#completablefuture的线程池设置\",\"284\":\"v-4cbedf23#_1-使用默认线程池\",\"285\":\"v-4cbedf23#_2-指定自定义线程池\",\"286\":\"v-4cbedf23#_2-1-创建自定义线程池\",\"287\":\"v-4cbedf23#_2-2-使用自定义线程池\",\"288\":\"v-4cbedf23#_3-完整示例\",\"289\":\"v-4cbedf23#_4-线程池类型\",\"290\":\"v-4cbedf23#_4-1-固定大小线程池\",\"291\":\"v-4cbedf23#_4-2-缓存线程池\",\"292\":\"v-4cbedf23#_4-3-单线程池\",\"293\":\"v-4cbedf23#_4-4-调度线程池\",\"294\":\"v-4cbedf23#_5-异步任务链中的线程池\",\"295\":\"v-bc3a2618\",\"296\":\"v-bc3a2618#说说阻塞队列是怎么实现的\",\"297\":\"v-266a0586\",\"298\":\"v-266a0586#什么是线程池\",\"299\":\"v-266a0586#_1-线程池的基本概念\",\"300\":\"v-266a0586#_2-线程池的优势\",\"301\":\"v-266a0586#_3-java中的线程池实现\",\"302\":\"v-266a0586#_3-1-常见的线程池类型\",\"303\":\"v-266a0586#_4-线程池的使用示例\",\"304\":\"v-266a0586#_5-线程池的配置参数\",\"305\":\"v-266a0586#_6-自定义线程池\",\"306\":\"v-266a0586#为什么说频繁创建和销毁线程的开销大\",\"307\":\"v-266a0586#_1-系统资源消耗\",\"308\":\"v-266a0586#_1-1-内存开销\",\"309\":\"v-266a0586#_1-2-操作系统资源\",\"310\":\"v-266a0586#_2-cpu消耗\",\"311\":\"v-266a0586#_2-1-线程上下文切换\",\"312\":\"v-266a0586#_2-2-同步开销\",\"313\":\"v-266a0586#_3-jvm的开销\",\"314\":\"v-266a0586#_3-1-垃圾回收\",\"315\":\"v-266a0586#_3-2-jit优化\",\"316\":\"v-266a0586#能说说工作中线程池的应用吗\",\"317\":\"v-266a0586#_1-web服务器\",\"318\":\"v-266a0586#场景描述\",\"319\":\"v-266a0586#解决方案\",\"320\":\"v-266a0586#代码示例\",\"321\":\"v-266a0586#_2-数据库连接池\",\"322\":\"v-266a0586#场景描述-1\",\"323\":\"v-266a0586#解决方案-1\",\"324\":\"v-266a0586#代码示例-1\",\"325\":\"v-266a0586#_3-并行数据处理\",\"326\":\"v-266a0586#场景描述-2\",\"327\":\"v-266a0586#解决方案-2\",\"328\":\"v-266a0586#代码示例-2\",\"329\":\"v-266a0586#_4-异步任务执行\",\"330\":\"v-266a0586#场景描述-3\",\"331\":\"v-266a0586#解决方案-3\",\"332\":\"v-266a0586#代码示例-3\",\"333\":\"v-266a0586#_5-定时任务\",\"334\":\"v-266a0586#场景描述-4\",\"335\":\"v-266a0586#解决方案-4\",\"336\":\"v-266a0586#代码示例-4\",\"337\":\"v-266a0586#能简单说一下线程池的工作流程吗\",\"338\":\"v-266a0586#_1-线程池初始化\",\"339\":\"v-266a0586#_2-任务提交\",\"340\":\"v-266a0586#_3-任务执行\",\"341\":\"v-266a0586#_4-任务执行完成\",\"342\":\"v-266a0586#_5-线程池关闭\",\"343\":\"v-266a0586#线程池的完整工作流程\",\"344\":\"v-266a0586#线程池主要参数有哪些\",\"345\":\"v-266a0586#线程池的拒绝策略有哪些\",\"346\":\"v-266a0586#线程池有哪几种工作队列\",\"347\":\"v-266a0586#线程池提交execute和submit有什么区别\",\"348\":\"v-266a0586#线程池怎么关闭知道吗\",\"349\":\"v-266a0586#线程池的线程数应该怎么配置\",\"350\":\"v-266a0586#线程池是怎么实现线程复用的\",\"351\":\"v-266a0586#有哪几种常见的线程池\",\"352\":\"v-266a0586#能说一下四种常见线程池的原理吗\",\"353\":\"v-266a0586#_1-fixedthreadpool-固定大小线程池\",\"354\":\"v-266a0586#_2-cachedthreadpool-缓存线程池\",\"355\":\"v-266a0586#_3-singlethreadexecutor-单线程线程池\",\"356\":\"v-266a0586#_4-scheduledthreadpool-定时任务线程池\",\"357\":\"v-266a0586#线程池异常怎么处理知道吗\",\"358\":\"v-266a0586#_1-捕获并处理异常\",\"359\":\"v-266a0586#_2-自定义线程池\",\"360\":\"v-266a0586#_3-使用-uncaughtexceptionhandler\",\"361\":\"v-266a0586#_4-使用自定义-rejectedexecutionhandler\",\"362\":\"v-266a0586#_5-使用-completablefuture-处理异步任务\",\"363\":\"v-266a0586#_6-使用-callable-和-future\",\"364\":\"v-266a0586#能说一下线程池有几种状态吗\",\"365\":\"v-266a0586#_1-running\",\"366\":\"v-266a0586#_2-shutdown\",\"367\":\"v-266a0586#_3-stop\",\"368\":\"v-266a0586#_4-tidying\",\"369\":\"v-266a0586#_5-terminated\",\"370\":\"v-266a0586#状态转换图\",\"371\":\"v-266a0586#线程池如何实现参数的动态修改\",\"372\":\"v-266a0586#线程池调优了解吗\",\"373\":\"v-266a0586#你能设计实现一个线程池吗\",\"374\":\"v-266a0586#单机线程池执行断电了应该怎么处理\",\"375\":\"v-266a0586#线程池并发调用api-有个调用特别耗时-怎么优化\",\"376\":\"v-266a0586#fork-join框架了解吗\",\"377\":\"v-421103ae\",\"378\":\"v-421103ae#synchronized用过吗-怎么使用\",\"379\":\"v-421103ae#synchronized的实现原理\",\"380\":\"v-421103ae#synchronized是怎么加锁的呢\",\"381\":\"v-421103ae#synchronized锁住的是什么呢\",\"382\":\"v-421103ae#除了原子性-synchronized可见性-有序性-可重入性怎么实现\",\"383\":\"v-421103ae#synchronized怎么保证可见性\",\"384\":\"v-421103ae#synchronized怎么保证有序性\",\"385\":\"v-421103ae#synchronized怎么实现可重入的呢\",\"386\":\"v-421103ae#锁升级-synchronized优化了解吗\",\"387\":\"v-421103ae#synchronized做了哪些优化\",\"388\":\"v-421103ae#锁升级的过程是什么样的\",\"389\":\"v-421103ae#偏向锁\",\"390\":\"v-421103ae#轻量级锁\",\"391\":\"v-421103ae#说说synchronized和reentrantlock的区别\",\"392\":\"v-421103ae#aqs了解多少\",\"393\":\"v-421103ae#reentrantlock实现原理\",\"394\":\"v-421103ae#公平锁-fairsync\",\"395\":\"v-421103ae#非公平锁-nonfairsync\",\"396\":\"v-421103ae#lock-的执行过程\",\"397\":\"v-421103ae#reentrantlock怎么实现公平锁的\",\"398\":\"v-421103ae#什么是cas\",\"399\":\"v-421103ae#cas-有什么问题-如何解决\",\"400\":\"v-421103ae#aba-问题\",\"401\":\"v-421103ae#怎么解决aba问题\",\"402\":\"v-421103ae#循环性能开销\",\"403\":\"v-421103ae#怎么解决循环性能开销问题\",\"404\":\"v-421103ae#只能保证一个变量的原子操作\",\"405\":\"v-421103ae#java有哪些保证原子性的方法-如何保证多线程下i-结果正确\",\"406\":\"v-421103ae#原子操作类了解多少\",\"407\":\"v-421103ae#atomicinteger-的原理\",\"408\":\"v-421103ae#线程死锁了解吗-该如何避免\",\"409\":\"v-421103ae#死锁问题怎么排查呢\",\"410\":\"v-2fb9c1b2\",\"411\":\"v-2fb9c1b2#arraylist和linkedlist有什么区别\",\"412\":\"v-2fb9c1b2#arraylist的扩容机制了解吗\",\"413\":\"v-2fb9c1b2#arraylist怎么序列化的知道吗-为什么用transient修饰数组\",\"414\":\"v-2fb9c1b2#为什么最arraylist不直接序列化元素数组呢\",\"415\":\"v-2fb9c1b2#那arraylist怎么序列化呢\",\"416\":\"v-2fb9c1b2#快速失败-fail-fast-和安全失败-fail-safe-了解吗\",\"417\":\"v-2fb9c1b2#实现arraylist线程安全有哪几种方法\",\"418\":\"v-2fb9c1b2#copyonwritearraylist了解多少\",\"419\":\"v-2fb9c1b2#数据拷贝的过程中-有其它线程写入数据怎么办\",\"420\":\"v-ae523934\",\"421\":\"v-ae523934#能说一下hashmap的数据结构吗\",\"422\":\"v-ae523934#你对红黑树了解多少-为什么不用二叉树-平衡树呢\",\"423\":\"v-ae523934#什么是红黑树\",\"424\":\"v-ae523934#为什么不用二叉树\",\"425\":\"v-ae523934#为什么不用平衡二叉树\",\"426\":\"v-ae523934#红黑树怎么保持平衡的知道吗\",\"427\":\"v-ae523934#hashmap的put流程知道吗\",\"428\":\"v-ae523934#hashmap怎么查找元素的呢\",\"429\":\"v-ae523934#hashmap的哈希-扰动函数是怎么设计的\",\"430\":\"v-ae523934#为什么哈希-扰动函数能降hash碰撞\",\"431\":\"v-ae523934#为什么hashmap的容量是2的倍数呢\",\"432\":\"v-ae523934#如果初始化hashmap-传一个17的值-new-hashmap-它会怎么处理\",\"433\":\"v-ae523934#你还知道哪些哈希函数的构造方法呢\",\"434\":\"v-ae523934#解决哈希冲突有哪些方法呢\",\"435\":\"v-ae523934#为什么hashmap链表转红黑树的阈值为8呢\",\"436\":\"v-ae523934#扩容在什么时候呢-为什么扩容因子是0-75\",\"437\":\"v-ae523934#那么为什么选择了0-75作为hashmap的默认加载因子呢\",\"438\":\"v-ae523934#hashmap扩容机制了解吗\",\"439\":\"v-ae523934#jdk1-8对hashmap主要做了哪些优化呢-为什么\",\"440\":\"v-ae523934#你能自己设计实现一个hashmap吗\",\"441\":\"v-ae523934#hashmap-是线程安全的吗-多线程下会有什么问题\",\"442\":\"v-ae523934#有什么办法能解决hashmap线程不安全的问题呢\",\"443\":\"v-ae523934#能说一下concurrenthashmap的具体实现吗\",\"444\":\"v-ae523934#jdk1-7-分段锁\",\"445\":\"v-ae523934#jdk1-8-cas-synchronized\",\"446\":\"v-ae523934#hashmap-内部节点是有序的吗\",\"447\":\"v-ae523934#讲讲-linkedhashmap-怎么实现有序的\",\"448\":\"v-ae523934#讲讲-treemap-怎么实现有序的\",\"449\":\"v-1aeb7fc0\",\"450\":\"v-1aeb7fc0#讲讲hashset的底层实现\",\"451\":\"v-03c57507\",\"452\":\"v-03c57507#说说有哪些常见集合\",\"453\":\"v-e1e3da16\",\"454\":\"v-40ed10a2\",\"455\":\"v-1303aad4\",\"456\":\"v-aefb69fe\",\"457\":\"v-152c160c\",\"458\":\"v-5911796e\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1],\"1\":[1,6],\"2\":[1,1],\"3\":[1,1],\"4\":[2,1],\"5\":[1],\"6\":[1],\"7\":[1],\"8\":[1,6],\"9\":[1,4],\"10\":[1,8],\"11\":[1,154],\"12\":[1,4],\"13\":[1],\"14\":[1,7],\"15\":[1],\"16\":[4,6],\"17\":[3,23],\"18\":[1],\"19\":[3],\"20\":[1,8],\"21\":[2,12],\"22\":[3,8],\"23\":[3,7],\"24\":[1,2],\"25\":[null,null,1],\"26\":[null,null,1],\"27\":[1,3],\"28\":[2],\"29\":[2],\"30\":[2],\"31\":[2],\"32\":[2],\"33\":[2],\"34\":[2],\"35\":[2],\"36\":[2],\"37\":[2],\"38\":[4],\"39\":[3],\"40\":[4],\"41\":[4],\"42\":[4],\"43\":[4],\"44\":[4],\"45\":[1],\"46\":[2],\"47\":[1],\"48\":[2],\"49\":[3],\"50\":[2],\"51\":[2,59],\"52\":[1],\"53\":[2,73],\"54\":[6,12],\"55\":[3,37],\"56\":[3,20],\"57\":[3,19],\"58\":[1],\"59\":[5,12],\"60\":[1,10],\"61\":[1,10],\"62\":[1,17],\"63\":[2,6],\"64\":[1,38],\"65\":[1,51],\"66\":[1,31],\"67\":[5,15],\"68\":[1,15],\"69\":[6,30],\"70\":[1,19],\"71\":[1,19],\"72\":[2,15],\"73\":[1],\"74\":[1,26],\"75\":[1,28],\"76\":[1,31],\"77\":[1,23],\"78\":[2,56],\"79\":[3,35],\"80\":[6,43],\"81\":[7,38],\"82\":[2,36],\"83\":[2,27],\"84\":[3,33],\"85\":[2,54],\"86\":[2,38],\"87\":[2,38],\"88\":[3,27],\"89\":[2,50],\"90\":[4,43],\"91\":[2,52],\"92\":[2,68],\"93\":[2,35],\"94\":[9,46],\"95\":[5,30],\"96\":[3,45],\"97\":[2,31],\"98\":[2,55],\"99\":[7,38],\"100\":[2,83],\"101\":[2,16],\"102\":[1,44],\"103\":[1,41],\"104\":[1,9],\"105\":[1,12],\"106\":[1,8],\"107\":[3,9],\"108\":[1,33],\"109\":[1,43],\"110\":[1,12],\"111\":[3,7],\"112\":[1,42],\"113\":[1],\"114\":[1,15],\"115\":[1,12],\"116\":[1,14],\"117\":[1,10],\"118\":[2,6],\"119\":[1,24],\"120\":[1,61],\"121\":[1,23],\"122\":[1,7],\"123\":[3,8],\"124\":[1,15],\"125\":[4,26],\"126\":[1,27],\"127\":[1,15],\"128\":[1,10],\"129\":[1,8],\"130\":[1],\"131\":[2,20],\"132\":[1,23],\"133\":[1,47],\"134\":[1,12],\"135\":[1,13],\"136\":[1],\"137\":[5,22],\"138\":[3,22],\"139\":[4,55],\"140\":[2],\"141\":[3,45],\"142\":[3,7],\"143\":[2,10],\"144\":[2,38],\"145\":[3,105],\"146\":[1],\"147\":[2,7],\"148\":[6,44],\"149\":[3,5],\"150\":[3,15],\"151\":[5,12],\"152\":[1],\"153\":[2,85],\"154\":[1],\"155\":[2,15],\"156\":[2,8],\"157\":[1,11],\"158\":[1],\"159\":[2,53],\"160\":[3,5],\"161\":[3,4],\"162\":[3,3],\"163\":[6,24],\"164\":[5,15],\"165\":[2,6],\"166\":[2,12],\"167\":[1],\"168\":[6,30],\"169\":[3,56],\"170\":[10,20],\"171\":[3,13],\"172\":[2,8],\"173\":[11,33],\"174\":[3,10],\"175\":[3,21],\"176\":[1],\"177\":[3,53],\"178\":[2,43],\"179\":[1],\"180\":[3,14],\"181\":[2,7],\"182\":[2,15],\"183\":[1,65],\"184\":[1],\"185\":[2,7],\"186\":[2,15],\"187\":[2,19],\"188\":[2,12],\"189\":[1],\"190\":[2,56],\"191\":[1],\"192\":[2,16],\"193\":[2,7],\"194\":[1],\"195\":[2,13],\"196\":[2,21],\"197\":[6,23],\"198\":[8,19],\"199\":[2,7],\"200\":[7,42],\"201\":[2,41],\"202\":[4,29],\"203\":[2,6],\"204\":[4,42],\"205\":[4,10],\"206\":[3,32],\"207\":[3,14],\"208\":[2,24],\"209\":[3,6],\"210\":[1],\"211\":[4,32],\"212\":[4,33],\"213\":[2,19],\"214\":[4,13],\"215\":[2,34],\"216\":[4,51],\"217\":[5,14],\"218\":[2,2],\"219\":[2,10],\"220\":[2,29],\"221\":[1],\"222\":[2,29],\"223\":[2,2],\"224\":[2,14],\"225\":[3,20],\"226\":[2,3],\"227\":[2,9],\"228\":[2,43],\"229\":[2,26],\"230\":[2,82],\"231\":[2,33],\"232\":[2,48],\"233\":[3,12],\"234\":[1],\"235\":[2,10],\"236\":[2,10],\"237\":[2,12],\"238\":[5,10],\"239\":[2,25],\"240\":[2,97],\"241\":[2,31],\"242\":[2,11],\"243\":[2,7],\"244\":[2,16],\"245\":[1,15],\"246\":[2,22],\"247\":[2,56],\"248\":[1],\"249\":[4,74],\"250\":[4,15],\"251\":[1,98],\"252\":[2,46],\"253\":[4,76],\"254\":[1,25],\"255\":[1,30],\"256\":[3,16],\"257\":[1,59],\"258\":[1,19],\"259\":[1,39],\"260\":[2],\"261\":[2,8],\"262\":[2],\"263\":[4,16],\"264\":[2],\"265\":[3,14],\"266\":[3,12],\"267\":[2,11],\"268\":[3],\"269\":[3,15],\"270\":[3,17],\"271\":[3,34],\"272\":[2],\"273\":[3,22],\"274\":[3,24],\"275\":[2],\"276\":[3,24],\"277\":[3,25],\"278\":[2],\"279\":[1,70],\"280\":[2],\"281\":[3,67],\"282\":[2,2],\"283\":[2,9],\"284\":[2,17],\"285\":[2,7],\"286\":[3,16],\"287\":[2,13],\"288\":[2,58],\"289\":[2],\"290\":[3,8],\"291\":[3,8],\"292\":[3,7],\"293\":[2,8],\"294\":[2,35],\"295\":[1],\"296\":[2,43],\"297\":[1],\"298\":[2,6],\"299\":[2,12],\"300\":[2,9],\"301\":[2,5],\"302\":[3,27],\"303\":[2,59],\"304\":[2,16],\"305\":[2,70],\"306\":[2,5],\"307\":[2],\"308\":[2,11],\"309\":[3,5],\"310\":[2],\"311\":[3,9],\"312\":[2,5],\"313\":[2],\"314\":[3,6],\"315\":[3,6],\"316\":[2,4],\"317\":[2],\"318\":[1,6],\"319\":[1,5],\"320\":[1,44],\"321\":[2],\"322\":[1,4],\"323\":[1,5],\"324\":[1,66],\"325\":[2],\"326\":[1,7],\"327\":[1,5],\"328\":[1,65],\"329\":[2],\"330\":[1,8],\"331\":[1,4],\"332\":[1,47],\"333\":[2],\"334\":[1,4],\"335\":[1,4],\"336\":[1,49],\"337\":[2,7],\"338\":[2,26],\"339\":[2,18],\"340\":[2,18],\"341\":[2,8],\"342\":[2,23],\"343\":[1,16],\"344\":[2,50],\"345\":[2,24],\"346\":[2,55],\"347\":[2,39],\"348\":[2,48],\"349\":[2,47],\"350\":[2,19],\"351\":[2,42],\"352\":[2],\"353\":[4,36],\"354\":[4,43],\"355\":[4,36],\"356\":[4,29],\"357\":[2,5],\"358\":[2,23],\"359\":[2,51],\"360\":[3,26],\"361\":[3,31],\"362\":[4,14],\"363\":[5,63],\"364\":[2,12],\"365\":[2,9],\"366\":[2,13],\"367\":[2,15],\"368\":[2,15],\"369\":[2,12],\"370\":[1,2],\"371\":[2,35],\"372\":[2,54],\"373\":[2,86],\"374\":[2,33],\"375\":[4,48],\"376\":[3,174],\"377\":[1],\"378\":[3,34],\"379\":[2],\"380\":[2,12],\"381\":[2,72],\"382\":[5],\"383\":[2,7],\"384\":[2,12],\"385\":[2,12],\"386\":[3,22],\"387\":[2,33],\"388\":[2,7],\"389\":[1,47],\"390\":[1,43],\"391\":[2,42],\"392\":[2,52],\"393\":[2,9],\"394\":[2,8],\"395\":[2,11],\"396\":[2,17],\"397\":[2,50],\"398\":[2,36],\"399\":[4,4],\"400\":[2,13],\"401\":[2,29],\"402\":[1,4],\"403\":[2,5],\"404\":[1,8],\"405\":[4,10],\"406\":[2,24],\"407\":[3,32],\"408\":[3,57],\"409\":[2,23],\"410\":[1],\"411\":[2,51],\"412\":[2,41],\"413\":[3,7],\"414\":[2,6],\"415\":[2,7],\"416\":[7,68],\"417\":[2,25],\"418\":[2,37],\"419\":[3,3],\"420\":[1],\"421\":[2,32],\"422\":[4],\"423\":[2,17],\"424\":[2,11],\"425\":[2,8],\"426\":[2,6],\"427\":[2,71],\"428\":[2,51],\"429\":[3,12],\"430\":[3,8],\"431\":[2,26],\"432\":[6,7],\"433\":[2,20],\"434\":[2,23],\"435\":[2,21],\"436\":[4,6],\"437\":[3,17],\"438\":[2,9],\"439\":[4,43],\"440\":[2,7],\"441\":[4,26],\"442\":[2,19],\"443\":[2,6],\"444\":[3,30],\"445\":[3,109],\"446\":[3,13],\"447\":[4,8],\"448\":[4,13],\"449\":[1],\"450\":[2,47],\"451\":[1],\"452\":[2,3],\"453\":[1],\"454\":[3],\"455\":[1],\"456\":[1],\"457\":[1],\"458\":[1]},\"averageFieldLength\":[2.2833115468409586,24.39137511300142,0.07407407407407407],\"storedFields\":{\"0\":{\"h\":\"鱼塘\"},\"1\":{\"h\":\"关于网站\",\"t\":[\"欢迎来到鱼塘\",\"传送门：GitHub | Gitee。\",\"项目介绍\"]},\"2\":{\"h\":\"关于作者\",\"t\":[\"关于作者\"]},\"3\":{\"h\":\"占个位\",\"t\":[\"占个位\"]},\"4\":{\"h\":\"Star 趋势\",\"t\":[\"Stars\"]},\"5\":{\"h\":\"主页\"},\"6\":{\"h\":\"幻灯片页\"},\"7\":{\"h\":\"三分钟搭建一个博客网站\"},\"8\":{\"h\":\"三分钟搭建一个博客网站\",\"t\":[\"基于vuepress-theme-hope 和 github pages搭建\"]},\"9\":{\"h\":\"准备运行环境\",\"t\":[\"安装nodejs 下载地址\",\"安装pnpm 参考资料\"]},\"10\":{\"h\":\"创建项目模板\",\"t\":[\"pnpm create vuepress-theme-hope my-docs \"]},\"11\":{\"h\":\"创建过程\",\"t\":[\"PowerShell 7.4.0 PS C:\\\\Users\\\\daiwencheng\\\\Documents\\\\BaiduSyncdisk\\\\ob\\\\ob\\\\blogs> pnpm create vuepress-theme-hope my-docs .../Local/pnpm/store/v3/tmp/dlx-7428 | +83 ++++++++ .../Local/pnpm/store/v3/tmp/dlx-7428 | Progress: resolved 83, reused 61, downloaded 22, added 83, done ? Select a language to display / 选择显示语言 简体中文 ? 选择包管理器 pnpm 生成 package.json... ? 设置应用名称 vuepress-theme-hope-template ? 设置应用版本号 2.0.0 ? 设置应用描述 A project of vuepress-theme-hope ? 设置协议 MIT ? 项目需要用到多语言么? No ? 是否需要一个自动部署文档到 GitHub Pages 的工作流？ Yes ? 你想要创建什么类型的项目？ blog 生成模板... ? 是否初始化 Git 仓库? Yes 安装依赖... 这可能需要数分钟，请耐心等待. 我们无法正确输出子进程的进度条，所以进程可能会看似未响应 WARN 2 deprecated subdependencies found: rollup-plugin-terser@7.0.2, sourcemap-codec@1.4.8 Packages: +606 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ Progress: resolved 639, reused 409, downloaded 197, added 606, done node_modules/.pnpm/esbuild@0.19.8/node_modules/esbuild: Running postinstall script, done in 825ms devDependencies: + @vuepress/client 2.0.0-rc.0 + vue 3.3.10 + vuepress 2.0.0-rc.0 + vuepress-theme-hope 2.0.0-rc.2 The dependency was already listed in devDependencies. If you want to make it a prod dependency, then move it manually. Done in 25.3s 模板已成功生成! ? 是否想要现在启动 Demo 查看? Yes 启动开发服务器... 启动成功后，请在浏览器输入给出的开发服务器地址(默认为 'localhost:8080') > vuepress-theme-hope-template@2.0.0 docs:dev C:\\\\Users\\\\daiwencheng\\\\Documents\\\\BaiduSyncdisk\\\\ob\\\\ob\\\\blogs\\\\my-docs > vuepress dev src vite v5.0.6 dev server running at: ➜ Local: http://localhost:8080/ ➜ Network: http://10.246.84.128:8080/ \"]},\"12\":{\"h\":\"访问\",\"t\":[\"打开http://localhost:8080/ 访问\"]},\"13\":{\"h\":\"效果\"},\"14\":{\"h\":\"项目启动命令\",\"t\":[\"需要先进入项目目录 my-docs\",\"npm run docs:dev \"]},\"15\":{\"h\":\"发布到github\"},\"16\":{\"h\":\"修改 deploy-docs.yml\",\"t\":[\"on: push: branches: # 确保这是你正在使用的分支名称 - master \"]},\"17\":{\"h\":\"修改 config.ts\",\"t\":[\"export default defineUserConfig({ base: \\\"/my-docs/\\\", lang: \\\"zh-CN\\\", title: \\\"博客演示\\\", description: \\\"vuepress-theme-hope 的博客演示\\\", theme, // Enable it with pwa // shouldPrefetch: false, }); \"]},\"18\":{\"h\":\"共享项目到GitHub\"},\"19\":{\"h\":\"从master新建分支gh-pages,推送新分支到github\"},\"20\":{\"h\":\"GitHub上开源\",\"t\":[\"打开仓库my-docs\",\"打开Settings\",\"底部设置Change visibility 为change to public\"]},\"21\":{\"h\":\"配置Github Pages\",\"t\":[\"打开仓库my-docs的Settings项,选中侧边栏pages,配置部署分支为gh-pages,点击save.\",\"在actions菜单栏中应该会触发自动发布,没有的话随便修改下master分支代码,就会触发自动发布\",\"发布完成后,此时pages页会显示访问域名,点击访问即可\"]},\"22\":{\"h\":\"更新博客只在master分支上改,不要动gh-pages分支\",\"t\":[\"master 是源码分支 gh-pages是发布分支 master的代码都是ts和一些markdown文件,需要build成html文件和js才行,即gh-pages\"]},\"23\":{\"h\":\"修复\\\"编辑此页\\\"功能链接跳转不对问题\",\"t\":[\"修改theme.ts\",\"docsBranch: 文档所在分支,默认值: \\\"main\\\"\"]},\"24\":{\"h\":\"踩坑\",\"t\":[\"踩了一些坑,可以看提交记录\"]},\"25\":{\"c\":[\"前端\"]},\"26\":{\"c\":[\"JavaScript\"]},\"27\":{\"h\":\"在markdown中使用mermaid画图\",\"t\":[\"有些图渲染不出来，是因为当前版本没支持。使用typora或者其他markdown软件就能渲染出来\"]},\"28\":{\"h\":\"1.流程图\"},\"29\":{\"h\":\"2.序列图\"},\"30\":{\"h\":\"3.类图\"},\"31\":{\"h\":\"4.状态图\"},\"32\":{\"h\":\"5.实体关系图\"},\"33\":{\"h\":\"6.用户旅程图\"},\"34\":{\"h\":\"7.甘特图\"},\"35\":{\"h\":\"8.饼图\"},\"36\":{\"h\":\"9.象限图\"},\"37\":{\"h\":\"10.需求图\"},\"38\":{\"h\":\"11.Gitgraph（git） 图表\"},\"39\":{\"h\":\"12.C4 图\"},\"40\":{\"h\":\"C4 系统上下文图（C4Context）\"},\"41\":{\"h\":\"C4 容器图（C4Container）\"},\"42\":{\"h\":\"C4 组件图（C4Component）\"},\"43\":{\"h\":\"C4 动态图（C4Dynamic）\"},\"44\":{\"h\":\"C4 部署图（C4Deployment）\"},\"45\":{\"h\":\"13思维导图\"},\"46\":{\"h\":\"14.时间线图\"},\"47\":{\"h\":\"15ZenUML\"},\"48\":{\"h\":\"16.桑基图\"},\"49\":{\"h\":\"17.XY 图表\"},\"50\":{\"h\":\"18.框图文档\"},\"51\":{\"h\":\"19.数据包图\",\"t\":[\"--- title: \\\"TCP Packet\\\" --- packet-beta 0-15: \\\"Source Port\\\" 16-31: \\\"Destination Port\\\" 32-63: \\\"Sequence Number\\\" 64-95: \\\"Acknowledgment Number\\\" 96-99: \\\"Data Offset\\\" 100-105: \\\"Reserved\\\" 106: \\\"URG\\\" 107: \\\"ACK\\\" 108: \\\"PSH\\\" 109: \\\"RST\\\" 110: \\\"SYN\\\" 111: \\\"FIN\\\" 112-127: \\\"Window\\\" 128-143: \\\"Checksum\\\" 144-159: \\\"Urgent Pointer\\\" 160-191: \\\"(Options and Padding)\\\" 192-255: \\\"Data (variable length)\\\" \",\"渲染失败了\"]},\"52\":{\"h\":\"内存管理\"},\"53\":{\"h\":\"能说一下JVM的内存区域吗？\",\"t\":[\"JVM的内存区域分为多个部分，每个部分有其特定的用途和生命周期。主要的内存区域包括：\",\"方法区（Method Area）：\",\"作用：存储已加载的类信息、常量、静态变量、即时编译器编译后的代码等。\",\"生命周期：在JVM启动时创建，在JVM退出时销毁。\",\"特点：对于HotSpot JVM，它的一部分也被称为永久代（PermGen），从Java 8开始被移除，替换为元空间（Metaspace），元空间使用的是本地内存而不是堆内存。\",\"堆（Heap）：\",\"作用：存储对象实例和数组，所有对象都在堆上分配。\",\"生命周期：在JVM启动时创建，在JVM退出时销毁。\",\"特点：堆是垃圾回收的主要区域，可以分为新生代（Young Generation）和老年代（Old Generation），新生代又可以进一步划分为伊甸园区（Eden Space）和两个幸存者区（Survivor Space）。\",\"Java栈（Java Stack）：\",\"作用：每个线程有一个独立的Java栈，存储方法调用的局部变量、操作数栈、动态链接、方法出口等信息。\",\"生命周期：与线程相同，线程创建时创建，线程结束时销毁。\",\"特点：栈中的变量是线程私有的，不会出现线程间的数据共享问题。\",\"程序计数器（Program Counter Register）：\",\"作用：当前线程执行的字节码的行号指示器。如果当前线程正在执行的是本地方法，这个计数器的值是未定义的。\",\"生命周期：与线程相同，线程创建时创建，线程结束时销毁。\",\"特点：它是线程私有的，每个线程都有独立的程序计数器。\",\"本地方法栈（Native Method Stack）：\",\"作用：与Java栈类似，但为Native方法服务，存储本地方法的调用信息。\",\"生命周期：与线程相同，线程创建时创建，线程结束时销毁。\",\"特点：也是线程私有的，支持Native方法调用。\",\"JVM的内存区域分为方法区、堆、Java栈、程序计数器和本地方法栈。每个区域都有其特定的用途和生命周期，合理地管理这些内存区域对于JVM高效运行和垃圾回收有着至关重要的作用。\"]},\"54\":{\"h\":\"说一下JDK1.6、1.7、1.8内存区域的变化？\",\"t\":[\"在不同版本的Java开发工具包（JDK）中，Java虚拟机（JVM）的内存区域有一些重要的变化。以下是JDK 1.6、1.7和1.8之间内存区域的主要变化：\"]},\"55\":{\"h\":\"JDK 1.6\",\"t\":[\"在JDK 1.6中，JVM的内存区域主要包括：\",\"方法区（Method Area）：用于存储类结构（例如运行时常量池、字段、方法代码），由永久代（Permanent Generation, PermGen）实现。\",\"堆（Heap）：用于存储对象实例，分为新生代和老年代。\",\"Java栈（Java Stack）：每个线程有一个独立的Java栈，用于存储局部变量、操作数栈、方法返回值等。\",\"程序计数器（Program Counter Register）：每个线程有一个独立的程序计数器，用于记录当前线程执行的字节码行号。\",\"本地方法栈（Native Method Stack）：用于支持Native方法的执行。\"]},\"56\":{\"h\":\"JDK 1.7\",\"t\":[\"在JDK 1.7中，主要变化是永久代（PermGen）的逐步移除，部分数据迁移到堆中（如运行时常量池），以解决PermGen空间不足的问题：\",\"永久代逐步移除：运行时常量池（Runtime Constant Pool）从永久代移出，变为堆的一部分。\",\"字符串池移出永久代：字符串常量池被移到Java堆中，解决了因为PermGen空间不足导致的OutOfMemoryError的问题。\"]},\"57\":{\"h\":\"JDK 1.8\",\"t\":[\"在JDK 1.8中，永久代被完全移除，替换为元空间（Metaspace）：\",\"元空间（Metaspace）：用于替代永久代，存储类的元数据。元空间在本地内存中分配，不再使用堆内存，从而可以避免PermGen空间不足的问题。\",\"其他内存区域：堆、Java栈、程序计数器、本地方法栈仍然保留，功能基本不变。\"]},\"58\":{\"h\":\"详细变化对比\"},\"59\":{\"h\":\"永久代（PermGen）与元空间（Metaspace）\",\"t\":[\"JDK 1.6和1.7：永久代用于存储类元数据、方法信息等。\",\"JDK 1.8：永久代被移除，元空间用于存储类元数据。元空间在本地内存中动态扩展，不受堆内存大小限制。\"]},\"60\":{\"h\":\"字符串常量池\",\"t\":[\"JDK 1.6：字符串常量池在永久代中。\",\"JDK 1.7和1.8：字符串常量池移到Java堆中，解决了字符串常量池引起的内存管理问题。 \",\"物理上存放在堆中，逻辑上属于方法区\"]},\"61\":{\"h\":\"运行时常量池\",\"t\":[\"JDK 1.6：运行时常量池在永久代中。\",\"JDK 1.7和1.8：运行时常量池移到Java堆中，避免了永久代空间不足的问题。 \",\"物理上存放在堆中，逻辑上属于方法区\"]},\"62\":{\"h\":\"总结\",\"t\":[\"JDK 1.6：使用永久代来存储类元数据、运行时常量池和字符串常量池等。\",\"JDK 1.7：开始移除永久代，运行时常量池和字符串常量池迁移到Java堆中。\",\"JDK 1.8：永久代完全移除，使用元空间替代，用于存储类元数据，字符串常量池和运行时常量池继续在Java堆中。\",\"这些变化主要是为了改进内存管理，减少OutOfMemoryError的发生，提升JVM的性能和稳定性。\"]},\"63\":{\"h\":\"字符串常量池和运行时常量池有啥区别？\",\"t\":[\"字符串常量池和运行时常量池虽然名称相似，但它们在Java虚拟机（JVM）中的用途和实现方式有所不同。以下是它们的主要区别：\"]},\"64\":{\"h\":\"字符串常量池\",\"t\":[\"定义：\",\"字符串常量池（String Constant Pool）是一个专门用于存储字符串字面值（String literals）的区域。\",\"位置：\",\"在JDK 1.6及之前，字符串常量池位于永久代（PermGen）。\",\"从JDK 1.7开始，字符串常量池被移到Java堆（Heap）。\",\"实现：\",\"当一个字符串字面值被创建时，JVM会先检查字符串常量池中是否已经存在相同的字符串。如果存在，则返回该字符串的引用；如果不存在，则在池中创建该字符串并返回引用。\",\"可以通过调用String类的intern()方法将字符串添加到字符串常量池中。\",\"示例：\",\"String str1 = \\\"Hello\\\"; String str2 = \\\"Hello\\\"; boolean isSame = (str1 == str2); // true，因为str1和str2指向同一个字符串常量池中的对象 \"]},\"65\":{\"h\":\"运行时常量池\",\"t\":[\"定义：\",\"运行时常量池（Runtime Constant Pool）是每个类文件中的常量池（常量表）在运行时的表示形式。它包含类中所有字面值和符号引用。\",\"位置：\",\"在JDK 1.6及之前，运行时常量池也位于永久代。\",\"从JDK 1.7开始，运行时常量池被移到Java堆。\",\"实现：\",\"运行时常量池包含类加载后所需的各种常量，包括数值常量（例如整数、浮点数）、字符串常量、类和接口的符号引用、字段引用、方法引用等。\",\"运行时常量池在类加载时从类文件的常量池（Class File Constant Pool）中提取，并且在运行时为常量池中的符号引用进行解析。\",\"示例：\",\"public class Example { public static void main(String[] args) { int a = 10; // 数值常量10存储在运行时常量池中 String str = \\\"Hello\\\"; // 字符串字面值\\\"Hello\\\"存储在字符串常量池中，并且字符串常量池的引用在运行时常量池中 } } \"]},\"66\":{\"h\":\"区别总结\",\"t\":[\"用途：\",\"字符串常量池：专门用于存储字符串字面值，确保相同的字符串字面值在内存中只有一个副本，以节省内存。\",\"运行时常量池：用于存储类加载后所需的各种常量和符号引用，支持类和方法的运行。\",\"位置：\",\"字符串常量池：在JDK 1.6及之前位于永久代，从JDK 1.7开始位于堆中。\",\"运行时常量池：在JDK 1.6及之前位于永久代，从JDK 1.7开始位于堆中。\",\"内容：\",\"字符串常量池：仅包含字符串字面值。\",\"运行时常量池：包含数值常量、字符串常量、类和接口的符号引用、字段引用、方法引用等。\",\"管理机制：\",\"字符串常量池：由JVM自动管理，intern()方法可手动将字符串添加到池中。\",\"运行时常量池：在类加载时从类文件常量池中提取，并动态解析符号引用。\",\"通过上述对比，可以清晰地看出字符串常量池和运行时常量池在用途、实现和管理机制上的不同。\"]},\"67\":{\"h\":\"上面的代码示例中int a = 10不应该存放在栈中吗？\",\"t\":[\"在Java中，int a = 10; 这样的局部变量的值确实存储在Java栈中。然而，这个示例中提到的“运行时常量池”涉及的是字面值 10 这个常量的存储位置和引用机制。因此，为了更好地解释它们的区别，我们需要澄清几点：\"]},\"68\":{\"h\":\"运行时常量池和栈中的局部变量\",\"t\":[\"运行时常量池：存储类文件中的各种常量，包括字面值（如整数、浮点数）和符号引用（如类、字段、方法的符号引用）。这些常量在类加载时被加载到内存中，并用于程序运行时的各种操作。\",\"Java栈：每个线程都有一个Java栈，存储方法调用的局部变量和部分方法执行时的中间结果。\"]},\"69\":{\"h\":\"解释 int a = 10;\",\"t\":[\"在代码 int a = 10; 中：\",\"10 这个字面值：\",\"作为字面值 10，它在编译时会被存储在类文件的常量池中。\",\"在运行时，类加载器会将类文件的常量池中的字面值 10 加载到运行时常量池中。\",\"局部变量 a：\",\"a 是一个局部变量，它在方法调用时存储在当前线程的Java栈的当前栈帧中。\",\"存储过程：\",\"当执行 int a = 10; 时，运行时常量池中的字面值 10 被取出并赋值给局部变量 a，这个局部变量 a 实际上是存储在栈中的。\",\"因此，在这段代码中：\",\"字面值 10：最初存储在运行时常量池中。\",\"局部变量 a：存储在栈中，并引用运行时常量池中的 10 的值。\"]},\"70\":{\"h\":\"修正后的解释和示例代码\",\"t\":[\"public class Example { public static void main(String[] args) { int a = 10; // 数值常量10存储在运行时常量池中，局部变量a存储在Java栈中 String str = \\\"Hello\\\"; // 字符串字面值\\\"Hello\\\"存储在字符串常量池中 } } \"]},\"71\":{\"h\":\"总结\",\"t\":[\"运行时常量池：存储类加载时从类文件中提取的常量，包括字面值和符号引用。\",\"字符串常量池：专门存储字符串字面值，确保相同的字符串字面值在内存中只有一个副本。\",\"Java栈：存储方法调用的局部变量，包括方法执行的中间结果。\",\"在上述示例中，int a = 10; 中的 10 作为常量被存储在运行时常量池中，而 a 这个局部变量本身存储在Java栈中。\"]},\"72\":{\"h\":\"为什么使用元空间替代永久代作为方法区的实现？\",\"t\":[\"在JDK 1.8中，Java虚拟机（JVM）用元空间（Metaspace）替代了永久代（PermGen）来实现方法区。这一变化有多方面的原因和好处，包括规避内存溢出问题、提高性能、简化内存管理等。\"]},\"73\":{\"h\":\"使用元空间替代永久代的原因\"},\"74\":{\"h\":\"客观原因\",\"t\":[\"内存溢出问题：\",\"永久代的限制：永久代的大小在JVM启动时设定，无法动态调整。一旦应用加载了大量类或使用了大量字符串常量，永久代可能会填满，从而导致java.lang.OutOfMemoryError: PermGen space错误。虽然可以通过-XX:MaxPermSize参数调整其大小，但这增加了内存管理的复杂性。\",\"其他JVM的优势：其他JVM如J9和JRockit不会因为固定大小的永久代而遭遇内存溢出问题，只要总内存没有达到系统限制。\",\"方法行为不一致：\",\"String::intern()的影响：永久代的设计可能导致某些方法在不同JVM下表现不同，例如String::intern()方法在处理字符串常量池时可能表现出不同的性能和行为。\"]},\"75\":{\"h\":\"主观原因\",\"t\":[\"Oracle收购BEA后的整合： \",\"整合JRockit功能：Oracle收购BEA后，计划将JRockit中的优秀功能（如Java Mission Control管理工具）移植到HotSpot虚拟机中。但由于HotSpot和JRockit对方法区实现的差异，移植工作面临诸多困难。\",\"未来发展规划：为了HotSpot未来的发展，Oracle在JDK 6时就计划放弃永久代，逐步改用本地内存（Native Memory）来实现方法区。在JDK 7中，部分数据（如字符串常量池、静态变量）已移出永久代；在JDK 8中，永久代被完全废弃，改用元空间。\"]},\"76\":{\"h\":\"元空间的优势\",\"t\":[\"动态调整内存大小：\",\"避免OOM错误：元空间在本地内存中分配，可以根据需要动态增长，不受堆内存大小的限制，减少了因类加载过多而导致的内存不足问题。\",\"减少配置复杂性：不再需要手动调整类似-XX:MaxPermSize参数，简化了内存管理。\",\"改进的性能和垃圾回收：\",\"更高的回收效率：元空间利用新的垃圾回收算法，提高了回收效率，减少了Full GC的频率和停顿时间。\",\"与分代垃圾回收协同工作：元空间设计使其更好地与分代垃圾回收器协同工作，提高整体性能。\",\"统一的内存管理：\",\"简化管理：类元数据存储在本地内存中，简化了JVM的内存管理，使得内存使用更加高效和一致。\",\"更好的类加载和卸载支持：\",\"支持更多类加载和卸载：元空间提供更好的类加载和卸载支持，特别是对于大量动态生成和卸载类的应用，提高了内存利用率和性能。\"]},\"77\":{\"h\":\"总结\",\"t\":[\"使用元空间（Metaspace）替代永久代（PermGen）作为方法区的实现带来了以下好处：\",\"避免永久代空间不足问题，减少OutOfMemoryError的发生。\",\"改进性能和内存管理，提高垃圾回收效率，减少Full GC的频率和停顿时间。\",\"简化内存管理，通过动态调整减少配置的复杂性。\",\"提供更好的类加载和卸载支持，提高内存利用率和性能。\",\"整合JRockit功能，支持HotSpot的未来发展。\",\"这些改进使得JVM在性能、稳定性和可维护性方面都有显著提升，因此在JDK 1.8中引入了元空间来替代永久代。\"]},\"78\":{\"h\":\"对象创建的过程了解吗？\",\"t\":[\"当创建一个对象时，Java虚拟机（JVM）会执行以下步骤：\",\"类加载：\",\"如果该类尚未加载，则先执行类加载过程。类加载过程包括加载、验证、准备、解析和初始化阶段。\",\"分配内存：\",\"在堆内存中为对象分配内存空间。在JDK 1.7及之前的版本中，对象的内存分配是连续的，使用指针碰撞或空闲列表实现。在JDK 1.8及之后的版本中，引入了TLAB（Thread-Local Allocation Buffer）来提高内存分配的效率。\",\"初始化零值：\",\"JVM会将分配的内存空间初始化为零值，这包括基本类型的零值（如int类型的0）和引用类型的null。\",\"设置对象头：\",\"JVM会为对象设置对象头信息，包括对象的哈希码、GC分代信息、锁状态标志等。对象头的大小取决于虚拟机的具体实现和运行环境（如32位或64位JVM）。\",\"执行构造函数：\",\"执行对象的构造函数，进行对象的初始化。构造函数可以是类的直接构造函数，也可以是从父类继承而来的构造函数。构造函数会对对象的实例变量进行初始化，包括设置初始值或通过参数传递的值。\",\"返回对象引用：\",\"当构造函数执行完毕后，会返回一个指向新创建对象的引用。通过这个引用，程序可以访问和操作对象的属性和方法。\",\"总的来说，对象创建的过程包括类加载、内存分配、初始化、构造函数执行等步骤，确保对象在内存中被正确地创建和初始化。\"]},\"79\":{\"h\":\"什么是指针碰撞？什么是空闲列表？\",\"t\":[\"在 JVM 中，内存分配的方式通常是指针碰撞和空闲列表两种。\",\"指针碰撞：\",\"指针碰撞适用于 Java 堆中内存是绝对规整的情况。在这种情况下，所有已被使用的内存和空闲的内存分别放在堆的两端，中间有一个指针作为分界点指示器。\",\"JVM 通过移动指针来分配内存，将指针向空闲空间方向挪动与对象大小相等的距离即可。这种方式称为“指针碰撞”，因为指针碰到对象后会被挪动到下一个可用位置。\",\"空闲列表：\",\"空闲列表适用于 Java 堆中的内存不规整的情况。在这种情况下，已被使用的内存和空闲的内存相互交错。\",\"JVM 需要维护一个列表，记录哪些内存块是可用的。在分配内存时，JVM 会从列表中找到一块足够大的空间，划分给对象实例，并更新列表上的记录。\",\"这种分配方式称为“空闲列表”，它相对于指针碰撞更加灵活，因为不要求内存是连续的，能更好地处理内存碎片化的情况。\",\"选择使用指针碰撞还是空闲列表取决于堆内存的布局情况以及 JVM 的具体实现。指针碰撞适用于内存连续的情况，而空闲列表适用于内存不规整的情况。\",\"两种方式的选择由Java堆是否规整决定，Java堆是否规整是由选择的垃圾收集器是否具有压缩整理能力决定的\"]},\"80\":{\"h\":\"什么是TLAB（Thread-Local Allocation Buffer）\",\"t\":[\"TLAB（Thread-Local Allocation Buffer）是 Java 虚拟机（JVM）中一种用于提高多线程并发性能的技术。\",\"TLAB 是为每个线程分配的一块私有的内存区域，用于线程独立地分配对象。它的作用在于减少线程间因为对象分配而频繁竞争内存分配的情况，从而提高并发性能。\",\"TLAB 的工作原理如下：\",\"每个线程分配自己的 TLAB：当一个线程开始执行时，JVM 会为其分配一个 TLAB 区域。这个区域在堆内存中是连续的，并且是该线程私有的，其他线程无法访问。\",\"线程独立地分配对象：线程在自己的 TLAB 区域内分配对象时，无需进行同步操作，因为这个区域是私有的，不存在与其他线程的竞争。这样可以避免了多线程情况下的锁竞争，提高了分配对象的效率。\",\"TLAB 分配原则：当线程需要分配对象时，首先会在自己的 TLAB 区域中进行分配。如果该区域空间不足，JVM 会尝试为该线程重新分配更大的 TLAB 区域。只有当 TLAB 区域不够大或者无法分配时，线程才会在堆的全局空间中进行对象分配。\",\"TLAB 技术的使用可以减少多线程情况下的内存分配竞争，提高了 JVM 在并发场景下的性能表现。\"]},\"81\":{\"h\":\"JVM 里 new 对象时，堆会发生抢占吗？JVM是怎么设计来保证线程安全的？\",\"t\":[\"在 JVM 中，堆内存的分配是线程共享的，因此在多线程环境下可能会发生堆内存的抢占现象。当多个线程同时执行 new 操作创建对象时，它们会竞争堆内存的分配。\",\"为了解决多线程环境下的堆内存分配竞争问题，常见的解决方案包括：\",\"原子性操作：JVM 使用 CAS（Compare and Swap）等原子性操作来确保对共享数据的原子性访问。CAS 操作可以比较并交换共享变量的值，如果期望值与当前值一致，则更新为新值，否则重试。这样可以避免使用锁，提高了并发性能。\",\"本地线程分配缓冲（TLAB）：JVM 为每个线程预先分配一小块内存空间作为本地线程分配缓冲。线程在分配对象时，首先尝试在自己的 TLAB 中分配内存，只有当 TLAB 用尽时才会竞争堆内存。这样做可以减少线程间因为堆内存分配而发生的竞争，提高了内存分配的效率。\",\"通过这些解决方案，JVM 能够有效地处理多线程环境下的堆内存分配问题，确保线程安全和性能的平衡。\"]},\"82\":{\"h\":\"能说一下对象的内存布局吗？\",\"t\":[\"在Java中，每个对象都会被分配一块内存空间。这块内存空间包括三个主要部分：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。\",\"对象头（Header）：对象头存储了一些元数据，例如对象的哈希码、锁状态、GC（垃圾回收）相关信息等。对象头的大小在不同的JVM实现中会有所不同，通常在32位JVM中占用4个字节，而在64位JVM中占用8个字节。\",\"实例数据（Instance Data）：实例数据存储了对象的成员变量值。这些成员变量按其声明顺序存放在内存中，基本数据类型直接存储其值，引用类型则存储指向实际对象数据的指针。\",\"对齐填充（Padding）：由于虚拟机内存访问要求数据存储在特定的内存地址上，因此在实例数据之后可能会添加一些填充字节，以保证对象在内存中的起始地址是按照要求对齐的。这些填充字节的大小取决于JVM实现和操作系统的要求。\",\"总体而言，对象的内存布局可以用以下示意图表示：\",\"|-------------------| | Object Header | (Header) |-------------------| | Instance Data | (成员变量) |-------------------| | Padding | (对齐填充) |-------------------| \",\"需要注意的是，这个内存布局在不同的JVM实现中可能会有所不同。\"]},\"83\":{\"h\":\"对象怎么访问定位？\",\"t\":[\"在Java程序中，通过栈上的reference数据来操作堆上的具体对象。Java虚拟机规范中只规定了reference是一个指向对象的引用，并未具体定义如何定位和访问堆中对象的具体位置，因此对象的访问方式由虚拟机实现而定。目前主流的访问方式有使用句柄和直接指针两种：\",\"句柄访问方式：在这种方式下，Java堆中可能会划分出一块内存作为句柄池，reference中存储的是对象的句柄地址。句柄中包含了对象实例数据与类型数据各自具体的地址信息。这种方式的优势在于稳定性，即reference中存储的是稳定的句柄地址，当对象被移动时（如垃圾收集时），只需修改句柄中的实例数据指针，而不需修改reference本身。\",\"直接指针访问方式：在这种方式下，reference中存储的直接是对象地址，而不是句柄地址。这种方式的优势在于速度更快，因为避免了一次指针定位的时间开销。由于对象访问在Java中非常频繁，这种方式可以节省大量的执行成本。\",\"HotSpot虚拟机主要采用直接指针访问方式来进行对象访问，以提高执行效率。\"]},\"84\":{\"h\":\"什么是内存溢出、内存泄漏？\",\"t\":[\"内存溢出（Memory Overflow）和内存泄漏（Memory Leak）是两种不同的内存管理问题：\",\"内存溢出（Memory Overflow）：内存溢出指的是程序在申请内存时，无法获得足够的内存空间，导致无法正常执行程序。这种情况通常发生在程序需要的内存超过了系统实际可用内存的情况下。内存溢出可能会导致程序崩溃，或者出现异常错误，例如Java中的OutOfMemoryError。常见的内存溢出场景包括：递归调用层次过深、无限循环创建对象等。\",\"内存泄漏（Memory Leak）：内存泄漏指的是程序中已经不再使用的内存没有被正确释放，导致该内存无法被再次使用，最终导致程序占用的内存越来越多，甚至耗尽系统的可用内存。内存泄漏通常发生在程序中频繁动态分配内存却未及时释放，或者是持有对某些对象的引用却未能及时释放这些引用，使得垃圾回收器无法回收这些对象。长时间运行的程序中如果存在内存泄漏，可能会导致系统性能下降、程序运行速度变慢，甚至系统崩溃。\",\"内存溢出和内存泄漏都是需要注意和及时解决的内存管理问题，特别是在长时间运行、资源密集型的程序中。及时发现和修复这些问题是保证程序性能和稳定性的重要一环。\"]},\"85\":{\"h\":\"能手写内存溢出的例子吗？\",\"t\":[\"Java堆内存溢出：OutOfMemoryError\",\"import java.util.ArrayList; import java.util.List; public class HeapOverflowExample { public static void main(String[] args) { List<byte[]> list = new ArrayList<>(); try { while (true) { list.add(new byte[1000000]); // 创建一个1MB大小的字节数组对象 } } catch (OutOfMemoryError e) { System.out.println(\\\"Java堆内存溢出！\\\"); } } } \",\"在这个示例中，我们创建了一个ArrayList，然后尝试不断地向其中添加1MB大小的字节数组对象。由于没有对添加的对象进行释放，堆内存会逐渐耗尽，最终抛出OutOfMemoryError，提示Java堆内存溢出。\",\"虚拟机栈溢出：StackOverflowError\",\"public class StackOverflowExample { public static void main(String[] args) { try { recursiveMethod(0); } catch (StackOverflowError e) { System.out.println(\\\"虚拟机栈溢出！\\\"); } } public static void recursiveMethod(int i) { recursiveMethod(i + 1); // 递归调用自身 } } \",\"在这个示例中，recursiveMethod()方法会无限递归调用自身，导致虚拟机栈溢出，最终抛出StackOverflowError异常。\"]},\"86\":{\"h\":\"内存泄漏可能由哪些原因导致呢？\",\"t\":[\"内存泄漏可能由以下几种常见原因导致：\",\"未及时释放资源：例如打开文件、数据库连接、网络连接等资源后，没有在使用完毕后及时关闭，导致资源未被释放。\",\"缓存导致的引用保留：缓存通常用于临时存储对象以提高访问速度，但如果没有正确管理缓存，可能会导致不再需要的对象一直被保留在内存中。\",\"监听器和回调：注册了监听器或回调函数，但在对象不再需要时未能正确注销，导致对象仍然被引用，无法被垃圾回收器回收。\",\"静态集合：如果将对象添加到静态集合中，即使在程序的其他部分不再需要这些对象，它们仍然会被集合保留，导致内存泄漏。\",\"内部类持有外部类的引用：如果内部类持有对外部类的引用，并且生命周期比外部类长，那么即使外部类不再需要，外部类的实例也无法被垃圾回收。\",\"长时间运行的程序：长时间运行的程序可能会持续产生新对象而不释放旧对象，导致内存逐渐耗尽。\",\"ThreadLocal使用不当：ThreadLocal的弱引用导致内存泄漏也是个老生常谈的话题了，使用完ThreadLocal一 定要记得使用remove方法来进行清除\",\"综上所述，内存泄漏通常是由于程序中持续保留了不再需要的对象或资源而引起的，因此在开发过程中需要仔细管理和释放对象和资源，以避免内存泄漏问题的发生。\"]},\"87\":{\"h\":\"如何判断对象仍然存活？\",\"t\":[\"在Java中，可以通过垃圾回收器来判断对象是否仍然存活。Java的垃圾回收器使用了“引用计数”和“可达性分析”两种方法来确定对象是否可以被回收。\",\"引用计数：这种方法通过给对象添加一个引用计数器来跟踪对象的引用数量。每当有一个新的引用指向对象时，引用计数器就加一；当引用被移除时，计数器减一。如果计数器为零，则说明对象没有被引用，可以被回收。但是，Java的垃圾回收器不使用引用计数算法，因为该算法无法处理循环引用的情况。\",\"可达性分析：这是Java垃圾回收器实际使用的方法。可达性分析从一组称为“GC Roots”的初始对象开始，通过对象之间的引用关系进行遍历，找出所有能够被直接或间接引用到的对象。如果某个对象无法通过任何引用链与GC Roots相连，则说明该对象不可达，即为“垃圾对象”，可以被回收。\",\"因此，对于一个对象，只要存在一条从GC Roots到该对象的引用链，该对象就被认为是存活的；反之，则被认为是可回收的垃圾对象。\"]},\"88\":{\"h\":\"Java中可作为GC Roots的对象有哪几种？\",\"t\":[\"在Java中，以下对象可以作为GC Roots，垃圾回收器从这些对象开始进行可达性分析：\",\"虚拟机栈中的引用：虚拟机栈（Java栈）中的本地变量表和操作栈中的引用。\",\"方法区中的静态引用：方法区中的静态变量引用的对象，即静态成员变量。\",\"方法区中的常量引用：方法区中的常量引用的对象，如字符串常量池中的字符串对象。\",\"本地方法栈中的JNI（Java Native Interface）引用：JNI引用的对象，即Java代码调用本地方法时传递的对象引用。\",\"这些对象是垃圾回收器进行可达性分析的起点，通过这些对象可以遍历到所有活动对象，判断哪些对象是可达的，哪些是不可达的，从而进行垃圾回收。\"]},\"89\":{\"h\":\"说一下对象有哪几种引用？\",\"t\":[\"在Java中，根据对象的引用强度和生命周期的不同，可以将对象的引用分为以下几种类型：\",\"强引用（Strong Reference）：\",\"强引用是最常见的引用类型，如果一个对象具有强引用，垃圾回收器不会回收它。\",\"即使系统出现内存溢出，也不会回收强引用的对象，而是抛出OutOfMemoryError异常。\",\"例如：普通的对象引用赋值，例如 Object obj = new Object();\",\"软引用（Soft Reference）：\",\"软引用是一种比强引用弱一些的引用，它在系统即将发生内存溢出之前，会被垃圾回收器回收。\",\"当系统内存不足时，垃圾回收器会尝试回收软引用指向的对象，如果回收后还是没有足够的内存，才会抛出OutOfMemoryError异常。\",\"适合用于缓存的场景，例如图片缓存。\",\"弱引用（Weak Reference）：\",\"弱引用的生命周期比软引用更短，当垃圾回收器进行垃圾回收时，无论内存是否充足，弱引用都会被回收。\",\"弱引用可以防止内存泄漏，但并不能保证在某个时刻被保留。\",\"主要用于实现对象的规范映射，例如ThreadLocal和WeakHashMap。\",\"虚引用（Phantom Reference）：\",\"虚引用是最弱的引用，几乎没有直接作用。\",\"虚引用的唯一目的是在对象被垃圾回收器回收时收到一个系统通知。\",\"在Java中，通过虚引用可以跟踪对象被垃圾回收的状态，但不能通过虚引用获取对象本身。\",\"主要用于清理前的资源释放工作。\",\"使用不同类型的引用可以更灵活地管理对象的生命周期和内存使用情况，同时可以避免一些内存泄漏问题。\"]},\"90\":{\"h\":\"finalize()方法了解吗？有什么作用？\",\"t\":[\"finalize()方法是Java中的一个特殊方法，定义在Object类中，具有以下特点：\",\"方法签名：protected void finalize() throws Throwable\",\"作用：finalize()方法被用来实现对象在被垃圾回收之前，自我清理或释放资源的操作。它允许在对象被回收之前执行一些特定的清理工作，例如关闭文件、释放资源等。\",\"调用时机：垃圾回收器在回收对象之前会调用其finalize()方法，但是并不保证会调用它，因此不能依赖于finalize()方法来执行重要的清理工作。垃圾回收器调用finalize()方法的时间是不确定的，有可能在对象被回收时调用，也有可能不会被调用。\",\"缺点：finalize()方法存在一些缺点，包括无法保证及时执行、不确定性高、会影响性能等。因此，不建议过度依赖finalize()方法来进行资源释放和清理操作，推荐使用try-with-resources语句或显式地调用close()等方法来确保资源的释放。\",\"总之，finalize()方法提供了一个在对象被垃圾回收之前进行一些清理操作的机会，但由于其不确定性和性能问题，应谨慎使用，并尽量避免过度依赖。\"]},\"91\":{\"h\":\"Java堆的内存分区了解吗？\",\"t\":[\"Java堆是Java虚拟机管理的最大的一块内存区域，主要用于存放对象实例。Java堆可以根据内存分配的策略划分为不同的区域，主要包括以下几个部分：\",\"新生代（Young Generation）：\",\"新生代是Java堆的一部分，用于存放新创建的对象。\",\"新生代通常被划分为三个区域：Eden区、Survivor区（From区和To区）。\",\"大多数对象在被分配时会被分配在Eden区，然后经过一次Minor GC后，仍然存活的对象会被移动到Survivor区。\",\"Survivor区用来保存经过一次GC后仍然存活的对象，From区和To区之间会进行对象的交换。\",\"老年代（Old Generation）：\",\"老年代用于存放长期存活的对象，通常存放在老年代的对象经过多次垃圾回收后仍然存活。\",\"大多数对象从新生代晋升到老年代，经过多次Minor GC后仍然存活的对象会被晋升到老年代。\",\"永久代/元空间（Permanent Generation/Metaspace）：\",\"永久代是Java 7及以前版本的概念，用于存放类的元数据、静态变量、常量池等。\",\"从Java 8开始，永久代被元空间（Metaspace）所取代，元空间不再位于Java堆中，而是位于本地内存中，因此不再受到Java堆的大小限制。\",\"代码缓存区（Code Cache）：\",\"代码缓存区用于存放编译后的本地代码，例如JIT编译器生成的机器代码。\",\"Java堆的内存分区主要是为了优化内存的使用和垃圾回收效率，通过将不同类型的对象放置在不同的区域中，可以采用不同的垃圾回收算法和策略来对各个区域进行回收，以提高垃圾回收的效率和内存利用率。\"]},\"92\":{\"h\":\"垃圾收集算法了解吗？\",\"t\":[\"当然，垃圾收集算法是Java虚拟机用来回收不再使用的内存空间的一种技术。Java虚拟机中常见的垃圾收集算法包括以下几种：\",\"标记-清除算法（Mark and Sweep）：\",\"标记-清除算法是最基本的垃圾收集算法之一，分为两个阶段：标记阶段和清除阶段。\",\"在标记阶段，从根节点出发，标记所有能够被访问到的对象。\",\"在清除阶段，垃圾收集器会遍历整个堆，清除所有未标记的对象，释放它们所占用的内存空间。\",\"标记-清除算法存在的问题是产生大量的内存碎片，容易导致内存分配失败。同时执行效率不稳定，垃圾回收时垃圾收集器会遍历整个堆，如果堆中包含大量对象，可能执行效率降低\",\"复制算法（Copying）：\",\"复制算法将内存空间划分为两个相等大小的区域：From区和To区。\",\"在垃圾回收时，将存活的对象复制到To区，然后清空From区。\",\"复制算法适用于新生代的垃圾回收，因为新生代中的对象存活时间短，复制的开销较小。\",\"标记-整理算法（Mark and Compact）：\",\"标记-整理算法结合了标记-清除和复制算法的优点，适用于老年代的垃圾回收。\",\"在标记阶段，标记所有存活的对象，并且将存活对象向一端移动。\",\"在整理阶段，将存活对象压缩，将它们移动到内存的一端，释放出连续的内存空间。\",\"分代算法（Generational）：\",\"分代算法基于“弱分代假设”，即大多数对象的生命周期很短。\",\"根据对象的存活周期将Java堆划分为新生代和老年代两个部分，分别采用不同的垃圾回收算法和策略。\",\"新生代通常使用复制算法，老年代通常使用标记-整理算法。\",\"增量式垃圾收集算法（Incremental Garbage Collection）：\",\"增量式垃圾收集算法将垃圾回收过程分解成多个阶段，每个阶段只收集部分对象，然后让程序继续执行。\",\"这种算法可以减少垃圾回收的停顿时间，提高系统的响应速度，但会增加垃圾回收器的复杂度。\",\"以上是一些常见的垃圾收集算法，不同的算法适用于不同的场景和需求，选择合适的垃圾收集算法可以提高垃圾回收的效率和系统的性能。\"]},\"93\":{\"h\":\"说一下新生代的区域划分？\",\"t\":[\"新生代是Java堆的一部分，用于存放新创建的对象。新生代通常被划分为三个区域：Eden区、Survivor区（From区和To区）。\",\"Eden区：\",\"Eden区是新创建对象的初始分配区域，大多数对象都会被分配到Eden区。\",\"当Eden区满时，触发Minor GC（新生代垃圾回收），将Eden区中存活的对象复制到Survivor区，并清空Eden区。\",\"Survivor区：\",\"Survivor区是用于存放经过一次Minor GC后仍然存活的对象。\",\"Survivor区通常有两个，分别称为From区和To区，它们之间会进行对象的交换。\",\"在对象经过多次Minor GC后仍然存活时，会被移动到老年代，而不再留在Survivor区。\",\"在新生代中，采用复制算法进行垃圾回收。该算法将内存空间分为两个相等大小的区域（Eden区和Survivor区），在Minor GC时，将Eden区和其中一个Survivor区的存活对象复制到另一个Survivor区，同时清空原来的Eden区和使用过的Survivor区。这样，新生代的垃圾回收可以避免内存碎片的产生，提高垃圾回收的效率。\"]},\"94\":{\"h\":\"Minor GC/Young GC、Major GC/Old GC、Mixed GC、Full GC都是什么意思？\",\"t\":[\"这些术语都与Java堆的垃圾回收相关，它们表示不同类型的垃圾回收操作：\",\"Minor GC / Young GC：\",\"Minor GC（也称为Young GC）是针对新生代的垃圾回收操作。\",\"当新生代的Eden区满时，触发Minor GC。在Minor GC中，只有新生代被回收，即Eden区和Survivor区。\",\"Minor GC的目标是清理新生代中的垃圾对象，提供足够的空间给新对象分配。\",\"Major GC / Old GC：\",\"Major GC（也称为Old GC）是针对老年代的垃圾回收操作。\",\"当老年代的内存空间不足时，或者当长时间存活的对象需要晋升到老年代时，触发Major GC。\",\"Major GC的目标是清理老年代中的垃圾对象，提供足够的空间给新对象分配。\",\"Mixed GC：\",\"Mixed GC是一种混合型的垃圾回收操作，同时针对新生代和老年代进行回收。\",\"在某些情况下，垃圾收集器可能会选择执行Mixed GC，以提高整体的垃圾回收效率。\",\"Mixed GC通常会在新生代和老年代之间进行对象的晋升和迁移，以保证整个堆的空间利用率。\",\"Full GC：\",\"Full GC是一种完全的垃圾回收操作，会对整个Java堆进行回收。\",\"在某些情况下，如永久代（在Java 7及以前版本）或元空间（在Java 8及以后版本）的内存不足时，可能会触发Full GC。\",\"Full GC会对新生代和老年代以及永久代/元空间进行垃圾回收，其过程比较耗时，会导致较长时间的应用程序暂停。\"]},\"95\":{\"h\":\"Minor GC/Young GC什么时候触发？\",\"t\":[\"Minor GC（也称为Young GC）在什么时候触发取决于新生代的内存分配情况。通常情况下，触发Minor GC的时机有两个主要条件：\",\"Eden区满：\",\"当Eden区（新生代的一部分）被新对象填满时，会触发Minor GC。\",\"新对象通常会被分配到Eden区，当Eden区没有足够的空间来分配新对象时，就会触发Minor GC。\",\"Survivor区不足：\",\"在新生代中，对象经过几次Minor GC后仍然存活的对象会被晋升到老年代。\",\"当新生代的Survivor区也无法容纳存活对象时，这些对象就会被晋升到老年代。\",\"这种情况也会触发Minor GC，因为Minor GC实际上是对新生代进行垃圾回收，包括Eden区和Survivor区。\",\"因此，Minor GC通常在Eden区满或者存活对象晋升到老年代时触发。它的目标是清理新生代中的垃圾对象，以便为新对象的分配提供足够的空间。\"]},\"96\":{\"h\":\"什么时候会触发Full GC？\",\"t\":[\"Full GC（Full Garbage Collection）通常在以下情况下会触发：\",\"老年代空间不足：当老年代的内存空间不足以容纳新对象，或者老年代中的对象存活时间过长，导致老年代的内存使用率达到阈值时，会触发Full GC。\",\"Young GC之后老年代空间不足：在执行Young GC之后，如果有一批对象需要放入老年代，但老年代没有足够的内存空间存放这些对象，就会触发Full GC。\",\"空间分配担保失败（Promotion Failure）：当新生代的To区放不下从Eden和From区拷贝过来的对象，或者新生代对象的GC年龄到达阈值需要晋升到老年代，而老年代放不下时，都会触发Full GC。\",\"方法区内存空间不足：如果方法区由永久代实现，而永久代的空间不足时，也会触发Full GC。\",\"System.gc()等命令触发：手动调用System.gc()或使用类似jmap -dump等命令也会触发Full GC。\",\"Young GC之前检查老年代：当要进行Young GC时，如果发现老年代可用的连续内存空间小于新生代历次Young GC后升入老年代的对象总和的平均大小，说明本次Young GC后可能升入老年代的对象大小可能超过了老年代当前可用内存空间，这时会触发Full GC。\",\"这些情况都反映了Java应用程序在运行过程中内存管理的一些具体场景，了解这些情况可以帮助开发者更好地调优Java应用程序的内存配置和性能。\"]},\"97\":{\"h\":\"对象什么时候会进入老年代？\",\"t\":[\"长期存活的对象：长期存活的对象，如全局变量、长时间存活的缓存对象等，会逐渐晋升到老年代。对象的迭代年龄会在每次Young GC之后的对象移动操作中增加，当迭代年龄达到一定阈值（默认为15）时，对象将被移入老年代。可以通过调整-XX:MaxTenuringThreshold参数来设置这个阈值。\",\"大对象：占用大量连续内存空间的对象，如大数组或长字符串，会直接进入老年代。可以通过调整-XX:PretenureSizeThreshold参数来设置大对象的大小阈值。\",\"动态年龄判断：HotSpot虚拟机并不要求对象的年龄必须达到阈值才能晋升到老年代。如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。\",\"空间分配担保：在Young GC之后，如果新生代仍有大量对象存活，就需要老年代进行分配担保，将Survivor区无法容纳的对象直接送入老年代。这个机制避免了频繁将存活对象从新生代复制到Survivor区，提高了垃圾回收的效率。\"]},\"98\":{\"h\":\"知道有哪些垃圾收集器吗？\",\"t\":[\"Java 中常见的垃圾收集器包括：\",\"Serial收集器：这是最早的收集器之一，它是单线程的收集器，使用标记-复制算法，适用于简单的客户端应用或者测试目的。\",\"ParNew收集器：ParNew是Serial收集器的多线程版本，主要用于新生代的收集，也使用标记-复制算法。\",\"Parallel Scavenge收集器：Parallel Scavenge收集器也是针对新生代的收集器，它关注的是吞吐量，使用标记-复制算法和多线程并行的方式实现高吞吐量的垃圾收集。\",\"Serial Old收集器：Serial Old是Serial收集器的老年代版本，使用标记-整理算法，适用于简单的客户端应用或者测试目的。\",\"Parallel Old收集器：Parallel Old是Parallel Scavenge收集器的老年代版本，也是使用标记-整理算法，适用于多核服务器上的应用，通过多线程并行收集实现高吞吐量。\",\"CMS（Concurrent Mark-Sweep）收集器：CMS收集器是一种以减少停顿时间为目标的收集器，它通过并发标记和并发清除来实现低停顿时间的垃圾收集，适用于对响应时间有要求的应用。\",\"G1（Garbage-First）收集器：G1收集器是一种面向服务端应用的垃圾收集器，它将堆内存划分为多个区域，通过并发标记、整理和清理来实现高吞吐和低停顿。\",\"ZGC（Z Garbage Collector）：ZGC是一种低延迟的垃圾收集器，通过并发的方式来实现在非常短的停顿时间内完成垃圾收集。\",\"Shenandoah收集器：Shenandoah是一种低延迟的垃圾收集器，它通过在Java线程运行的情况下执行并发标记、并发整理和并发回收来实现低停顿时间。\",\"每种垃圾收集器都有其自己的特点和适用场景，选择合适的垃圾收集器取决于应用程序的性能需求和特点。在实际应用中，通常需要根据具体的场景进行选择和调优。\"]},\"99\":{\"h\":\"什么是Stop The World ? 什么是 OopMap ？什么是安全点？\",\"t\":[\"垃圾回收过程中的“Stop The World”现象指的是在执行垃圾回收时，需要暂停所有的用户线程。这个暂停的目的是为了保证对象引用更新的正确性。在这个暂停期间，虚拟机会执行垃圾回收操作，包括对象的移动等，以确保内存的正确回收和整理。\",\"在HotSpot虚拟机中，OopMap（Object-oriented Programming Map）是一种数据结构，用于记录对象内的偏移量上存储的数据类型。当类加载完成时，HotSpot会计算并记录下对象内部各个偏移量上存储的数据类型。在即时编译过程中，也会生成OopMap，并记录下栈上和寄存器里哪些位置是引用。\",\"安全点（Safe Point）是指在程序执行过程中的特定位置，垃圾收集器可以在这些位置暂停用户程序的执行，进行垃圾回收操作。这些安全点通常出现在循环的末尾、方法调用之后、可能抛出异常的位置等。在这些特定位置上，用户程序的状态是可预期的，因此可以暂停执行进行垃圾回收操作，而不会导致程序状态的不一致。\"]},\"100\":{\"h\":\"能详细说一下CMS收集器的垃圾收集过程吗？\",\"t\":[\"CMS（Concurrent Mark-Sweep）收集器是Java虚拟机（JVM）中用于垃圾收集的一种算法，旨在最小化应用程序的停顿时间。CMS收集器主要用于老年代（Tenured Generation）的垃圾收集。它的工作过程可以分为以下几个阶段：\",\"初始标记（Initial Mark）：\",\"这一阶段会暂停所有应用线程（Stop-The-World，STW）。\",\"主要标记从根集合（GC Roots）直接可达的对象。\",\"这个阶段时间较短，因为只需要标记GC Roots。\",\"并发标记（Concurrent Mark）：\",\"在这个阶段，应用线程和垃圾收集线程并发运行。\",\"垃圾收集线程从初始标记阶段标记的对象开始，遍历整个对象图，标记所有可达的对象。\",\"由于与应用线程并发运行，这个阶段不会造成显著的停顿。\",\"重新标记（Remark）：\",\"这一阶段需要再次暂停所有应用线程（STW）。\",\"由于并发标记阶段和应用线程并发运行，可能会有新创建或删除的对象，这一阶段就是为了重新标记这些对象。\",\"这个阶段也会标记由于并发标记阶段遗漏的对象，确保所有可达对象都被正确标记。\",\"并发清理（Concurrent Sweep）：\",\"这个阶段再次与应用线程并发运行。\",\"垃圾收集线程清理那些没有被标记为可达的对象，回收其占用的内存。\",\"由于是并发进行，不会导致应用线程停顿。\",\"CMS收集器有以下几个特点：\",\"低停顿：CMS收集器设计的主要目的是降低垃圾收集对应用程序的停顿时间。\",\"并发性：大部分的垃圾收集工作与应用程序并发进行。\",\"碎片化问题：CMS使用标记-清除（Mark-Sweep）算法，这可能导致内存碎片。为了应对碎片化，CMS收集器提供了并发压缩（Compacting）和类Unloading的机制。\",\"停顿时间不可预测：尽管CMS降低了停顿时间，但由于碎片化问题和并发的复杂性，有时可能会出现比预期更长的停顿。\",\"另外，CMS收集器还有一个重要的参数：CMSInitiatingOccupancyFraction，它决定了当老年代使用率达到多少时，CMS开始进行垃圾收集。通过调整这个参数，可以控制垃圾收集的频率和停顿时间。\",\"总结来说，CMS收集器通过初始标记、并发标记、重新标记和并发清理四个阶段，尽量减少垃圾收集对应用程序的影响，提升应用程序的响应速度和用户体验。然而，CMS也有其缺点，如内存碎片化问题和某些情况下的长停顿时间，需要在使用时根据具体应用场景进行调优。\"]},\"101\":{\"h\":\"G1垃圾收集器了解吗？\",\"t\":[\"G1垃圾收集器（Garbage First Garbage Collector）是Java虚拟机（JVM）中一种相对现代的垃圾收集器，旨在替代CMS（Concurrent Mark-Sweep）收集器。G1收集器专为多处理器和大内存的环境设计，目标是实现高吞吐量与低停顿时间之间的平衡。其工作过程可以概括为以下几个阶段：\"]},\"102\":{\"h\":\"G1垃圾收集器的关键特点\",\"t\":[\"分区区域（Region）：\",\"堆内存被划分为多个大小相等的区域（Region），每个区域可以是年轻代（Young Generation）或老年代（Old Generation）的一部分。这样做的目的是简化内存管理和优化垃圾收集。\",\"并发标记（Concurrent Marking）：\",\"G1收集器和CMS一样，采用了并发标记的策略，以减少应用停顿时间。\",\"并发标记阶段分为初始标记（Initial Marking）、根区域扫描（Root Region Scanning）、并发标记（Concurrent Marking）、最终标记（Remarking）和清理（Cleanup）五个子阶段。\",\"混合回收（Mixed Collections）：\",\"G1在回收过程中会同时处理年轻代和老年代的垃圾收集，称为混合回收（Mixed Collections）。这与传统的分代垃圾收集器不同，传统方法通常分为年轻代收集和老年代收集。\",\"暂停时间可控（Pause Time Control）：\",\"G1可以通过参数配置目标暂停时间（Pause Time Goals），如通过-XX:MaxGCPauseMillis参数设置，G1会根据设置的暂停时间来调整其行为。\"]},\"103\":{\"h\":\"G1垃圾收集器的工作阶段\",\"t\":[\"初始标记（Initial Mark）：\",\"标记从根对象直接可达的对象。\",\"需要STW，但时间较短。\",\"通常会与年轻代的垃圾收集（Minor GC）一起执行，以减少停顿时间。\",\"根区域扫描（Root Region Scanning）：\",\"并发标记开始前，扫描在初始标记阶段确定的根区域。\",\"这个阶段不需要暂停应用线程。\",\"并发标记（Concurrent Marking）：\",\"该阶段和应用线程并发运行，遍历对象图，标记所有可达对象。\",\"计算存活对象和各区域的存活数据。\",\"最终标记（Remark）：\",\"完成对并发标记阶段遗漏对象的标记。\",\"需要STW，但优化了停顿时间。\",\"清理（Cleanup）：\",\"重新计算各个区域的存活对象，进行垃圾回收和区域回收。\",\"一部分需要STW，但大部分是并发进行。\",\"复制（Evacuation）：\",\"这是垃圾收集的核心操作，涉及将存活对象从一个区域复制到另一个区域。\",\"主要在年轻代GC和混合GC中执行。\"]},\"104\":{\"h\":\"G1垃圾收集器的优势\",\"t\":[\"低停顿时间：通过分区和并发标记，G1在处理大堆内存时能有效控制垃圾收集的停顿时间。\",\"可预测性：G1可以根据用户设定的停顿时间目标自动调整其行为。\",\"适应性强：G1适用于多核处理器和大内存的环境，能高效管理和利用资源。\"]},\"105\":{\"h\":\"G1垃圾收集器的配置参数\",\"t\":[\"-XX:+UseG1GC：启用G1垃圾收集器。\",\"-XX:MaxGCPauseMillis=<N>：设置目标最大GC停顿时间（毫秒）。\",\"-XX:InitiatingHeapOccupancyPercent=<N>：设置在进行混合回收之前，老年代占用的堆内存百分比阈值。\",\"-XX:G1HeapRegionSize=<size>：设置每个Region的大小。\"]},\"106\":{\"h\":\"总结\",\"t\":[\"G1垃圾收集器通过分区管理、并发标记和混合回收，提供了一种平衡高吞吐量和低停顿时间的垃圾收集解决方案。它适用于现代大内存和多处理器的环境，能够自动调整行为以满足用户设定的停顿时间目标，具有高效、可预测的特点。\"]},\"107\":{\"h\":\"有了CMS，为什么还要引入G1？\",\"t\":[\"尽管CMS（Concurrent Mark-Sweep）垃圾收集器在降低垃圾收集停顿时间方面取得了显著成功，但它也存在一些局限性和缺点，这促使了G1垃圾收集器的引入。以下是引入G1垃圾收集器的主要原因：\"]},\"108\":{\"h\":\"CMS的局限性\",\"t\":[\"内存碎片化：\",\"CMS使用标记-清除算法，不会移动存活对象，因此容易导致堆内存碎片化。碎片化会导致分配大对象时频繁触发Full GC，进而导致长时间的停顿。\",\"Full GC停顿时间长：\",\"当CMS收集器无法获取足够的内存空间时，会退化为单线程的标记-整理（Mark-Compact）算法进行Full GC。这个过程会导致显著的停顿时间，尤其在大堆内存环境下。\",\"并发模式失效（Concurrent Mode Failure）：\",\"如果在CMS的并发阶段内没有足够的空闲内存，CMS会触发一次Full GC，导致长时间的应用停顿。这种情况被称为并发模式失效。\",\"调优复杂：\",\"CMS需要对许多参数进行调优（如启动阈值、线程数量等），以确保在不同工作负载下的良好表现。这增加了维护和管理的复杂性。\"]},\"109\":{\"h\":\"G1垃圾收集器的优势\",\"t\":[\"减少碎片化：\",\"G1采用了分区（Region）和标记-复制（Mark-Copy）算法，显著减少了内存碎片化问题。通过压缩阶段，可以整理内存，避免碎片化。\",\"可预测的停顿时间：\",\"G1引入了目标停顿时间设置（Pause Time Goals），允许用户通过参数-XX:MaxGCPauseMillis指定目标停顿时间。G1会动态调整垃圾收集过程，以尽量满足这个目标。\",\"自动调优：\",\"G1具有自适应调优功能，能够根据应用的运行状况自动调整垃圾收集的行为和策略，减少了手动调优的复杂性。\",\"分代式垃圾收集：\",\"G1通过混合回收（Mixed Collections）机制，在单次GC中同时处理年轻代和老年代的对象，提高了内存回收效率。\",\"并发与并行：\",\"G1除了支持并发标记外，还支持并行回收，充分利用多处理器的优势，减少垃圾收集的停顿时间。\",\"更好的大堆支持：\",\"G1设计之初即考虑了大内存环境，能够高效管理和回收大堆内存中的垃圾，适应现代应用的需求。\"]},\"110\":{\"h\":\"总结\",\"t\":[\"虽然CMS在降低停顿时间方面表现优秀，但其内存碎片化、Full GC停顿时间长和调优复杂等问题限制了其进一步的应用和发展。G1垃圾收集器通过分区管理、压缩回收、可预测停顿时间和自动调优等特性，提供了一个更加高效和灵活的垃圾收集解决方案，特别适用于大内存和多处理器的现代应用环境。G1的引入旨在克服CMS的局限性，为Java应用提供更好的性能和可预测性。\"]},\"111\":{\"h\":\"你们线上用的什么垃圾收集器？为什么要用它？\",\"t\":[\"选择合适的垃圾收集器取决于应用程序的需求、运行环境和性能目标。在生产环境中，常见的垃圾收集器有CMS、G1和ZGC。以下是一些大公司和常见应用场景中使用的垃圾收集器及其原因：\"]},\"112\":{\"h\":\"常见的垃圾收集器\",\"t\":[\"CMS（Concurrent Mark-Sweep）：\",\"使用场景：曾广泛用于响应时间要求高的应用，如Web服务器和交易系统。\",\"优点：降低了垃圾收集的停顿时间，适用于具有中等堆大小的应用。\",\"缺点：内存碎片化问题、Full GC停顿时间长、调优复杂。\",\"G1（Garbage First）：\",\"使用场景：现代化的Java应用，特别是大堆内存环境，如数据处理系统和大规模微服务架构。\",\"优点：可预测的停顿时间、减少内存碎片化、自动调优、适用于大堆内存。\",\"缺点：初期调优可能需要一定时间。\",\"ZGC（Z Garbage Collector）：\",\"使用场景：需要极低停顿时间的应用，如实时系统、大数据处理和金融系统。\",\"优点：极低停顿时间（通常在1-10毫秒范围内）、支持超大堆（数TB）、无需复杂调优。\",\"缺点：相对新，成熟度不如G1和CMS，但随着时间推移越来越成熟。\"]},\"113\":{\"h\":\"为什么选择某种垃圾收集器\"},\"114\":{\"h\":\"使用G1的理由\",\"t\":[\"可预测的低停顿时间：G1的设计目标之一就是提供可预测的低停顿时间，这对于需要保证响应时间的应用非常重要。\",\"适合大堆内存：G1通过分区管理和并发回收机制，能够高效地处理大堆内存中的垃圾。\",\"减少内存碎片：G1通过标记-复制和压缩回收，显著减少了内存碎片化问题。\",\"自动调优：G1具有自适应调优能力，可以根据运行时的表现自动调整垃圾收集策略，减少手动调优的复杂性。\"]},\"115\":{\"h\":\"使用ZGC的理由\",\"t\":[\"超低停顿时间：ZGC的设计目标是实现极低的停顿时间，通常在1-10毫秒范围内，非常适合对响应时间有严格要求的应用。\",\"支持超大堆：ZGC能够处理数TB的堆内存，适用于需要处理大量数据的应用场景。\",\"无需复杂调优：ZGC的自动管理和优化能力强，减少了对垃圾收集器的复杂调优需求。\"]},\"116\":{\"h\":\"大公司和常见应用中的选择\",\"t\":[\"大型互联网公司（如Google、Netflix）：常常使用G1或ZGC来处理大规模服务和数据处理系统，因为这些垃圾收集器能够在保持高吞吐量的同时提供可预测的低停顿时间。\",\"金融机构（如银行、证券交易所）：对停顿时间要求极高，往往选择ZGC来确保系统的实时性和低延迟。\",\"中小型Web应用：可能继续使用CMS或转向G1，特别是当需要平衡响应时间和吞吐量时。\"]},\"117\":{\"h\":\"总结\",\"t\":[\"在选择垃圾收集器时，关键是要根据应用的具体需求和运行环境来做出决策。如果需要低停顿时间和大堆内存支持，G1和ZGC是首选。G1适用于大多数现代应用，提供了可预测的低停顿时间和自动调优能力。ZGC适合需要极低停顿时间和处理超大堆内存的应用。最终的选择应根据应用的性能需求、堆内存大小和停顿时间要求来确定。\"]},\"118\":{\"h\":\"垃圾收集器应该如何选择？\",\"t\":[\"选择合适的垃圾收集器（GC）是确保Java应用程序性能和稳定性的关键。不同的GC适用于不同的应用场景和需求，以下是选择GC时需要考虑的几个关键因素和常见的垃圾收集器选项：\"]},\"119\":{\"h\":\"关键考虑因素\",\"t\":[\"停顿时间要求：\",\"低停顿时间：适用于对响应时间敏感的应用，如实时系统、交易系统、在线游戏等。\",\"高吞吐量：适用于批处理、后台任务等对响应时间不敏感的应用。\",\"堆内存大小：\",\"小到中等堆内存：几百MB到几GB。\",\"大堆内存：几十GB到几TB。\",\"并发线程数：\",\"多核处理器可以利用并行GC和并发GC。\",\"应用类型：\",\"低延迟应用：如金融交易、在线游戏。\",\"高吞吐量应用：如批处理、大数据处理。\"]},\"120\":{\"h\":\"常见垃圾收集器选项\",\"t\":[\"Serial GC：\",\"适用场景：单处理器或低并发应用、小堆内存。\",\"特点：简单、单线程、停顿时间较长，但适合内存使用较小且对GC停顿不敏感的应用。\",\"启用方式：-XX:+UseSerialGC\",\"Parallel GC（也称为Throughput GC）：\",\"适用场景：多处理器环境、大堆内存、高吞吐量应用。\",\"特点：多线程、侧重于高吞吐量，可能会有较长的停顿时间。\",\"启用方式：-XX:+UseParallelGC\",\"CMS（Concurrent Mark-Sweep）GC：\",\"适用场景：中等到大堆内存、对停顿时间敏感的应用。\",\"特点：并发标记和清理，减少停顿时间，但存在内存碎片化问题。\",\"启用方式：-XX:+UseConcMarkSweepGC\",\"G1（Garbage First）GC：\",\"适用场景：中等到大堆内存、需要可预测的低停顿时间。\",\"特点：分区管理、并发标记和压缩回收、可预测的停顿时间。\",\"启用方式：-XX:+UseG1GC\",\"关键参数：-XX:MaxGCPauseMillis=<N>（设置目标最大GC停顿时间）\",\"ZGC（Z Garbage Collector）：\",\"适用场景：非常大堆内存（数百GB到数TB）、需要极低停顿时间。\",\"特点：极低停顿时间（通常在1-10毫秒范围内）、支持超大堆内存、无需复杂调优。\",\"启用方式：-XX:+UseZGC\",\"Shenandoah GC（适用于OpenJDK）：\",\"适用场景：大堆内存、需要低停顿时间的应用。\",\"特点：并发压缩、低停顿时间。\",\"启用方式：-XX:+UseShenandoahGC\"]},\"121\":{\"h\":\"选择垃圾收集器的步骤\",\"t\":[\"评估应用需求：\",\"确定应用对停顿时间和吞吐量的要求。\",\"确定应用的堆内存大小。\",\"试验和测量：\",\"使用不同的GC选项运行应用，测量GC停顿时间、吞吐量和内存使用情况。\",\"使用JVM提供的工具（如JVisualVM、GC日志）监控和分析GC性能。\",\"调优参数：\",\"根据测量结果，调整GC参数以优化性能。\",\"例如，G1 GC可以通过调整-XX:MaxGCPauseMillis来优化停顿时间。\",\"考虑未来需求：\",\"考虑应用未来的增长和变化，选择能适应未来需求的GC。\"]},\"122\":{\"h\":\"总结\",\"t\":[\"选择合适的垃圾收集器是一个平衡应用需求、硬件资源和GC特性的过程。通过评估应用的停顿时间需求、堆内存大小和并发能力，结合实际测试和调优，可以选择最适合的垃圾收集器来优化Java应用的性能和稳定性。\"]},\"123\":{\"h\":\"对象一定分配在堆中吗？有没有了解逃逸分析技术？\",\"t\":[\"在Java中，对象的内存分配通常是在堆中进行的。然而，并非所有对象都必须分配在堆中。有些情况下，对象可以被分配在栈上或者通过逃逸分析技术进行优化。下面详细说明这些概念。\"]},\"124\":{\"h\":\"对象分配的基本概念\",\"t\":[\"堆内存（Heap Memory）：\",\"通常用于动态分配对象，生命周期不受方法调用结束的影响。\",\"GC（垃圾收集器）会负责回收堆内存中的对象。\",\"栈内存（Stack Memory）：\",\"栈用于存储局部变量和方法调用栈帧。\",\"栈内存的分配和释放由JVM自动管理，当方法调用结束时，相应的栈帧和局部变量会被释放。\"]},\"125\":{\"h\":\"逃逸分析（Escape Analysis）\",\"t\":[\"逃逸分析是一种编译时技术，用于确定对象的作用域，特别是确定对象是否会逃逸出方法的作用域。根据逃逸分析的结果，JVM可以进行一些优化，例如：\",\"栈上分配（Stack Allocation）：\",\"如果通过逃逸分析确定对象不会逃逸出当前方法，则对象可以在栈上分配而不是在堆上。这减少了GC的压力，因为栈上的对象在方法结束时自动释放。\",\"标量替换（Scalar Replacement）：\",\"如果对象不会逃逸并且可以分解为多个标量变量，编译器可以将对象的成员变量直接分配在栈上，而不分配整个对象。\",\"同步消除（Synchronization Elimination）：\",\"如果通过逃逸分析确定对象不会逃逸到多个线程中，JVM可以消除不必要的同步代码，以提高性能。\"]},\"126\":{\"h\":\"逃逸分析的应用示例\",\"t\":[\"假设有以下简单的Java方法：\",\"public class EscapeAnalysisExample { public void exampleMethod() { Point p = new Point(1, 2); // Use the point p } } class Point { int x; int y; Point(int x, int y) { this.x = x; this.y = y; } } \",\"在这个例子中，Point对象只在exampleMethod方法内部使用，没有逃逸出方法的作用域。因此，通过逃逸分析，JVM可能会优化，将Point对象分配在栈上而不是堆上。\"]},\"127\":{\"h\":\"JVM参数和逃逸分析\",\"t\":[\"JVM支持逃逸分析的参数包括：\",\"-XX:+DoEscapeAnalysis：启用逃逸分析（默认开启）。\",\"-XX:+EliminateAllocations：启用标量替换优化（需要逃逸分析）。\",\"-XX:+EliminateLocks：启用同步消除优化（需要逃逸分析）。\",\"这些参数可以在启动JVM时配置，例如：\",\"java -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:+EliminateLocks MyApplication \"]},\"128\":{\"h\":\"逃逸分析的优势\",\"t\":[\"性能提升：减少了堆内存的分配和垃圾收集，提高了程序的运行性能。\",\"降低GC压力：更多对象分配在栈上或优化掉，减少了GC的负担。\",\"减少锁开销：同步消除减少了不必要的锁开销，提高了并发性能。\"]},\"129\":{\"h\":\"总结\",\"t\":[\"虽然Java对象通常分配在堆中，但通过逃逸分析技术，JVM可以进行一系列优化，将某些对象分配在栈上或者进行标量替换，从而提升性能和减少GC的压力。这些优化技术使得Java在保持易用性的同时，也能在性能方面接近手动内存管理的编程语言。\"]},\"130\":{\"h\":\"引言\"},\"131\":{\"h\":\"什么是JVM?\",\"t\":[\"JVM，全称为Java虚拟机（Java Virtual Machine），是一个虚拟的计算机，它能够运行以字节码（bytecode）形式编写的Java程序。JVM是Java技术的核心部分，它使得Java具有跨平台特性，即“编写一次，运行在任何地方”（Write Once, Run Anywhere, WORA）。\"]},\"132\":{\"h\":\"JVM的主要功能\",\"t\":[\"加载代码：JVM从文件系统中加载Java字节码文件（.class文件），并将其转换成可以执行的机器码。\",\"内存管理：JVM负责分配和管理程序运行时所需的内存，包括堆（Heap）和栈（Stack）管理。\",\"执行代码：JVM将字节码解释或编译成本地机器码，然后执行这些代码。\",\"垃圾回收：JVM自动管理内存，通过垃圾回收机制回收不再使用的对象，防止内存泄漏。\",\"安全性管理：JVM有一套安全管理机制，能够在执行代码前对其进行验证，确保代码不会进行非法操作。\"]},\"133\":{\"h\":\"JVM的结构\",\"t\":[\"JVM的结构大致可以分为以下几个部分：\",\"类加载器子系统（Class Loader Subsystem）：负责加载.class文件，并将其转换为JVM可以使用的内部数据结构。\",\"运行时数据区（Runtime Data Area）：包括方法区（Method Area）、堆（Heap）、Java栈（Java Stack）、程序计数器（Program Counter Register）和本地方法栈（Native Method Stack）。\",\"执行引擎（Execution Engine）：负责执行字节码，包括解释器（Interpreter）和即时编译器（Just-In-Time Compiler，JIT）。\",\"本地方法接口（Native Interface）：使Java程序能够调用本地（非Java）库和函数。\",\"垃圾回收器（Garbage Collector）：负责自动回收不再使用的内存。\"]},\"134\":{\"h\":\"JVM的工作过程\",\"t\":[\"加载：通过类加载器将.class文件加载到内存中。\",\"链接：包括验证、准备和解析步骤，确保字节码文件的正确性和一致性。\",\"初始化：对类的静态变量和静态代码块进行初始化。\",\"执行：由执行引擎将字节码解释或编译为机器码并执行。\"]},\"135\":{\"h\":\"JVM的跨平台特性\",\"t\":[\"Java程序在不同平台上运行时，只需要有对应平台的JVM即可。JVM负责将字节码转换为对应平台的机器码，因此Java程序无需修改即可在不同操作系统上运行。\",\"总结来说，JVM是Java语言实现跨平台特性、内存管理、安全性等功能的关键组件。它通过加载、解释、执行Java字节码，使得Java程序能够在各种硬件和操作系统上稳定运行。\"]},\"136\":{\"h\":\"IO\"},\"137\":{\"h\":\"Java 中 IO 流分为几种?\",\"t\":[\"按照流的流向分，可以分为 输入流 和 输出流 \",\"InputStream / Reader : 所有的输入流的基类，前者是字节输入流，后者是字符输入流\",\"OutputStream / Writer : 所有输出流的基类，前者是字节输出流，后者是字符输出流\",\"按照操作单元划分，可以划分为 字节流 和 字符流\",\"按照流的角色划分为 节点流 和 处理流\"]},\"138\":{\"h\":\"既然有了字节流,为什么还要有字符流？\",\"t\":[\"字节流\",\"字节流则更适合处理二进制数据\",\"字节流以字节为单位进行输入输出，适用于处理二进制数据（例如图像、音频、视频等）或与底层设备进行通信时。字节流通常用于处理文件和网络连接中的数据传输。它们是处理数据的底层工具，提供了最基本的输入输出操作。\",\"字符流\",\"字符流更适合读取和写入文本文件\",\"字符流以字符为单位进行输入输出，适用于处理文本数据。字符流会自动处理字符编码和解码，而字节流则需要手动处理。这使得字符流在处理文本数据时更方便和高效，尤其是当涉及到国际化和本地化时、\",\"尽管字节流可以处理所有类型的数据，但为了更方便地处理文本数据，Java提供了字符流\"]},\"139\":{\"h\":\"BIO、NIO、AIO？\",\"t\":[\"BIO\",\"同步阻塞IO\",\"客户端有连接请求时服务器端就需要启动一个线程进行处理（可以使用连接池优化）\",\"JDK1.4之前的选择\",\"NIO\",\"同步非阻塞IO\",\"服务器端用一个线程处理多个连接，客户端发送的连接请求会注册到多路复用器上，多路复用器轮询到连接有IO请求就进行处理\",\"NIO工作原理\",\"应用程序（A）通过选择器（B）发起连接请求\",\"选择器（B）将通道（channel代表了服务端与客户端的连接）注册，使其成为监视对象，以便选择器可以监听多个通道的事件。\",\"当有新的连接请求到达时，选择器（B）会处理这个事件，并将新的通道（C）加入到已注册的通道列表（D）中，以备后续操作。\",\"选择器（B）不断监听通道列表（D）中通道的读写事件。\",\"当某个通道（E）有读或写事件时，选择器（B）会将该通道标记为就绪状态，并执行相应的读取或写入操作。\",\"读取或写入操作使用缓冲区（F）来处理数据，应用程序可以在缓冲区中读取或写入数据。\",\"AIO\",\"异步非阻塞IO\",\"Java 的 NIO 就是 Reactor\",\"当有事件触发时，服务器端得到通知，进行相应的处理，完成后才通知(回调)服务端程序启动线程去处理\",\"一般适用于连接数较多且连接时间较长的应用\"]},\"140\":{\"h\":\"JDK1.8新特性\"},\"141\":{\"h\":\"JDK1.8都有哪些新特性？\",\"t\":[\"接口的默认方法和静态方法 \",\"在Java 8中，接口可以包含默认方法和静态方法\",\"Lambda 表达式和函数式接口 \",\"Lambda 表达式本质上是一段匿名内部类，可以传递一段代码\",\"Lambda 允许把函数作为一个方法的参数（函数作为参数传递到方法中），使用 Lambda 表达式使代码更加简洁\",\"但是也不要滥用，否则会有可读性等问题\",\"《Effective Java》作者 Josh Bloch 建议使用 Lambda 表达式最好不要超过3行\",\"Stream API \",\"Stream API提供了一种更简洁、更易于并行处理数据集合的方式\",\"通过Stream API，我们可以对集合进行过滤、映射、排序、聚合等操作，提高了代码的可读性和简洁性\",\"新的日期和时间API \",\"Java 8引入了新的日期和时间API（java.time包），提供了更好的日期和时间处理方式\",\"新的API解决了旧的Date和Calendar类在处理日期和时间时的一些问题，并提供了更多的功能和灵活性\",\"Optional 类 \",\"Optional类是一个容器类，用于表示一个值可能存在或不存在\",\"通过Optional类，我们可以避免空指针异常，并更好地处理可能为空的值\"]},\"142\":{\"h\":\"Lambda 表达式了解多少？\",\"t\":[\"Lambda 表达式本质上是一段匿名内部类，也可以是一段可以传递的代码\",\"只有函数式接口（FunctionalInterface）才能缩写成 Lambda 表示式\"]},\"143\":{\"h\":\"Java8有哪些内置函数式接口？\",\"t\":[\"添加了 @FunctionalInterface 注解的接口 \",\"Comparator\",\"Runnable\",\"Callable\",\"Predicate\",\"Function\",\"Supplier\",\"Consumer\"]},\"144\":{\"h\":\"Optional了解吗？\",\"t\":[\"Optional 是用于防范 NullPointerException\",\"可以将 Optional 看做是包装对象（可能是 null , 也有可能非 null ）的容器\",\"当我们定义了 一个方法，这个方法返回的对象可能是空，也有可能非空的时候，我们就可以考虑用 Optional 来包装它，这也是在 Java 8 被推荐使用的做法\",\"Optional<String> optional = Optional.of(\\\"bam\\\"); optional.isPresent(); // true optional.get(); // \\\"bam\\\" optional.orElse(\\\"fallback\\\"); // \\\"bam\\\" optional.ifPresent((s) -> System.out.println(s.charAt(0))); \"]},\"145\":{\"h\":\"Stream 流用过吗？\",\"t\":[\"Stream 流，简单来说，使用 java.util.Stream 对一个包含一个或多个元素的集合做各种操作\",\"这些操作可能是 中间操作 亦或是 终端操作\",\"终端操作会返回一个结果，而中间操作会返回一个 Stream 流\",\"Stream流一般用于集合，Stream的常用操作有\",\" List<String> stringCollection = new ArrayList<>(); stringCollection.add(\\\"ddd2\\\"); stringCollection.add(\\\"aaa2\\\"); stringCollection.add(\\\"bbb1\\\"); stringCollection.add(\\\"aaa1\\\"); stringCollection.add(\\\"bbb3\\\"); stringCollection.add(\\\"ccc\\\"); stringCollection.add(\\\"bbb2\\\"); stringCollection.add(\\\"ddd1\\\"); \",\"Filter 过滤\",\"stringCollection .stream() .filter((s) -> s.startsWith(\\\"a\\\")) .forEach(System.out::println); \",\"Sorted 排序\",\" stringCollection .stream() .sorted() .filter((s) -> s.startsWith(\\\"a\\\")) .forEach(System.out::println); \",\"Map 转换\",\" stringCollection .stream() .map(String::toUpperCase) .sorted((a, b) -> b.compareTo(a)) .forEach(System.out::println); \",\"Match 匹配\",\"// 验证 list 中 string 是否有以 a 开头的, 匹配到第一个，即返回 true boolean anyStartsWithA = stringCollection .stream() .anyMatch((s) -> s.startsWith(\\\"a\\\")) boolean allStartsWithA = stringCollection .stream() .allMatch((s) -> s.startsWith(\\\"a\\\")); System.out.println(allStartsWithA); // false // 验证 list 中 string 是否都不是以 z 开头的, boolean noneStartsWithZ = stringCollection .stream() .noneMatch((s) -> s.startsWith(\\\"z\\\")) \",\"Count 计数\",\"// 先对 list 中字符串开头为 b 进行过滤，让后统计数量 long startsWithB = stringCollection .stream() .filter((s) -> s.startsWith(\\\"b\\\")) .count(); \",\"count 是一个终端操作，它能够统计 stream 流中的元素总数，返回值是 long类型\",\"Reduce归约\",\"Optional<String> reduced = stringCollection .stream() .sorted() .reduce((s1, s2) -> s1 + \\\"#\\\" + s2); \",\"Reduce 中文翻译为：减少、缩小。通过入参的 Function ，我们能够将 list归约成一个值。它的返回类型是 Optional 类型\",\"Stream的常用API\"]},\"146\":{\"h\":\"Java概述\"},\"147\":{\"h\":\"Java语言有哪些特点？\",\"t\":[\"面向对象 \",\"封装\",\"继承\",\"多态\",\"平台无关性\",\"支持多线程\",\"编译与解释并存\"]},\"148\":{\"h\":\"JVM、JDK 和 JRE 有什么区别？\",\"t\":[\"JVM\",\"Java Virtual Machine，Java虚拟机，Java程序运行在Java虚拟机上。针对不同 系统的实现（Windows，Linux，macOS）不同的JVM，因此Java语言可以实现跨平 台。\",\"JRE\",\"Java 运⾏时环境。它是运⾏已编译 Java 程序所需的所有内容的集合，包括Java 虚拟机（JVM），Java 类库，Java 命令和其他的⼀些基础构件。但是，它不能⽤于创建新程序。\",\"JDK\",\"Java Development Kit，它是功能⻬全的 Java SDK。它拥有 JRE 所拥有的⼀ 切，还有编译器（javac）和⼯具（如 javadoc 和 jdb）。它能够创建和编译程序。 简单来说，JDK包含JRE，JRE包含JVM。\"]},\"149\":{\"h\":\"说说什么是跨平台性？原理是什么?\",\"t\":[\"跨平台：一次编译，多操作系统运行\",\"实现原理：不同系统安装不同Java虚拟机\"]},\"150\":{\"h\":\"什么是字节码？采用字节码的好处是什么?\",\"t\":[\".class文件\",\"字节码能够被虚拟机识别，从而实现Java程序的跨平台性\",\"Java 程序从源代码到运行主要有三步 \",\"编译：.java ->.class\",\"解释：虚拟机执行Java字节码，.class -机器码\",\"执行 ：对应的操作系统执行二进制机器码\"]},\"151\":{\"h\":\"为什么说 Java 语言“编译与解释并存”？\",\"t\":[\"因为 Java 程序要经过先编译，后解释两个步骤 \",\"由 Java 编写的程序需要先经过编译步骤，生成字节码（ *.class 文件）\",\"这种字节码必须再经过JVM，解释成操作系统能识别的机器码，再由操作系统执行\"]},\"152\":{\"h\":\"其它\"},\"153\":{\"h\":\"说下什么是Java的SPI机制？\",\"t\":[\"Java的SPI（Service Provider Interface）机制是Java标准库提供的一种服务发现机制\",\"它允许第三方组件在不修改源代码的情况下，通过在Classpath中提供配置文件，向应用程序注入实现了特定接口的服务提供者\",\"SPI中的几个关键元素\",\"服务接口（Service Interface）： 定义了服务的契约，描述了服务提供者需要实现的接口或抽象类\",\"服务提供者（Service Provider）： 实现了服务接口的具体类，并通过配置文件等方式注册到SPI框架中\",\"服务提供者配置文件（Service Provider Configuration File）： 是一种元数据文件，通常位于META-INF/services/目录下，文件名为服务接口的全限定名。该文件包含了服务接口的实现类的全限定名，每个实现类占据一行\",\"服务加载器（Service Loader）： 是用于加载和实例化服务提供者的API。它在运行时查找并加载META-INF/services/目录下的配置文件，并根据配置文件中指定的实现类实例化相应的对象\",\"SPI机制的工作原理如下\",\"定义服务接口\",\"首先，应用程序定义一个接口，这个接口是服务的契约，规定了需要提供的功能或扩展点\",\"public interface HelloService { void sayHello(); } \",\"编写服务提供者\",\"接着，编写服务提供者，实现服务接口，并提供了具体的功能实现\",\"public class HelloServiceImpl implements HelloService { @Override public void sayHello() { System.out.println(\\\"Hello from HelloServiceImpl!\\\"); } } \",\"编写服务提供者配置文件\",\"每个服务提供者将自己的实现类配置到一个特定的配置文件中，该文件位于 META-INF/services/ 目录下，以接口的全限定名命名\",\"com.example.service.HelloServiceImpl com.example.service.HelloServiceImpl2 \",\"服务加载\",\"在应用程序运行时，Java的SPI机制会使用服务加载器加载这些配置文件，并根据文件中指定的实现类，实例化对应的服务提供者对象\",\"ServiceLoader<HelloService> loader =ServiceLoader.load(HelloService.class) \",\"服务使用\",\"ServiceLoader<HelloService> loader =ServiceLoader.load(HelloService.class) for (HelloService service : loader) { service.sayHello(); } \",\"SPI机制的优势\",\"解耦了服务的实现和调用方\",\"应用程序可以在不修改源代码的情况下，动态地替换、扩展或定制某个功能或组件的实现\",\"SPI机制的应用场景\",\"数据库驱动、日志框架、插件系统等\"]},\"154\":{\"h\":\"反射\"},\"155\":{\"h\":\"什么是反射？\",\"t\":[\"new 对象 \",\"创建对象实例的方式\",\"在编译时候就确定了类型信息\",\"反射 \",\"在运行时动态地获取类信息、创建类实例、调用类方法这时候就要用到反射\",\"通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性\",\"反射相关类 \",\"Class\",\"Method\",\"Field\",\"Constructor\"]},\"156\":{\"h\":\"反射的应用场景？\",\"t\":[\"Spring/Spring Boot、MyBatis 等等框架中都大量使用了反射机制\",\"Spring里的很多注解 ，它真正的功能实现就是利用反射 \",\"@Component\",\"@Value\"]},\"157\":{\"h\":\"反射的实现原理\",\"t\":[\"基于Java虚拟机（JVM）的类加载机制和类对象模型\",\"在Java中，每个类都有一个对应的Class对象，该对象包含了类的名称、字段、方法等信息\",\"通过反射，我们可以获取到Class对象信息，并在运行时动态地操作类和对象\"]},\"158\":{\"h\":\"基础语法\"},\"159\":{\"h\":\"Java有哪些数据类型？\",\"t\":[\"基本数据类型\",\"数值型 \",\"整数类型（byte、short、int、long）\",\"浮点类型（float、double）\",\"字符型（char）\",\"布尔型（boolean）\",\"基本类型\",\"位数\",\"字节\",\"默认值\",\"最小值\",\"最大值\",\"int\",\"32\",\"4\",\"0\",\"-2^31\",\"2^31-1\",\"short\",\"16\",\"2\",\"0\",\"-2^15\",\"2^15-1\",\"long\",\"64\",\"8\",\"0L\",\"-2^63\",\"2^63-1\",\"byte\",\"8\",\"1\",\"0\",\"-128\",\"127\",\"char\",\"16\",\"2\",\"'\\\\u0000'\",\"'\\\\u0000'\",\"'\\\\uffff'\",\"float\",\"32\",\"4\",\"0.0f\",\"1.4E-45\",\"3.4028235E38\",\"double\",\"64\",\"8\",\"0.0d\",\"4.9E-324\",\"1.7976931348623157E308\",\"boolean\",\"1\",\"false\",\"引用数据类型\",\"类（class）\",\"接口（interface）\",\"数组([])\"]},\"160\":{\"h\":\"什么是自动类型转换、强制类型转换？\",\"t\":[\"自动类型转换：把一个表数范围小的数值或变量直接赋给另一个数范围大的变量时\",\"强制类型转换：反之，需要强制转换\"]},\"161\":{\"h\":\"什么是自动拆箱/封箱？\",\"t\":[\"装箱 ：将基本类型用它们对应的引用类型包装起来\",\"拆箱 ：将包装类型转换为基本数据类型\"]},\"162\":{\"h\":\"&和&&有什么区别？\",\"t\":[\"&：短路与\",\"&&：逻辑与\"]},\"163\":{\"h\":\"switch 是否能作用在 byte/long/String上？\",\"t\":[\"Java5 以前 switch(expr)中，expr 只能是 byte、short、char、int\",\"从 Java 5 开始，Java 中引入了枚举类型， expr 也可以是 enum 类型\",\"从 Java 7 开始，expr还可以是字符串(String)，但是长整型(long)在目前所有的版本中都是不可以的\"]},\"164\":{\"h\":\"break ,continue ,return 的区别及作用？\",\"t\":[\"break 跳出整个循环，不再执行循环( 结束当前的循环体 )\",\"continue 跳出本次循环，继续执行下次循环( 结束正在执行的循环 进入下一个循环条件 )\",\"return 程序返回，不再执行下面的代码( 结束当前的方法 直接返回 )\"]},\"165\":{\"h\":\"用最有效率的方法计算2乘以8？\",\"t\":[\"2 << 3。位运算，数字的二进制位左移三位相当于乘以2的三次方。\"]},\"166\":{\"h\":\"说说自增自减运算？\",\"t\":[\"++和--运算符可以放在变量之前，也可以放在变量之后\",\"运算符放在变量之前时(前缀)，先自增/减，再赋值\",\"当运算符放在变量之后时(后缀)，先赋值，再自增/减\"]},\"167\":{\"h\":\"常用类\"},\"168\":{\"h\":\"String 是 Java 基本数据类型吗？可以被继承吗？\",\"t\":[\"String是Java基本数据类型吗？\",\"不是，引用数据类型\",\"String 类可以继承吗?\",\"不行。String类在Java中被声明为final类，这意味着它不能被继承\",\"这样设计的原因\",\"字符串的不可变性\",\"String类的不可变性使得它可以被安全地用于多线程环境下，不会出现线程安全问题\",\"任何对 String 对象的操作（如拼接、替换等）都会返回一个新的 String 对象，而不会修改原始对象的值\",\"字符串常量池的优化\",\"由于字符串是不可变的，Java可以对字符串进行缓存和共享，以提高性能和节省内存\",\"这就是通过字符串常量池来实现的，它存储了所有字符串字面量的唯一实例\",\"安全性和可靠性\",\"String类的不可变性使得它在安全性和可靠性方面更加可靠。例如，它可以被用作Map的键，因为它的哈希值是固定的\"]},\"169\":{\"h\":\"String和StringBuilder、StringBuffer？\",\"t\":[\"类名\",\"可变性\",\"线程安全性\",\"性能\",\"String\",\"不可变\",\"线程安全\",\"低\",\"StringBuffer\",\"可变\",\"线程安全\",\"低\",\"StringBuilder\",\"可变\",\"非线程安全\",\"高\",\"String类 \",\"String是不可变的，使用 private final char value[] 来存储字符串，一旦创建就不能修改其值 \",\"jdk11使用byte[]存储字符串\",\"任何对String的修改都会创建一个新的String对象\",\"String类是线程安全的，因为它的不可变性保证了多个线程可以安全地共享String对象\",\"由于不可变性的特性，对于频繁的字符串拼接操作，会产生大量的临时对象，影响性能\",\"StringBuffer类 \",\"StringBuffer是可变的，使用 char value[] 存储字符串，它的值可以被修改\",\"为了保证线程安全性，StringBuffer的方法都使用synchronized关键字进行同步，在多线程环境下，使用StringBuffer可以保证线程安全\",\"由于同步的开销，StringBuffer的性能相对较低\",\"StringBuilder类 \",\"StringBuilder是StringBuffer的非线程安全版本，它的方法没有使用synchronized关键字进行同步\",\"在单线程环境下，使用StringBuilder可以获得更好的性能\",\"在多线程环境下使用StringBuilder，需要自行保证线程安全\",\"使用建议 \",\"操作的数据量较小，可以使用String类\",\"多线程环境下操作大量的数据，需要保证线程安全，可以使用StringBuffer类\",\"单线程环境下操作大量的数据，可以使用StringBuilder类以，性能更好\"]},\"170\":{\"h\":\"String str1 = new String(\\\"abc\\\")和String str2 = \\\"abc\\\" 和 区别？\",\"t\":[\"对象创建过程 \",\"两个语句都会去字符串常量池中检查是否已经存在 “abc”，如果有则直接使用，如果没有则会在常量池中创建 “abc” 对象\",\"String str1 = new String(\\\"abc\\\") 还会通过 new String() 在堆里创建一个\\\"abc\\\" 字符串对象实例\",\"String s = new String(\\\"abc\\\")创建了几个对象？ \",\"一个或两个 \",\"如果字符串常量池已经有“abc”，则是一个；否则，两个\"]},\"171\":{\"h\":\"String不是不可变类吗？字符串拼接是如何实现的？\",\"t\":[\"String的确是不可变的，“+”的拼接操作，其实是会生成新的对象\",\"在jdk1.8之前，那么会生成多个中间对象 \",\"a和b初始化时位于字符串常量池，a+b拼接后的对象位于堆中。经过拼接新生成了String对象。如果拼接多次，那么会生成多个中间对象\",\"在Java8时JDK对“+”号拼接会编译成StringBuilder的append方法\"]},\"172\":{\"h\":\"intern方法有什么作用？\",\"t\":[\"如果当前字符串内容存在于字符串常量池（即equals()方法为true，也就是内容一样），直接返回字符串常量池中的字符串\",\"否则，将此String对象添加到池中，并返回String对象的引用\"]},\"173\":{\"h\":\"Integer a= 127，Integer b = 127；Integer c= 128，Integer d =128；相等吗?\",\"t\":[\"是a和b相等，c和d不相等 \",\"Integer a= 127这种赋值，是用到了Integer自动装箱的机制。自动装箱的时候会去缓存池里取Integer对象，没有取到才会创建新的对象\",\"如果整型字面量的值在-128到127之间，那么自动装箱时不会new新的Integer对象，而是直接引用缓存池中的Integer对象，超过范围 a1==b1的结果是false\",\"什么是Integer缓存？ \",\"因为根据实践发现大部分的数据操作都集中在值比较小的范围，因此 Integer 搞了个缓存池，默认范围是 -128 到 127，可以根据通过设置 JVM-XX:AutoBoxCacheMax=来修改缓存的最大值，最小值改不了\",\"实现的原理是int 在自动装箱的时候会调用Integer.valueOf，进而用到了IntegerCache\",\"IntegerCache是一个静态内部类， 在静态块中会初始化好缓存值\"]},\"174\":{\"h\":\"String怎么转成Integer的？原理？\",\"t\":[\"方法\",\"Integer.parseInt(String s)\",\"Integer.valueOf(String s)\",\"原理\",\"最终都调用parseInt(String s, int radix) 方法\"]},\"175\":{\"h\":\"Object 类的常见方法?\",\"t\":[\"对象比较 \",\"hashCode()\",\"equals(Object obj)\",\"对象拷贝 \",\"clone()\",\"对象转字符串 \",\"toString()\",\"多线程调度 \",\"wait()\",\"wait(long timeout)\",\"wait(long timeout,int nanos)\",\"notify()\",\"notifyAll()\",\"反射 \",\"getClass()\",\"垃圾回收 \",\"finalize\"]},\"176\":{\"h\":\"序列化\"},\"177\":{\"h\":\"什么是序列化？什么是反序列化？\",\"t\":[\"序列化 \",\"把Java对象转为二进制流，方便存储和传输\",\"反序列化 \",\"把二进制流恢复成对象\",\"Serializable接口有什么用？ \",\"用于标识类可以被序列化\",\"实现Serializable接口的类可以将对象转换为字节流进行传输和存储，实现数据的持久化和 跨平台的数据交换\",\"serialVersionUID 又有什么用 \",\"版本控制 \",\"当一个类被序列化后，如果后续对该类进行了修改，例如添加、删除或修改了类的属性、方法等，那么序列化和反序列化时可能会出现版本不一致的问题。为了避免这种问题，可以在类中显式地定义serialVersionUID字段，并确保在类的修改后，serialVersionUID的值保持不变。当反序列化时，会比较序列化类的版本号和当前类的版本号是否一致，如果不一致，则会抛出InvalidClassException异常\",\"兼容性 \",\"当一个类的实例被序列化后，如果在后续的版本中对该类进行了修改，但是仍然希望能够反序列化之前的序列化数据，那么可以通过显式地指定serialVersionUID来保持兼容性。如果新版本的类和旧版本的类具有相同的serialVersionUID，那么即使类的结构发生了变化，仍然可以成功反序列化之前的序列化数据\",\"Java 序列化不包含静态变量 \",\"Java序列化只会保存对象的非静态成员变量，不包含静态变量\",\"静态变量属于类的状态信息，在序列化时不需要保存\",\"如果有些变量不想序列化，怎么办？ \",\"使用 transient 关键字修饰\",\"transient 关键字的作用 \",\"阻止实例中那些用此关键字修饰的的变量序列化\",\"当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复\",\"transient 只能修饰变量，不能修饰类和方法\"]},\"178\":{\"h\":\"说说有哪些常见的序列化方式？\",\"t\":[\"Java对象流序列化 \",\"Java对象流序列化是Java标准库提供的一种序列化方式\",\"通过实现Serializable接口和Externalizable接口来实现对象的序列化和反序列化\",\"Java序列化可以将对象序列化为字节流，也可以将对象序列化为JSON、XML等格式\",\"JSON序列化 \",\"是一种轻量级的数据交换格式，常用于Web应用中\",\"Java中可以使用第三方库，如Jackson、Gson等，将对象序列化为JSON格式，也可以将JSON格式的数据反序列化为Java对象\",\"XML序列化 \",\"XML（Extensible Markup Language）是一种标记语言，常用于Web应用中\",\"Java中可以使用第三方库，如JAXB、XStream等，将对象序列化为XML格式，也可以将XML格式的数据反序列化为Java对象\",\"Protobuf序列化 \",\"Protobuf（Protocol Buffers）是Google开发的一种高效的序列化协议\",\"可以将结构化的数据序列化为紧凑的二进制格式\",\"Java中可以使用Google提供的protobuf-java库，将对象序列化为Protobuf格式，也可以将Protobuf格式的数据反序列化为Java对象\",\"Hessian序列化 \",\"Hessian是一种基于HTTP的轻量级二进制序列化协议\",\"可以将Java对象序列化为二进制格式，并通过HTTP协议进行传输\",\"Java中可以使用第三方库，如Hessian、Dubbo等，将对象序列化为Hessian格式，也可以将Hessian格式\\n的数据反序列化为Java对象\"]},\"179\":{\"h\":\"异常处理\"},\"180\":{\"h\":\"Java 中异常层级结构?\",\"t\":[\"Throwable \",\"Error \",\"内部错误，是程序无法处理的，比如虚拟机异常\",\"Exception \",\"CheckedException \",\"受检异常：编译器会强制检查并要求处理的异常\",\"RuntimeException \",\"运行时异常：程序运行中出现异常，比如我们熟悉的空指针、数组下标越界等等\",\"Exception\"]},\"181\":{\"h\":\"异常的处理机制？\",\"t\":[\"抛出异常 \",\"throw\",\"throws\",\"系统自动抛异常\",\"捕获异常 \",\"try catch\"]},\"182\":{\"h\":\"finally一定会执行吗？\",\"t\":[\"可能不会执行的情况\",\"程序还没有进入try语句块就因为异常导致程序终止\",\"在try块中调用了System.exit()方法：System.exit()方法会终止Java虚拟机的运行，导致程序直接退出，此时finally块中的代码不会执行\",\"在try块中发生了死循环或无限递归：如果try块中的代码导致了无限循环或无限递归，程序将无法继续执行，finally块中的代码也无法执行\",\"在try块中发生了线程死锁：如果try块中的代码导致了线程死锁，程序将无法继续执行，finally块中的代码也无法执行\"]},\"183\":{\"h\":\"三道经典异常处理代码题\",\"t\":[\"题目1：finally中正常执行（执行顺序：先finally，再catch中return）\",\"public static void main(String[] args) { System.out.println(test()); } public static int test() { try { return 1; } catch (Exception e) { return 2; } finally { System.out.print(\\\"3\\\"); } } \",\"执行结果：31\",\"解析：try、catch。finally 的基础用法，在 return 前会先执行 finally 语句块，所以是先输出 finally 里的 3，再输出 return 的 1\",\"题目2：finally中return（按finally中return的为准）\",\"public static void main(String[] args) { System.out.println(test()); } public static int test() { try { return 2; } finally { return 3; } } \",\"执行结果：3\",\"解析：try 返回前先执行 finally，结果 finally 里不按套路出牌，直接 return 了，自然也就走不到 try 里面的 return 了\",\"题目3：finally中修改try中return的值（修改是无效的）\",\"public static void main(String[] args) { System.out.println(test()); } public static int test() { int i = 0; try { i = 2; return i; } finally { i = 3; } } \",\"执行结果：2\",\"在执行 finally 之前，JVM 会先将 i 的结果暂存起来，然后 finally 执行完毕后，会返回之前暂存的结果，而不是返回 i，所以即使 i 已经被修改为 3，最终返回的还是之前暂存起来的结果 2\"]},\"184\":{\"h\":\"泛型\"},\"185\":{\"h\":\"什么是泛型？\",\"t\":[\"用于在编译时期提供类型安全的参数化类型 \",\"Java泛型是Java 5引入的一个特性\",\"通过使用泛型，可以在编写代码时指定类、接口或方法的参数和返回值的类型，从而增加代码的可读性和安全性\"]},\"186\":{\"h\":\"泛型的使用方法？\",\"t\":[\"泛型类\",\"public class ClassName <T> \",\"泛型接口\",\"public interface InterfaceName <T> \",\"泛型方法\",\"public static <T> ReturnType functionName \",\"public <T> ReturnType functionName(T arg) \"]},\"187\":{\"h\":\"泛型常用的通配符有哪些？\",\"t\":[\"?表示不确定的 java 类型\",\"T(type)表示具体的一个 java 类型\",\"K V (key value) 分别代表 java 键值中的 Key Value\",\"E (element) 代表 Element\"]},\"188\":{\"h\":\"什么是泛型擦除？\",\"t\":[\"泛型主要是为了提供编译时类型检查，而在运行时，泛型信息会被擦除，这就是泛型擦除\",\"优点：提高了代码的运行效率和与旧版本 Java 的兼容性（JDK5之前是没有泛型 ）\",\"缺点：在运行时获取泛型类型信息，以及无法使用基本类型作为泛型参数等\"]},\"189\":{\"h\":\"注解\"},\"190\":{\"h\":\"说一下你对注解的理解？\",\"t\":[\"Java注解本质上是一个标记\",\"注解可以标记在类上、方法上、属性上等，标记自身也可以设置一些值\",\"有了标记之后，我们就可以在编译或者运行阶段去识别这些标记，然后搞一些事情，这就是注解的用处\",\"AOP，使用注解作为切点就是运行期注解的应用\",\"lombok，就是注解在编译期的运行\",\"注解生命周期\",\"RetentionPolicy.SOURCE\",\"给编译器用的，不会写入 class 文件\",\"@Target(ElementType.METHOD) @Retention(RetentionPolicy.SOURCE) public @interface Override { } \",\"RetentionPolicy.CLASS\",\"会写入 class 文件，在类加载阶段丢弃，也就是运行的时候就没这个信息了\",\"没找到 \",\"RetentionPolicy.RUNTIME\",\"会写入 class 文件，永久保存，可以通过反射获取注解信息\",\"@Target({ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.PARAMETER, ElementType.FIELD, ElementType.ANNOTATION_TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface Autowired { /** * Declares whether the annotated dependency is required. * <p>Defaults to {@code true}. */ boolean required() default true; } \"]},\"191\":{\"h\":\"集合基础\"},\"192\":{\"h\":\"Java中实现Map接口的有哪些类？\",\"t\":[\"HashMap：基于哈希表实现的Map，无序，允许键和值为null。\",\"LinkedHashMap：基于哈希表和双向链表实现的Map，保持插入顺序或访问顺序。\",\"TreeMap：基于红黑树实现的有序Map，按照键的自然顺序或自定义顺序进行排序。\",\"Hashtable：基于哈希表实现的Map，线程安全，不允许键和值为null。\",\"ConcurrentHashMap：基于哈希表实现的线程安全的Map，支持高并发操作\"]},\"193\":{\"h\":\"遍历HashMap的几种方法？\",\"t\":[\"使用迭代器遍历\",\"使用for-each循环遍历键集合或值集合\",\"使用for-each循环遍历键值对\",\"使用Java 8的Stream API遍历\"]},\"194\":{\"h\":\"面向对象\"},\"195\":{\"h\":\"⾯向对象和⾯向过程的区别?\",\"t\":[\"⾯向过程\",\"面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候再一个一个的一次调用就可以。\",\"⾯向对象\",\"面向对象，把构成问题的事务分解成各个对象，而建立对象的目的也不是为了完成一个个步骤，而是为了描述某个事件在解决整个问题的过程所发生的行为。 目的是为了写出通用的代码，加强代码的重用，屏蔽差异性。\"]},\"196\":{\"h\":\"面向对象有哪些特性?\",\"t\":[\"封装 \",\"封装把⼀个对象的属性私有化，同时提供⼀些可以被外界访问的属性的⽅法\",\"继承 \",\"继承是使⽤已存在的类的定义作为基础创建新的类，新类的定义可以增加新的属性或新的方法，也可以继承父类的属性和方法。通过继承可以很方便地进行代码复用\",\"多态 \",\"所谓多态就是指程序中定义的引⽤变量所指向的具体类型和通过该引⽤变量发出的⽅法调⽤在编程时并不确定，⽽是在程序运⾏期间才确定\",\"即⼀个引⽤变量到底会指向哪个类的实例对象，该引⽤变量发出的⽅法调⽤到底是哪个类中实现的⽅法，必须在由程序运⾏期间才能决定\",\"在 Java 中有两种形式可以实现多态：继承（多个⼦类对同⼀⽅法的重写）和接⼝（实现接⼝并覆盖接⼝中同⼀⽅法）\"]},\"197\":{\"h\":\"重载（overload）和重写（override）的区别？\",\"t\":[\"方法重载和方法重写都是实现多态性的方式\",\"区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性\",\"方法重载\",\"方法名相同，形参不同（参数个数、参数类型、参数顺序满足任一）则视为重载；\",\"与返回值和修饰符无关\",\"调用方法不同，与异常类型更没关系\",\"发生在同一个类中\",\"方法重写\",\"方法名相同，形参相同\",\"基本数据类型相同，若为引用数据类型则返回值为被重写方法的返回值或是其子类\",\"重写方法不能抛出范围更大的受控异常（父类不希望子类出现更多的异常）\",\"重写方法的访问权限可以更广（子类可以扩大方法的访问范围）\",\"发生在具有继承关系的父子类中\"]},\"198\":{\"h\":\"访问修饰符public、private、protected、以及不写（默认）时的 区别?\",\"t\":[\"default (即默认，什么也不写） \",\"在同一包内可见，不使用任何修饰符。可以修饰在类、接口、变量、方法。\",\"private \",\"在同一类内可见。可以修饰变量、方法。\",\"注意：不能修饰外部类\",\"public \",\"对所有类可见。可以修饰类、接口、变量、方法\",\"protected \",\"对同一包内的类和所有子类可见。可以修饰变量、方法。\",\"注意：不能修饰外部类\"]},\"199\":{\"h\":\"this关键字有什么作用？\",\"t\":[\"指向对象本身的一个指针\",\"this的用法在Java中大体可以分为3种 \",\"普通的直接引用，this相当于是指向当前对象本身\",\"形参与成员变量名字重名，用this来区分\",\"引用本类的构造函数\"]},\"200\":{\"h\":\"抽象类(abstract class)和接口(interface)有什么区别？\",\"t\":[\"方法实现 \",\"接口中的方法默认是公开的(public)，只能定义，不能实现。从JDK 8开始，接口中的方法可以有默认实现，而抽象类可以包含非抽象的方法 \",\"如果同时实现两个接口，并且接口中定义了相同的默认方法，则必须重写方法，否则会报错\",\"在JDK 8中，接口也可以定义静态方法，并且可以直接使用接口名调用 \",\"实现类和实例不能调用静态方法\",\"JDK 9允许在接口中定义私有方法\",\"变量 \",\"接口中只能包含静态(static)和常量(final)变量，不能有其他类型的变量。而抽象类中可以包含任意类型的变量\",\"实现 \",\"一个类可以实现多个接口，但只能继承一个抽象类。接口自身可以通过extends关键字扩展多个接口\",\"方法修饰符 \",\"接口中的方法默认修饰符是public，抽象方法可以有public、protected和default修饰符。抽象方法是为了被重写，所以不能使用private修饰符\",\"设计层面 \",\"抽象类是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为规范\"]},\"201\":{\"h\":\"成员变量与局部变量的区别有哪些？\",\"t\":[\"成员变量 = 实例变量 + 静态变量（类变量）\",\"语法形式 \",\"成员变量是在类中声明的变量，可以被public、private、static等修饰符所修饰\",\"成员变量包括实例变量和静态变量（类变量） \",\"实例变量是每个对象独有的，而静态变量是类共享的\",\"局部变量是在方法中或代码块中声明的变量，不能被访问控制修饰符及static所修饰\",\"存储方式 \",\"实例变量存储在堆内存中\",\"静态变量存储在方法区（元空间）的静态存储区，所有对象共享同一份静态变量的拷贝\",\"局部变量存在栈内存中，随着方法或代码块的执行而创建和销毁\",\"生存周期 \",\"静态变量在类被加载至数据区后，只有当程序结束时才会被销毁，它的生命周期与程序的生命周期相同。\",\"实例变量即对象变量，随对象的创建而生，随对象的销毁而销毁\",\"局部变量只在方法或代码块内有效，一旦超出这个范围就不再有效\",\"默认值 \",\"非final修饰的成员变量具有默认值，而局部变量没有默认值\",\"成员变量的默认值根据其类型而定，例如整型默认为0，布尔型默认为false，引用类型默认为null\",\"局部变量在使用前必须显式地进行初始化\"]},\"202\":{\"h\":\"静态变量和实例变量的区别？静态方法、实例方法呢？\",\"t\":[\"静态变量 \",\"是被 static 修饰符修饰的变量，也称为类变量，它属于类，不属于类的任何一个对象，一个类不管创建多少个对象，静态变量在内存中有且仅有一个副本\",\"实例变量 \",\"必须依存于某一实例，需要先创建对象然后通过对象才能访问到它。静态变量可以实现让多个对象共享内存\",\"静态方法 \",\"static修饰的方法，也被称为类方法\",\"在外部调⽤静态⽅法时，可以使⽤\\\"类名.⽅法名\\\"的⽅式，也可以使⽤\\\"对象名.⽅法名\\\"的⽅式\",\"静态方法里不能访问类的非静态成员变量和方法\",\"实例⽅法 \",\"依存于类的实例\",\"需要使用\\\"对象名.⽅法名\\\"的⽅式调用\",\"可以访问类的所有成员变量和方法\"]},\"203\":{\"h\":\"final关键字有什么作用？\",\"t\":[\"被final修饰的类不可以被继承\",\"被final修饰的方法不可以被重写\",\"被final修饰的变量不可变，被final修饰的变量必须被显式第指定初始值 \",\"这里的不可变指的是变量的引用不可变，不是引用指向的内容的不可变\"]},\"204\":{\"h\":\"final、finally、finalize的区别？\",\"t\":[\"final 用于修饰变量、方法和类 \",\"final修饰的类不可被继承\",\"修饰的方法不可被重写\",\"修饰的变量不可变\",\"在 try/catch 语句中，最终一定被执行 \",\"经常被用在需要释放资源的情况下\",\"System.exit (0) 可以阻断 finally 执行\",\"finalize 是在 java.lang.Object 里定义的方法 \",\"这个方法在 gc 启动，该对象被回收的时候被调用\",\"一个对象的 finalize 方法只会被调用一次，finalize 被调用不一定会立即回收该对象 \",\"不推荐使用 \",\"有可能调用 finalize 后，该对象又不需要被回收了，然后到了真正要被回收的时候，因为前面调用过一次，所以不会再次调用 finalize 了，进而产生问题，因此不推荐使用 finalize 方法\"]},\"205\":{\"h\":\"==和 equals 的区别？\",\"t\":[\"== \",\"判断两个对象是不是同⼀个对象 \",\"基本数据类型==比较的是值\",\"引⽤数据类型==比较的是内存地址\",\"equals() \",\"判断两个对象是否相等\",\"默认情况类没有覆盖 equals() ⽅法，等价于通过“ == ”比较这两个对象\"]},\"206\":{\"h\":\"hashCode与 equals?\",\"t\":[\"什么是HashCode？ \",\"hashCode方法用于获取对象的哈希码，哈希码是一个整数，用来表示对象的唯一标识\",\"哈希码常用于哈希表等数据结构的实现中，可以快速定位对象\",\"为什么重写 quals 时必须重写 hashCode ⽅法？ \",\"这是Java的规定，主要目的是确保 Java 中的集合类（例如 HashMap、HashSet 等）能够正确地工作并保持一致性 \",\"对象相等性原则 \",\"如果两个对象根据 equals() 方法判断相等，则它们的 hashCode() 方法的返回值必须相等\",\"hashCode() 的默认⾏为是对堆上的对象产⽣独特值。如果没有重写 hashCode() ，则该class 的两个对象⽆论如何都不会相等（即使这两个对象指向相同的数据）\"]},\"207\":{\"h\":\"Java是值传递，还是引用传递？\",\"t\":[\"Java语言是值传递 \",\"当传递基本数据类型（如int、float、boolean等）时 \",\"传递的是该值的副本，对形参的修改不会影响实参\",\"当传递对象引用时 \",\"传递的是该引用的副本，而不是对象本身。因此，对形参引用的修改不会影响实参引用的指向，但可以通过引用修改对象的状态\"]},\"208\":{\"h\":\"什么是深拷贝和浅拷贝?\",\"t\":[\"浅拷贝 \",\"仅拷贝被拷贝对象的成员变量的值，也就是基本数据类型变量的值，和引用数据类型变量的地址值，而对于引用类型变量指向的堆中的对象不会拷贝。\",\"深拷贝 \",\"完全拷贝一个对象，拷贝被拷贝对象的成员变量的值，堆中的对象也会拷贝一份\",\"深拷贝是安全的 \",\"浅拷贝的话如果有引用类型，那么拷贝后对象，引用类型变量修改，会影响原对象\",\"浅拷贝如何实现呢？ \",\"Object类提供的clone()方法可以非常简单地实现对象的浅拷贝\",\"深拷贝如何实现呢？ \",\"重写克隆方法 \",\"重写克隆方法，引用类型变量单独克隆，这里可能会涉及多层递归\",\"序列化 \",\"可以先讲原对象序列化，再反序列化成拷贝对象\"]},\"209\":{\"h\":\"Java 创建对象有哪几种方式？\",\"t\":[\"new创建新对象\",\"通过反射机制\",\"采用clone机制\",\"通过序列化机制 \",\"Java中序列化可以通过实现Externalizable或者Serializable来实现\",\"或者使用json序列化\"]},\"210\":{\"h\":\"Java内存模型\"},\"211\":{\"h\":\"说一下你对Java内存模型（JMM）的理解 ？\",\"t\":[\"Java内存模型（Java Memory Model，JMM），是一种抽象的模型，被定义出来屏蔽各种硬件和操作系统的内存访问差异\",\"JMM定义了线程和主内存之间的抽象关系\",\"线程之间的共享变量存储在 主内存（Main Memory）中，每个线程都有一个私有的 本地内存 （Local Memory），本地内存中存储了该线程以读/写共享变量的副本 \",\"Java内存模型的抽象图\",\"本地内存是JMM的 一个抽象概念，并不真实存在，实际的线程工作模型如下图所示，其中每个线程都有自己的控制器和运算器，以及一级缓存。有些架构还有一个共享的二级缓存。这些硬件组件对应着JMM中的工作内存\",\"Java内存模型通过定义内存间的交互操作规则，例如读取、写入和同步操作，来确保多线程程序的可见性、有序性和原子性。\"]},\"212\":{\"h\":\"说说你对原子性、可见性、有序性的理解？\",\"t\":[\"原子性、有序性、可见性是并发编程中非常重要的基础概念，用于描述多线程环境下的内存访问行为，JMM的很多技术都是围绕着这三大特性展开\",\"原子性（Atomicity） \",\"原子性是指一个操作是不可分割的，要么完全执行，要么不执行。\",\"在多线程环境下，原子性保证了对共享变量的操作是原子的，不会被其他线程中断\",\"可见性（Visibility） \",\"可见性是指当一个线程对共享变量进行修改后，其他线程能够立即看到这个修改\",\"在多线程环境下，由于每个线程都有自己的本地内存，线程之间对共享变量的修改不一定能够及时同步到主内存和其他线程的本地内存中\",\"可见性保证了共享变量的修改对其他线程是可见的，即能够正确读取到最新的值\",\"有序性（Ordering） \",\"是指程序执行的顺序与代码的顺序一致\",\"在多线程环境下，由于指令重排序和编译器优化的存在，代码的执行顺序可能与代码的编写顺序不一致\",\"序性保证了程序的执行顺序与代码的顺序一致，即保证了代码的串行语义\",\"为了保证原子性、可见性和有序性，我们可以使用同步机制（如锁、volatile关键字、synchronized关键字等）来控制线程的访问和操作\"]},\"213\":{\"h\":\"分析下面几行代码的原子性？\",\"t\":[\"int i = 2; int j = i; i++; i = i + 1; \",\"第1句是基本类型赋值，是原子性操作\",\"第2句先读i的值，再赋值到j，两步操作，不能保证原子性\",\"第3和第4句其实是等效的，先读取i的值，再+1，最后赋值到i，三步操作了，不能保证原子性\"]},\"214\":{\"h\":\"原子性、可见性、有序性都应该怎么保证呢？\",\"t\":[\"原子性 \",\"使用同步机制，如synchronized关键字、Lock接口、Atomic类等，来控制对共享变量的访问和操作，确保操作是不可分割的\",\"可见性 \",\"使用volatile关键字或者同步机制，如synchronized关键字、Lock接口等，来保证对共享变量的修改对其他线程是可见的\",\"有序性 \",\"使用volatile关键字或者同步机制，如synchronized关键字、Lock接口等，来保证程序执行的顺序与代码的顺序一致\"]},\"215\":{\"h\":\"那说说什么是指令重排？\",\"t\":[\"在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排序\",\"重排序分3种类型 \",\"编译器优化的重排序 \",\"编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序\",\"指令级并行的重排序 \",\"现代处理器采用了指令级并行技术（Instruction-Level Parallelism，ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应 机器指令的执行顺序\",\"内存系统的重排序 \",\"由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行\",\"双重校验单例模式就是一个经典的指令重排的例子：Singleton instance=new Singleton() \",\"对应的JVM指令分为三步：分配内存空间-->初始化对象--->对象指向分配的内存空间\",\"经过了编译器的指令重排序，第二步和第三步就可能会重排序\",\"JMM属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证\"]},\"216\":{\"h\":\"指令重排有限制吗？happens-before了解吗？\",\"t\":[\"指令重排也是有一些限制的，有两个规则 happens-before 和 as-if-serial 来约束\",\"happens-before的定义 \",\"如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前\",\"两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照 happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么这种重排序并不非法\",\"happens-before和我们息息相关的有六大规则 \",\"程序顺序规则 \",\"一个线程中的每个操作，happens-before于该线程中的任意后续操作\",\"监视器锁规则 \",\"对一个锁的解锁，happens-before于随后对这个锁的加锁\",\"volatile变量规则 \",\"对一个volatile域的写，happens-before于任意后续对这个volatile域的读\",\"传递性 \",\"如果A happens-before B，且B happens-before C，那么A happens-beforeC\",\"start()规则 \",\"如果线程A执行操作ThreadB.start()（启动线程B），那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作\",\"join()规则 \",\"如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作 happens-before于线程A从ThreadB.join()操作成功返回\"]},\"217\":{\"h\":\"as-if-serial又是什么？单线程的程序一定是顺序的吗？\",\"t\":[\"as-if-serial语义的意思是：不管怎么重排序（编译器和处理器为了提高并行度），单线程程序的执行结果不能被改变\",\"编译器、runtime和处理器都必须遵守as-if-serial语义\",\"为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果\",\"如果操作之间不存在数据依赖关系，这些操作就可能被编译器和处理器重排序\"]},\"218\":{\"h\":\"volatile实现原理了解吗？\",\"t\":[\"volatile有两个作用，保证可见性和有序性\"]},\"219\":{\"h\":\"volatile怎么保证可见性的呢？\",\"t\":[\"相比synchronized的加锁方式来解决共享变量的内存可见性问题，volatile就是更轻量的选择，它没有上下文切换的额外开销成本\",\"volatile可以确保对某个变量的更新对其他线程马上可见 \",\"一个变量被声明为volatile时，线程在写入变量时不会把值缓存在寄存器或者其他地方，而是会把值刷新回主内存\",\"当其它线程读取该共享变量 ，会从主内存重新获取最新值，而不是使用当前线程的本地内存中的值\"]},\"220\":{\"h\":\"volatile怎么保证有序性的呢？\",\"t\":[\"重排序可以分为编译器重排序和处理器重排序，valatile保证有序性，就是通过分别限制这两种类型的重排序\",\"为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序 \",\"在每个volatile写操作的前面插入一个 StoreStore 屏障 \",\"功能：确保在屏障前的所有写操作（存储操作）都在屏障后的写操作之前被刷新到主内存中。即确保第一个存储操作的结果对后续的存储操作可见。\",\"在每个volatile写操作的后面插入一个 StoreLoad 屏障 \",\"确保在屏障前的所有写操作在屏障后的所有读操作（加载操作）之前被刷新到主内存中。即防止写操作重排序到读操作之后\",\"在每个volatile读操作的后面插入一个 LoadLoad 屏障 \",\"功能：确保在屏障前的所有读操作都完成之后，再进行屏障后的读操作。即确保第一个加载操作的结果对后续的加载操作可见。\",\"在每个volatile读操作的后面插入一个 LoadStore 屏障 \",\"功能：确保在屏障前的所有读操作都完成之后，再进行屏障后的写操作。即防止读操作重排序到写操作之后\",\"​\"]},\"221\":{\"h\":\"ThreadLocal\"},\"222\":{\"h\":\"ThreadLocal是什么？\",\"t\":[\"ThreadLocal，也就是线程本地变量\",\"创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的一个本地拷贝\",\"多个线程操作这个变量的时候，实际是操作自己本地内存里面的变量，从而起到线程隔离的作用，避免了线程 安全问题\",\"创建\",\"创建了一个ThreadLoca变量localVariable，任何一个线程都能并发访问localVariable。\",\"//创建一个ThreadLocal变量 public static ThreadLocal<String> localVariable = new ThreadLocal<>(); \",\"写入\",\"线程可以在任何地方使用localVariable，写入变量\",\"localVariable.set(\\\"鄙人张三”); \",\"读取\",\"线程在任何地方读取的都是它写入的变量。\",\" localVariable.get(); \"]},\"223\":{\"h\":\"你在工作中用到过ThreadLocal吗？\",\"t\":[\"用来做用户信息上下文的存储 \",\"存放token\"]},\"224\":{\"h\":\"ThreadLocal怎么实现的呢？\",\"t\":[\"Thread类有一个类型为ThreadLocal.ThreadLocalMap的实例变量threadLocals，每个线程都有一个属于自己的ThreadLocalMap\",\"ThreadLocalMap内部维护着Entry数组，每个Entry代表一个完整的对象，key是ThreadLocal的弱引用，value是ThreadLocal的泛型值\",\"每个线程在往ThreadLocal里设置值的时候，都是往自己的ThreadLocalMap里存，读也是以某个ThreadLocal作为引用，在自己的map里找对应的key，从而实现了线程隔离\",\"ThreadLocal本身不存储值，它只是作为一个key来让线程往ThreadLocalMap里存取值\"]},\"225\":{\"h\":\"ThreadLocal 内存泄露是怎么回事？\",\"t\":[\"ThreadLocalMap中使用的 key 为 ThreadLocal 的弱引用 \",\"弱引用：只要垃圾回收机制一运行，不管JVM的内存空间是否充足，都会回收该对象占用的内存。\",\"弱引用很容易被回收，如果ThreadLocal（ThreadLocalMap的Key）被垃圾回收器回收了，但是ThreadLocalMap生命周期和Thread是一样的，它这时候如果不被回收，就会出现这种情况：ThreadLocalMap的key没了，value还在，这 就会造成了内存泄漏问题\"]},\"226\":{\"h\":\"那怎么解决内存泄漏问题呢？\",\"t\":[\"使用完ThreadLocal后，及时调用remove()方法释放内存空间\"]},\"227\":{\"h\":\"为什么key还要设计成弱引用？\",\"t\":[\"key设计成弱引用同样是为了防止内存泄漏问题 \",\"在ThreadLocal中，每个ThreadLocal实例都对应着一个ThreadLocalMap对象，而ThreadLocalMap使用ThreadLocal实例作为键，用于存储线程局部变量的值。\",\"如果将ThreadLocal实例作为强引用存储在ThreadLocalMap中，那么即使线程不再使用某个ThreadLocal实例，该实例也无法被垃圾回收，从而可能导致内存泄漏\"]},\"228\":{\"h\":\"ThreadLocalMap的结构了解吗？\",\"t\":[\"元素数组\",\"一个table数组，存储Entry类型的元素，Entry是ThreaLocal弱引用作为key，Object作为value的结构\",\"private Entry[] table \",\"散列方法\",\"散列方法就是怎么把对应的key映射到table数组的相应下标，ThreadLocalMap用的是哈希取余法，取出key的threadLocalHashCode，然后和table数组长度减一&运算（相当于取余）\",\"int i = key.threadLocalHashCode & (table.length - 1); \",\"这里的threadLocalHashCode计算有点东西，每创建一个ThreadLocal对象，它就会新增 0x61c88647\",\"这个值很特殊，它是斐波那契数 也叫 黄金分割数\",\"hash 增量为 这个数字，带来的好处就是 hash 分布非常均匀\",\"private static final int HASH_INCREMENT = 0x61c88647; private static int nextHashCode() { return nextHashCode.getAndAdd(HASH_INCREMENT); } \"]},\"229\":{\"h\":\"ThreadLocalMap怎么解决Hash冲突的？\",\"t\":[\"开放定址法\",\"简单来说，就是这个坑被人占了，那就接着去找空着的坑，往后找一圈没找到就会从头开始找\",\"如上图所示，如果我们插入一个value=27的数据，通过 hash计算后应该落入第 4 个槽位中，而槽位 4 已经有了 Entry数据，而且Entry数据的key和当前不相等。此时就会线性向后查找，一直找到 Entry为 null的槽位才会停止查找，把元素放到空的槽中\",\"在get的时候，也会根据ThreadLocal对象的hash值，定位到table中的位置，然后判断该槽位Entry对象中的key是否和get的key一致，如果不一致，就判断下一个位置\"]},\"230\":{\"h\":\"ThreadLocalMap扩容机制了解吗？\",\"t\":[\"rehash()时机\",\"在ThreadLocalMap.set()方法的最后，如果执行完启发式清理工作后，未清理到任何数据，且当前散列数组中 Entry 的数量已经达到了列表的扩容阈值 (len*2/3) ，就开始执行 rehash() 逻辑\",\"if (!cleanSomeSlots(i, sz) && sz >= threshold) rehash(); \",\"rehash\",\"会先去清理过期的Entry\",\"然后还要根据条件判断size >= threshold - threshold / 4 也就是 size >= threshold* 3/4 来决定是否需要扩容\",\"private void rehash() { //清理过期Entry expungeStaleEntries(); // Use lower threshold for doubling to avoid hysteresis if (size >= threshold - threshold / 4) resize(); } \",\"resize\",\"扩容后的 newTab 的大小为老数组的两倍\",\"然后遍历老的table数组，散列方法重新计算位置\",\"开放地址解决冲突，然后放到新的newTab ，遍历完成之后， oldTab 中所有的 entry 数据都已经放入到 newTab 中了，然后table引用指向 newTab\",\" private void resize() { Entry[] oldTab = table; int oldLen = oldTab.length; int newLen = oldLen * 2; Entry[] newTab = new Entry[newLen]; int count = 0; for (Entry e : oldTab) { if (e != null) { ThreadLocal<?> k = e.get(); if (k == null) { e.value = null; // Help the GC } else { int h = k.threadLocalHashCode & (newLen - 1); while (newTab[h] != null) h = nextIndex(h, newLen); newTab[h] = e; count++; } } } setThreshold(newLen); size = count; table = newTab; } \"]},\"231\":{\"h\":\"父子线程怎么共享数据？\",\"t\":[\"InheritableThreadLocal\",\"在主线程的InheritableThreadLocal实例设置值，在子线程中就可以拿到了\",\"public class InheritableThreadLocalTest { public static void main(String[] args) { final ThreadLocal threadLocal = new InheritableThreadLocal(); // 主线程 threadLocal.set(\\\"不擅技术\\\"); //子线程 Thread t = new Thread() { @Override public void run() { super.run(); System.out.println(\\\"鄙人三某 ，\\\" + threadLocal.get()); } }; t.start(); } } \"]},\"232\":{\"h\":\"InheritableThreadLocal原理是什么呢？\",\"t\":[\"原理很简单，在Thread类里还有另外一个变量\",\"ThreadLocal.ThreadLocalMap inheritableThreadLocals = null; \",\"在Thread的构造函数中，如果父线程的 inheritableThreadLocals 不为空，就把它赋给当前线程（子线程）的 inheritableThreadLocals\",\" // thread locals if (!attached) { if ((characteristics & NO_INHERIT_THREAD_LOCALS) == 0) { ThreadLocal.ThreadLocalMap parentMap = parent.inheritableThreadLocals; if (parentMap != null && parentMap.size() > 0) { //从父线程中取出inheritableThreadLocals this.inheritableThreadLocals = ThreadLocal.createInheritedMap(parentMap); } if (VM.isBooted()) { this.contextClassLoader = contextClassLoader(parent); } } else if (VM.isBooted()) { // default CCL to the system class loader when not inheriting this.contextClassLoader = ClassLoader.getSystemClassLoader(); } } \"]},\"233\":{\"h\":\"还有什么其它办法？TTL？\",\"t\":[\"TransmittableThreadLocal（TTL） \",\"是阿里巴巴开源的基于 InheritableThreadLocal 的增强版\",\"解决了线程池等场景下InheritableThreadLocal 的值传递问题\",\"TTL通过重写 ThreadLocal 的方法和使用特定的数据结构，确保子线程能够正确获取父线程最新的值\",\"它还提供了自定义初始化方法和支持传递不可序列化对象的功能\"]},\"234\":{\"h\":\"基础\"},\"235\":{\"h\":\"并行跟并发有什么区别？\",\"t\":[\"并行就是同一时刻，两个线程都在执行。这就要求有两个CPU去分别执行两个线程\",\"并发就是同一时刻，只有一个执行，但是一个时间段内，两个线程都执行了 \",\"并发的实现依赖于CPU切换线程，因为切换的时间特别短，所以基本对于用户是无感知的\"]},\"236\":{\"h\":\"说说什么是进程和线程？\",\"t\":[\"进程 \",\"进程是代码在数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位\",\"一个进程中有多个线程，多个线程共用进程的堆和方法区资源\",\"线程 \",\"线程是进程的一个执行路径，一个进程中至少有一个线程，进程中的多个线程共享进程的资源\",\"每个线程有自己的程序计数器和栈\"]},\"237\":{\"h\":\"说说线程有几种创建方式？\",\"t\":[\"继承Thread类 \",\"继承Thread类，重写run()方法，调用start()方法启动线程\",\"实现Runnable接口 \",\"实现 Runnable 接口，重写run()方法\",\"实现Callable接口 \",\"实现Callable接口，重写call()方法，这种方式可以通过FutureTask获取任务执行的返回值\"]},\"238\":{\"h\":\"为什么调用start()方法时会执行run()方法，那怎么不直接调用run()方法？\",\"t\":[\"JVM执行start方法，会先创建一条线程，由创建出来的新线程去执行thread的run方法，这才起到多线程的效果\",\"为什么我们不能直接调用run()方法？ \",\"如果直接调用Thread的run()方法，那么run方法还是运行在主线程中，相当于顺序执行，就起不到多线程的效果\"]},\"239\":{\"h\":\"Thread和Runnable有什么区别？\",\"t\":[\"特点\",\"Thread\",\"Runnable\",\"继承关 系\",\"是一个类\",\"是一个接口\",\"代码复 用\",\"不方便，每个线程需要创建新实 例\",\"方便，多个线程可以共享同一实 例\",\"灵活性\",\"相对较低，只能继承Thread类\",\"相对较高，可以与其他接口组合\",\"可控性\",\"相对较低，需要手动管理线程\",\"相对较高，可以通过线程池管理\",\"Thread类适合直接创建新线程\",\"而Runnable接口适合定义线程要执行的任务，并可以与其他接口组合使用\"]},\"240\":{\"h\":\"线程有哪些常用的调度方法？\",\"t\":[\"线程等待与通知 \",\"Object类方法 \",\"wait() \",\"当一个线程A调用一个共享变量的 wait()方法时， 线程A会被阻塞挂起，发生下面几种情况才会返回\",\"其他线程调用了线程A共享对象 notify()或者 notifyAll()方法\",\"其他线程调用了线程A的 interrupt() 方法，线程A抛出InterruptedException异常返回\",\"wait(long timeout) \",\"这个方法相比 wait() 方法多了一个超时参数\",\"在等待时间内没有其他线程调用相同对象的 notify() 或 notifyAll() 方法唤醒它，或者等待时间到期，线程会被自动唤醒，并且重新尝试获取对象的锁\",\"如果等待时间到期而线程没有获取到锁，则线程会被唤醒，但是它不会重新尝试获取锁。相反，它会在等待队列中等待，直到其他线程通过 notify() 或 notifyAll() 方法唤醒它，并且在获取锁之前，线程是不会继续执行的\",\"wait(long timeout, int nanos)\",\"其内部调用的是 wait(long timout）函数\",\"notify() \",\"一个线程A调用共享对象的 notify() 方法后，会唤醒一个在这个共享变量上调用 wait 系列方法后被挂起的线程。 一个共享变量上可能会有多个线程在等待，具体唤醒哪个等待的线程是随机的\",\"notifyAll() \",\"不同于在共享变量上调用 notify() 函数会唤醒被阻塞到该共享变量上的一个线程，notifyAll()方法则会唤醒所有在该共享变量上由于调用 wait 系列方法而被挂起的线程\",\"Thread类的方法 \",\"join() \",\"如果一个线程A执行了thread.join()语句，其含义是：当前线程A等待thread线程终止之后从thread.join()返回\",\"线程休眠 \",\"sleep(long millis) \",\"Thread类中的静态方法\",\"当一个执行中的线程A调用了Thread的sleep方法后，线程A会暂时让出指定时间的执行权\",\"但是线程A所拥有的监视器资源，比如锁还是持有不让出的\",\"指定的睡眠时间到了后该函数会正常返回，接着参与 CPU 的调度，获取到 CPU 资源后就可以继续运行\",\"让出优先权 \",\"yield() \",\"Thread类中的静态方法\",\"当一个线程调用 yield 方法时，实际就是在暗示线程调度器当前线程请求让出自己的CPU ，但是线程调度器可以无条件忽略这个暗示\",\"线程中断 \",\"定义 \",\"Java 中的线程中断是一种线程间的协作模式\",\"通过设置线程的中断标志并不能直接终止该线程的执行，而是被中断的线程根据中断状态自行处理\",\"方法 \",\"void interrupt() \",\"中断线程\",\"例如，当线程A运行时，线程B可以调用线程interrupt() 方法来设置线程的中断标志为true 并立即返回\",\"线程A实际并没有被中断， 会继续往下执行\",\"boolean isInterrupted() \",\"检测当前线程是否被中断\",\"boolean interrupted() \",\"检测当前线程是否被中断，与 isInterrupted 不同的是，该方法如果发现当前线程被中断，则会清除中断标志\"]},\"241\":{\"h\":\"线程有几种状态？\",\"t\":[\"线程共有六种状态\",\"状态\",\"说明\",\"NEW\",\"初始状态：线程被创建，但还没有调用start()方法\",\"RUNNABLE\",\"运行状态：Java线程将操作系统中的就绪和运行两种状态笼 统的称作“运行”\",\"BLOCKED\",\"阻塞状态：表示线程阻塞于锁\",\"WAITING\",\"等待状态：表示线程进入等待状态，进入该状态表示当前线 程需要等待其他线程做出一些特定动作（通知或中断）\",\"TIME_WAITING\",\"超时等待状态：该状态不同于 WAITIND，它是可以在指定 的时间自行返回的\",\"TERMINATED\",\"终止状态：表示当前线程已经执行完毕\"]},\"242\":{\"h\":\"BLOCKED和WAITING有什么区别？\",\"t\":[\"BLOCKED状态表示线程被阻塞，无法继续执行，通常是因为等待获取锁\",\"WAITING状态表示线程正在等待其他线程的通知，通常是因为调用了wait()方法、join()方法或LockSupport.park()方法\",\"这两种状态的区别在于阻塞状态是等待获取锁，而等待状态是等待其他线程的通知或中断\"]},\"243\":{\"h\":\"WAITING和TERMINATED有什么区别？\",\"t\":[\"WAITING状态表示线程在等待其他线程的通知或中断\",\"而TERMINATED状态表示线程已经执行完毕，不再执行任何代码\",\"WAITING状态是暂时的，可以再次进入RUNNABLE状态，而TERMINATED状态是永久的，线程不会再进入任何状态\"]},\"244\":{\"h\":\"什么是线程上下文切换？\",\"t\":[\"线程上下文切换是指在多线程环境下，CPU 从一个线程转而执行另一个线程的过程。\",\"在这个过程中，操作系统会保存当前线程的上下文（包括寄存器状态、程序计数器、堆栈指针等信息），然后恢复下一个线程的上下文，以便该线程可以继续执行。\",\"线程上下文切换是一种非常耗时的操作，因为操作系统需要保存和恢复线程的上下文信息。因此，在编写多线程应用程序时，应尽量减少线程上下文切换的次数，以提高系统的性能和效率\"]},\"245\":{\"h\":\"线程上下文切换通常发生在以下几种情况下\",\"t\":[\"当一个线程的时间片用完时，操作系统会强制进行线程上下文切换，将 CPU 时间片分配给另一个处于就绪状态的线程。\",\"当一个线程因为等待某些事件（如I/O操作、锁的释放等）而被阻塞时，操作系统会将 CPU 时间片分配给另一个处于就绪状态的线程\",\"当一个线程调用了 yield() 方法主动放弃 CPU 时间片时，操作系统会将 CPU 时间片分配给另一个处于就绪状态的线程\"]},\"246\":{\"h\":\"守护线程了解吗？\",\"t\":[\"Java中的线程分为两类，分别为 daemon 线程（守护线程）和 user 线程（用户线程）\",\"在JVM 启动时会调用 main 函数，main函数所在的钱程就是一个用户线程\",\"其实在JVM 内部同时还启动了很多守护线程， 比如垃圾回收线程\",\"那么守护线程和用户线程有什么区别呢 ？ \",\"是当最后一个非守护线程束时，JVM会正常退出，而不管当前是否存在守护线程，也就是说守护线程是否结束并不影响 JVM退出\"]},\"247\":{\"h\":\"线程间有哪些通信方式？\",\"t\":[\"volatile和synchronized关键字 \",\"关键字volatile可以用来修饰字段（成员变量），就是告知程序任何对该变量的访问均需要从共享内存中获取，而对它的改变必须同步刷新回共享内存，它能保证所有线程对变量访问的可见性\",\"关键字synchronized可以修饰方法或者以同步块的形式来进行使用，它主要确保多个线程在同一个时刻，只能有一个线程处于方法或者同步块中，它保证了线程对变量访问的可见性和排他性\",\"等待/通知机制 \",\"可以通过Java内置的等待/通知机制（wait()/notify()）实现一个线程修改一个对象的值，而另一个线程感知到了变化，然后进行相应的操作\",\"管道输入/输出流 \",\"管道输入/输出流和普通的文件输入/输出流或者网络输入/输出流不同之处在于，它主要用于线程之间的数据传输，而传输的媒介为内存\",\"管道输入/输出流主要包括了如下4种具体实现 \",\"PipedOutputStream、PipedInputStream、 PipedReader和PipedWriter，前两种面向字节，而后两种面向字 符\",\"使用Thread.join() \",\"如果一个线程A执行了thread.join()语句，其含义是：当前线程A等待thread线程终止之后才从thread.join()返回\",\"线程Thread除了提供join()方法之外，还提供了join(long millis)和join(long millis,int nanos)两个具备超时特性的方法\",\"使用ThreadLocal（线程内 ） \",\"ThreadLocal，即线程变量，是一个以ThreadLocal对象为键、任意对象为值的存储结构\",\"这个结构被附带在线程上，也就是说一个线程可以根据一个ThreadLocal对象查询到绑定在这个线程上的一个值\"]},\"248\":{\"h\":\"并发工具类\"},\"249\":{\"h\":\"CountDownLatch（倒计数器）了解吗？\",\"t\":[\"CountDownLatch，倒计数器，有两个常见的应用场景\",\"场景1：协调子线程结束动作：等待所有子线程运行结束\",\"public static void main(String[] args) throws InterruptedException { CountDownLatch countDownLatch = new CountDownLatch(5); Thread 大乔 = new Thread(countDownLatch::countDown); Thread 兰陵王 = new Thread(countDownLatch::countDown); Thread 安其拉 = new Thread(countDownLatch::countDown); Thread 哪吒 = new Thread(countDownLatch::countDown); Thread 铠 = new Thread(() -> { try { // 稍等，上个卫生间，马上到... Thread.sleep(1500); countDownLatch.countDown(); } catch (InterruptedException ignored) { } }); 大乔.start(); 兰陵王.start(); 安其拉.start(); 哪吒.start(); 铠.start(); countDownLatch.await(); System.out.println(\\\"所有玩家已经就位！\\\"); } \",\"子线程使用countDownLatch.countDown()进行倒数计数\",\"主线程使用countDownLatch.await()进行阻塞，等待子线程完成\",\"场景2：协调子线程开始动作：统一各线程动作开始的时机\",\" public static void main(String[] args) throws InterruptedException { CountDownLatch countDownLatch = new CountDownLatch(1); Thread 大乔 = new Thread(() -> waitToFight(countDownLatch)); Thread 兰陵王 = new Thread(() -> waitToFight(countDownLatch)); Thread 安其拉 = new Thread(() -> waitToFight(countDownLatch)); Thread 哪吒 = new Thread(() -> waitToFight(countDownLatch)); Thread 铠 = new Thread(() -> waitToFight(countDownLatch)); 大乔.start(); 兰陵王.start(); 安其拉.start(); 哪吒.start(); 铠.start(); Thread.sleep(1000); countDownLatch.countDown(); System.out.println(\\\"敌方还有5秒达到战场，全军出击！\\\"); } private static void waitToFight(CountDownLatch countDownLatch) { try { countDownLatch.await(); // 在此等待信号再继续 System.out.println(\\\"收到，发起进攻！\\\"); } catch (InterruptedException e) { e.printStackTrace(); } } \",\"子线程使用countDownLatch.await()进行阻塞，等待主线程完成\",\"主线程使用countDownLatch.countDown()进行倒数计数\",\"CountDownLatch的核心方法\",\"await() ：等待latch降为0\",\"boolean await(long timeout, TimeUnit unit) ：等待latch降为0，但是可以设置超时时间。比如有玩家超时未确认，那就重新匹配，总不能为了某个玩家等到天荒地老\",\"countDown() ：latch数量减1\",\"getCount() ：获取当前的latch数量\"]},\"250\":{\"h\":\"CyclicBarrier（同步屏障）了解吗？\",\"t\":[\"CyclicBarrier的字面意思是可循环使用（Cyclic）的屏障（Barrier）\",\"它要做的事情是，让一 组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行\",\"它和CountDownLatch类似，都可以协调多线程的结束动作，在它们结束后都可以执行特定动作\"]},\"251\":{\"h\":\"重要注意事项\",\"t\":[\"线程中断：如果某个线程在等待时被中断，会抛出 InterruptedException，此时其他线程也会收到 BrokenBarrierException 并继续执行。\",\"重用性：CyclicBarrier 可以重复使用，当所有等待线程都被释放后，屏障会自动重置，可以再次使用。\",\"异常处理：需要处理可能的 BrokenBarrierException 和 TimeoutException（如果使用带超时参数的 await 方法）。\",\"核心方法await()：\",\"使线程在屏障点等待，直到所有线程都到达。如果当前线程是最后一个到达的线程，则会放行，往下执行\",\"如再次await()则阻塞，当前线程是最后一个到达的线程await时，再次放行，循环往复\",\"public class CyclicBarrierExample { public static void main(String[] args) { // 创建CyclicBarrier实例，并设置屏障点操作（所有线程到达屏障点时执行） CyclicBarrier barrier = new CyclicBarrier(3, new Runnable() { @Override public void run() { System.out.println(\\\"所有线程已到达屏障点，继续执行后续任务...\\\"); } }); // 创建并启动三个线程 for (int i = 1; i <= 3; i++) { new Thread(new Task(barrier), \\\"线程 \\\" + i).start(); } } static class Task implements Runnable { private CyclicBarrier barrier; public Task(CyclicBarrier barrier) { this.barrier = barrier; } @Override public void run() { try { while (true) { System.out.println(Thread.currentThread().getName() + \\\" 正在执行任务...\\\"); // 模拟任务执行时间 Thread.sleep((long) (Math.random() * 1000)); System.out.println(Thread.currentThread().getName() + \\\" 完成任务，等待其他线程...\\\"); // 调用await方法等待其他线程 barrier.await(); // 所有线程到达屏障点后执行的代码 System.out.println(Thread.currentThread().getName() + \\\" 继续执行后续任务...\\\"); } } catch (InterruptedException | BrokenBarrierException e) { e.printStackTrace(); } } } } \",\"线程 1 正在执行任务... 线程 2 正在执行任务... 线程 3 正在执行任务... 线程 3 完成任务，等待其他线程... 线程 2 完成任务，等待其他线程... 线程 1 完成任务，等待其他线程... 所有线程已到达屏障点，继续执行后续任务... 线程 1 继续执行后续任务... 线程 1 正在执行任务... 线程 2 继续执行后续任务... 线程 3 继续执行后续任务... 线程 2 正在执行任务... 线程 3 正在执行任务... 线程 3 完成任务，等待其他线程... 线程 2 完成任务，等待其他线程... 线程 1 完成任务，等待其他线程... 所有线程已到达屏障点，继续执行后续任务... 线程 1 继续执行后续任务... 线程 1 正在执行任务... 线程 3 继续执行后续任务... 线程 3 正在执行任务... 线程 2 继续执行后续任务... 线程 2 正在执行任务... 线程 1 完成任务，等待其他线程... 线程 2 完成任务，等待其他线程... 线程 3 完成任务，等待其他线程... 所有线程已到达屏障点，继续执行后续任务... 线程 3 继续执行后续任务... 线程 3 正在执行任务... 线程 1 继续执行后续任务... 线程 1 正在执行任务... 线程 2 继续执行后续任务... 线程 2 正在执行任务... 线程 3 完成任务，等待其他线程... 线程 1 完成任务，等待其他线程... 线程 2 完成任务，等待其他线程... 所有线程已到达屏障点，继续执行后续任务... ... \",\"线程达到公共屏障点（barrier）前阻塞，知道最后一个线程达到屏障点，然后又开始执行\",\"循环往复的做达到屏障点->放行->达到屏障点->放行...\"]},\"252\":{\"h\":\"CyclicBarrier和CountDownLatch有什么区别？\",\"t\":[\"CountDownLatch是一次性的，而CyclicBarrier则可以多次设置屏障，实现重复利用\",\"CountDownLatch中的各个子线程不可以等待其他线程，只能完成自己的任务；而CyclicBarrier中的各个线程可以等待其他线程\",\"CyclicBarrier\",\"CountDownLatch\",\"CyclicBarrier是可重用的，其中的线程会等待 所有的线程完成任务。届时，屏障将被拆 除，并可以选择性地做一些特定的动作。\",\"CountDownLatch是一次性的， 不同的线程在同一个计数器上 工作，直到计数器为0.\",\"CyclicBarrier面向的是线程数\",\"CountDownLatch面向的是任务 数\",\"在使用CyclicBarrier时，你必须在构造中指定 参与协作的线程数，这些线程必须调用await() 方法\",\"使用CountDownLatch时，则必 须要指定任务数，至于这些任 务由哪些线程完成无关紧要\",\"CyclicBarrier可以在所有的线程释放后重新使 用\",\"CountDownLatch在计数器为0 时不能再使用\",\"在CyclicBarrier中，如果某个线程遇到了中 断、超时等问题时，则处于await的线程都会 出现问题\",\"在CountDownLatch中，如果某 个线程出现问题，其他线程不 受影响\"]},\"253\":{\"h\":\"Semaphore（信号量）了解吗？\",\"t\":[\"定义\",\"Semaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源\",\"应用场景\",\"资源池管理：如数据库连接池，限制同时访问数据库的连接数\",\"限流控制：如限制同时处理的请求数量，防止过载\",\"多线程限量操作：如控制多个线程对某个资源的访问，确保不会出现资源争用\",\"示例代码\",\"public class SemaphoreExample { public static void main(String[] args) { // 创建一个Semaphore实例，设定可用许可数量为3（表示有3个停车位） Semaphore parkingLot = new Semaphore(3); // 创建并启动六个线程模拟汽车 for (int i = 1; i <= 6; i++) { new Thread(new Car(parkingLot), \\\"汽车 \\\" + i).start(); } } static class Car implements Runnable { private Semaphore parkingLot; public Car(Semaphore parkingLot) { this.parkingLot = parkingLot; } @Override public void run() { try { System.out.println(Thread.currentThread().getName() + \\\" 尝试进入停车场...\\\"); // 获取一个许可，阻塞直到有可用的许可 parkingLot.acquire(); System.out.println(Thread.currentThread().getName() + \\\" 成功进入停车场。\\\"); // 模拟停车时间 Thread.sleep((long) (Math.random() * 10000)); System.out.println(Thread.currentThread().getName() + \\\" 离开停车场。\\\"); // 释放许可 parkingLot.release(); } catch (InterruptedException e) { e.printStackTrace(); } } } } \"]},\"254\":{\"h\":\"解释\",\"t\":[\"Semaphore：构造函数中传入的参数表示可以同时访问的资源数量。在这个例子中，设定为3，表示有3个停车位。\",\"acquire() 方法：线程调用这个方法尝试获取一个许可，如果没有可用许可，线程会被阻塞，直到有可用许可为止。\",\"release() 方法：线程调用这个方法释放一个许可，使其他被阻塞的线程可以继续执行。\",\"模拟停车场：Car 类中的 run 方法模拟了汽车进入停车场、停车和离开的过程。线程首先尝试获取一个许可，成功后进入停车场， 停车一段时间后离开，并释放许可。\"]},\"255\":{\"h\":\"重要注意事项\",\"t\":[\"公平性：Semaphore可以设置为公平模式（FIFO），通过在构造函数中传入 true，确保线程按请求顺序获取许可：\",\"Semaphore parkingLot = new Semaphore(3, true); \",\"中断：acquire 方法响应中断，如果线程在等待许可时被中断，会抛出 InterruptedException。\",\"tryAcquire 方法：尝试获取许可但不阻塞，有多种重载形式：\",\"boolean acquired = parkingLot.tryAcquire(); boolean acquiredWithTimeout = parkingLot.tryAcquire(1, TimeUnit.SECONDS); \",\"使用 Semaphore 可以有效控制对资源的并发访问，确保系统资源的有效利用和安全性\"]},\"256\":{\"h\":\"Exchanger 了解吗？\",\"t\":[\"Exchanger 是 Java 中的一个同步辅助类，专门用于在两个线程之间交换数据。它的主要应用场景包括：\",\"双线程数据交换：两个线程需要在某个点交换数据，如生产者和消费者模式中的数据交换。\",\"任务分配与结果收集：一个线程生成任务，另一个线程处理任务并返回结果。\",\"资源双向传递：两个线程互相传递数据或资源，如双缓冲区交换。\"]},\"257\":{\"h\":\"代码示例\",\"t\":[\"以下是一个简单的 Exchanger 使用示例，模拟两个线程之间的数据交换：\",\"import java.util.concurrent.Exchanger; public class ExchangerExample { public static void main(String[] args) { // 创建一个Exchanger实例 Exchanger<String> exchanger = new Exchanger<>(); // 创建并启动两个线程 new Thread(new Producer(exchanger), \\\"生产者\\\").start(); new Thread(new Consumer(exchanger), \\\"消费者\\\").start(); } static class Producer implements Runnable { private Exchanger<String> exchanger; public Producer(Exchanger<String> exchanger) { this.exchanger = exchanger; } @Override public void run() { try { String data = \\\"生产的数据\\\"; System.out.println(Thread.currentThread().getName() + \\\" 生产了数据：\\\" + data); // 与消费者交换数据 String response = exchanger.exchange(data); System.out.println(Thread.currentThread().getName() + \\\" 收到消费者的数据：\\\" + response); } catch (InterruptedException e) { e.printStackTrace(); } } } static class Consumer implements Runnable { private Exchanger<String> exchanger; public Consumer(Exchanger<String> exchanger) { this.exchanger = exchanger; } @Override public void run() { try { String data = \\\"消费者处理的数据\\\"; // 接收生产者的数据并返回处理后的数据 String received = exchanger.exchange(data); System.out.println(Thread.currentThread().getName() + \\\" 接收到生产者的数据：\\\" + received); System.out.println(Thread.currentThread().getName() + \\\" 处理后数据：\\\" + data); } catch (InterruptedException e) { e.printStackTrace(); } } } } \"]},\"258\":{\"h\":\"解释\",\"t\":[\"Exchanger：一个用于在两个线程之间交换数据的同步点。通过 exchange 方法，两个线程可以交换数据，并且这两个线程在此方法处阻塞，直到对方也到达此同步点。\",\"Producer 类：模拟生产者线程，生成数据并与消费者交换。\",\"Consumer 类：模拟消费者线程，准备处理数据并与生产者交换。\",\"exchange() 方法：线程调用此方法进行数据交换，该方法会阻塞，直到另一个线程也调用 exchange 方法。\"]},\"259\":{\"h\":\"重要注意事项\",\"t\":[\"成对使用：Exchanger 是为成对线程设计的，如果有一个线程没有配对线程来交换数据，那么它会一直阻塞。\",\"超时机制：exchange 方法有带超时参数的重载形式，可以指定最大等待时间：\",\"String response = exchanger.exchange(data, 1, TimeUnit.SECONDS); \",\"中断处理：如果线程在等待交换数据时被中断，会抛出 InterruptedException。\",\"Exchanger 可以简化两个线程之间的数据交换逻辑，确保交换操作是同步和线程安全的，非常适合需要双向数据传递的场景。\",\"应用场景\",\"遗传算法 \",\"Exchanger可以用于遗传算法，遗传算法里需要选出两个人作为交配对象，这时候会交换两人的数据，并使用交叉规则得出2个交配结果\",\"校对工作 \",\"Exchanger也可以用于校对工作，比如我们需要将纸制银行流水通过人工的方式录入成电子银行流水，为了避免错误，采用AB岗两人进行录入，录入到Excel之后，系统需要加载这两个Excel，并对两个Excel数据进行校对，看看是否录入一致\"]},\"260\":{\"h\":\"说说你对CompletableFuture的理解？\"},\"261\":{\"h\":\"1. 引言\",\"t\":[\"CompletableFuture 是Java 8引入的一个异步编程工具类，用于处理异步任务的结果和执行流程。它提供了一种简洁而强大的方式来处理异步操作，包括任务的串行执行、并行执行、组合以及异常处理等\"]},\"262\":{\"h\":\"2. 基本概念\"},\"263\":{\"h\":\"2.1 创建 CompletableFuture\",\"t\":[\"你可以使用静态工厂方法来创建 CompletableFuture 对象：\",\"supplyAsync：用于执行有返回值的异步任务。\",\"runAsync：用于执行没有返回值的异步任务。\",\"CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> { // 任务逻辑 return \\\"结果\\\"; }); CompletableFuture<Void> future = CompletableFuture.runAsync(() -> { // 任务逻辑 }); \"]},\"264\":{\"h\":\"3. 任务完成后的回调\"},\"265\":{\"h\":\"3.1 thenApply\",\"t\":[\"用于在任务完成后，对结果进行处理并返回新的结果。\",\"CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> \\\"Hello\\\") .thenApply(result -> result + \\\" World\\\"); \"]},\"266\":{\"h\":\"3.2 thenAccept\",\"t\":[\"用于在任务完成后，消费结果但不返回新的结果。\",\"CompletableFuture.supplyAsync(() -> \\\"Hello\\\") .thenAccept(result -> System.out.println(result)); \"]},\"267\":{\"h\":\"3.3 thenRun\",\"t\":[\"用于在任务完成后执行一个没有返回值的操作。\",\"CompletableFuture.supplyAsync(() -> \\\"Hello\\\") .thenRun(() -> System.out.println(\\\"任务完成\\\")); \"]},\"268\":{\"h\":\"4. 组合多个 CompletableFuture\"},\"269\":{\"h\":\"4.1 thenCompose\",\"t\":[\"用于在一个 CompletableFuture 完成后，启动另一个 CompletableFuture。\",\"CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> \\\"Hello\\\") .thenCompose(result -> CompletableFuture.supplyAsync(() -> result + \\\" World\\\")); \"]},\"270\":{\"h\":\"4.2 thenCombine\",\"t\":[\"用于将两个独立的 CompletableFuture 的结果进行合并。\",\"CompletableFuture<String> future1 = CompletableFuture.supplyAsync(() -> \\\"Hello\\\"); CompletableFuture<String> future2 = CompletableFuture.supplyAsync(() -> \\\" World\\\"); CompletableFuture<String> resultFuture = future1.thenCombine(future2, (result1, result2) -> result1 + result2); \"]},\"271\":{\"h\":\"4.3 allOf\",\"t\":[\"用于等待所有给定的 CompletableFuture 完成。\",\"CompletableFuture<String> future1 = CompletableFuture.supplyAsync(() -> \\\"结果1\\\"); CompletableFuture<String> future2 = CompletableFuture.supplyAsync(() -> \\\"结果2\\\"); CompletableFuture<String> future3 = CompletableFuture.supplyAsync(() -> \\\"结果3\\\"); CompletableFuture<Void> allOf = CompletableFuture.allOf(future1, future2, future3); allOf.thenAccept(v -> { try { String result1 = future1.get(); String result2 = future2.get(); String result3 = future3.get(); System.out.println(result1 + \\\", \\\" + result2 + \\\", \\\" + result3); } catch (InterruptedException | ExecutionException e) { e.printStackTrace(); } }); \"]},\"272\":{\"h\":\"5. 处理异常\"},\"273\":{\"h\":\"5.1 exceptionally\",\"t\":[\"用于在异步任务发生异常时提供一个默认值。\",\"CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> { if (Math.random() > 0.5) { throw new RuntimeException(\\\"发生异常\\\"); } return \\\"成功\\\"; }).exceptionally(ex -> \\\"默认值\\\"); \"]},\"274\":{\"h\":\"5.2 handle\",\"t\":[\"用于在异步任务完成或发生异常时对结果进行处理。\",\"CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> { if (Math.random() > 0.5) { throw new RuntimeException(\\\"发生异常\\\"); } return \\\"成功\\\"; }).handle((result, ex) -> { if (ex != null) { return \\\"异常处理后的默认值\\\"; } return result; }); \"]},\"275\":{\"h\":\"6. 超时控制\"},\"276\":{\"h\":\"6.1 orTimeout\",\"t\":[\"用于为异步操作设定超时。\",\"CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> { try { Thread.sleep(3000); } catch (InterruptedException e) { throw new IllegalStateException(e); } return \\\"结果\\\"; }).orTimeout(2, TimeUnit.SECONDS); \"]},\"277\":{\"h\":\"6.2 completeOnTimeout\",\"t\":[\"用于在超时时返回默认值。\",\"CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> { try { Thread.sleep(3000); } catch (InterruptedException e) { throw new IllegalStateException(e); } return \\\"结果\\\"; }).completeOnTimeout(\\\"超时默认值\\\", 2, TimeUnit.SECONDS); \"]},\"278\":{\"h\":\"7. 并行执行多个任务\"},\"279\":{\"h\":\"示例\",\"t\":[\"import java.util.concurrent.CompletableFuture; import java.util.concurrent.ExecutionException; import java.util.List; import java.util.stream.Collectors; public class CompletableFutureParallelExample { public static void main(String[] args) { // 定义三个异步任务 CompletableFuture<String> future1 = CompletableFuture.supplyAsync(() -> { try { Thread.sleep(1000); // 模拟耗时操作 } catch (InterruptedException e) { throw new IllegalStateException(e); } return \\\"结果1\\\"; }); CompletableFuture<String> future2 = CompletableFuture.supplyAsync(() -> { try { Thread.sleep(2000); // 模拟耗时操作 } catch (InterruptedException e) { throw new IllegalStateException(e); } return \\\"结果2\\\"; }); CompletableFuture<String> future3 = CompletableFuture.supplyAsync(() -> { try { Thread.sleep(3000); // 模拟耗时操作 } catch (InterruptedException e) { throw new IllegalStateException(e); } return \\\"结果3\\\"; }); // 创建一个包含所有异步任务的CompletableFuture CompletableFuture<Void> allOf = CompletableFuture.allOf(future1, future2, future3); // 在所有任务完成后处理结果 allOf.thenAccept(v -> { List<String> results = List.of(future1, future2, future3).stream() .map(future -> { try { return future.get(); } catch (InterruptedException | ExecutionException e) { throw new IllegalStateException(e); } }) .collect(Collectors.toList()); // 处理所有结果 results.forEach(result -> System.out.println(\\\"任务完成，结果: \\\" + result)); }).join(); // 等待所有任务完成 System.out.println(\\\"主线程继续执行其他操作...\\\"); } } \"]},\"280\":{\"h\":\"8. 真实场景应用\"},\"281\":{\"h\":\"8.1 并行获取数据\",\"t\":[\"以下示例展示如何并行获取多个远程数据源的数据，并在所有数据获取完成后进行处理。\",\"import java.util.concurrent.CompletableFuture; import java.util.concurrent.ExecutionException; import java.util.List; import java.util.stream.Collectors; public class CompletableFutureRealWorldExample { public static void main(String[] args) { CompletableFuture<String> future1 = fetchDataFromService1(); CompletableFuture<String> future2 = fetchDataFromService2(); CompletableFuture<String> future3 = fetchDataFromService3(); CompletableFuture<Void> allOf = CompletableFuture.allOf(future1, future2, future3); allOf.thenAccept(v -> { try { String result1 = future1.get(); String result2 = future2.get(); String result3 = future3.get(); // 合并结果 String finalResult = result1 + \\\", \\\" + result2 + \\\", \\\" + result3; System.out.println(\\\"最终结果: \\\" + finalResult); } catch (InterruptedException | ExecutionException e) { e.printStackTrace(); } }).join(); // 等待所有任务完成 } private static CompletableFuture<String> fetchDataFromService1() { return CompletableFuture.supplyAsync(() -> { // 模拟远程调用 try { Thread.sleep(1000); } catch (InterruptedException e) { throw new IllegalStateException(e); } return \\\"Service1数据\\\"; }); } private static CompletableFuture<String> fetchDataFromService2() { return CompletableFuture.supplyAsync(() -> { // 模拟远程调用 try { Thread.sleep(2000); } catch (InterruptedException e) { throw new IllegalStateException(e); } return \\\"Service2数据\\\"; }); } private static CompletableFuture<String> fetchDataFromService3() { return CompletableFuture.supplyAsync(() -> { // 模拟远程调用 try { Thread.sleep(3000); } catch (InterruptedException e) { throw new IllegalStateException(e); } return \\\"Service3数据\\\"; }); } } \"]},\"282\":{\"h\":\"9. 总结\",\"t\":[\"CompletableFuture 提供了一种简洁而强大的方式来处理异\"]},\"283\":{\"h\":\"CompletableFuture的线程池设置？\",\"t\":[\"CompletableFuture 使用 ForkJoinPool.commonPool() 作为默认线程池来执行异步任务，但你可以指定自定义的线程池来满足特殊需求，如提高性能或控制资源使用。以下是如何设置和使用自定义线程池的详细指南。\"]},\"284\":{\"h\":\"1. 使用默认线程池\",\"t\":[\"默认情况下，CompletableFuture 使用 ForkJoinPool.commonPool()。这对于大多数情况已经足够，但在需要更多控制或资源隔离时，可以使用自定义线程池。\",\"CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> { // 异步任务逻辑 return \\\"结果\\\"; }); \"]},\"285\":{\"h\":\"2. 指定自定义线程池\",\"t\":[\"你可以使用 CompletableFuture.supplyAsync 或 CompletableFuture.runAsync 方法的重载版本来指定自定义的线程池。\"]},\"286\":{\"h\":\"2.1 创建自定义线程池\",\"t\":[\"首先，创建一个自定义线程池。你可以使用 Executors 工具类来创建不同类型的线程池：\",\"import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; ExecutorService customThreadPool = Executors.newFixedThreadPool(10); // 创建一个固定大小的线程池 \"]},\"287\":{\"h\":\"2.2 使用自定义线程池\",\"t\":[\"然后，将自定义线程池传递给 CompletableFuture：\",\"CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> { // 异步任务逻辑 return \\\"结果\\\"; }, customThreadPool); \"]},\"288\":{\"h\":\"3. 完整示例\",\"t\":[\"以下是一个完整的示例，展示如何使用自定义线程池执行异步任务：\",\"import java.util.concurrent.CompletableFuture; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.TimeUnit; public class CustomThreadPoolExample { public static void main(String[] args) { // 创建自定义线程池 ExecutorService customThreadPool = Executors.newFixedThreadPool(10); // 提交异步任务并使用自定义线程池 CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> { try { Thread.sleep(1000); // 模拟耗时操作 } catch (InterruptedException e) { throw new IllegalStateException(e); } return \\\"结果\\\"; }, customThreadPool); // 注册回调处理结果 future.thenAccept(result -> System.out.println(\\\"异步任务完成，结果: \\\" + result)); // 主线程继续执行其他操作 System.out.println(\\\"主线程继续执行其他操作...\\\"); // 关闭线程池 customThreadPool.shutdown(); try { if (!customThreadPool.awaitTermination(800, TimeUnit.MILLISECONDS)) { customThreadPool.shutdownNow(); } } catch (InterruptedException e) { customThreadPool.shutdownNow(); } } } \"]},\"289\":{\"h\":\"4. 线程池类型\"},\"290\":{\"h\":\"4.1 固定大小线程池\",\"t\":[\"适用于已知固定数量的并发任务：\",\"ExecutorService fixedThreadPool = Executors.newFixedThreadPool(10); \"]},\"291\":{\"h\":\"4.2 缓存线程池\",\"t\":[\"适用于大量短生命周期的并发任务，线程池大小根据需要动态调整：\",\"ExecutorService cachedThreadPool = Executors.newCachedThreadPool(); \"]},\"292\":{\"h\":\"4.3 单线程池\",\"t\":[\"适用于需要顺序执行任务的场景：\",\"ExecutorService singleThreadPool = Executors.newSingleThreadExecutor(); \"]},\"293\":{\"h\":\"4.4 调度线程池\",\"t\":[\"适用于需要定期执行任务的场景：\",\"ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(5); \"]},\"294\":{\"h\":\"5. 异步任务链中的线程池\",\"t\":[\"你还可以在异步任务链中的不同部分使用不同的线程池：\",\"ExecutorService pool1 = Executors.newFixedThreadPool(5); ExecutorService pool2 = Executors.newCachedThreadPool(); CompletableFuture.supplyAsync(() -> { // 使用 pool1 执行异步任务 return \\\"任务1结果\\\"; }, pool1).thenApplyAsync(result -> { // 使用 pool2 处理结果 return result + \\\" 经过处理\\\"; }, pool2).thenAcceptAsync(result -> { System.out.println(\\\"最终结果: \\\" + result); // 可以不指定线程池，则使用默认的 ForkJoinPool.commonPool() }); \",\"通过设置自定义线程池，你可以更好地控制 CompletableFuture 的并发行为，满足不同应用场景的需求。\"]},\"295\":{\"h\":\"并发队列\"},\"296\":{\"h\":\"说说阻塞队列是怎么实现的？\",\"t\":[\"阻塞队列是一种特殊的队列数据结构，在多线程编程中起着重要作用。它允许多个线程在队列为空或者队列已满时进行阻塞等待，从而实现线程之间的同步与通信。阻塞队列的实现通常基于经典的队列数据结构，如数组或者链表，并结合了锁和条件等待机制来实现线程的阻塞和唤醒。\",\"下面是阻塞队列的基本实现原理：\",\"队列数据结构： 阻塞队列基于数组或链表等数据结构实现，用于存储元素。常见的阻塞队列有 ArrayBlockingQueue、LinkedBlockingQueue 等。\",\"锁和条件等待： 阻塞队列内部通常使用锁和条件等待来实现线程的阻塞和唤醒。当队列为空时，试图从队列中取出元素的线程会被阻塞，直到队列非空；当队列已满时，试图向队列中添加元素的线程会被阻塞，直到队列有空闲位置。\",\"线程阻塞和唤醒机制： 在队列为空或已满时，等待队列状态改变的线程会进入等待状态，释放锁并进入等待队列。当有其他线程向队列中添加或取出元素时，会触发条件变量的通知操作，唤醒等待队列中的线程。\",\"线程安全性： 阻塞队列需要保证在多线程环境下的线程安全性。因此，在对队列进行添加或移除元素的操作时，需要使用锁来保护对队列数据结构的访问，从而确保操作的原子性和线程安全性。\",\"总的来说，阻塞队列通过结合队列数据结构、锁和条件等待机制，实现了多线程环境下的线程安全、阻塞和唤醒操作，从而为多线程编程提供了便利和高效的同步与通信机制。\"]},\"297\":{\"h\":\"线程池\"},\"298\":{\"h\":\"什么是线程池？\",\"t\":[\"线程池是一种管理和控制多个线程并发执行的机制，旨在提高性能并优化资源使用。线程池通过预先创建一组线程，避免了频繁创建和销毁线程的开销，从而提高了系统效率。\"]},\"299\":{\"h\":\"1. 线程池的基本概念\",\"t\":[\"线程复用：线程池在初始化时创建一定数量的线程，这些线程在处理完一个任务后不会被销毁，而是被重用来处理下一个任务。\",\"任务队列：当所有线程都在忙碌时，新的任务会被放入一个队列中等待执行。\",\"线程管理：线程池会自动管理线程的生命周期，如创建新线程、回收空闲线程等。\"]},\"300\":{\"h\":\"2. 线程池的优势\",\"t\":[\"提高性能：减少了频繁创建和销毁线程的开销。\",\"资源控制：可以限制并发线程的数量，防止系统资源耗尽。\",\"简化编程：提供了统一的接口来管理和调度线程，简化了并发编程的复杂性。\"]},\"301\":{\"h\":\"3. Java中的线程池实现\",\"t\":[\"Java通过java.util.concurrent包提供了多种线程池实现，主要通过Executors工具类来创建。\"]},\"302\":{\"h\":\"3.1 常见的线程池类型\",\"t\":[\"FixedThreadPool：固定大小的线程池，适用于已知线程数固定的场景。\",\"ExecutorService fixedThreadPool = Executors.newFixedThreadPool(10); \",\"CachedThreadPool：根据需要创建新线程的线程池，但在空闲时会重用先前创建的线程，适用于大量短生命周期任务。\",\"ExecutorService cachedThreadPool = Executors.newCachedThreadPool(); \",\"SingleThreadExecutor：单线程线程池，适用于需要顺序执行任务的场景。\",\"ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor(); \",\"ScheduledThreadPool：定时或周期性执行任务的线程池。\",\"ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(5); \"]},\"303\":{\"h\":\"4. 线程池的使用示例\",\"t\":[\"以下是一个使用固定大小线程池执行多个任务的示例：\",\"import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.TimeUnit; public class ThreadPoolExample { public static void main(String[] args) { // 创建一个固定大小的线程池 ExecutorService executor = Executors.newFixedThreadPool(5); // 提交多个任务 for (int i = 0; i < 10; i++) { final int index = i; executor.submit(() -> { try { System.out.println(\\\"任务 \\\" + index + \\\" 由线程 \\\" + Thread.currentThread().getName() + \\\" 执行\\\"); Thread.sleep(2000); // 模拟任务执行 } catch (InterruptedException e) { Thread.currentThread().interrupt(); } }); } // 关闭线程池 executor.shutdown(); try { if (!executor.awaitTermination(60, TimeUnit.SECONDS)) { executor.shutdownNow(); } } catch (InterruptedException e) { executor.shutdownNow(); } } } \"]},\"304\":{\"h\":\"5. 线程池的配置参数\",\"t\":[\"线程池的配置参数影响其行为和性能，常见参数包括：\",\"corePoolSize：核心线程数，线程池维护的最小线程数。\",\"maximumPoolSize：最大线程数，线程池能够创建的最大线程数。\",\"keepAliveTime：空闲线程的存活时间，当线程池中的线程数超过核心线程数时，多余的空闲线程在终止前等待新任务的最长时间。\",\"workQueue：任务队列，用于保存等待执行的任务。\"]},\"305\":{\"h\":\"6. 自定义线程池\",\"t\":[\"你可以使用ThreadPoolExecutor来创建自定义线程池，以更灵活地控制线程池的行为：\",\"import java.util.concurrent.ArrayBlockingQueue; import java.util.concurrent.ThreadPoolExecutor; import java.util.concurrent.TimeUnit; public class CustomThreadPoolExample { public static void main(String[] args) { // 创建自定义线程池 ThreadPoolExecutor executor = new ThreadPoolExecutor( 5, // corePoolSize 10, // maximumPoolSize 60, // keepAliveTime TimeUnit.SECONDS, // keepAliveTime单位 new ArrayBlockingQueue<>(100) // workQueue ); // 提交多个任务 for (int i = 0; i < 10; i++) { final int index = i; executor.submit(() -> { try { System.out.println(\\\"任务 \\\" + index + \\\" 由线程 \\\" + Thread.currentThread().getName() + \\\" 执行\\\"); Thread.sleep(2000); // 模拟任务执行 } catch (InterruptedException e) { Thread.currentThread().interrupt(); } }); } // 关闭线程池 executor.shutdown(); try { if (!executor.awaitTermination(60, TimeUnit.SECONDS)) { executor.shutdownNow(); } } catch (InterruptedException e) { executor.shutdownNow(); } } } \",\"通过自定义线程池，你可以精细控制线程池的各种参数，以满足不同应用场景的需求。\"]},\"306\":{\"h\":\"为什么说频繁创建和销毁线程的开销大？\",\"t\":[\"频繁创建和销毁线程的开销大，主要是因为线程的创建和销毁涉及操作系统和JVM层面的多种资源管理和调度。具体来说，有以下几个原因：\"]},\"307\":{\"h\":\"1. 系统资源消耗\"},\"308\":{\"h\":\"1.1 内存开销\",\"t\":[\"每个线程在创建时需要分配内存，用于其堆栈空间和线程本地存储（Thread Local Storage）。默认情况下，在典型的JVM中，每个线程的堆栈大小可能是1MB或者更大。频繁创建和销毁线程会导致内存分配和释放操作的频繁发生，从而增加内存管理的开销。\"]},\"309\":{\"h\":\"1.2 操作系统资源\",\"t\":[\"操作系统为每个线程分配了一些内核对象和数据结构，这些结构用于线程调度和管理。频繁创建和销毁线程会导致操作系统不断地创建和销毁这些内核对象，增加了系统调用的开销。\"]},\"310\":{\"h\":\"2. CPU消耗\"},\"311\":{\"h\":\"2.1 线程上下文切换\",\"t\":[\"操作系统通过线程调度器在多个线程之间切换执行。每次切换执行线程时，需要保存当前线程的状态（寄存器、程序计数器等），然后恢复即将执行线程的状态。频繁的线程创建和销毁会增加上下文切换的次数，从而增加CPU的负担。\"]},\"312\":{\"h\":\"2.2 同步开销\",\"t\":[\"线程的创建和销毁需要在操作系统和JVM内部进行同步，以确保线程状态的一致性。这些同步操作会导致锁的竞争和开销，降低系统性能。\"]},\"313\":{\"h\":\"3. JVM的开销\"},\"314\":{\"h\":\"3.1 垃圾回收\",\"t\":[\"频繁创建和销毁线程会导致大量短生命周期的对象被创建，例如线程对象、任务对象等。这些短生命周期的对象会加大垃圾回收的压力，频繁的垃圾回收会导致应用程序的性能下降。\"]},\"315\":{\"h\":\"3.2 JIT优化\",\"t\":[\"JVM中的即时编译器（JIT）会对热点代码进行优化，但频繁的线程创建和销毁会导致代码路径的变化，从而影响JIT的优化效果。\"]},\"316\":{\"h\":\"能说说工作中线程池的应用吗？\",\"t\":[\"线程池在实际工作中有着广泛的应用，特别是在高并发和需要处理大量任务的场景中。以下是线程池在各种工作场景中的一些典型应用：\"]},\"317\":{\"h\":\"1. Web服务器\"},\"318\":{\"h\":\"场景描述\",\"t\":[\"Web服务器需要处理大量的客户端请求。每个请求可能涉及复杂的处理逻辑，包括数据库访问、文件操作和计算等。频繁地为每个请求创建和销毁线程将导致性能瓶颈。\"]},\"319\":{\"h\":\"解决方案\",\"t\":[\"通过使用线程池，Web服务器可以预先创建一组线程来处理请求。线程池中的线程会在处理完一个请求后立即准备处理下一个请求，从而减少了线程创建和销毁的开销。\"]},\"320\":{\"h\":\"代码示例\",\"t\":[\"以下是一个使用线程池处理HTTP请求的简单示例：\",\"import java.io.IOException; import java.net.ServerSocket; import java.net.Socket; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; public class SimpleWebServer { private final ExecutorService threadPool; public SimpleWebServer(int port, int poolSize) throws IOException { ServerSocket serverSocket = new ServerSocket(port); threadPool = Executors.newFixedThreadPool(poolSize); while (true) { Socket clientSocket = serverSocket.accept(); threadPool.submit(() -> handleRequest(clientSocket)); } } private void handleRequest(Socket clientSocket) { // 处理请求逻辑 } public static void main(String[] args) throws IOException { new SimpleWebServer(8080, 10); // 端口8080，线程池大小为10 } } \"]},\"321\":{\"h\":\"2. 数据库连接池\"},\"322\":{\"h\":\"场景描述\",\"t\":[\"数据库操作通常是IO密集型的，需要消耗较多的时间。频繁地创建和销毁数据库连接会导致性能下降和资源浪费。\"]},\"323\":{\"h\":\"解决方案\",\"t\":[\"通过使用数据库连接池，应用程序可以复用一组数据库连接，减少连接创建和销毁的开销，并提高数据库操作的效率。\"]},\"324\":{\"h\":\"代码示例\",\"t\":[\"以Apache Commons DBCP为例，使用连接池管理数据库连接：\",\"import org.apache.commons.dbcp2.BasicDataSource; import java.sql.Connection; import java.sql.PreparedStatement; import java.sql.ResultSet; import java.sql.SQLException; public class DatabaseConnectionPoolExample { public static void main(String[] args) { BasicDataSource dataSource = new BasicDataSource(); dataSource.setUrl(\\\"jdbc:mysql://localhost:3306/mydatabase\\\"); dataSource.setUsername(\\\"username\\\"); dataSource.setPassword(\\\"password\\\"); dataSource.setMinIdle(5); dataSource.setMaxIdle(10); dataSource.setMaxOpenPreparedStatements(100); try (Connection conn = dataSource.getConnection(); PreparedStatement stmt = conn.prepareStatement(\\\"SELECT * FROM mytable\\\"); ResultSet rs = stmt.executeQuery()) { while (rs.next()) { System.out.println(\\\"Column 1: \\\" + rs.getString(1)); } } catch (SQLException e) { e.printStackTrace(); } } } \"]},\"325\":{\"h\":\"3. 并行数据处理\"},\"326\":{\"h\":\"场景描述\",\"t\":[\"在大数据处理和计算任务中，数据处理通常可以并行化以提高效率。例如，处理大型数据集时，可以将数据分割成多个块，并行处理每个块。\"]},\"327\":{\"h\":\"解决方案\",\"t\":[\"通过使用线程池，可以并行处理数据块，充分利用多核CPU的优势，提高数据处理的速度。\"]},\"328\":{\"h\":\"代码示例\",\"t\":[\"以下是一个使用线程池并行处理数据块的示例：\",\"import java.util.Arrays; import java.util.List; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.TimeUnit; public class ParallelDataProcessingExample { public static void main(String[] args) { List<Integer> data = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10); ExecutorService executor = Executors.newFixedThreadPool(4); for (Integer item : data) { executor.submit(() -> process(item)); } executor.shutdown(); try { if (!executor.awaitTermination(60, TimeUnit.SECONDS)) { executor.shutdownNow(); } } catch (InterruptedException e) { executor.shutdownNow(); } } private static void process(Integer item) { System.out.println(\\\"Processing item: \\\" + item + \\\" by \\\" + Thread.currentThread().getName()); try { Thread.sleep(1000); // 模拟处理时间 } catch (InterruptedException e) { Thread.currentThread().interrupt(); } } } \"]},\"329\":{\"h\":\"4. 异步任务执行\"},\"330\":{\"h\":\"场景描述\",\"t\":[\"在许多应用中，需要执行一些异步任务，例如发送邮件、日志记录、文件上传等。这些任务不需要立即完成，可以在后台执行。\"]},\"331\":{\"h\":\"解决方案\",\"t\":[\"通过使用线程池，可以将异步任务提交到线程池中执行，主线程可以继续处理其他工作。\"]},\"332\":{\"h\":\"代码示例\",\"t\":[\"以下是一个使用线程池执行异步任务的示例：\",\"import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; public class AsyncTaskExample { public static void main(String[] args) { ExecutorService executor = Executors.newFixedThreadPool(5); // 提交异步任务 executor.submit(() -> { sendEmail(\\\"user@example.com\\\"); }); // 主线程继续执行其他操作 System.out.println(\\\"主线程继续执行其他操作...\\\"); executor.shutdown(); } private static void sendEmail(String recipient) { System.out.println(\\\"发送邮件给: \\\" + recipient); try { Thread.sleep(2000); // 模拟发送邮件时间 } catch (InterruptedException e) { Thread.currentThread().interrupt(); } System.out.println(\\\"邮件发送完成\\\"); } } \"]},\"333\":{\"h\":\"5. 定时任务\"},\"334\":{\"h\":\"场景描述\",\"t\":[\"需要定期执行一些任务，例如清理临时文件、定时备份数据库等。\"]},\"335\":{\"h\":\"解决方案\",\"t\":[\"通过使用ScheduledThreadPoolExecutor，可以调度定时任务，在指定时间或周期性执行。\"]},\"336\":{\"h\":\"代码示例\",\"t\":[\"以下是一个使用调度线程池执行定时任务的示例：\",\"import java.util.concurrent.Executors; import java.util.concurrent.ScheduledExecutorService; import java.util.concurrent.TimeUnit; public class ScheduledTaskExample { public static void main(String[] args) { ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1); // 定期执行任务，每隔5秒执行一次 scheduler.scheduleAtFixedRate(() -> { System.out.println(\\\"执行定时任务: \\\" + System.currentTimeMillis()); }, 0, 5, TimeUnit.SECONDS); // 关闭调度器 Runtime.getRuntime().addShutdownHook(new Thread(() -> { scheduler.shutdown(); try { if (!scheduler.awaitTermination(60, TimeUnit.SECONDS)) { scheduler.shutdownNow(); } } catch (InterruptedException e) { scheduler.shutdownNow(); } })); } } \"]},\"337\":{\"h\":\"能简单说一下线程池的工作流程吗？\",\"t\":[\"线程池的工作流程可以分为以下几个步骤：初始化、任务提交、任务执行和资源回收。了解这些步骤有助于理解线程池如何管理线程和任务，提高并发编程的效率和资源利用率。\"]},\"338\":{\"h\":\"1. 线程池初始化\",\"t\":[\"线程池在初始化时，会根据配置参数创建一定数量的核心线程，并准备好任务队列。这些参数通常包括核心线程数（corePoolSize）、最大线程数（maximumPoolSize）、空闲线程存活时间（keepAliveTime）和任务队列（workQueue）等。\",\"ExecutorService executor = new ThreadPoolExecutor( 5, // corePoolSize 10, // maximumPoolSize 60L, // keepAliveTime TimeUnit.SECONDS, // 时间单位 new LinkedBlockingQueue<Runnable>() // 任务队列 ); \"]},\"339\":{\"h\":\"2. 任务提交\",\"t\":[\"任务可以通过execute()或submit()方法提交到线程池。execute()方法提交的任务没有返回值，而submit()方法可以返回一个Future对象，用于获取任务的执行结果。\",\"executor.execute(() -> { // 任务逻辑 }); Future<String> future = executor.submit(() -> { // 任务逻辑 return \\\"任务结果\\\"; }); \"]},\"340\":{\"h\":\"3. 任务执行\",\"t\":[\"当一个任务被提交到线程池后，线程池按照以下顺序处理任务：\",\"空闲核心线程执行任务：如果有空闲的核心线程，则直接由核心线程执行任务。\",\"任务加入队列：如果没有空闲的核心线程且任务队列未满，则将任务放入任务队列等待执行。\",\"创建新线程执行任务：如果任务队列已满且线程数未达到最大线程数，则创建新的非核心线程执行任务。\",\"拒绝策略：如果线程数已达到最大线程数且任务队列已满，则根据设置的拒绝策略处理新任务。常见的拒绝策略包括抛出异常、丢弃任务、丢弃队列最前的任务和由调用线程执行任务。\"]},\"341\":{\"h\":\"4. 任务执行完成\",\"t\":[\"线程执行任务时，如果任务执行完成且当前线程数超过核心线程数，且空闲时间超过keepAliveTime，该线程将被终止。否则，线程将继续处于空闲状态，准备执行下一个任务。\"]},\"342\":{\"h\":\"5. 线程池关闭\",\"t\":[\"线程池可以通过调用shutdown()或shutdownNow()方法关闭：\",\"shutdown()：停止接受新任务，并在所有已提交任务执行完成后关闭线程池。\",\"shutdownNow()：立即停止所有任务，尝试终止正在执行的任务，并返回未执行的任务列表。\",\"executor.shutdown(); // 优雅关闭 try { if (!executor.awaitTermination(60, TimeUnit.SECONDS)) { executor.shutdownNow(); // 强制关闭 } } catch (InterruptedException e) { executor.shutdownNow(); } \"]},\"343\":{\"h\":\"线程池的完整工作流程\",\"t\":[\"线程池的工作流程如下图所示：\",\"初始化线程池，创建核心线程和任务队列。\",\"任务提交到线程池。\",\"空闲核心线程执行任务；如无空闲核心线程则将任务加入队列；队列已满则创建新线程；达到最大线程数则执行拒绝策略。\",\"任务执行完成，线程空闲或终止。\",\"线程池关闭，停止接受新任务，等待已提交任务完成或立即终止。\",\"这个流程保证了线程资源的高效利用和任务的有效调度，使得线程池成为并发编程中重要的工具。\"]},\"344\":{\"h\":\"线程池主要参数有哪些？\",\"t\":[\"线程池的主要参数包括：\",\"corePoolSize（核心线程数）：线程池中保持活动状态的最小线程数。即使线程处于空闲状态，也不会被回收，除非设置了allowCoreThreadTimeOut。当有新任务提交时，线程池会优先使用核心线程来处理任务。\",\"maximumPoolSize（最大线程数）：线程池中允许存在的最大线程数。当核心线程都在忙碌，并且任务队列已满时，新任务会触发创建额外的线程，直到达到最大线程数。\",\"keepAliveTime（线程空闲时间）：当线程数超过核心线程数时，空闲线程在被终止前等待新任务的最长时间。如果线程空闲时间超过该值，则线程会被终止，直到线程数量等于核心线程数。\",\"TimeUnit（时间单位）：用于指定keepAliveTime的时间单位，通常为秒、分钟等。\",\"workQueue（任务队列）：用于存储等待执行的任务的队列。常见的任务队列包括有界队列（如ArrayBlockingQueue）和无界队列（如LinkedBlockingQueue、SynchronousQueue）。\",\"ThreadFactory（线程工厂）：用于创建新线程的工厂。可以通过自定义ThreadFactory来指定线程的名称、优先级等属性。\",\"RejectedExecutionHandler（拒绝策略）：当任务无法被接受执行时的处理策略。常见的拒绝策略包括抛出异常、丢弃任务、丢弃队列最前的任务和由调用线程执行任务。\",\"这些参数可以根据应用场景的需求进行调整和配置，以优化线程池的性能和资源利用率。\"]},\"345\":{\"h\":\"线程池的拒绝策略有哪些？\",\"t\":[\"线程池的拒绝策略用于定义当线程池无法接受新任务时应该采取的操作。以下是常见的线程池拒绝策略：\",\"AbortPolicy（默认策略）：默认的拒绝策略。当任务无法被执行时，会抛出RejectedExecutionException异常。\",\"CallerRunsPolicy：调用者运行策略。如果线程池无法接受新任务，会在调用线程中直接执行被拒绝的任务。这样做可能会导致调用线程的性能下降，因为调用线程需要承担执行任务的负责。\",\"DiscardPolicy：丢弃策略。当任务无法被执行时，会默默地丢弃被拒绝的任务，不会抛出异常也不会进行任何处理。\",\"DiscardOldestPolicy：丢弃最旧策略。当任务无法被执行时，会丢弃任务队列中最旧的任务，并尝试重新提交当前任务。\",\"可以根据具体的业务需求和系统特性选择合适的拒绝策略，以保证系统的稳定性和可靠性。\"]},\"346\":{\"h\":\"线程池有哪几种工作队列？\",\"t\":[\"线程池通常使用工作队列来存储等待执行的任务。常见的线程池工作队列包括：\",\"无界队列（Unbounded Queue）：无界队列可以存储无限数量的任务，即使线程池中的线程都在忙碌，新任务也可以被放入队列等待执行。常见的无界队列包括LinkedBlockingQueue，它基于链表实现，具有高吞吐量和无限容量的特点。\",\"有界队列（Bounded Queue）：有界队列有限制存储的任务数量，当队列已满时，新任务将被拒绝。有界队列可以有效地控制线程池中任务的数量，防止任务过载。常见的有界队列包括ArrayBlockingQueue，它基于数组实现，具有固定容量的特点。\",\"同步移交队列（Synchronous Transfer Queue）：同步移交队列是一种特殊的队列，它不存储任务，而是将任务直接移交给线程池中的线程进行执行。如果没有空闲线程可用，新任务会被拒绝。常见的同步移交队列包括SynchronousQueue，它实际上不存储任何元素，只是用于线程之间的任务传递。\",\"优先级队列（Priority Queue）：优先级队列根据元素的优先级来决定元素的顺序。在线程池中，可以使用优先级队列来根据任务的优先级高低来执行任务。Java中的PriorityBlockingQueue是一个线程安全的优先级队列实现。\",\"延迟队列（Delay Queue）：延迟队列用于存储延迟执行的任务，即在指定延迟时间之后才能被消费。延迟队列通常用于实现定时任务调度。Java中的Delayed接口和DelayedWorkQueue类用于实现延迟队列。\",\"工作窃取队列（Work Stealing Queue）：工作窃取队列是一种用于并行计算的特殊队列，每个线程都有自己的工作队列，并且可以从其他线程的队列中窃取任务来执行。工作窃取队列通常用于实现任务并行化的线程池。Java中的ForkJoinPool使用工作窃取队列来实现任务的并行执行。\",\"这些不同类型的工作队列具有不同的特性和适用场景，可以根据具体的需求选择合适的队列类型来优化线程池的性能和行为。\"]},\"347\":{\"h\":\"线程池提交execute和submit有什么区别？\",\"t\":[\"在Java的线程池中，execute()和submit()方法都用于向线程池提交任务，但它们之间存在一些区别：\",\"返回值类型：\",\"execute()方法没有返回值，因为它用于提交不需要返回结果的任务。\",\"submit()方法返回一个Future对象，可以用来获取任务的执行结果或者监控任务的执行状态。这使得submit()方法更加灵活，可以处理需要返回结果的任务。\",\"异常处理：\",\"execute()方法无法处理任务执行过程中抛出的异常。如果任务抛出了未捕获的异常，线程池会将其记录下来，但不会通知调用者。\",\"submit()方法可以通过Future对象来捕获任务执行过程中抛出的异常。调用Future对象的get()方法时，如果任务抛出了异常，会将异常包装在ExecutionException中重新抛出，从而让调用者能够捕获和处理异常。\",\"参数类型：\",\"execute()方法接受Runnable接口类型的任务作为参数，这种任务不返回结果。\",\"submit()方法除了接受Runnable接口类型的任务外，还可以接受Callable接口类型的任务作为参数，这种任务可以返回结果。\",\"综上所述，execute()方法用于提交不需要返回结果的任务，而submit()方法则更加灵活，既可以提交不需要返回结果的任务，也可以提交需要返回结果的任务，并且可以处理任务执行过程中抛出的异常。\"]},\"348\":{\"h\":\"线程池怎么关闭知道吗？\",\"t\":[\"线程池的关闭可以通过调用shutdown()方法或shutdownNow()方法来实现。这两种方法都是用来关闭线程池的，但它们之间有一些细微的差别：\",\"shutdown()方法： \",\"shutdown()方法用于平缓地关闭线程池。调用shutdown()方法后，线程池将不再接受新的任务，但会继续执行已提交的任务，直到所有任务执行完毕后才会关闭。\",\"shutdown()方法不会立即停止线程池，而是等待所有已提交的任务执行完成后再关闭线程池。\",\"executor.shutdown(); \",\"shutdownNow()方法： \",\"shutdownNow()方法用于立即关闭线程池。调用shutdownNow()方法后，线程池会尝试停止所有正在执行的任务，并返回未执行的任务列表。\",\"shutdownNow()方法会尝试中断正在执行的任务，以便更快地停止线程池，但并不保证所有任务都能被成功中断。 \",\"它的原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止\",\"executor.shutdownNow(); \",\"在调用了shutdown()或shutdownNow()方法后，可以通过调用awaitTermination()方法来等待线程池关闭，或者通过轮询isTerminated()方法来检查线程池是否已经关闭。\",\"try { if (!executor.awaitTermination(60, TimeUnit.SECONDS)) { executor.shutdownNow(); } } catch (InterruptedException e) { executor.shutdownNow(); } \",\"总之，通过调用shutdown()方法或shutdownNow()方法可以安全地关闭线程池，确保所有任务得到正确处理，并释放线程池所占用的资源。\"]},\"349\":{\"h\":\"线程池的线程数应该怎么配置？\",\"t\":[\"线程池的线程数配置应该根据你的应用场景和需求来决定，需要考虑以下几个因素：\",\"任务的性质：首先要考虑的是你的任务的性质。如果你的任务是CPU密集型的（计算密集型），那么你可能需要配置较少的线程数，因为每个线程都会占用较多的CPU资源。如果你的任务是I/O密集型的（如网络请求、文件操作等），那么你可能需要配置较多的线程数，因为线程在执行任务时会阻塞等待I/O操作的完成。\",\"系统资源：其次要考虑的是你的系统资源。你需要确保你的线程池的线程数不要超过系统资源的限制，包括CPU核心数、内存等。过多的线程可能会导致系统资源的竞争和浪费，从而降低系统的性能和稳定性。\",\"任务执行时间：还需要考虑任务的执行时间。如果你的任务执行时间较长，那么可能需要更多的线程来处理任务队列中的任务，以避免任务等待时间过长。但是，如果线程数过多，可能会导致线程间上下文切换的开销增加，从而降低系统的性能。\",\"任务队列容量：线程池的任务队列也是需要考虑的因素之一。如果任务队列容量较小，那么可能需要配置更多的线程来处理任务，以避免任务被拒绝。反之，如果任务队列容量较大，那么可能可以配置较少的线程来处理任务，减少线程间的竞争。\",\"综上所述，线程池的线程数配置需要根据任务性质、系统资源、任务执行时间和任务队列容量等因素综合考虑。通常情况下，可以通过监控系统资源的使用情况和线程池的运行状态来动态调整线程数配置，以保证线程池的性能和稳定性。\"]},\"350\":{\"h\":\"线程池是怎么实现线程复用的？\",\"t\":[\"核心应该是线程池+任务队列，使线程和队列解耦\",\"在线程池中，一开始会创建一定数量的线程，并将它们放入线程池中。\",\"当有任务需要执行时，可以通过向线程池提交任务的方式，将任务放入任务队列中。\",\"线程池中的线程作为消费者，会不断地从任务队列中取出任务来执行。当线程取出任务后，会执行任务的run()方法。执行完任务后，线程并不会立即销毁，而是回线程池中，继续等待新的任务\",\"这样，线程池中的线程就实现了复用\"]},\"351\":{\"h\":\"有哪几种常见的线程池？\",\"t\":[\"常见的线程池包括以下几种：\",\"FixedThreadPool（固定大小线程池）：\",\"固定大小线程池包含固定数量的线程，线程池中的线程数量不会发生变化。\",\"当有新任务提交时，如果线程池中有空闲的线程，则将任务分配给空闲线程执行；如果线程池中的线程都在执行任务，新任务将在任务队列中等待。\",\"适用于需要限制线程数量的场景，例如并发量稳定的服务器应用。\",\"CachedThreadPool（缓存线程池）：\",\"缓存线程池可以根据需要创建新线程，线程池中的线程数量会根据任务的数量自动调整。\",\"当有新任务提交时，如果线程池中有空闲的线程，则将任务分配给空闲线程执行；如果线程池中的线程都在执行任务，将创建新的线程来处理新任务。\",\"适用于短时任务较多、任务执行时间较短的场景，可以动态调整线程数量以适应任务量的变化。\",\"SingleThreadExecutor（单线程线程池）：\",\"单线程线程池只包含一个线程，所有任务按照顺序在这个线程中执行。\",\"当有新任务提交时，如果线程池中的线程空闲，则将任务分配给该线程执行；如果线程正在执行任务，新任务将在任务队列中等待。\",\"适用于需要保证任务按照顺序执行、不需要并发执行的场景，例如任务依赖性较强的场景。\",\"ScheduledThreadPool（定时任务线程池）：\",\"定时任务线程池用于执行定时任务和周期性任务，可以在指定的时间点执行任务，也可以按照固定的时间间隔执行任务。\",\"通过调用schedule()方法或scheduleAtFixedRate()方法提交定时任务或周期性任务。\",\"适用于需要执行定时任务和周期性任务的场景，例如定时任务调度、定时数据同步等。\"]},\"352\":{\"h\":\"能说一下四种常见线程池的原理吗？\"},\"353\":{\"h\":\"1.FixedThreadPool（固定大小线程池）\",\"t\":[\"// 创建固定大小线程池 public static ExecutorService newFixedThreadPool(int nThreads) { return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>()); } \",\"线程池特点 \",\"核心线程数和最大线程数大小一样\",\"没有所谓的非空闲时间，即keepAliveTime为0\",\"阻塞队列为无界队列LinkedBlockingQueue，可能会导致OOM\",\"工作流程 \",\"提交任务\",\"如果线程数少于核心线程，创建核心线程执行任务\",\"如果线程数等于核心线程，把任务添加到LinkedBlockingQueue阻塞队列\",\"如果线程执行完任务，去阻塞队列取任务，继续执行。\",\"适用场景 \",\"FixedThreadPool 适用于处理CPU密集型的任务，确保CPU在长期被工作线程使用的情况下，尽可能的少的分配线程，即适用执行长期的任务\"]},\"354\":{\"h\":\"2.CachedThreadPool（缓存线程池）\",\"t\":[\"// 创建缓存线程池 public static ExecutorService newCachedThreadPool() { return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue<Runnable>()); } \",\"线程池特点 \",\"核心线程数为0\",\"最大线程数为Integer.MAX_VALUE，即无限大，可能会因为无限创建线程，导致OOM\",\"队列是同步移交队列SynchronousQueue\",\"非核心线程空闲存活时间为60秒\",\"工作流程 \",\"提交任务\",\"因为没有核心线程，所以任务直接加到SynchronousQueue队列\",\"判断是否有空闲线程，如果有，就去取出任务执行\",\"如果没有空闲线程，就新建一个线程执行\",\"执行完任务的线程，还可以存活60秒，如果在这期间，接到任务，可以继续活下去；否则，被销毁\",\"适用场景 \",\"用于并发执行大量短期的小任务\"]},\"355\":{\"h\":\"3.SingleThreadExecutor（单线程线程池）\",\"t\":[\"// 创建单线程线程池 public static ExecutorService newSingleThreadExecutor() { return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>())); } \",\"线程池特点 \",\"核心线程数为1\",\"最大线程数也为1\",\"阻塞队列是无界队列LinkedBlockingQueue，可能会导致OOM\",\"keepAliveTime为0\",\"工作流程 \",\"提交任务\",\"线程池是否有一条线程在，如果没有，新建线程执行任务\",\"如果有，将任务加到阻塞队列\",\"当前的唯一线程，从队列取任务，执行完一个，再继续取，一个线程执行任务\",\"适用场景 \",\"适用于串行执行任务的场景，一个任务一个任务地执行\"]},\"356\":{\"h\":\"4.ScheduledThreadPool（定时任务线程池）\",\"t\":[\"// 创建定时任务线程池 public ScheduledThreadPoolExecutor(int corePoolSize) { super(corePoolSize, Integer.MAX_VALUE, DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS, new DelayedWorkQueue()); } \",\"线程池特点 \",\"最大线程数为Integer.MAX_VALUE，也有OOM的风险\",\"阻塞队列是DelayedWorkQueue\",\"keepAliveTime默认是10\",\"工作流程 \",\"线程从DelayQueue中获取已到期的ScheduledFutureTask（DelayQueue.take()）。\",\"到期任务是指ScheduledFutureTask的time大于等于当前时间\",\"适用场景 \",\"周期性执行任务的场景，需要限制线程数量的场景\"]},\"357\":{\"h\":\"线程池异常怎么处理知道吗？\",\"t\":[\"线程池异常处理是一个常见的问题，特别是在高并发或多线程应用程序中。处理线程池中的异常可以确保程序的稳定性和可靠性。以下是一些处理线程池异常的常见方法和技巧：\"]},\"358\":{\"h\":\"1. 捕获并处理异常\",\"t\":[\"在任务（Runnable 或 Callable）内部捕获并处理异常。这可以防止异常传播到线程池外部，从而避免线程池中的线程因未处理的异常而终止。\",\"ExecutorService executor = Executors.newFixedThreadPool(10); executor.submit(() -> { try { // 任务逻辑 } catch (Exception e) { // 处理异常 e.printStackTrace(); } }); \"]},\"359\":{\"h\":\"2. 自定义线程池\",\"t\":[\"创建一个自定义的线程池，通过覆盖 afterExecute 方法来处理线程执行完毕后的异常。\",\"public class CustomThreadPool extends ThreadPoolExecutor { public CustomThreadPool(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue) { super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue); } @Override protected void afterExecute(Runnable r, Throwable t) { super.afterExecute(r, t); if (t == null && r instanceof Future<?>) { try { Future<?> future = (Future<?>) r; if (future.isDone()) { future.get(); } } catch (CancellationException ce) { t = ce; } catch (ExecutionException ee) { t = ee.getCause(); } catch (InterruptedException ie) { Thread.currentThread().interrupt(); } } if (t != null) { // 处理异常 t.printStackTrace(); } } } \"]},\"360\":{\"h\":\"3. 使用 UncaughtExceptionHandler\",\"t\":[\"设置线程的 UncaughtExceptionHandler，处理未捕获的异常。\",\"ThreadFactory threadFactory = new ThreadFactory() { @Override public Thread newThread(Runnable r) { Thread thread = new Thread(r); thread.setUncaughtExceptionHandler((t, e) -> { // 处理未捕获的异常 e.printStackTrace(); }); return thread; } }; ExecutorService executor = Executors.newFixedThreadPool(10, threadFactory); \"]},\"361\":{\"h\":\"4. 使用自定义 RejectedExecutionHandler\",\"t\":[\"如果任务被拒绝执行，可以通过自定义 RejectedExecutionHandler 来处理异常情况。\",\"RejectedExecutionHandler handler = new RejectedExecutionHandler() { @Override public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) { // 处理被拒绝的任务 System.err.println(\\\"Task rejected: \\\" + r.toString()); } }; ExecutorService executor = new ThreadPoolExecutor(10, 10, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<>(100), handler); \"]},\"362\":{\"h\":\"5. 使用 CompletableFuture 处理异步任务\",\"t\":[\"对于需要处理异步任务的情况，可以使用 CompletableFuture，它提供了更加灵活的异常处理方式。\",\"CompletableFuture.runAsync(() -> { // 任务逻辑 }).exceptionally(e -> { // 处理异常 e.printStackTrace(); return null; }); \"]},\"363\":{\"h\":\"6. 使用 Callable 和 Future\",\"t\":[\"在任务内部使用 Callable，并通过 Future 来捕获和处理异常。\",\"import java.util.concurrent.*; public class FutureExceptionHandling { public static void main(String[] args) { ExecutorService executor = Executors.newFixedThreadPool(10); Callable<Integer> task = () -> { // 任务逻辑 if (true) { throw new Exception(\\\"Callable Exception\\\"); } return 42; }; Future<Integer> future = executor.submit(task); try { Integer result = future.get(); System.out.println(\\\"Task result: \\\" + result); } catch (InterruptedException e) { Thread.currentThread().interrupt(); // 恢复中断状态 e.printStackTrace(); } catch (ExecutionException e) { // 处理任务执行期间抛出的异常 e.getCause().printStackTrace(); } executor.shutdown(); } } \",\"通过这些方法，您可以有效地处理线程池中的异常，确保程序的稳定运行。选择合适的方法取决于您的具体需求和应用场景。\"]},\"364\":{\"h\":\"能说一下线程池有几种状态吗？\",\"t\":[\"线程池（Thread Pool）在执行过程中会经历多个状态，这些状态有助于管理线程池的生命周期和行为。Java 的 ThreadPoolExecutor 类定义了五种线程池状态，每种状态都表示线程池当前的不同运行阶段。以下是详细的线程池状态：\"]},\"365\":{\"h\":\"1. RUNNING\",\"t\":[\"这是线程池的初始状态。在该状态下，线程池可以接受新任务，并处理已经在队列中的任务。\",\"RUNNING \",\"特征：\",\"可以接受新任务。\",\"可以处理队列中的任务。\"]},\"366\":{\"h\":\"2. SHUTDOWN\",\"t\":[\"当调用 shutdown() 方法时，线程池进入 SHUTDOWN 状态。在该状态下，线程池不再接受新任务，但会继续执行已提交的任务和队列中等待的任务。\",\"SHUTDOWN \",\"特征：\",\"不接受新任务。\",\"继续处理已提交和队列中的任务。\"]},\"367\":{\"h\":\"3. STOP\",\"t\":[\"当调用 shutdownNow() 方法时，线程池进入 STOP 状态。在该状态下，线程池不再接受新任务，也不处理队列中的任务，并且会尝试中断正在进行的任务。\",\"STOP \",\"特征：\",\"不接受新任务。\",\"不处理队列中的任务。\",\"尝试中断正在执行的任务。\"]},\"368\":{\"h\":\"4. TIDYING\",\"t\":[\"当线程池在 SHUTDOWN 状态下完成了所有任务，或在 STOP 状态下中断了所有任务后，会进入 TIDYING 状态。在该状态下，线程池中没有活动的线程，且任务队列为空。\",\"TIDYING \",\"特征：\",\"所有任务都已完成。\",\"线程池中没有活动的线程。\"]},\"369\":{\"h\":\"5. TERMINATED\",\"t\":[\"当线程池在 TIDYING 状态下完成终止操作后，会进入 TERMINATED 状态。这是线程池的最终状态，表示线程池已经完全终止。\",\"TERMINATED \",\"特征：\",\"线程池完全终止。\",\"不再有任何活动线程。\"]},\"370\":{\"h\":\"状态转换图\",\"t\":[\"以下是线程池状态的转换图：\"]},\"371\":{\"h\":\"线程池如何实现参数的动态修改？\",\"t\":[\"下面是对答案的一些完善和补充：\",\"使用可调整的线程池（ThreadPoolExecutor）确实是一种常见的方式。通过调用 ThreadPoolExecutor 的构造函数或者提供的方法，可以动态地调整线程池的参数。例如，可以使用 setCorePoolSize()、setMaximumPoolSize()、setQueue() 方法来修改核心线程数、最大线程数以及任务队列等参数。\",\"使用动态代理也是一种有效的方式。通过在代理类中封装线程池，并在代理类中提供方法来动态修改线程池的参数，可以实现更灵活的控制。这种方式可以通过反射机制来实现，但需要一些额外的编码工作。\",\"使用配置文件是一种常见的方式，特别适用于需要频繁调整参数的情况。将线程池的参数配置在外部的配置文件或者配置中心中，可以实现在不修改代码的情况下动态修改线程池的参数。这种方式使得参数的修改更加便捷，并且可以配合其他配置管理工具来实现自动化管理。\",\"使用管理平台是一种更高级的方式，可以提供可视化界面让用户方便地修改线程池的参数，并实时查看线程池的状态和性能指标。管理平台可以根据实际需求提供各种功能，如监控、报警、日志记录等，帮助用户更好地管理线程池。\"]},\"372\":{\"h\":\"线程池调优了解吗？\",\"t\":[\"事前评估： 在上线之前，通过对系统负载、任务类型和处理速度等进行评估，确定合适的线程池配置。这包括确定核心线程数、最大线程数、任务队列类型和大小等参数。评估的目的是为了在上线之前就能够预估系统的负载情况，并针对性地配置线程池，以满足系统的性能需求和稳定性要求。\",\"测试： 在上线之前进行充分的测试，包括功能测试、性能测试、压力测试等。通过测试可以验证线程池的配置是否合理，是否能够满足系统的性能和稳定性要求。如果测试发现线程池存在性能瓶颈或者稳定性问题，需要及时调整配置并重新测试，直到达到预期的效果。\",\"监控机制： 在上线之后建立完善的线程池监控机制，包括监控线程池的运行状态、性能指标、任务执行情况等。监控机制可以帮助及时发现线程池的问题，如线程池过载、任务堆积、线程死锁等，并采取相应的措施进行处理。\",\"告警机制： 结合监控机制建立告警机制，及时发现线程池的异常情况，并发送告警通知给相关人员进行处理。告警机制可以帮助及时发现线程池的问题，避免问题进一步恶化。\",\"事中分析优化： 结合监控告警机制，分析线程池的问题或者可优化点，根据实际情况动态调整线程池的配置。这包括调整核心线程数、最大线程数、任务队列大小等参数，以适应系统的动态变化和优化性能。\",\"事后观察调整： 在线程池上线之后，需要仔细观察线程池的运行情况，随时调整线程池的配置，以确保线程池能够始终保持良好的性能和稳定性。\",\"通过以上评估方案，可以有效地管理和调优线程池的配置，保障系统的性能和稳定性，提高系统的可靠性和可维护性。\"]},\"373\":{\"h\":\"你能设计实现一个线程池吗？\",\"t\":[\"当然可以。以下是一个简单的线程池的设计和实现，包括线程池的初始化、任务提交、线程执行任务、线程池关闭等基本功能：\",\"import java.util.concurrent.BlockingQueue; import java.util.concurrent.LinkedBlockingQueue; public class CustomThreadPool { private final int poolSize; private final WorkerThread[] workers; private final BlockingQueue<Runnable> taskQueue; public CustomThreadPool(int poolSize) { this.poolSize = poolSize; taskQueue = new LinkedBlockingQueue<>(); workers = new WorkerThread[poolSize]; for (int i = 0; i < poolSize; i++) { workers[i] = new WorkerThread(); workers[i].start(); } } public void submit(Runnable task) { try { taskQueue.put(task); } catch (InterruptedException e) { Thread.currentThread().interrupt(); } } public void shutdown() { for (WorkerThread worker : workers) { worker.stopWorker(); } } private class WorkerThread extends Thread { private volatile boolean running = true; @Override public void run() { while (running) { try { Runnable task = taskQueue.take(); task.run(); } catch (InterruptedException e) { running = false; Thread.currentThread().interrupt(); } } } public void stopWorker() { running = false; interrupt(); } } // 测试 public static void main(String[] args) { CustomThreadPool threadPool = new CustomThreadPool(3); // 提交任务 for (int i = 0; i < 5; i++) { final int taskId = i; threadPool.submit(() -> { System.out.println(\\\"Task \\\" + taskId + \\\" is running on thread: \\\" + Thread.currentThread().getName()); try { Thread.sleep(1000); } catch (InterruptedException e) { Thread.currentThread().interrupt(); } System.out.println(\\\"Task \\\" + taskId + \\\" is completed.\\\"); }); } // 关闭线程池 threadPool.shutdown(); } } \",\"这个简单的线程池实现了基本的功能，包括线程池的初始化、任务提交、线程执行任务、线程池关闭等。你可以根据实际需求和场景进一步扩展和优化这个线程池的实现。\"]},\"374\":{\"h\":\"单机线程池执行断电了应该怎么处理？\",\"t\":[\"当单机线程池执行断电时，系统无法继续执行任务，因此需要一些机制来处理这种情况，以确保任务的一致性和可靠性。以下是处理单机线程池断电情况的一般策略：\",\"持久化任务队列： 将任务队列中的任务持久化到可靠的存储介质中，例如数据库、磁盘文件等。这样即使发生断电，任务队列中的任务数据也不会丢失。\",\"事务性执行任务： 在执行任务时，确保任务操作是原子性的，即要么任务执行成功，要么任务执行失败需要回滚。可以使用事务管理的机制来实现这一点。\",\"日志记录和回滚： 在执行任务之前和之后，记录任务的执行日志。当系统发生断电时，根据任务执行日志来回滚已经执行成功但未持久化的任务，以保证任务的一致性和可靠性。\",\"系统重启后的处理： 当系统重新启动时，可以重新加载持久化的任务队列，并根据任务执行日志来恢复任务的执行状态。然后继续执行任务队列中的任务。\",\"综上所述，通过持久化任务队列、事务性执行任务、日志记录和回滚等机制，可以确保单机线程池在断电情况下的任务一致性和可靠性。\"]},\"375\":{\"h\":\"线程池并发调用api，有个调用特别耗时，怎么优化？\",\"t\":[\"当线程池中存在一个调用特别耗时的 API 时，可能会影响到整个线程池的性能和响应速度。为了优化这种情况，可以考虑以下几种策略：\",\"异步调用： 将耗时的 API 调用改为异步调用，即将任务提交到线程池后立即返回，并在后台执行耗时的操作。这样可以避免阻塞线程池中的其他任务，提高线程池的并发能力。\",\"任务拆分： 将耗时的操作拆分为多个小任务，并将这些小任务分配给线程池中的多个线程并行执行。这样可以利用多个线程同时执行任务，提高任务的并发性和执行效率。\",\"限制并发数： 对耗时的 API 调用进行限流，限制同时执行的任务数量，避免线程池中的任务过多导致资源耗尽和性能下降。可以使用信号量或者线程池的控制参数来实现并发数的限制。\",\"超时机制： 对耗时的 API 调用设置超时时间，如果调用超过预设的时间仍未返回结果，则取消调用并释放资源。这样可以避免线程被长时间阻塞，提高线程池的响应速度。\",\"缓存结果： 对于频繁调用且结果稳定的耗时 API，可以将调用结果缓存起来，避免重复调用同一个耗时操作。这样可以减少对耗时 API 的调用次数，提高系统的性能和响应速度。\",\"优化算法： 对耗时的操作进行算法上的优化，减少其执行时间。可以使用更高效的算法、数据结构或者并行计算等技术来优化耗时操作的执行效率。\",\"综上所述，通过异步调用、任务拆分、限制并发数、超时机制、缓存结果和优化算法等策略，可以有效优化线程池中调用特别耗时的 API，提高线程池的性能和响应速度。\"]},\"376\":{\"h\":\"Fork/Join框架了解吗？\",\"t\":[\"Fork/Join框架是Java7提供的一个用于并行执行任务的框架，是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。\",\"要想掌握Fork/Join框架，首先需要理解两个点，分而治之和工作窃取算法。\",\"分而治之 \",\"Fork/Join框架的定义，其实就体现了分治思想：将一个规模为N的问题分解为K个规模较小的子问题，这些子问题相互独立且与原问题性质相同。求出子问题的解，就可得到原问题的解。\",\"工作窃取算法 \",\"大任务拆成了若干个小任务，把这些小任务放到不同的队列里，各自创建单独线程来执行队列里的任务。 那么问题来了，有的线程干活块，有的线程干活慢。干完活的线程不能让它空下来，得让它去帮没干完活的线程干活。它去其它线程的队列里窃取一个任务来执行，这就是所谓的工作窃取。\",\"工作窃取发生的时候，它们会访问同一个队列，为了减少窃取任务线程和被窃取任务线程之间的竞争，通常任务会使用双端队列，被窃取任务线程永远从双端队列的头部拿，而窃取任务的线程永远从双端队列的尾部拿任务执行\",\"Fork/Join框架的工作原理如下：\",\"任务分解（Fork）： 当一个大任务到来时，Fork/Join框架会将这个大任务拆分成若干个小任务，直到拆分的任务足够小而可以被快速处理为止。这个过程是递归的，直到达到拆分任务的终止条件。\",\"任务执行（Join）： 拆分出的小任务会被分配给线程池中的工作线程执行。每个工作线程会不断地从任务队列中获取任务并执行，直到任务队列为空为止。\",\"结果合并： 当一个线程执行完一个小任务后，会将其结果合并到大任务的结果中。这个过程也是递归的，直到所有小任务的结果都被合并到大任务的结果中为止。\",\"Fork/Join框架的关键组件包括：\",\"ForkJoinPool： ForkJoinPool是Fork/Join框架的线程池实现，管理着一组工作线程，用于执行Fork/Join任务。ForkJoinPool实现了工作窃取算法，使得任务能够动态地分配给空闲的线程，提高了线程的利用率和任务的并行性。\",\"ForkJoinTask： ForkJoinTask是Fork/Join框架中表示任务的抽象类，有两个主要的子类：RecursiveTask用于表示有返回值的任务，和RecursiveAction用于表示没有返回值的任务。开发者可以继承ForkJoinTask类来定义自己的任务。\",\"下面是一个简单的示例代码，演示了如何使用Fork/Join框架来计算斐波那契数列的值：\",\"import java.util.concurrent.RecursiveTask; public class FibonacciTask extends RecursiveTask<Integer> { private final int n; public FibonacciTask(int n) { this.n = n; } @Override protected Integer compute() { if (n <= 1) { return n; } else { FibonacciTask task1 = new FibonacciTask(n - 1); FibonacciTask task2 = new FibonacciTask(n - 2); task1.fork(); int result2 = task2.compute(); int result1 = task1.join(); return result1 + result2; } } public static void main(String[] args) { FibonacciTask task = new FibonacciTask(10); int result = task.compute(); System.out.println(\\\"Fibonacci(10) = \\\" + result); } } \",\"以上代码示例演示了如何使用Fork/Join框架来计算斐波那契数列的值。下面是对代码示例的解释：\",\"FibonacciTask 类继承了 RecursiveTask<Integer> 类，表示这是一个有返回值的递归任务，返回值类型为 Integer。\",\"在 FibonacciTask 类中，有一个私有的成员变量 n，表示要计算斐波那契数列的第 n 个数。\",\"compute() 方法是 RecursiveTask 类的抽象方法，需要子类来实现。在 FibonacciTask 类中，我们重写了 compute() 方法来定义具体的任务逻辑。\",\"在 compute() 方法中，首先判断当前要计算的斐波那契数列的位置 n 是否小于等于1。如果是，直接返回 n，因为斐波那契数列的第一个数和第二个数都是1。\",\"如果 n 大于1，则将问题拆分成两个子任务，分别计算第 n-1 和第 n-2 个斐波那契数。使用 FibonacciTask 类自身的构造函数创建两个新的任务对象。\",\"调用 fork() 方法提交第一个子任务给线程池执行，并直接在当前线程中执行第二个子任务的 compute() 方法。\",\"在执行第二个子任务的过程中，如果需要继续拆分任务，则会递归调用 compute() 方法，直到计算到基本情况。\",\"使用 join() 方法等待第一个子任务的执行结果，然后将第一个子任务和第二个子任务的结果相加，得到当前位置的斐波那契数。\",\"在 main() 方法中，创建一个 FibonacciTask 对象，表示要计算斐波那契数列的第10个数。\",\"调用 compute() 方法开始执行任务，得到斐波那契数列的第10个数的值，并输出结果。\",\"在这个示例中，我们定义了一个继承自RecursiveTask<Integer>的FibonacciTask类，用于计算斐波那契数列的值。在compute()方法中，如果n的值小于等于1，则直接返回n；否则，将问题拆分成两个子任务并使用fork()方法提交给线程池执行，并通过join()方法等待子任务的完成并合并结果。\"]},\"377\":{\"h\":\"锁\"},\"378\":{\"h\":\"synchronized用过吗？怎么使用？\",\"t\":[\"修饰实例方法\",\"作用于当前对象实例加锁，进入同步代码前要获得 当前对象实例的锁\",\"synchronized void method() { //业务代码 } \",\"修饰静态方法\",\"也就是给当前类加锁，会作⽤于类的所有对象实例 ，进⼊同步代码前要获得当前 class 的锁\",\"因为静态成员不属于任何⼀个实例对象，是类成员（ static 表明这是该类的⼀个静态资源，不管 new 了多少个对象，只有⼀份）\",\"synchronized void staic method() { //业务代码 } \",\"修饰代码块\",\"指定加锁对象，对给定对象/类加锁。\",\"synchronized(this|object) 表示进⼊同步代码库前要获得给定对象的锁。\",\"synchronized(类.class) 表示进⼊同步代码前要获得 当前 class 的锁\",\"synchronized(this) { //业务代码 } \"]},\"379\":{\"h\":\"synchronized的实现原理？\"},\"380\":{\"h\":\"synchronized是怎么加锁的呢？\",\"t\":[\"synchronized修饰代码块时 \",\"JVM采用 monitorenter 、 monitorexit 两个指令来实现同步\",\"monitorenter 指令指向同步代码块的开始位置\",\"monitorexit 指令则指向同步代码块的结束位置\",\"ynchronized修饰同步方法时 \",\"JVM采用 ACC_SYNCHRONIZED 标记符来实现同步，这个标识指明了该方法是一个同步方法\"]},\"381\":{\"h\":\"synchronized锁住的是什么呢？\",\"t\":[\"monitorenter、monitorexit或者ACC_SYNCHRONIZED，其实都是基于对象的内置锁（Intrinsic Lock）或称为监视器锁（Monitor Lock）\",\"每个对象都有一个内置锁\",\"当一个线程获取了对象的内置锁时，其他线程必须等待该线程释放锁后才能获取锁\",\"这样就保证了同一时间只有一个线程能够访问该对象的同步代码块或同步方法\",\"ObjectMonitor的工作原理\",\"ObjectMonitor有两个队列： _ WaitSet、 _ EntryList，用来保存ObjectWaiter 对象列表\",\"_owner，获取 Monitor 对象的线程进入 _owner 区时， _count + 1。如果线程调用了 wait() 方法，此时会释放 Monitor 对象， _owner 恢复为空， _count - 1。同时该等待线程进入 _WaitSet 中，等待被唤醒\",\"ObjectMonitor() { _header = NULL; _count = 0; // 记录线程获取锁的次数 _waiters = 0, _recursions = 0; //锁的重入次数 _object = NULL; _owner = NULL; // 指向持有ObjectMonitor对象的线程 _WaitSet = NULL; // 处于wait状态的线程，会被加入到 _WaitSet _WaitSetLock = 0 ; _Responsible = NULL ; _succ = NULL ; _cxq = NULL ; FreeNext = NULL ; _EntryList = NULL ; // 处于等待锁block状态的线程，会被加入 到该列表 _SpinFreq = 0 ; _SpinClock = 0 ; OwnerIsThread = 0 ; } \",\"所以我们就知道了，同步是锁住的什么东西\",\"monitorenter，在判断拥有同步标识 ACC_SYNCHRONIZED 抢先进入此方法的线程会优先拥有 Monitor 的 owner ，此时计数器 +1\",\"monitorexit，当执行完退出后，计数器 -1，归 0 后被其他进入的线程获得。\"]},\"382\":{\"h\":\"除了原子性，synchronized可见性，有序性，可重入性怎么实现？\"},\"383\":{\"h\":\"synchronized怎么保证可见性？\",\"t\":[\"线程加锁前，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新读取最新的值\",\"线程加锁后，其它线程无法获取主内存中的共享变量\",\"线程解锁前，必须把共享变量的最新值刷新到主内存中\"]},\"384\":{\"h\":\"synchronized怎么保证有序性？\",\"t\":[\"synchronized同步的代码块，具有排他性，一次只能被一个线程拥有，所以synchronized保证同一时刻，代码是单线程执行的 \",\"因为as-if-serial语义的存在，单线程的程序能保证最终结果是有序的，但是不保证不会指令重排\",\"所以synchronized保证的有序是执行结果的有序性，而不是防止指令重排的有序性\"]},\"385\":{\"h\":\"synchronized怎么实现可重入的呢？\",\"t\":[\"synchronized 是可重入锁，也就是说，允许一个线程二次请求自己持有对象锁的临界资源，这种情况称为可重入锁\",\"synchronized 锁对象的时候有个计数器，他会记录下线程获取锁的次数，在执行完对应的代码块之后，计数器就会-1，直到计数器清零，就释放锁了\"]},\"386\":{\"h\":\"锁升级？synchronized优化了解吗？\",\"t\":[\"锁的状态\",\"Mark Word 标记字段记录着锁的状态\",\"Java对象头里，有一块结构，叫 Mark Word 标记字段，记录着锁的状态，这块结构会随着锁的状态变化而变化\",\"64 位虚拟机 Mark Word 是 64bit，我们来看看它的状态变化\",\"Mark Word存储对象自身的运行数据，如哈希码、GC分代年龄、锁状态标志、偏向时间戳（Epoch） 等\"]},\"387\":{\"h\":\"synchronized做了哪些优化？\",\"t\":[\"在JDK1.6之前 \",\"在JDK1.6之前synchronized的实现直接调用ObjectMonitor的enter和exit，这种锁被称之为重量级锁\",\"从JDK6开始 \",\"从JDK6开始HotSpot虚拟机开发团队对Java中的锁进行优化，如增加了适应性自旋、锁消除、锁粗化、轻量级锁和偏向锁等优化策略，提升了synchronized的性能\",\"偏向锁 \",\"在无竞争的情况下，只是在Mark Word里存储当前线程指针，CAS操作都不做\",\"在没有多线程竞争时，相对重量级锁，减少操作系统互斥量带来的性能消耗。但是，如果存在锁竞争，除了互斥量本身开销，还额外有CAS操作的开销\",\"自旋锁 \",\"减少不必要的CPU上下文切换。在轻量级锁升级为重量级锁时，就使用了自旋加锁的方式\",\"锁粗化 \",\"将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁\",\"锁消除 \",\"虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除\"]},\"388\":{\"h\":\"锁升级的过程是什么样的？\",\"t\":[\"锁升级方向：无锁-->偏向锁---> 轻量级锁---->重量级锁，这个方向基本上是不可逆的\"]},\"389\":{\"h\":\"偏向锁\",\"t\":[\"偏向锁的获取 \",\"判断是否为可偏向状态--MarkWord中锁标志是否为‘01’，偏向锁标记是否为‘1‘\",\"如果是可偏向状态，则查看线程ID是否为当前线程，如果是，则进入步骤'5'，否则进入步骤‘3’\",\"通过CAS操作竞争锁，如果竞争成功，则将MarkWord中线程ID设置为当前线程ID，然后执行‘5’；竞争失败，则执行‘4’\",\"CAS获取偏向锁失败表示有竞争。当达到safepoint时获得偏向锁的线程被挂起，偏向锁升级为轻量级锁 ，然后被阻塞在安全点的线程继续往下执行同步代码块\",\"执行同步代码\",\"偏向锁的撤销 \",\"偏向锁不会主动释放(撤销)，只有遇到其他线程竞争时才会执行撤销，由于撤销需要知道当前持有该偏向锁的线程栈状态，因此要等到safepoint时执行，此时持有该偏向锁的线程（T）有‘2’，‘3’两种情况\",\"撤销 \",\"T线程已经退出同步代码块，或者已经不再存活，则直接撤销偏向锁，变成无锁状态----该状态达到阈值20则执行批量重偏向\",\"升级 \",\"T线程还在同步代码块中，则将T线程的偏向锁 升级为轻量级锁 ，当前线程执行轻量级锁状态下的锁获取步骤----该状态达到阈值40则执行批量撤销\"]},\"390\":{\"h\":\"轻量级锁\",\"t\":[\"轻量级锁的获取\",\"进行加锁操作时，jvm会判断是否已经是重量级锁，如果不是，则会在当前线程栈帧中划出一块空间，作为该锁的锁记录，并且将锁对象MarkWord复制到该锁记录中\",\"复制成功之后，jvm使用CAS操作将对象头MarkWord更新为指向锁记录的指针，并将锁记录里的owner指针指向对象头的MarkWord。如果成功，则执行‘3’，否则执行‘4’\",\"更新成功，则当前线程持有该对象锁，并且对象MarkWord锁标志设置为‘00’，即表示此对象处于轻量级锁状态\",\"更新失败，jvm先检查对象MarkWord是否指向当前线程栈帧中的锁记录，如果是则执行‘5’，否则执行6 ’\",\"表示锁重入；然后当前线程栈帧中增加一个锁记录第一部分（Displaced Mark Word）为null，并指向Mark Word的锁对象，起到一个重入计数器的作用。\",\"表示该锁对象已经被其他线程抢占，则进行 自旋等待 （默认10次），等待次数达到阈值仍未获取到锁，则 升级为重量级锁\",\"简略的锁升级过程\",\"完整的升级过程\"]},\"391\":{\"h\":\"说说synchronized和ReentrantLock的区别？\",\"t\":[\"锁的实现 \",\"synchronized是Java语言的关键字，基于JVM实现\",\"ReentrantLock是基于JDK的API层面实现的（一般是lock()和unlock()方法配合try/finally 语句块来完成。）\",\"性能 \",\"在JDK1.6锁优化以前，synchronized的性能比ReenTrantLock差很多\",\"但是JDK6开始，增加了适应性自旋、锁消除等，两者性能就差不多了\",\"功能特点 \",\"ReentrantLock 比 synchronized 增加了一些高级功能，如等待可中断、可实现公平锁、可实现选择性通知 \",\"ReentrantLock提供了一种能够中断等待锁的线程的机制，通过lock.lockInterruptibly()来实现这个机制\",\"ReentrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。\",\"synchronized与wait()和notify()/notifyAll()方法结合实现等待/通知机制，ReentrantLock类借助Condition接口与newCondition()方法实现\",\"ReentrantLock需要手工声明来加锁和释放锁，一般跟finally配合释放锁。而synchronized不用手动释放锁\"]},\"392\":{\"h\":\"AQS了解多少？\",\"t\":[\"AbstractQueuedSynchronizer 抽象同步队列，简称 AQS ，它是Java并发包的根基，并发包中的锁就是基于AQS实现的，是Java并发面试的高频题目\",\"AQS是一个一个FIFO的双向队列，Node节点中的thread变量用来存放进入AQS队列里的线程，SHARED表示是获取共享资源时被阻塞挂起后放入AQS队列的，EXCLUSIVE表示是获取独占资源时被挂起后放入AQS队列的\",\"AQS 使用一个 volatile 修饰的 int 类型的成员变量 state 来表示同步状态，修改同步状态成功即为获得锁 ，volatile 保证了变量在多线程之间的可见性，修改 state值时通过 CAS 机制来保证修改的原子性\",\"获取state的方式分为两种，\",\"独占方式 tryAcquire() \",\"一个线程使用独占方式获取了资源，其它线程就会在获取失败后被阻塞。\",\"抽象方法，需要子类自行实现\",\"共享方式tryAcquireShared() \",\"一个线程使用共享方式获取了资源，另外一个线程还可以通过CAS的方式进行获取\",\"抽象方法，需要子类自行实现\",\"如果共享资源被占用，需要一定的阻塞等待唤醒机制来保证锁的分配，AQS 中会将竞争共享资源失败的线程添加到队列中，线程进入队列后会进行自旋，自旋一定次数后，会使用LockSupport.park()进入阻塞状态\",\"获取到锁的线程可以重入，每重入一次，state+1，释放资源的时候，会使用CAS操作将state修改为0，重入多少次，释放多少次，并使用LockSupport.unpark()唤醒处于等待状态的线程\"]},\"393\":{\"h\":\"ReentrantLock实现原理？\",\"t\":[\"ReentrantLock通过Sync类，间接继承了AQS\",\"它是可重入的独占锁，只能有一个线程可以获取该锁，其它获取该锁的线程会被阻塞而被放入该锁的阻塞队列里面\",\"new ReentrantLock() 构造函数默认创建的是非公平锁 NonfairSync\"]},\"394\":{\"h\":\"公平锁 FairSync\",\"t\":[\"公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁\",\"公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU 唤醒阻塞线程的开销比非公平锁大\"]},\"395\":{\"h\":\"非公平锁 NonfairSync\",\"t\":[\"非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁\",\"非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU 不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁\"]},\"396\":{\"h\":\"Lock()的执行过程\",\"t\":[\"如果锁当前没有被其它线程占用，并且当前线程之前没有获取过该锁，则当前线程会获取到该锁，然后设置当前锁的拥有者为当前线程，并设置 AQS 的状态值为1 ，然后直接返回。\",\"如果当前线程之前己经获取过该锁，则这次只是简单地把AQS 的状态值加1后返回。\",\"如果该锁己经被其他线程持有，非公平锁会尝试去获取锁，获取失败的话，则调用该方法线程会被放入 AQS 队列阻塞挂起。\"]},\"397\":{\"h\":\"ReentrantLock怎么实现公平锁的？\",\"t\":[\"new ReentrantLock() 构造函数默认创建的是非公平锁 NonfairSync\",\"public ReentrantLock() { sync = new NonfairSync(); } \",\"同时也可以在创建锁构造函数中传入具体参数创建公平锁 FairSync\",\"ReentrantLock lock = new ReentrantLock(true); --- ReentrantLock // true 代表公平锁，false 代表非公平锁 public ReentrantLock(boolean fair) { sync = fair ? new FairSync() : new NonfairSync(); } \",\"FairSync、NonfairSync 代表公平锁和非公平锁，两者都是 ReentrantLock 静态内部类，只不过实现不同锁语义\",\"非公平锁和公平锁的两处不同\",\"非公平锁在调用 lock 后，首先就会调用 CAS 进行一次抢锁，如果这个时候恰巧锁没有被占用，那么直接就获取到锁返回了\",\"非公平锁在 CAS 失败后，和公平锁一样都会进入到 tryAcquire 方法，在tryAcquire 方法中，如果发现锁这个时候被释放了（state == 0），非公平锁会直接 CAS 抢锁，但是公平锁会判断等待队列是否有线程处于等待状态，如果有则不去抢锁，乖乖排到后面\",\"相对来说，非公平锁会有更好的性能，因为它的吞吐量比较大。当然，非公平锁让获取锁的时间变得更加不确定，可能会导致在阻塞队列中的线程长期处于饥饿状态\"]},\"398\":{\"h\":\"什么是CAS?\",\"t\":[\"CAS（Compare And Swap）是一种原子操作，用于实现多线程环境下的同步操作\",\"CAS 操作包含三个操作数：内存位置（V）、旧的预期值（A）和新值（B）\",\"当且仅当预期值 A 和内存位置 V 的值相同时，CAS 会将内存位置 V 的值更新为新值B\",\"CAS 的操作过程如下 \",\"比较：比较内存位置 V 的当前值是否等于预期值 A \",\"如果相等，说明内存位置 V 的值没有被其他线程改变，继续执行第2步\",\"如果不相等，说明内存位置 V 的值已经被其他线程改变，CAS 操作失败，返回 false\",\"交换：将内存位置 V 的值更新为新值 B，CAS 操作成功，返回 true\"]},\"399\":{\"h\":\"CAS 有什么问题？如何解决？\",\"t\":[\"ABA 问题\",\"循环性能开销\",\"只能保证一个变量的原子操作\"]},\"400\":{\"h\":\"ABA 问题\",\"t\":[\"A ->B ->A\",\"并发环境下，假设初始条件是A，去修改数据时，发现是A就会执行修改\",\"但是看到的虽然是A，中间可能发生了A变B，B又变回A的情况\",\"此时A已经非彼A，数据即使成功修改，也可能有问题\"]},\"401\":{\"h\":\"怎么解决ABA问题？\",\"t\":[\"加版本号\",\"使用AtomicStampReference类\",\"Java提供了AtomicStampReference类，它的compareAndSet方法首先检查当前的对象引用值是否等于预期引用，并且当前印戳（Stamp）标志是否等于预期标志，如果全部相等，则以原子方式将引用值和印戳标志的值更新为给定的更新值\",\"通过native方法实现以原子方式将引用值和印戳标志的值更新为给定的更新值\",\" private boolean casPair(Pair<V> cmp, Pair<V> val) { return PAIR.compareAndSet(this, cmp, val); } \",\" public final native @MethodHandle.PolymorphicSignature @IntrinsicCandidate boolean compareAndSet(Object... args); \"]},\"402\":{\"h\":\"循环性能开销\",\"t\":[\"自旋CAS，如果一直循环执行，一直不成功，会给CPU带来非常大的执行开销\"]},\"403\":{\"h\":\"怎么解决循环性能开销问题？\",\"t\":[\"在Java中，很多使用自旋CAS的地方，会有一个自旋次数的限制，超过一定次数，就停止自旋\"]},\"404\":{\"h\":\"只能保证一个变量的原子操作\",\"t\":[\"CAS 保证的是对一个变量执行操作的原子性，如果对多个变量操作时，CAS 目前无法直接保证操作的原子性的\",\"可以考虑合并多个变量，将多个变量封装成一个对象，通过AtomicReference来保证原子性。\"]},\"405\":{\"h\":\"Java有哪些保证原子性的方法？如何保证多线程下i++ 结果正确？\",\"t\":[\"使用循环原子类，例如AtomicInteger，实现i++原子操作\",\"使用juc包下的锁，如ReentrantLock ，对i++操作加锁lock.lock()来实现原子性\",\"使用synchronized，对i++操作加锁\"]},\"406\":{\"h\":\"原子操作类了解多少？\",\"t\":[\"原子操作类是Java提供的一组线程安全的工具类，用于在多线程环境下保证共享变量的操作是原子性的\",\"原子操作类一般都是通过底层的CAS（Compare and Swap）操作来实现的\",\"Java中提供了多种原子操作类，如AtomicBoolean、AtomicInteger、AtomicLong、AtomicReference等，这些类都提供了一些原子操作方法，如getAndIncrement()、compareAndSet()、getAndSet()等，这些方法都是原子性的，可以保证对变量的操作是线程安全的\",\"原子操作类的优点在于，它们提供了一种更高效的线程安全机制，不需要像synchronized关键字那样对整个代码块进行加锁，而是只对需要进行原子操作的代码进行了保护，从而提高了程序的并发性能\"]},\"407\":{\"h\":\"AtomicInteger 的原理？\",\"t\":[\"使用自旋+CAS实现\",\"以AtomicInteger的添加方法为例\",\" public final int getAndDecrement() { return U.getAndAddInt(this, VALUE, -1); } \",\" public final int getAndAddInt(Object o, long offset, int delta) { int v; do { v = getIntVolatile(o, offset); } while (!weakCompareAndSetInt(o, offset, v, v + delta)); return v; } \",\" public final boolean weakCompareAndSetInt(Object o, long offset, int expected, int x) { return compareAndSetInt(o, offset, expected, x); } \",\" public final native boolean compareAndSetInt(Object o, long offset, int expected, int x); \",\"compareAndSetInt是个native方法，\",\"基于CAS来操作int类型变量。其它的原子操作类基本都是大同小异\"]},\"408\":{\"h\":\"线程死锁了解吗？该如何避免？\",\"t\":[\"死锁 \",\"死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的互相等待的现象，在无外力作用的情况下，这些线程会一直相互等待而无法继续运行下去\",\"死锁产生的四个条件 \",\"互斥条件 \",\"指线程对己经获取到的资源进行排它性使用，即该资源同时只由一个线程占用\",\"如果此时还有其它线程请求获取获取该资源，则请求者只能等待，直至占有资源的线程释放该资源\",\"请求并持有 \",\"持有一个资源的同时请求一个新资源\",\"指一个 线程己经持有了至少一个资源，但又提出了新的资源请求，而新资源己被其它线程占有，所以当前线程会被阻塞，但阻塞 的同时并不释放自己已经获取的资源\",\"不可剥夺条件 \",\"指线程获取到的资源在自己使用完之前不能被其它线程抢占，只有在自己使用完毕后才由自己释放该资源\",\"环路等待条件 \",\"形成了一个等待环路，使得每个线程都在等待下一个线程占有的资源，从而形成循环等待\",\"该如何避免死锁呢？ 答案是至少破坏死锁发生的一个条件 \",\"其中，互斥这个条件我们没有办法破坏，因为用锁为的就是互斥。不过其他三个条件都是有办法破坏掉的，到底如何做呢？\",\"对于“请求并持有”这个条件，可以一次性请求所有的资源\",\"对于“不可剥夺”这个条件，占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源，然后重新尝试，这样不可抢占这个条件就破坏掉了。 \",\"如何做到的？ \",\"超时机制：在获取资源时设置超时，如果超过一定时间没有获取到资源，则释放已持有的资源，并重试或采取其他措施。\",\"对于“环路等待”这个条件，可以靠按序申请资源来预防。所谓按序申请，是指资源是有线性顺序的，申请的时候可以先申请资源序号小的，再申请资源序号大的，这样线性化后就不存在环路了\"]},\"409\":{\"h\":\"死锁问题怎么排查呢？\",\"t\":[\"可以使用JDK自带的命令行工具排查 \",\"使用jps查找运行的Java进程：jps -l\",\"使用jstack查看线程堆栈信息：jstack -l 进程id\",\"还可以利用图形化工具，比如JConsole \",\"出现线程死锁以后，点击JConsole线程面板的 检测到死锁 按钮，将会看到线程的死锁信息\",\"死锁检测算法 \",\"可以使用图算法如找环算法来检测死锁\",\"死锁恢复 \",\"终止死锁进程：强制终止一个或多个进程，释放它们持有的资源。\",\"资源剥夺：从一些死锁进程中剥夺资源，将这些资源分配给其他等待进程\"]},\"410\":{\"h\":\"List\"},\"411\":{\"h\":\"ArrayList和LinkedList有什么区别？\",\"t\":[\"数据结构不同 \",\"ArrayList基于数组实现\",\"LinkedList基于双向链表实现\",\"多数情况下，ArrayList更利于查找，LinkedList更利于增删 \",\"查找速率 \",\"ArrayList基于数组实现，get(int index)可以直接通过数组下标获取，时间复杂度是O(1)\",\"LinkedList基于链表实现，get(int index)需要遍历链表，时间复杂度是O(n)\",\"get(E element)这种查找，两种集合都需要遍历，时间复杂度都是O(n)\",\"增删速率 \",\"ArrayList增删如果是数组末尾的位置，直接插入或者删除就可以了，但是如果插入中间的位置，就需要把插入位置后的元素都向前或者向后移动，甚至还有可能触发扩容\",\"双向链表的插入和删除只需要改变前驱节点、后继节点和插入节点的指向就行了，不需要移动元素\",\"是否支持随机访问 \",\"ArrayList基于数组，所以它可以根据下标查找，支持随机访问 \",\"它也实现了RandmoAccess 接口，这个接口只是用来标识是否支持随机访问\",\"LinkedList基于链表，所以它没法根据序号直接获取元素，它没有实现RandmoAccess 接口，标记不支持随机访问\",\"内存占用 \",\"ArrayList基于数组，是一块连续的内存空间 \",\"ArrayList是预先定义好的数组，可能会有空的内存空间，存在一定空间浪费\",\"LinkedList基于链表，内存空间不连续，它们在空间占用上都有一些额外的消耗 \",\"LinkedList每个节点，需要存储前驱和后继，所以每个节点会占用更多的空间\"]},\"412\":{\"h\":\"ArrayList的扩容机制了解吗？\",\"t\":[\"数组满了，再插入时，触发扩容\",\"计算新数组容量，容量大小为原数组1.5倍\",\" private int newCapacity(int minCapacity) { // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity >> 1); if (newCapacity - minCapacity <= 0) { if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) return Math.max(DEFAULT_CAPACITY, minCapacity); if (minCapacity < 0) // overflow throw new OutOfMemoryError(); return minCapacity; } return (newCapacity - MAX_ARRAY_SIZE <= 0) ? newCapacity : hugeCapacity(minCapacity); } \",\"int newCapacity = oldCapacity + (oldCapacity >> 1);\",\"复制原数组元素到新数组\"]},\"413\":{\"h\":\"ArrayList怎么序列化的知道吗？ 为什么用transient修饰数组？\",\"t\":[\"ArrayList的序列化不太一样，它使用 transient 修饰存储元素的 elementData 的数组\",\"transient 关键字的作用是让被修饰的成员属性不被序列化\"]},\"414\":{\"h\":\"为什么最ArrayList不直接序列化元素数组呢？\",\"t\":[\"出于效率的考虑 \",\"数组可能长度100，但实际只用了50，剩下的50不用其实不用序列化，这样可以提高序列化和反序列化的效率，还可以节省内存空间\"]},\"415\":{\"h\":\"那ArrayList怎么序列化呢 ？\",\"t\":[\"ArrayList通过两个方法readObject、writeObject自定义序列化和反序列化策略，实际直接使用两个流 ObjectOutputStream 和 ObjectInputStream 来进行序列化和反序列化\"]},\"416\":{\"h\":\"快速失败(fail-fast)和安全失败(fail-safe)了解吗？\",\"t\":[\"快速失败（fail—fast）：快速失败是Java集合的一种错误检测机制 \",\"触发 \",\"在用迭代器遍历一个集合对象时，如果线程A遍历过程中，线程B对集合对象的内容进行了修改（增加、删除、修改），则会抛出Concurrent Modification Exception\",\"原理 \",\"迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个modCount 变量。集合在被遍历期间如果内容发生变化，就会改变 modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测 modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。\",\"注意 \",\"这里异常的抛出条件是检测到 modCount！=expectedmodCount 这个条件。如果集合发生变化时修改modCount值刚好又设置为了expectedmodCount值，则异常不会抛出。因此，不能依赖于这个异常是否抛出而进行并发操作的编程，这个异常只建议用于检测并发修改的bug\",\"场景 \",\"java.util包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改），比如ArrayList 类。\",\"安全失败（fail—safe） \",\"策略 \",\"采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历\",\"原理 \",\"由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception\",\"缺点 \",\"基于拷贝内容的优点是避免了Concurrent Modification Exception，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的\",\"场景 \",\"java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改，比如CopyOnWriteArrayList类\"]},\"417\":{\"h\":\"实现ArrayList线程安全有哪几种方法？\",\"t\":[\"用Vector代替ArrayList \",\"Vector是一个线程安全的动态数组类，可以直接使用它来替代ArrayList\",\"Vector的所有方法都是同步的，因此在并发环境下可以安全地进行读写操作。\",\"但它的性能很低，不推荐使用。\",\"使用Collections.synchronizedList包装ArrayList \",\"可以使用Collections工具类的synchronizedList方法将ArrayList转换为线程安全的List\",\"该方法返回一个包装后的线程安全List，对该List的所有操作都会进行同步处理，确保线程安全\",\"使用CopyOnWriteArrayList代替ArrayList \",\"CopyOnWriteArrayList是一种线程安全的并发List\",\"它通过在修改时创建副本来实现并发访问\",\"由于读操作不需要加锁，因此在读多写少的场景中，CopyOnWriteArrayList具有较高的性能\",\"使用同步机制控制ArrayList的读写 \",\"在使用ArrayList时，可以通过同步机制（如使用synchronized关键字或Lock）来控制对ArrayList的读写操作，以确保线程安全\"]},\"418\":{\"h\":\"CopyOnWriteArrayList了解多少？\",\"t\":[\"CopyOnWriteArrayList就是线程安全版本的ArrayList，它的名字叫 CopyOnWrite，写时复制，已经明示了它的原理\",\"特点 \",\"线程安全性 \",\"CopyOnWriteArrayList通过创建副本的方式实现线程安全，因此可以在多线程环境下安全地进行读操作，而不需要额外的同步措施\",\"读写分离 \",\"CopyOnWriteArrayList适合在读多写少的场景中使用，因为每次写操作都会创建一个新的副本，会带来一定的内存开销。但在读操作频繁、写操作较少的情况下，可以获得较高的读取性能\",\"迭代器的弱一致性 \",\"由于CopyOnWriteArrayList在写操作时会创建副本，因此在遍历集合时使用的迭代器可能不反映最新的修改。迭代器提供的是一个一致性视图，即迭代器创建时的集合状态\",\"工作流程 \",\"将原数组拷贝一份\",\"写操作在副本上，加锁\",\"读操作在原数组上，无锁\",\"写完将元素数组指向副本\",\"缺点 \",\"由于CopyOnWriteArrayList在每次写操作时都会创建副本，因此适用于写操作较少、读操作频繁且对实时性要求不高的场景。如果写操作频繁或对实时性要求较高，可能会带来较高的内存开销和延迟。\",\"volatile修饰原数组array，保证了可见性\"]},\"419\":{\"h\":\"数据拷贝的过程中，有其它线程写入数据怎么办？\",\"t\":[\"阻塞呗，数据拷贝在add方法中进行，add方法有锁\"]},\"420\":{\"h\":\"Map\"},\"421\":{\"h\":\"能说一下HashMap的数据结构吗？\",\"t\":[\"数组 + 链表（JDK1.7）\",\"数组 + 链表 + 红黑树 （JDK1.8）\",\"数据结构示意图\",\"存储结构 \",\"HashMap内部使用一个数组（Entry[]）来存储数据\",\"数组中的每个元素称为一个桶（Bucket），每个桶存储一个键值对（Entry）\",\"哈希函数 \",\"HashMap使用键的哈希码（hash code）来计算存储位置\",\"每个键值对根据哈希函数计算得到一个桶的索引，然后将键值对存储在该桶中\",\"冲突处理 \",\"由于哈希函数的计算结果可能会出现冲突，即不同的键计算得到相同的桶索引\",\"HashMap使用链表或红黑树来解决冲突\",\"当桶中的元素较少时，使用链表存储键值对\",\"当桶中的元素较多时，将链表转换为红黑树，以提高查找、插入和删除的效率\"]},\"422\":{\"h\":\"你对红黑树了解多少？为什么不用二叉树/平衡树呢？\"},\"423\":{\"h\":\"什么是红黑树？\",\"t\":[\"红黑树是一种自平衡的二叉搜索树\",\"二叉搜索树性质\",\"左子节点的值小于等于当前节点的值，右子节点的值大于等于当前节点的值\",\"节点颜色\",\"每个节点要么是红色，要么是黑色\",\"根节点和叶子节点\",\"根节点是黑色的，叶子节点（NIL节点）是黑色的\",\"红色节点限制\",\"红色节点的子节点必须是黑色的\",\"黑色节点计数\",\"从任一节点到其每个叶子节点的路径上，黑色节点的数量是相同的\"]},\"424\":{\"h\":\"为什么不用二叉树？\",\"t\":[\"红黑树相对于普通的二叉搜索树的优势在于它能够保持良好的平衡，性能更加优秀和稳定\",\"普通的二叉搜索树在最坏情况下可能会退化成链表 ,导致插入、删除和查找操作的时间复杂度变为O(n)\",\"而红黑树通过自平衡的特性，避免了这种退化情况，保证了操作的最坏时间复杂度为O(log n)，其中n是树中节点的数量\"]},\"425\":{\"h\":\"为什么不用平衡二叉树？\",\"t\":[\"相比于平衡二叉树，红黑树在保持平衡的过程中旋转的次数较少，提高了插入和删除操作的效率\",\"红黑树通过引入节点颜色和特定性质，保证了树的相对平衡\",\"而平衡二叉树要求更严格的平衡条件，需要更多的旋转操作来保持平衡，导致插入和删除操作的效率较低\"]},\"426\":{\"h\":\"红黑树怎么保持平衡的知道吗？\",\"t\":[\"红黑树有两种方式保持平衡： 旋转 和 染色\",\"旋转 \",\"旋转分为两种，左旋和右旋\",\"染色\"]},\"427\":{\"h\":\"HashMap的put流程知道吗？\",\"t\":[\"首先进行哈希值的扰动，获取一个新的哈希值\",\"(key == null) ? 0 : (h =key.hashCode()) ^ (h >>> 16) \",\"判断tab是否位空或者长度为0，如果是则进行扩容操作\",\"if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; \",\"根据哈希值计算下标，如果对应下标正好没有存放数据，则直接插入即可，否则需要覆盖\",\"if ((p = tab[i = (n - 1) & hash]) == null) tab[i] = newNode(hash, key, value, null); else { //覆盖 } \",\"判断tab[i]是否为树节点，否则向链表中插入数据，是则向树中插入节点\",\"// 覆盖逻辑 Node<K,V> e; K k; if (p.hash == hash && ((k = p.key) == key || (key != null && key.equals(k)))) e = p; else if (p instanceof TreeNode) e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value); else { for (int binCount = 0; ; ++binCount) { if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; } if (e.hash == hash && ((k = e.key) == key || (key != null && key.equals(k)))) break; p = e; } } \",\"如果链表中插入节点的时候，链表长度大于等于8，则需要把链表转换为红黑树\",\" if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); \",\"最后所有元素处理完成后，判断是否超过阈值； threshold ，超过则扩容\",\" if (++size > threshold) resize(); \"]},\"428\":{\"h\":\"HashMap怎么查找元素的呢？\",\"t\":[\" public V get(Object key) { Node<K,V> e; return (e = getNode(hash(key), key)) == null ? null : e.value; } \",\" final Node<K,V> getNode(int hash, Object key) { Node<K,V>[] tab; Node<K,V> first, e; int n; K k; if ((tab = table) != null && (n = tab.length) > 0 && (first = tab[(n - 1) & hash]) != null) { if (first.hash == hash && // always check first node ((k = first.key) == key || (key != null && key.equals(k)))) return first; if ((e = first.next) != null) { if (first instanceof TreeNode) return ((TreeNode<K,V>)first).getTreeNode(hash, key); do { if (e.hash == hash && ((k = e.key) == key || (key != null && key.equals(k)))) return e; } while ((e = e.next) != null); } } return null; } \",\"使用扰动函数，获取新的哈希值\",\"计算数组下标，获取节点\",\"当前节点和key匹配，直接返回\",\"否则，当前节点是否为树节点，查找红黑树\",\"否则，遍历链表查找\"]},\"429\":{\"h\":\"HashMap的哈希/扰动函数是怎么设计的?\",\"t\":[\"HashMap的哈希函数是先通过 hashCode() 获取到key的哈希值\",\"哈希值是一个32位的int类型的数值，然后再将哈希值右移16位（高位），然后与哈希值本身异或，达到高位与低位混合的效果\",\"这样的设计增加了哈希值的随机性，降低了哈希冲突的概率 。\",\"异或操作使得低位的特征影响到高位，减少了相同低位的哈希值导致相同索引位置的情况\"]},\"430\":{\"h\":\"为什么哈希/扰动函数能降hash碰撞？\",\"t\":[\"因为哈希值&(数组长度 - 1)保留的是hash值的地位特征，所以对扰动函数通过对哈希值进行变换，新hash值保留了高低位的特征，这样使得哈希值的分布更加均匀，从而降低哈希碰撞的概率\"]},\"431\":{\"h\":\"为什么HashMap的容量是2的倍数呢？\",\"t\":[\"方便哈希取余 \",\"取余是去除整数倍，保留整数倍以下的数据\",\"hash值&(数组大小-1) ，也达到了取余的效果 \",\"数组大小为2的倍数，(数组大小-1) 则为一个全是1的二进制数\",\"hash值&(数组大小-1) 结果为直接保留hash值对(数组大小-1) 的低位的余数部分 \",\"因为任意数&1得任意数\",\"任意数&0得0\",\"hash值&(数组大小-1) ，将(数组大小-1)高位补0，补全到和hash值一样多的位数，那么hash值高位是与0做&运算，低位是与1做位运算，即保留了低位hash值，也是取余的效果\",\"在扩容时，利用扩容后的大小也是2的倍数，将已经产生hash碰撞的元素完美的转移到新的table中去\"]},\"432\":{\"h\":\"如果初始化HashMap，传一个17的值 new HashMap<> ，它会怎么处理？\",\"t\":[\"初始化时，传的不是2的倍数时，HashMap会向上寻找 离得最近的2的倍数 ，所以传入17，但HashMap的实际容量是32\",\"HashMap的容量必须是2的倍数\"]},\"433\":{\"h\":\"你还知道哪些哈希函数的构造方法呢？\",\"t\":[\"除留取余法 \",\"HashMap里进行了优化改造，效率更高，散列也更均衡\",\"直接定址法 \",\"直接根据 key 来映射到对应的数组位置，例如1232放到下标1232的位置\",\"数字分析法 \",\"取 key 的某些数字（例如十位和百位）作为映射的位置\",\"平方取中法 \",\"取 key 平方的中间几位作为映射的位置\",\"折叠法 \",\"将 key 分割成位数相同的几段，然后把它们的叠加和作为映射的位置\"]},\"434\":{\"h\":\"解决哈希冲突有哪些方法呢？\",\"t\":[\"链地址法 \",\"在冲突的位置拉一个链表，把冲突的元素放进去\",\"开放定址法 \",\"开放定址法就是从冲突的位置再接着往下找，给冲突元素找个空位\",\"找到空闲位置的方法也有很多 \",\"线行探查法 \",\"从冲突的位置开始，依次判断下一个位置是否空闲，直至找到空闲位置\",\"平方探查法 \",\"从冲突的位置x开始，第一次增加 1^2 个位置，第二次增加2^2 …，直至找到空闲的位置\",\"再哈希法 \",\"换种哈希函数，重新计算冲突元素的地址\",\"建立公共溢出区 \",\"再建一个数组，把冲突的元素放进去\"]},\"435\":{\"h\":\"为什么HashMap链表转红黑树的阈值为8呢？\",\"t\":[\"红黑树节点的大小大概是普通节点大小的两倍，所以转红黑树，牺牲了空间换时间，更多的是一种兜底的策略，保证极端情况下的查找效率\",\"链表转红黑树的阈值为什么要选8呢？ \",\"和统计学有关。理想情况下，使用随机哈希码，链表里的节点符合泊松分布，出现节点个数的概率是递减的，节点个数为8的情况，发生概率仅为0.00000006\",\"红黑树转回链表的阈值为什么是6，而不是8？ \",\"是因为如果这个阈值也设置成8，假如发生碰撞，节点增减刚好在8附近，会发生链表和红黑树的不断转换，导致资源浪费\"]},\"436\":{\"h\":\"扩容在什么时候呢？为什么扩容因子是0.75？\",\"t\":[\"为了减少哈希冲突发生的概率,当前HashMap的元素个数达到一个临界值的时候，就会触发扩容\",\"这个 临界值threshold 就是由加载因子和当前容器的容量大小来确定的\"]},\"437\":{\"h\":\"那么为什么选择了0.75作为HashMap的默认加载因子呢？\",\"t\":[\"这是对 空间 成本和 时间 成本平衡的考虑 \",\"假如我们设的比较大，元素比较多，空位比较少的时候才扩容，那么发生哈希冲突的概率就增加了，查找的时间成本就增加了\",\"我们设的比较小的话，元素比较少，空位比较多的时候就扩容了，发生哈希碰撞的概率就降低了，查找时间成本降低，但是就需要更多的空间去存储元素，空间成本就增加了\"]},\"438\":{\"h\":\"HashMap扩容机制了解吗？\",\"t\":[\"为了减少哈希冲突发生的概率,当前HashMap的元素个数达到一个临界值的时候，就会触发扩容\",\"链表结构扩容后 \",\"hash&老容量==0 \",\"现在位置=原先位置\",\"hash&老容量==1 \",\"现在位置=原先位置+oldCap\"]},\"439\":{\"h\":\"JDK1.8对HashMap主要做了哪些优化呢？为什么？\",\"t\":[\"数据结构 \",\"在JDK 1.8中，当哈希冲突较多时，HashMap会将链表转换为红黑树，以提高查找、插入和删除操作的效率\",\"种优化是为了解决在极端情况下链表过长导致的性能问题。\",\"红黑树的平均时间复杂度为O(log n)，相比于链表的O(n)更高效\",\"哈希碰撞优化 \",\"JDK 1.8对哈希碰撞的处理进行了优化\",\"当发生哈希碰撞时，HashMap会使用更加均匀的哈希函数来计算索引位置，减少碰撞的概率\",\"JDK 1.8还引入了\\\"树化阈值\\\"和\\\"链表转树阈值\\\"的概念，动态调整链表和红黑树的阈值，以平衡性能和空间的消耗\",\"链表插入方式 \",\"在JDK 1.8中，当插入新的键值对时，HashMap采用了尾插法（将新键值对插入链表或红黑树末尾），而不是头插法\",\"这样做可以减少链表或红黑树的重新排序次数，提高插入操作的效率\",\"扩容优化 \",\"JDK 1.8对HashMap的扩容操作进行了优化\",\"在扩容时，HashMap采用了\\\"渐进式扩容\\\"的策略，将扩容操作分散到多次进行，避免了一次性重新计算所有键的哈希值和索引位置，减少了扩容操作的时间和资源消耗\"]},\"440\":{\"h\":\"你能自己设计实现一个HashMap吗？\",\"t\":[\"散列函数 \",\"hashCode()+除留余数法\",\"冲突解决 \",\"链地址法\",\"扩容 \",\"节点重新hash获取位置\"]},\"441\":{\"h\":\"HashMap 是线程安全的吗？多线程下会有什么问题？\",\"t\":[\"不是线程安全的\",\"多线程下扩容死循环 \",\"在JDK1.7中，HashMap使用头插法插入元素，当多个线程同时进行扩容操作时，可能会导致环形链表的出现，从而形成死循环\",\"JDK1.8中的HashMap改为使用尾插法插入元素，在扩容时保持链表元素原本的顺序，避免了环形链表的问题\",\"多线程的put可能导致元素的丢失 \",\"当多个线程同时执行put操作时，如果计算出来的索引位置相同，就会导致后一个key覆盖前一个key，从而导致元素的丢失\",\"这个问题在JDK1.7和JDK1.8中都存在\",\"put和get并发时，可能导致get为null \",\"当一个线程执行put操作导致扩容时，另一个线程同时执行get操作\",\"由于扩容过程中元素迁移的不可见性，可能导致get操作返回null\",\"这个问题在JDK1.7和JDK1.8中都存在\"]},\"442\":{\"h\":\"有什么办法能解决HashMap线程不安全的问题呢？\",\"t\":[\"使用线程安全的包装类 \",\"使用 Collections.synchronizedMap() 方法将HashMap包装成线程安全的Map\",\"这个方法返回一个线程安全的Map对象，对该对象的操作会自动进行同步，从而保证线程安全\",\"使用同步机制 \",\"可以使用 synchronized 关键字或其他同步机制（如ReentrantLock ）对HashMap进行加锁\",\"使用线程安全的并发容器 \",\"可以使用 ConcurrentHashMap 代替HashMap\",\"ConcurrentHashMap 是Java提供的线程安全的哈希表实现，通过使用锁分段技术和CAS操作来实现高效的并发性能\"]},\"443\":{\"h\":\"能说一下ConcurrentHashmap的具体实现吗？\",\"t\":[\"ConcurrentHashmap线程安全在jdk1.7版本是基于 分段锁 实现\",\"在jdk1.8是基于CAS+synchronized 实现\"]},\"444\":{\"h\":\"JDK1.7：分段锁\",\"t\":[\"JDK1.7版本的ConcurrentHashMap采用分段锁机制 \",\"里面包含一个Segment数组，Segment继承于ReentrantLock，Segment则包含HashEntry的数组\",\"HashEntry本身就是一个链表的结构，具有保存key、value的能力能指向下一个节点的指针\",\"实际上就是相当于每个Segment都是一个HashMap\",\"默认的Segment长度是16，也就是支持16个线程的并发写，Segment之间相互不会受到影响\",\"put流程 \",\"计算hash，定位到segment，segment如果是空就先初始化\",\"使用ReentrantLock加锁，如果获取锁失败则尝试自旋，自旋超过次数就阻塞获取，保证一定获取锁成功\",\"遍历HashEntry，就是和HashMap一样，数组中key和hash一样就直接替换，不存在就再插入链表，链表同样操作\",\"get流程 \",\"key通过hash定位到segment，再遍历链表定位到具体的元素上\",\"需要注意的是value是volatile的，所以get是不需要加锁的\"]},\"445\":{\"h\":\"JDK1.8：CAS+synchronized\",\"t\":[\"数据结构\",\"数据结构和HashMap是一样的，数组+链表+红黑树\",\"它实现线程安全的关键点在于put流程\",\"put流程\",\"首先计算hash，遍历node数组，如果数组是空的话，就通过CAS+自旋的方式初始化数组\",\" if (tab == null || (n = tab.length) == 0) tab = initTable(); \",\"初始化数组\",\"private final Node<K,V>[] initTable() { Node<K,V>[] tab; int sc; while ((tab = table) == null || tab.length == 0) { //如果正在初始化或者扩容 if ((sc = sizeCtl) < 0) //等待(让出线程) Thread.yield(); // lost initialization race; just spin else if (U.compareAndSetInt(this, SIZECTL, sc, -1)) {//CAS操作 try { if ((tab = table) == null || tab.length == 0) { int n = (sc > 0) ? sc : DEFAULT_CAPACITY; @SuppressWarnings(\\\"unchecked\\\") Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n]; table = tab = nt; sc = n - (n >>> 2); } } finally { sizeCtl = sc; } break; } } return tab; } \",\"如果当前数组位置是空则直接通过CAS自旋写入数据\",\"else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) { if (casTabAt(tab, i, null, new Node<K,V>(hash, key, value))) break; // no lock when adding to empty bin } \",\"如果hash==MOVED，说明需要扩容，执行扩容\",\" final Node<K,V>[] helpTransfer(Node<K,V>[] tab, Node<K,V> f) { Node<K,V>[] nextTab; int sc; if (tab != null && (f instanceof ForwardingNode) && (nextTab = ((ForwardingNode<K,V>)f).nextTable) != null) { int rs = resizeStamp(tab.length) << RESIZE_STAMP_SHIFT; while (nextTab == nextTable && table == tab && (sc = sizeCtl) < 0) { if (sc == rs + MAX_RESIZERS || sc == rs + 1 || transferIndex <= 0) break; if (U.compareAndSetInt(this, SIZECTL, sc, sc + 1)) { transfer(tab, nextTab); break; } } return nextTab; } return table; } \",\"如果都不满足，就使用synchronized写入数据\",\"写入数据同样判断链表、红黑树，链表写入和HashMap的方式一样，key hash一样就覆盖，反之就尾插法，链表长度超过8就转换成红黑树\",\"get查询\",\"无锁化读取，和HashMap的get流程基本相同 \",\"头节点通过Unsafe获取\"]},\"446\":{\"h\":\"HashMap 内部节点是有序的吗？\",\"t\":[\"HashMap 内部节点的顺序是无序的\",\"因为 HashMap 使用的是哈希表的数据结构，它通过哈希函数将键映射到桶（bucket）中，而不是按照插入顺序进行存储\",\"如果需要有序的存储和遍历元素，可以考虑使用 LinkedHashMap 或者 TreeMap\"]},\"447\":{\"h\":\"讲讲 LinkedHashMap 怎么实现有序的？\",\"t\":[\"LinkedHashMap在 HashMap 的基础上维护了一个双向链表，用于记录元素的插入顺序或访问顺序\",\"通过这个链表， LinkedHashMap 可以按照插入顺序或访问顺序进行遍历。\"]},\"448\":{\"h\":\"讲讲 TreeMap 怎么实现有序的？\",\"t\":[\"TreeMap 是基于红黑树实现的，是一种有序的的集合\",\"在 TreeMap 中，元素是按照是按照 Key 的自然顺序或者 Comprator 的顺序进行排序，因此可以通过键值来遍历 集合中的元素 \",\"不是通过插入顺序遍历\"]},\"449\":{\"h\":\"Set\"},\"450\":{\"h\":\"讲讲HashSet的底层实现？\",\"t\":[\"HashSet 底层就是基于 HashMap 实现的\",\"HashSet 的源码⾮常⾮常少，因为除了clone() 、 writeObject() 、 readObject() 是 HashSet⾃⼰不得不实现之外，其他⽅法都是直接调⽤ HashMap 中的⽅法。\",\"HashSet的add方法\",\" public boolean add(E e) { return map.put(e, PRESENT)==null; } \",\"直接调用HashMap的put方法，将添加的元素作为key，new一个Object作为value\",\"会根据返回值是否为空来判断是否插入元素成功\",\"HashMap的putVal\",\"进行了一系列判断，最后的结果是，只有在key在table数组中不存在的时候，才会返回插入的值\",\"if (e != null) { // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; } \"]},\"451\":{\"h\":\"引言\"},\"452\":{\"h\":\"说说有哪些常见集合？\",\"t\":[\"List\",\"Map\",\"Set\"]},\"453\":{\"h\":\"Posts\"},\"454\":{\"h\":\"J V M\"},\"455\":{\"h\":\"Java\"},\"456\":{\"h\":\"Java基础\"},\"457\":{\"h\":\"Java并发\"},\"458\":{\"h\":\"Java集合\"}},\"dirtCount\":0,\"index\":[[\"底层就是基于\",{\"1\":{\"450\":1}}],[\"底部设置change\",{\"1\":{\"20\":1}}],[\"讲讲hashset的底层实现\",{\"0\":{\"450\":1}}],[\"讲讲\",{\"0\":{\"447\":1,\"448\":1}}],[\"头节点通过unsafe获取\",{\"1\":{\"445\":1}}],[\"冲突解决\",{\"1\":{\"440\":1}}],[\"冲突处理\",{\"1\":{\"421\":1}}],[\"渐进式扩容\",{\"1\":{\"439\":1}}],[\"树化阈值\",{\"1\":{\"439\":1}}],[\"种优化是为了解决在极端情况下链表过长导致的性能问题\",{\"1\":{\"439\":1}}],[\"老容量==1\",{\"1\":{\"438\":1}}],[\"老容量==0\",{\"1\":{\"438\":1}}],[\"老年代占用的堆内存百分比阈值\",{\"1\":{\"105\":1}}],[\"老年代空间不足\",{\"1\":{\"96\":1}}],[\"老年代通常使用标记\",{\"1\":{\"92\":1}}],[\"老年代用于存放长期存活的对象\",{\"1\":{\"91\":1}}],[\"老年代\",{\"1\":{\"91\":1}}],[\"临界值threshold\",{\"1\":{\"436\":1}}],[\"假如我们设的比较大\",{\"1\":{\"437\":1}}],[\"假如发生碰撞\",{\"1\":{\"435\":1}}],[\"假设初始条件是a\",{\"1\":{\"400\":1}}],[\"假设有以下简单的java方法\",{\"1\":{\"126\":1}}],[\"理想情况下\",{\"1\":{\"435\":1}}],[\"牺牲了空间换时间\",{\"1\":{\"435\":1}}],[\"建立公共溢出区\",{\"1\":{\"434\":1}}],[\"建议使用\",{\"1\":{\"141\":1}}],[\"换种哈希函数\",{\"1\":{\"434\":1}}],[\"依次判断下一个位置是否空闲\",{\"1\":{\"434\":1}}],[\"依存于类的实例\",{\"1\":{\"202\":1}}],[\"线行探查法\",{\"1\":{\"434\":1}}],[\"线程b对集合对象的内容进行了修改\",{\"1\":{\"416\":1}}],[\"线程b可以调用线程interrupt\",{\"1\":{\"240\":1}}],[\"线程己经持有了至少一个资源\",{\"1\":{\"408\":1}}],[\"线程死锁了解吗\",{\"0\":{\"408\":1}}],[\"线程死锁等\",{\"1\":{\"372\":1}}],[\"线程直接进入队列中排队\",{\"1\":{\"394\":1}}],[\"线程进入队列后会进行自旋\",{\"1\":{\"392\":1}}],[\"线程解锁前\",{\"1\":{\"383\":1}}],[\"线程加锁后\",{\"1\":{\"383\":1}}],[\"线程加锁前\",{\"1\":{\"383\":1}}],[\"线程执行任务\",{\"1\":{\"373\":2}}],[\"线程执行任务时\",{\"1\":{\"341\":1}}],[\"线程从delayqueue中获取已到期的scheduledfuturetask\",{\"1\":{\"356\":1}}],[\"线程并不会立即销毁\",{\"1\":{\"350\":1}}],[\"线程工厂\",{\"1\":{\"344\":1}}],[\"线程空闲时间\",{\"1\":{\"344\":1}}],[\"线程空闲或终止\",{\"1\":{\"343\":1}}],[\"线程将继续处于空闲状态\",{\"1\":{\"341\":1}}],[\"线程的创建和销毁需要在操作系统和jvm内部进行同步\",{\"1\":{\"312\":1}}],[\"线程管理\",{\"1\":{\"299\":1}}],[\"线程复用\",{\"1\":{\"299\":1}}],[\"线程阻塞和唤醒机制\",{\"1\":{\"296\":1}}],[\"线程池并发调用api\",{\"0\":{\"375\":1}}],[\"线程池调优了解吗\",{\"0\":{\"372\":1}}],[\"线程池如何实现参数的动态修改\",{\"0\":{\"371\":1}}],[\"线程池完全终止\",{\"1\":{\"369\":1}}],[\"线程池不再接受新任务\",{\"1\":{\"366\":1,\"367\":1}}],[\"线程池进入\",{\"1\":{\"366\":1,\"367\":1}}],[\"线程池可以接受新任务\",{\"1\":{\"365\":1}}],[\"线程池可以通过调用shutdown\",{\"1\":{\"342\":1}}],[\"线程池异常处理是一个常见的问题\",{\"1\":{\"357\":1}}],[\"线程池异常怎么处理知道吗\",{\"0\":{\"357\":1}}],[\"线程池特点\",{\"1\":{\"353\":1,\"354\":1,\"355\":1,\"356\":1}}],[\"线程池是否有一条线程在\",{\"1\":{\"355\":1}}],[\"线程池是怎么实现线程复用的\",{\"0\":{\"350\":1}}],[\"线程池是一种管理和控制多个线程并发执行的机制\",{\"1\":{\"298\":1}}],[\"线程池将不再接受新的任务\",{\"1\":{\"348\":1}}],[\"线程池怎么关闭知道吗\",{\"0\":{\"348\":1}}],[\"线程池提交execute和submit有什么区别\",{\"0\":{\"347\":1}}],[\"线程池通常使用工作队列来存储等待执行的任务\",{\"1\":{\"346\":1}}],[\"线程池通过预先创建一组线程\",{\"1\":{\"298\":1}}],[\"线程池有哪几种工作队列\",{\"0\":{\"346\":1}}],[\"线程池会尝试停止所有正在执行的任务\",{\"1\":{\"348\":1}}],[\"线程池会将其记录下来\",{\"1\":{\"347\":1}}],[\"线程池会优先使用核心线程来处理任务\",{\"1\":{\"344\":1}}],[\"线程池会自动管理线程的生命周期\",{\"1\":{\"299\":1}}],[\"线程池中没有活动的线程\",{\"1\":{\"368\":2}}],[\"线程池中的线程数量会根据任务的数量自动调整\",{\"1\":{\"351\":1}}],[\"线程池中的线程数量不会发生变化\",{\"1\":{\"351\":1}}],[\"线程池中的线程就实现了复用\",{\"1\":{\"350\":1}}],[\"线程池中的线程作为消费者\",{\"1\":{\"350\":1}}],[\"线程池中的线程会在处理完一个请求后立即准备处理下一个请求\",{\"1\":{\"319\":1}}],[\"线程池中允许存在的最大线程数\",{\"1\":{\"344\":1}}],[\"线程池中保持活动状态的最小线程数\",{\"1\":{\"344\":1}}],[\"线程池主要参数有哪些\",{\"0\":{\"344\":1}}],[\"线程池关闭等\",{\"1\":{\"373\":1}}],[\"线程池关闭等基本功能\",{\"1\":{\"373\":1}}],[\"线程池关闭\",{\"0\":{\"342\":1},\"1\":{\"343\":1}}],[\"线程池按照以下顺序处理任务\",{\"1\":{\"340\":1}}],[\"线程池初始化\",{\"0\":{\"338\":1}}],[\"线程池大小为10\",{\"1\":{\"320\":1}}],[\"线程池大小根据需要动态调整\",{\"1\":{\"291\":1}}],[\"线程池在初始化时\",{\"1\":{\"338\":1}}],[\"线程池在初始化时创建一定数量的线程\",{\"1\":{\"299\":1}}],[\"线程池在实际工作中有着广泛的应用\",{\"1\":{\"316\":1}}],[\"线程池能够创建的最大线程数\",{\"1\":{\"304\":1}}],[\"线程池维护的最小线程数\",{\"1\":{\"304\":1}}],[\"线程池的任务队列也是需要考虑的因素之一\",{\"1\":{\"349\":1}}],[\"线程池的线程数配置需要根据任务性质\",{\"1\":{\"349\":1}}],[\"线程池的线程数配置应该根据你的应用场景和需求来决定\",{\"1\":{\"349\":1}}],[\"线程池的线程数应该怎么配置\",{\"0\":{\"349\":1}}],[\"线程池的关闭可以通过调用shutdown\",{\"1\":{\"348\":1}}],[\"线程池的拒绝策略用于定义当线程池无法接受新任务时应该采取的操作\",{\"1\":{\"345\":1}}],[\"线程池的拒绝策略有哪些\",{\"0\":{\"345\":1}}],[\"线程池的主要参数包括\",{\"1\":{\"344\":1}}],[\"线程池的工作流程如下图所示\",{\"1\":{\"343\":1}}],[\"线程池的工作流程可以分为以下几个步骤\",{\"1\":{\"337\":1}}],[\"线程池的完整工作流程\",{\"0\":{\"343\":1}}],[\"线程池的配置参数影响其行为和性能\",{\"1\":{\"304\":1}}],[\"线程池的配置参数\",{\"0\":{\"304\":1}}],[\"线程池的使用示例\",{\"0\":{\"303\":1}}],[\"线程池的优势\",{\"0\":{\"300\":1}}],[\"线程池的基本概念\",{\"0\":{\"299\":1}}],[\"线程池\",{\"0\":{\"297\":1},\"1\":{\"364\":1}}],[\"线程池类型\",{\"0\":{\"289\":1}}],[\"线程调用此方法进行数据交换\",{\"1\":{\"258\":1}}],[\"线程调用这个方法释放一个许可\",{\"1\":{\"254\":1}}],[\"线程调用这个方法尝试获取一个许可\",{\"1\":{\"254\":1}}],[\"线程首先尝试获取一个许可\",{\"1\":{\"254\":1}}],[\"线程会被阻塞\",{\"1\":{\"254\":1}}],[\"线程会被自动唤醒\",{\"1\":{\"240\":1}}],[\"线程达到公共屏障点\",{\"1\":{\"251\":1}}],[\"线程内\",{\"1\":{\"247\":1}}],[\"线程thread除了提供join\",{\"1\":{\"247\":1}}],[\"线程间有哪些通信方式\",{\"0\":{\"247\":1}}],[\"线程上下文切换\",{\"0\":{\"311\":1}}],[\"线程上下文切换通常发生在以下几种情况下\",{\"0\":{\"245\":1}}],[\"线程上下文切换是一种非常耗时的操作\",{\"1\":{\"244\":1}}],[\"线程上下文切换是指在多线程环境下\",{\"1\":{\"244\":1}}],[\"线程不会再进入任何状态\",{\"1\":{\"243\":1}}],[\"线程被创建\",{\"1\":{\"241\":1}}],[\"线程共有六种状态\",{\"1\":{\"241\":1}}],[\"线程有几种状态\",{\"0\":{\"241\":1}}],[\"线程有哪些常用的调度方法\",{\"0\":{\"240\":1}}],[\"线程中断\",{\"1\":{\"240\":1,\"251\":1}}],[\"线程休眠\",{\"1\":{\"240\":1}}],[\"线程是不会继续执行的\",{\"1\":{\"240\":1}}],[\"线程是进程的一个执行路径\",{\"1\":{\"236\":1}}],[\"线程a实际并没有被中断\",{\"1\":{\"240\":1}}],[\"线程a会暂时让出指定时间的执行权\",{\"1\":{\"240\":1}}],[\"线程a会被阻塞挂起\",{\"1\":{\"240\":1}}],[\"线程a抛出interruptedexception异常返回\",{\"1\":{\"240\":1}}],[\"线程等待与通知\",{\"1\":{\"240\":1}}],[\"线程\",{\"1\":{\"236\":1,\"246\":2,\"251\":34}}],[\"线程可以在任何地方使用localvariable\",{\"1\":{\"222\":1}}],[\"线程之间对共享变量的修改不一定能够及时同步到主内存和其他线程的本地内存中\",{\"1\":{\"212\":1}}],[\"线程之间的共享变量存储在\",{\"1\":{\"211\":1}}],[\"线程安全\",{\"1\":{\"169\":2,\"192\":1}}],[\"线程安全性\",{\"1\":{\"169\":1,\"296\":1,\"418\":1}}],[\"线程数量等\",{\"1\":{\"108\":1}}],[\"线程在任何地方读取的都是它写入的变量\",{\"1\":{\"222\":1}}],[\"线程在写入变量时不会把值缓存在寄存器或者其他地方\",{\"1\":{\"219\":1}}],[\"线程在分配对象时\",{\"1\":{\"81\":1}}],[\"线程在自己的\",{\"1\":{\"80\":1}}],[\"线程才会在堆的全局空间中进行对象分配\",{\"1\":{\"80\":1}}],[\"线程独立地分配对象\",{\"1\":{\"80\":1}}],[\"线程结束时销毁\",{\"1\":{\"53\":3}}],[\"线程创建时创建\",{\"1\":{\"53\":3}}],[\"找到空闲位置的方法也有很多\",{\"1\":{\"434\":1}}],[\"找出所有能够被直接或间接引用到的对象\",{\"1\":{\"87\":1}}],[\"给冲突元素找个空位\",{\"1\":{\"434\":1}}],[\"给编译器用的\",{\"1\":{\"190\":1}}],[\"折叠法\",{\"1\":{\"433\":1}}],[\"散列函数\",{\"1\":{\"440\":1}}],[\"散列也更均衡\",{\"1\":{\"433\":1}}],[\"散列方法重新计算位置\",{\"1\":{\"230\":1}}],[\"散列方法就是怎么把对应的key映射到table数组的相应下标\",{\"1\":{\"228\":1}}],[\"散列方法\",{\"1\":{\"228\":1}}],[\"效率更高\",{\"1\":{\"433\":1}}],[\"效果\",{\"0\":{\"13\":1}}],[\"离得最近的2的倍数\",{\"1\":{\"432\":1}}],[\"离开停车场\",{\"1\":{\"253\":1}}],[\"利用扩容后的大小也是2的倍数\",{\"1\":{\"431\":1}}],[\"补全到和hash值一样多的位数\",{\"1\":{\"431\":1}}],[\"取\",{\"1\":{\"433\":2}}],[\"取余是去除整数倍\",{\"1\":{\"431\":1}}],[\"取出key的threadlocalhashcode\",{\"1\":{\"228\":1}}],[\"扰动函数能降hash碰撞\",{\"0\":{\"430\":1}}],[\"扰动函数是怎么设计的\",{\"0\":{\"429\":1}}],[\"达到高位与低位混合的效果\",{\"1\":{\"429\":1}}],[\"达到最大线程数则执行拒绝策略\",{\"1\":{\"343\":1}}],[\"覆盖逻辑\",{\"1\":{\"427\":1}}],[\"覆盖\",{\"1\":{\"427\":1}}],[\"^\",{\"1\":{\"427\":1}}],[\"左旋和右旋\",{\"1\":{\"426\":1}}],[\"左子节点的值小于等于当前节点的值\",{\"1\":{\"423\":1}}],[\"染色\",{\"1\":{\"426\":2}}],[\"旋转分为两种\",{\"1\":{\"426\":1}}],[\"旋转\",{\"1\":{\"426\":2}}],[\"黑色节点的数量是相同的\",{\"1\":{\"423\":1}}],[\"黑色节点计数\",{\"1\":{\"423\":1}}],[\"红色节点的子节点必须是黑色的\",{\"1\":{\"423\":1}}],[\"红色节点限制\",{\"1\":{\"423\":1}}],[\"红黑树的平均时间复杂度为o\",{\"1\":{\"439\":1}}],[\"红黑树转回链表的阈值为什么是6\",{\"1\":{\"435\":1}}],[\"红黑树节点的大小大概是普通节点大小的两倍\",{\"1\":{\"435\":1}}],[\"红黑树有两种方式保持平衡\",{\"1\":{\"426\":1}}],[\"红黑树怎么保持平衡的知道吗\",{\"0\":{\"426\":1}}],[\"红黑树通过引入节点颜色和特定性质\",{\"1\":{\"425\":1}}],[\"红黑树在保持平衡的过程中旋转的次数较少\",{\"1\":{\"425\":1}}],[\"红黑树相对于普通的二叉搜索树的优势在于它能够保持良好的平衡\",{\"1\":{\"424\":1}}],[\"红黑树是一种自平衡的二叉搜索树\",{\"1\":{\"423\":1}}],[\"红黑树\",{\"1\":{\"421\":1,\"445\":1}}],[\"叶子节点\",{\"1\":{\"423\":1}}],[\"节点重新hash获取位置\",{\"1\":{\"440\":1}}],[\"节点增减刚好在8附近\",{\"1\":{\"435\":1}}],[\"节点个数为8的情况\",{\"1\":{\"435\":1}}],[\"节点颜色\",{\"1\":{\"423\":1}}],[\"节点流\",{\"1\":{\"137\":1}}],[\"右子节点的值大于等于当前节点的值\",{\"1\":{\"423\":1}}],[\"二叉搜索树性质\",{\"1\":{\"423\":1}}],[\"平方探查法\",{\"1\":{\"434\":1}}],[\"平方的中间几位作为映射的位置\",{\"1\":{\"433\":1}}],[\"平方取中法\",{\"1\":{\"433\":1}}],[\"平衡树呢\",{\"0\":{\"422\":1}}],[\"平台无关性\",{\"1\":{\"147\":1}}],[\"插入和删除操作的效率\",{\"1\":{\"439\":1}}],[\"插入和删除的效率\",{\"1\":{\"421\":1}}],[\"插件系统等\",{\"1\":{\"153\":1}}],[\"哈希碰撞优化\",{\"1\":{\"439\":1}}],[\"哈希值是一个32位的int类型的数值\",{\"1\":{\"429\":1}}],[\"哈希函数\",{\"1\":{\"421\":1}}],[\"哈希码常用于哈希表等数据结构的实现中\",{\"1\":{\"206\":1}}],[\"哈希码是一个整数\",{\"1\":{\"206\":1}}],[\"链地址法\",{\"1\":{\"434\":1,\"440\":1}}],[\"链表长度超过8就转换成红黑树\",{\"1\":{\"445\":1}}],[\"链表长度大于等于8\",{\"1\":{\"427\":1}}],[\"链表写入和hashmap的方式一样\",{\"1\":{\"445\":1}}],[\"链表同样操作\",{\"1\":{\"444\":1}}],[\"链表插入方式\",{\"1\":{\"439\":1}}],[\"链表转树阈值\",{\"1\":{\"439\":1}}],[\"链表转红黑树的阈值为什么要选8呢\",{\"1\":{\"435\":1}}],[\"链表结构扩容后\",{\"1\":{\"438\":1}}],[\"链表里的节点符合泊松分布\",{\"1\":{\"435\":1}}],[\"链表\",{\"1\":{\"421\":2}}],[\"链接\",{\"1\":{\"134\":1}}],[\"策略\",{\"1\":{\"416\":1}}],[\"迭代器提供的是一个一致性视图\",{\"1\":{\"418\":1}}],[\"迭代器的弱一致性\",{\"1\":{\"418\":1}}],[\"迭代器遍历的是开始遍历那一刻拿到的集合拷贝\",{\"1\":{\"416\":1}}],[\"迭代器并不能访问到修改后的内容\",{\"1\":{\"416\":1}}],[\"迭代器在遍历时直接访问集合中的内容\",{\"1\":{\"416\":1}}],[\"迭代过程中被修改\",{\"1\":{\"416\":1}}],[\"集合中的元素\",{\"1\":{\"448\":1}}],[\"集合在被遍历期间如果内容发生变化\",{\"1\":{\"416\":1}}],[\"集合基础\",{\"0\":{\"191\":1}}],[\"删除和查找操作的时间复杂度变为o\",{\"1\":{\"424\":1}}],[\"删除\",{\"1\":{\"416\":1}}],[\"删除或修改了类的属性\",{\"1\":{\"177\":1}}],[\"快速失败是java集合的一种错误检测机制\",{\"1\":{\"416\":1}}],[\"快速失败\",{\"0\":{\"416\":1},\"1\":{\"416\":1}}],[\"剩下的50不用其实不用序列化\",{\"1\":{\"414\":1}}],[\"出于效率的考虑\",{\"1\":{\"414\":1}}],[\"出现节点个数的概率是递减的\",{\"1\":{\"435\":1}}],[\"出现线程死锁以后\",{\"1\":{\"409\":1}}],[\"出现问题\",{\"1\":{\"252\":1}}],[\"触发\",{\"1\":{\"416\":1}}],[\"触发扩容\",{\"1\":{\"412\":1}}],[\"触发major\",{\"1\":{\"94\":1}}],[\"触发minor\",{\"1\":{\"93\":1,\"94\":1,\"95\":1}}],[\"查找时间成本降低\",{\"1\":{\"437\":1}}],[\"查找的时间成本就增加了\",{\"1\":{\"437\":1}}],[\"查找红黑树\",{\"1\":{\"428\":1}}],[\"查找速率\",{\"1\":{\"411\":1}}],[\"查看\",{\"1\":{\"11\":1}}],[\"检测到死锁\",{\"1\":{\"409\":1}}],[\"检测当前线程是否被中断\",{\"1\":{\"240\":2}}],[\"申请的时候可以先申请资源序号小的\",{\"1\":{\"408\":1}}],[\"环路等待\",{\"1\":{\"408\":1}}],[\"环路等待条件\",{\"1\":{\"408\":1}}],[\"互斥这个条件我们没有办法破坏\",{\"1\":{\"408\":1}}],[\"互斥条件\",{\"1\":{\"408\":1}}],[\"答案是至少破坏死锁发生的一个条件\",{\"1\":{\"408\":1}}],[\"持有一个资源的同时请求一个新资源\",{\"1\":{\"408\":1}}],[\"持久化任务队列\",{\"1\":{\"374\":1}}],[\"死锁恢复\",{\"1\":{\"409\":1}}],[\"死锁检测算法\",{\"1\":{\"409\":1}}],[\"死锁问题怎么排查呢\",{\"0\":{\"409\":1}}],[\"死锁产生的四个条件\",{\"1\":{\"408\":1}}],[\"死锁是指两个或两个以上的线程在执行过程中\",{\"1\":{\"408\":1}}],[\"死锁\",{\"1\":{\"408\":1}}],[\"很多使用自旋cas的地方\",{\"1\":{\"403\":1}}],[\"去修改数据时\",{\"1\":{\"400\":1}}],[\"去阻塞队列取任务\",{\"1\":{\"353\":1}}],[\"循环性能开销\",{\"0\":{\"402\":1},\"1\":{\"399\":1}}],[\"循环往复的做达到屏障点\",{\"1\":{\"251\":1}}],[\"循环往复\",{\"1\":{\"251\":1}}],[\"问题\",{\"0\":{\"400\":1},\"1\":{\"399\":1}}],[\"交换\",{\"1\":{\"398\":1}}],[\"交易系统\",{\"1\":{\"119\":1}}],[\"旧的预期值\",{\"1\":{\"398\":1}}],[\"乖乖排到后面\",{\"1\":{\"397\":1}}],[\"抢锁\",{\"1\":{\"397\":1}}],[\"抢先进入此方法的线程会优先拥有\",{\"1\":{\"381\":1}}],[\"失败后\",{\"1\":{\"397\":1}}],[\"公平锁的优点是等待锁的线程不会饿死\",{\"1\":{\"394\":1}}],[\"公平锁是指多个线程按照申请锁的顺序来获取锁\",{\"1\":{\"394\":1}}],[\"公平锁\",{\"0\":{\"394\":1}}],[\"公平性\",{\"1\":{\"255\":1}}],[\"间接继承了aqs\",{\"1\":{\"393\":1}}],[\"唤醒阻塞线程的开销比非公平锁大\",{\"1\":{\"394\":1}}],[\"唤醒处于等待状态的线程\",{\"1\":{\"392\":1}}],[\"唤醒等待队列中的线程\",{\"1\":{\"296\":1}}],[\"共享方式tryacquireshared\",{\"1\":{\"392\":1}}],[\"共享项目到github\",{\"0\":{\"18\":1}}],[\"独占方式\",{\"1\":{\"392\":1}}],[\"起到一个重入计数器的作用\",{\"1\":{\"390\":1}}],[\"升级为重量级锁\",{\"1\":{\"390\":1}}],[\"升级为轻量级锁\",{\"1\":{\"389\":1}}],[\"升级\",{\"1\":{\"389\":1}}],[\"撤销\",{\"1\":{\"389\":2}}],[\"竞争失败\",{\"1\":{\"389\":1}}],[\"轻量级锁的获取\",{\"1\":{\"390\":1}}],[\"轻量级锁\",{\"0\":{\"390\":1},\"1\":{\"388\":1}}],[\"轻量级锁和偏向锁等优化策略\",{\"1\":{\"387\":1}}],[\"偏向锁不会主动释放\",{\"1\":{\"389\":1}}],[\"偏向锁的撤销\",{\"1\":{\"389\":1}}],[\"偏向锁的获取\",{\"1\":{\"389\":1}}],[\"偏向锁升级为轻量级锁\",{\"1\":{\"389\":1}}],[\"偏向锁标记是否为\",{\"1\":{\"389\":1}}],[\"偏向锁\",{\"0\":{\"389\":1},\"1\":{\"387\":1}}],[\"偏向时间戳\",{\"1\":{\"386\":1}}],[\"叫\",{\"1\":{\"386\":1}}],[\"他会记录下线程获取锁的次数\",{\"1\":{\"385\":1}}],[\"归\",{\"1\":{\"381\":1}}],[\"处于等待锁block状态的线程\",{\"1\":{\"381\":1}}],[\"处于wait状态的线程\",{\"1\":{\"381\":1}}],[\"处理任务执行期间抛出的异常\",{\"1\":{\"363\":1}}],[\"处理异步任务\",{\"0\":{\"362\":1}}],[\"处理异常\",{\"0\":{\"272\":1},\"1\":{\"358\":1,\"359\":1,\"362\":1}}],[\"处理被拒绝的任务\",{\"1\":{\"361\":1}}],[\"处理未捕获的异常\",{\"1\":{\"360\":2}}],[\"处理线程池中的异常可以确保程序的稳定性和可靠性\",{\"1\":{\"357\":1}}],[\"处理大型数据集时\",{\"1\":{\"326\":1}}],[\"处理请求逻辑\",{\"1\":{\"320\":1}}],[\"处理结果\",{\"1\":{\"294\":1}}],[\"处理所有结果\",{\"1\":{\"279\":1}}],[\"处理后数据\",{\"1\":{\"257\":1}}],[\"处理器可以改变语句对应\",{\"1\":{\"215\":1}}],[\"处理流\",{\"1\":{\"137\":1}}],[\"恢复为空\",{\"1\":{\"381\":1}}],[\"恢复中断状态\",{\"1\":{\"363\":1}}],[\"业务代码\",{\"1\":{\"378\":3}}],[\"得到斐波那契数列的第10个数的值\",{\"1\":{\"376\":1}}],[\"得到当前位置的斐波那契数\",{\"1\":{\"376\":1}}],[\"得让它去帮没干完活的线程干活\",{\"1\":{\"376\":1}}],[\"演示了如何使用fork\",{\"1\":{\"376\":1}}],[\"拆分出的小任务会被分配给线程池中的工作线程执行\",{\"1\":{\"376\":1}}],[\"拆箱\",{\"1\":{\"161\":1}}],[\"干完活的线程不能让它空下来\",{\"1\":{\"376\":1}}],[\"各自创建单独线程来执行队列里的任务\",{\"1\":{\"376\":1}}],[\"求出子问题的解\",{\"1\":{\"376\":1}}],[\"要想掌握fork\",{\"1\":{\"376\":1}}],[\"要么是黑色\",{\"1\":{\"423\":1}}],[\"要么任务执行失败需要回滚\",{\"1\":{\"374\":1}}],[\"要么不执行\",{\"1\":{\"212\":1}}],[\"要么完全执行\",{\"1\":{\"212\":1}}],[\"怎么实现有序的\",{\"0\":{\"447\":1,\"448\":1}}],[\"怎么解决循环性能开销问题\",{\"0\":{\"403\":1}}],[\"怎么解决aba问题\",{\"0\":{\"401\":1}}],[\"怎么使用\",{\"0\":{\"378\":1}}],[\"怎么优化\",{\"0\":{\"375\":1}}],[\"怎么办\",{\"1\":{\"177\":1}}],[\"记录着锁的状态\",{\"1\":{\"386\":1}}],[\"记录线程获取锁的次数\",{\"1\":{\"381\":1}}],[\"记录任务的执行日志\",{\"1\":{\"374\":1}}],[\"记录哪些内存块是可用的\",{\"1\":{\"79\":1}}],[\"磁盘文件等\",{\"1\":{\"374\":1}}],[\"事务性执行任务\",{\"1\":{\"374\":2}}],[\"事后观察调整\",{\"1\":{\"372\":1}}],[\"事中分析优化\",{\"1\":{\"372\":1}}],[\"事前评估\",{\"1\":{\"372\":1}}],[\"告警机制可以帮助及时发现线程池的问题\",{\"1\":{\"372\":1}}],[\"告警机制\",{\"1\":{\"372\":1}}],[\"压力测试等\",{\"1\":{\"372\":1}}],[\"压缩回收\",{\"1\":{\"110\":1}}],[\"测试\",{\"1\":{\"372\":1,\"373\":1}}],[\"测量gc停顿时间\",{\"1\":{\"121\":1}}],[\"评估的目的是为了在上线之前就能够预估系统的负载情况\",{\"1\":{\"372\":1}}],[\"评估应用需求\",{\"1\":{\"121\":1}}],[\"帮助用户更好地管理线程池\",{\"1\":{\"371\":1}}],[\"报警\",{\"1\":{\"371\":1}}],[\"您可以有效地处理线程池中的异常\",{\"1\":{\"363\":1}}],[\"捕获并处理异常\",{\"0\":{\"358\":1}}],[\"捕获异常\",{\"1\":{\"181\":1}}],[\"周期性执行任务的场景\",{\"1\":{\"356\":1}}],[\"过多的线程可能会导致系统资源的竞争和浪费\",{\"1\":{\"349\":1}}],[\"过滤\",{\"1\":{\"145\":1}}],[\"既可以提交不需要返回结果的任务\",{\"1\":{\"347\":1}}],[\"既然有了字节流\",{\"0\":{\"138\":1}}],[\"延迟队列通常用于实现定时任务调度\",{\"1\":{\"346\":1}}],[\"延迟队列用于存储延迟执行的任务\",{\"1\":{\"346\":1}}],[\"延迟队列\",{\"1\":{\"346\":1}}],[\"queue\",{\"1\":{\"346\":6}}],[\"quals\",{\"1\":{\"206\":1}}],[\"队列阻塞挂起\",{\"1\":{\"396\":1}}],[\"队列中的第一个线程才能获得锁\",{\"1\":{\"394\":1}}],[\"队列是同步移交队列synchronousqueue\",{\"1\":{\"354\":1}}],[\"队列已满则创建新线程\",{\"1\":{\"343\":1}}],[\"队列数据结构\",{\"1\":{\"296\":1}}],[\"优化算法\",{\"1\":{\"375\":1}}],[\"优先级队列根据元素的优先级来决定元素的顺序\",{\"1\":{\"346\":1}}],[\"优先级队列\",{\"1\":{\"346\":1}}],[\"优先级等属性\",{\"1\":{\"344\":1}}],[\"优雅关闭\",{\"1\":{\"342\":1}}],[\"优点\",{\"1\":{\"112\":3,\"188\":1}}],[\"立即停止所有任务\",{\"1\":{\"342\":1}}],[\"丢弃最旧策略\",{\"1\":{\"345\":1}}],[\"丢弃策略\",{\"1\":{\"345\":1}}],[\"丢弃队列最前的任务和由调用线程执行任务\",{\"1\":{\"340\":1,\"344\":1}}],[\"丢弃任务\",{\"1\":{\"340\":1,\"344\":1}}],[\"拒绝策略\",{\"1\":{\"340\":1,\"344\":1}}],[\"邮件发送完成\",{\"1\":{\"332\":1}}],[\"日志记录和回滚等机制\",{\"1\":{\"374\":1}}],[\"日志记录和回滚\",{\"1\":{\"374\":1}}],[\"日志记录等\",{\"1\":{\"371\":1}}],[\"日志记录\",{\"1\":{\"330\":1}}],[\"日志框架\",{\"1\":{\"153\":1}}],[\"充分利用多核cpu的优势\",{\"1\":{\"327\":1}}],[\"充分利用多处理器的优势\",{\"1\":{\"109\":1}}],[\"端口8080\",{\"1\":{\"320\":1}}],[\"频繁地创建和销毁数据库连接会导致性能下降和资源浪费\",{\"1\":{\"322\":1}}],[\"频繁地为每个请求创建和销毁线程将导致性能瓶颈\",{\"1\":{\"318\":1}}],[\"频繁的垃圾回收会导致应用程序的性能下降\",{\"1\":{\"314\":1}}],[\"频繁的线程创建和销毁会增加上下文切换的次数\",{\"1\":{\"311\":1}}],[\"频繁创建和销毁线程会导致大量短生命周期的对象被创建\",{\"1\":{\"314\":1}}],[\"频繁创建和销毁线程会导致操作系统不断地创建和销毁这些内核对象\",{\"1\":{\"309\":1}}],[\"频繁创建和销毁线程会导致内存分配和释放操作的频繁发生\",{\"1\":{\"308\":1}}],[\"频繁创建和销毁线程的开销大\",{\"1\":{\"306\":1}}],[\"寄存器\",{\"1\":{\"311\":1}}],[\"增加\",{\"1\":{\"416\":1}}],[\"增加了一些高级功能\",{\"1\":{\"391\":1}}],[\"增加了适应性自旋\",{\"1\":{\"391\":1}}],[\"增加了系统调用的开销\",{\"1\":{\"309\":1}}],[\"增删速率\",{\"1\":{\"411\":1}}],[\"增量为\",{\"1\":{\"228\":1}}],[\"增量式垃圾收集算法将垃圾回收过程分解成多个阶段\",{\"1\":{\"92\":1}}],[\"增量式垃圾收集算法\",{\"1\":{\"92\":1}}],[\"核心应该是线程池+任务队列\",{\"1\":{\"350\":1}}],[\"核心线程数为1\",{\"1\":{\"355\":1}}],[\"核心线程数为0\",{\"1\":{\"354\":1}}],[\"核心线程数和最大线程数大小一样\",{\"1\":{\"353\":1}}],[\"核心线程数\",{\"1\":{\"304\":1,\"344\":1}}],[\"核心方法await\",{\"1\":{\"251\":1}}],[\"固定大小的线程池\",{\"1\":{\"302\":1}}],[\"固定大小线程池包含固定数量的线程\",{\"1\":{\"351\":1}}],[\"固定大小线程池\",{\"0\":{\"290\":1,\"353\":1},\"1\":{\"351\":1}}],[\"试图向队列中添加元素的线程会被阻塞\",{\"1\":{\"296\":1}}],[\"试图从队列中取出元素的线程会被阻塞\",{\"1\":{\"296\":1}}],[\"试验和测量\",{\"1\":{\"121\":1}}],[\"满足不同应用场景的需求\",{\"1\":{\"294\":1}}],[\"展示如何使用自定义线程池执行异步任务\",{\"1\":{\"288\":1}}],[\"工具类来创建不同类型的线程池\",{\"1\":{\"286\":1}}],[\"工作窃取发生的时候\",{\"1\":{\"376\":1}}],[\"工作窃取算法\",{\"1\":{\"376\":1}}],[\"工作窃取队列通常用于实现任务并行化的线程池\",{\"1\":{\"346\":1}}],[\"工作窃取队列是一种用于并行计算的特殊队列\",{\"1\":{\"346\":1}}],[\"工作窃取队列\",{\"1\":{\"346\":1}}],[\"工作流程\",{\"1\":{\"353\":1,\"354\":1,\"355\":1,\"356\":1,\"418\":1}}],[\"工作\",{\"1\":{\"252\":1}}],[\"合并结果\",{\"1\":{\"281\":1}}],[\"合理地管理这些内存区域对于jvm高效运行和垃圾回收有着至关重要的作用\",{\"1\":{\"53\":1}}],[\"真实场景应用\",{\"0\":{\"280\":1}}],[\"消费结果但不返回新的结果\",{\"1\":{\"266\":1}}],[\"消费者处理的数据\",{\"1\":{\"257\":1}}],[\"消费者\",{\"1\":{\"257\":1}}],[\"看看是否录入一致\",{\"1\":{\"259\":1}}],[\"看做是包装对象\",{\"1\":{\"144\":1}}],[\"录入到excel之后\",{\"1\":{\"259\":1}}],[\"校对工作\",{\"1\":{\"259\":1}}],[\"遗传算法里需要选出两个人作为交配对象\",{\"1\":{\"259\":1}}],[\"遗传算法\",{\"1\":{\"259\":1}}],[\"另一个线程同时执行get操作\",{\"1\":{\"441\":1}}],[\"另一个线程处理任务并返回结果\",{\"1\":{\"256\":1}}],[\"另外一个线程还可以通过cas的方式进行获取\",{\"1\":{\"392\":1}}],[\"另外\",{\"1\":{\"100\":1}}],[\"双向链表的插入和删除只需要改变前驱节点\",{\"1\":{\"411\":1}}],[\"双线程数据交换\",{\"1\":{\"256\":1}}],[\"双重校验单例模式就是一个经典的指令重排的例子\",{\"1\":{\"215\":1}}],[\"尝试中断正在执行的任务\",{\"1\":{\"367\":1}}],[\"尝试终止正在执行的任务\",{\"1\":{\"342\":1}}],[\"尝试获取许可但不阻塞\",{\"1\":{\"255\":1}}],[\"尝试进入停车场\",{\"1\":{\"253\":1}}],[\"停止接受新任务\",{\"1\":{\"342\":1,\"343\":1}}],[\"停车一段时间后离开\",{\"1\":{\"254\":1}}],[\"停车和离开的过程\",{\"1\":{\"254\":1}}],[\"停顿时间较长\",{\"1\":{\"120\":1}}],[\"停顿时间要求\",{\"1\":{\"119\":1}}],[\"停顿时间不可预测\",{\"1\":{\"100\":1}}],[\"汽车\",{\"1\":{\"253\":1}}],[\"防止任务过载\",{\"1\":{\"346\":1}}],[\"防止系统资源耗尽\",{\"1\":{\"300\":1}}],[\"防止过载\",{\"1\":{\"253\":1}}],[\"防止内存泄漏\",{\"1\":{\"132\":1}}],[\"限制同时执行的任务数量\",{\"1\":{\"375\":1}}],[\"限制同时访问数据库的连接数\",{\"1\":{\"253\":1}}],[\"限制并发数\",{\"1\":{\"375\":2}}],[\"限流控制\",{\"1\":{\"253\":1}}],[\"信号量\",{\"0\":{\"253\":1},\"1\":{\"253\":1}}],[\"受影响\",{\"1\":{\"252\":1}}],[\"受检异常\",{\"1\":{\"180\":1}}],[\"个位置\",{\"1\":{\"434\":1}}],[\"个斐波那契数\",{\"1\":{\"376\":1}}],[\"个数\",{\"1\":{\"376\":1}}],[\"个线程出现问题\",{\"1\":{\"252\":1}}],[\"个槽位中\",{\"1\":{\"229\":1}}],[\"断\",{\"1\":{\"252\":1}}],[\"务由哪些线程完成无关紧要\",{\"1\":{\"252\":1}}],[\"至于这些任\",{\"1\":{\"252\":1}}],[\"须要指定任务数\",{\"1\":{\"252\":1}}],[\"除留取余法\",{\"1\":{\"433\":1}}],[\"除了互斥量本身开销\",{\"1\":{\"387\":1}}],[\"除了原子性\",{\"0\":{\"382\":1}}],[\"除非设置了allowcorethreadtimeout\",{\"1\":{\"344\":1}}],[\"除\",{\"1\":{\"252\":1}}],[\"届时\",{\"1\":{\"252\":1}}],[\"知道最后一个线程达到屏障点\",{\"1\":{\"251\":1}}],[\"知道有哪些垃圾收集器吗\",{\"0\":{\"98\":1}}],[\"模拟发送邮件时间\",{\"1\":{\"332\":1}}],[\"模拟处理时间\",{\"1\":{\"328\":1}}],[\"模拟任务执行\",{\"1\":{\"303\":1,\"305\":1}}],[\"模拟任务执行时间\",{\"1\":{\"251\":1}}],[\"模拟远程调用\",{\"1\":{\"281\":3}}],[\"模拟耗时操作\",{\"1\":{\"279\":3,\"288\":1}}],[\"模拟消费者线程\",{\"1\":{\"258\":1}}],[\"模拟生产者线程\",{\"1\":{\"258\":1}}],[\"模拟两个线程之间的数据交换\",{\"1\":{\"257\":1}}],[\"模拟停车场\",{\"1\":{\"254\":1}}],[\"模拟停车时间\",{\"1\":{\"253\":1}}],[\"模板已成功生成\",{\"1\":{\"11\":1}}],[\"正在执行任务\",{\"1\":{\"251\":13}}],[\"组合多个\",{\"0\":{\"268\":1}}],[\"组合以及异常处理等\",{\"1\":{\"261\":1}}],[\"组线程到达一个屏障\",{\"1\":{\"250\":1}}],[\"组件图\",{\"0\":{\"42\":1}}],[\"获取节点\",{\"1\":{\"428\":1}}],[\"获取新的哈希值\",{\"1\":{\"428\":1}}],[\"获取一个新的哈希值\",{\"1\":{\"427\":1}}],[\"获取一个许可\",{\"1\":{\"253\":1}}],[\"获取失败的话\",{\"1\":{\"396\":1}}],[\"获取不到才会到等待队列的队尾等待\",{\"1\":{\"395\":1}}],[\"获取state的方式分为两种\",{\"1\":{\"392\":1}}],[\"获取\",{\"1\":{\"381\":1}}],[\"获取当前的latch数量\",{\"1\":{\"249\":1}}],[\"获取到key的哈希值\",{\"1\":{\"429\":1}}],[\"获取到锁的线程可以重入\",{\"1\":{\"392\":1}}],[\"获取到\",{\"1\":{\"240\":1}}],[\"收到消费者的数据\",{\"1\":{\"257\":1}}],[\"收到\",{\"1\":{\"249\":1}}],[\"收集器是java虚拟机\",{\"1\":{\"100\":1}}],[\"收集器\",{\"1\":{\"98\":2,\"101\":1}}],[\"全军出击\",{\"1\":{\"249\":1}}],[\"全称为java虚拟机\",{\"1\":{\"131\":1}}],[\"敌方还有5秒达到战场\",{\"1\":{\"249\":1}}],[\"协调子线程开始动作\",{\"1\":{\"249\":1}}],[\"协调子线程结束动作\",{\"1\":{\"249\":1}}],[\"场景\",{\"1\":{\"416\":2}}],[\"场景描述\",{\"0\":{\"318\":1,\"322\":1,\"326\":1,\"330\":1,\"334\":1}}],[\"场景2\",{\"1\":{\"249\":1}}],[\"场景1\",{\"1\":{\"249\":1}}],[\"马上到\",{\"1\":{\"249\":1}}],[\"上个卫生间\",{\"1\":{\"249\":1}}],[\"上面的代码示例中int\",{\"0\":{\"67\":1}}],[\"稍等\",{\"1\":{\"249\":1}}],[\"铠\",{\"1\":{\"249\":4}}],[\"哪吒\",{\"1\":{\"249\":4}}],[\"哪些是不可达的\",{\"1\":{\"88\":1}}],[\"兰陵王\",{\"1\":{\"249\":4}}],[\"倒计数器\",{\"0\":{\"249\":1},\"1\":{\"249\":1}}],[\"任意数\",{\"1\":{\"431\":1}}],[\"任意对象为值的存储结构\",{\"1\":{\"247\":1}}],[\"任务分解\",{\"1\":{\"376\":1}}],[\"任务分配与结果收集\",{\"1\":{\"256\":1}}],[\"任务拆分\",{\"1\":{\"375\":2}}],[\"任务堆积\",{\"1\":{\"372\":1}}],[\"任务类型和处理速度等进行评估\",{\"1\":{\"372\":1}}],[\"任务的性质\",{\"1\":{\"349\":1}}],[\"任务加入队列\",{\"1\":{\"340\":1}}],[\"任务执行情况等\",{\"1\":{\"372\":1}}],[\"任务执行时间较短的场景\",{\"1\":{\"351\":1}}],[\"任务执行时间和任务队列容量等因素综合考虑\",{\"1\":{\"349\":1}}],[\"任务执行时间\",{\"1\":{\"349\":1}}],[\"任务执行完成\",{\"0\":{\"341\":1},\"1\":{\"343\":1}}],[\"任务执行\",{\"0\":{\"340\":1},\"1\":{\"376\":1}}],[\"任务执行和资源回收\",{\"1\":{\"337\":1}}],[\"任务结果\",{\"1\":{\"339\":1}}],[\"任务可以通过execute\",{\"1\":{\"339\":1}}],[\"任务提交到线程池\",{\"1\":{\"343\":1}}],[\"任务提交\",{\"0\":{\"339\":1},\"1\":{\"337\":1,\"373\":2}}],[\"任务对象等\",{\"1\":{\"314\":1}}],[\"任务\",{\"1\":{\"303\":1,\"305\":1}}],[\"任务队列中的任务数据也不会丢失\",{\"1\":{\"374\":1}}],[\"任务队列大小等参数\",{\"1\":{\"372\":1}}],[\"任务队列类型和大小等参数\",{\"1\":{\"372\":1}}],[\"任务队列容量\",{\"1\":{\"349\":1}}],[\"任务队列\",{\"1\":{\"299\":1,\"304\":1,\"338\":1,\"344\":1}}],[\"任务1结果\",{\"1\":{\"294\":1}}],[\"任务完成\",{\"1\":{\"267\":1,\"279\":1}}],[\"任务完成后的回调\",{\"0\":{\"264\":1}}],[\"任务逻辑\",{\"1\":{\"263\":2,\"339\":2,\"358\":1,\"362\":1,\"363\":1}}],[\"任何一个线程都能并发访问localvariable\",{\"1\":{\"222\":1}}],[\"任何对string的修改都会创建一个新的string对象\",{\"1\":{\"169\":1}}],[\"任何对\",{\"1\":{\"168\":1}}],[\"符\",{\"1\":{\"247\":1}}],[\"管道输入\",{\"1\":{\"247\":3}}],[\"管理着一组工作线程\",{\"1\":{\"376\":1}}],[\"管理平台可以根据实际需求提供各种功能\",{\"1\":{\"371\":1}}],[\"管理\",{\"1\":{\"132\":1}}],[\"管理机制\",{\"1\":{\"66\":1}}],[\"守护线程\",{\"1\":{\"246\":1}}],[\"守护线程了解吗\",{\"0\":{\"246\":1}}],[\"锁粗化\",{\"1\":{\"387\":2}}],[\"锁消除等\",{\"1\":{\"391\":1}}],[\"锁消除\",{\"1\":{\"387\":2}}],[\"锁升级方向\",{\"1\":{\"388\":1}}],[\"锁升级的过程是什么样的\",{\"0\":{\"388\":1}}],[\"锁升级\",{\"0\":{\"386\":1}}],[\"锁对象的时候有个计数器\",{\"1\":{\"385\":1}}],[\"锁的实现\",{\"1\":{\"391\":1}}],[\"锁的状态\",{\"1\":{\"386\":1}}],[\"锁的重入次数\",{\"1\":{\"381\":1}}],[\"锁的释放等\",{\"1\":{\"245\":1}}],[\"锁\",{\"0\":{\"377\":1}}],[\"锁和条件等待机制\",{\"1\":{\"296\":1}}],[\"锁和条件等待\",{\"1\":{\"296\":1}}],[\"锁状态标志\",{\"1\":{\"386\":1}}],[\"锁状态标志等\",{\"1\":{\"78\":1}}],[\"锁状态\",{\"1\":{\"82\":1}}],[\"终止遍历\",{\"1\":{\"416\":1}}],[\"终止死锁进程\",{\"1\":{\"409\":1}}],[\"终止状态\",{\"1\":{\"241\":1}}],[\"终端操作会返回一个结果\",{\"1\":{\"145\":1}}],[\"终端操作\",{\"1\":{\"145\":1}}],[\"程需要等待其他线程做出一些特定动作\",{\"1\":{\"241\":1}}],[\"程序顺序规则\",{\"1\":{\"216\":1}}],[\"程序将无法继续执行\",{\"1\":{\"182\":2}}],[\"程序还没有进入try语句块就因为异常导致程序终止\",{\"1\":{\"182\":1}}],[\"程序运行中出现异常\",{\"1\":{\"180\":1}}],[\"程序运行速度变慢\",{\"1\":{\"84\":1}}],[\"程序返回\",{\"1\":{\"164\":1}}],[\"程序要经过先编译\",{\"1\":{\"151\":1}}],[\"程序从源代码到运行主要有三步\",{\"1\":{\"150\":1}}],[\"程序所需的所有内容的集合\",{\"1\":{\"148\":1}}],[\"程序可以访问和操作对象的属性和方法\",{\"1\":{\"78\":1}}],[\"程序计数器等\",{\"1\":{\"311\":1}}],[\"程序计数器和本地方法栈\",{\"1\":{\"53\":1}}],[\"程序计数器\",{\"1\":{\"53\":1,\"55\":1,\"57\":1,\"133\":1,\"244\":1}}],[\"阻塞呗\",{\"1\":{\"419\":1}}],[\"阻塞和唤醒操作\",{\"1\":{\"296\":1}}],[\"阻塞队列是delayedworkqueue\",{\"1\":{\"356\":1}}],[\"阻塞队列是无界队列linkedblockingqueue\",{\"1\":{\"355\":1}}],[\"阻塞队列是一种特殊的队列数据结构\",{\"1\":{\"296\":1}}],[\"阻塞队列为无界队列linkedblockingqueue\",{\"1\":{\"353\":1}}],[\"阻塞队列通过结合队列数据结构\",{\"1\":{\"296\":1}}],[\"阻塞队列需要保证在多线程环境下的线程安全性\",{\"1\":{\"296\":1}}],[\"阻塞队列内部通常使用锁和条件等待来实现线程的阻塞和唤醒\",{\"1\":{\"296\":1}}],[\"阻塞队列基于数组或链表等数据结构实现\",{\"1\":{\"296\":1}}],[\"阻塞队列的实现通常基于经典的队列数据结构\",{\"1\":{\"296\":1}}],[\"阻塞直到有可用的许可\",{\"1\":{\"253\":1}}],[\"阻塞状态\",{\"1\":{\"241\":1}}],[\"阻止实例中那些用此关键字修饰的的变量序列化\",{\"1\":{\"177\":1}}],[\"统一各线程动作开始的时机\",{\"1\":{\"249\":1}}],[\"统一的内存管理\",{\"1\":{\"76\":1}}],[\"统的称作\",{\"1\":{\"241\":1}}],[\"状态转换图\",{\"0\":{\"370\":1}}],[\"状态下完成终止操作后\",{\"1\":{\"369\":1}}],[\"状态下完成了所有任务\",{\"1\":{\"368\":1}}],[\"状态下中断了所有任务后\",{\"1\":{\"368\":1}}],[\"状态\",{\"1\":{\"241\":1,\"366\":1,\"367\":1,\"368\":1,\"369\":1}}],[\"状态图\",{\"0\":{\"31\":1}}],[\"让出线程\",{\"1\":{\"445\":1}}],[\"让出优先权\",{\"1\":{\"240\":1}}],[\"让一\",{\"1\":{\"250\":1}}],[\"让后统计数量\",{\"1\":{\"145\":1}}],[\"资源剥夺\",{\"1\":{\"409\":1}}],[\"资源控制\",{\"1\":{\"300\":1}}],[\"资源双向传递\",{\"1\":{\"256\":1}}],[\"资源池管理\",{\"1\":{\"253\":1}}],[\"资源后就可以继续运行\",{\"1\":{\"240\":1}}],[\"资源密集型的程序中\",{\"1\":{\"84\":1}}],[\"具体来说\",{\"1\":{\"306\":1}}],[\"具体唤醒哪个等待的线程是随机的\",{\"1\":{\"240\":1}}],[\"具有保存key\",{\"1\":{\"444\":1}}],[\"具有排他性\",{\"1\":{\"384\":1}}],[\"具有固定容量的特点\",{\"1\":{\"346\":1}}],[\"具有高吞吐量和无限容量的特点\",{\"1\":{\"346\":1}}],[\"具有高效\",{\"1\":{\"106\":1}}],[\"具有以下特点\",{\"1\":{\"90\":1}}],[\"函数会唤醒被阻塞到该共享变量上的一个线程\",{\"1\":{\"240\":1}}],[\"函数\",{\"1\":{\"240\":1,\"246\":1}}],[\"函数作为参数传递到方法中\",{\"1\":{\"141\":1}}],[\"直至找到空闲的位置\",{\"1\":{\"434\":1}}],[\"直至找到空闲位置\",{\"1\":{\"434\":1}}],[\"直至占有资源的线程释放该资源\",{\"1\":{\"408\":1}}],[\"直到计数器清零\",{\"1\":{\"385\":1}}],[\"直到计数器为0\",{\"1\":{\"252\":1}}],[\"直到计算到基本情况\",{\"1\":{\"376\":1}}],[\"直到任务队列为空为止\",{\"1\":{\"376\":1}}],[\"直到拆分的任务足够小而可以被快速处理为止\",{\"1\":{\"376\":1}}],[\"直到达到拆分任务的终止条件\",{\"1\":{\"376\":1}}],[\"直到达到预期的效果\",{\"1\":{\"372\":1}}],[\"直到达到最大线程数\",{\"1\":{\"344\":1}}],[\"直到所有小任务的结果都被合并到大任务的结果中为止\",{\"1\":{\"376\":1}}],[\"直到所有任务执行完毕后才会关闭\",{\"1\":{\"348\":1}}],[\"直到所有线程都到达\",{\"1\":{\"251\":1}}],[\"直到线程数量等于核心线程数\",{\"1\":{\"344\":1}}],[\"直到队列有空闲位置\",{\"1\":{\"296\":1}}],[\"直到队列非空\",{\"1\":{\"296\":1}}],[\"直到另一个线程也调用\",{\"1\":{\"258\":1}}],[\"直到对方也到达此同步点\",{\"1\":{\"258\":1}}],[\"直到有可用许可为止\",{\"1\":{\"254\":1}}],[\"直到最后一个线程到达屏障时\",{\"1\":{\"250\":1}}],[\"直到其他线程通过\",{\"1\":{\"240\":1}}],[\"直接调用hashmap的put方法\",{\"1\":{\"450\":1}}],[\"直接根据\",{\"1\":{\"433\":1}}],[\"直接定址法\",{\"1\":{\"433\":1}}],[\"直接插入或者删除就可以了\",{\"1\":{\"411\":1}}],[\"直接\",{\"1\":{\"183\":1}}],[\"直接返回字符串常量池中的字符串\",{\"1\":{\"172\":1}}],[\"直接返回\",{\"1\":{\"164\":1,\"376\":1,\"428\":1}}],[\"直接可达的对象\",{\"1\":{\"100\":1}}],[\"直接指针访问方式\",{\"1\":{\"83\":1}}],[\"灵活性\",{\"1\":{\"239\":1}}],[\"例\",{\"1\":{\"239\":2}}],[\"例如十位和百位\",{\"1\":{\"433\":1}}],[\"例如1232放到下标1232的位置\",{\"1\":{\"433\":1}}],[\"例如atomicinteger\",{\"1\":{\"405\":1}}],[\"例如数据库\",{\"1\":{\"374\":1}}],[\"例如定时任务调度\",{\"1\":{\"351\":1}}],[\"例如任务依赖性较强的场景\",{\"1\":{\"351\":1}}],[\"例如并发量稳定的服务器应用\",{\"1\":{\"351\":1}}],[\"例如清理临时文件\",{\"1\":{\"334\":1}}],[\"例如发送邮件\",{\"1\":{\"330\":1}}],[\"例如线程对象\",{\"1\":{\"314\":1}}],[\"例如读取\",{\"1\":{\"211\":1}}],[\"例如整型默认为0\",{\"1\":{\"201\":1}}],[\"例如整数\",{\"1\":{\"65\":1}}],[\"例如添加\",{\"1\":{\"177\":1}}],[\"例如图像\",{\"1\":{\"138\":1}}],[\"例如图片缓存\",{\"1\":{\"89\":1}}],[\"例如jit编译器生成的机器代码\",{\"1\":{\"91\":1}}],[\"例如java中的outofmemoryerror\",{\"1\":{\"84\":1}}],[\"例如关闭文件\",{\"1\":{\"90\":1}}],[\"例如threadlocal和weakhashmap\",{\"1\":{\"89\":1}}],[\"例如\",{\"1\":{\"89\":2,\"121\":1,\"125\":1,\"127\":1,\"168\":1,\"206\":1,\"240\":1,\"326\":1,\"371\":1}}],[\"例如打开文件\",{\"1\":{\"86\":1}}],[\"例如对象的哈希码\",{\"1\":{\"82\":1}}],[\"例如string\",{\"1\":{\"74\":1}}],[\"例如运行时常量池\",{\"1\":{\"55\":1}}],[\"系列方法而被挂起的线程\",{\"1\":{\"240\":1}}],[\"系列方法后被挂起的线程\",{\"1\":{\"240\":1}}],[\"系\",{\"1\":{\"239\":1}}],[\"系统重启后的处理\",{\"1\":{\"374\":1}}],[\"系统无法继续执行任务\",{\"1\":{\"374\":1}}],[\"系统资源\",{\"1\":{\"349\":2}}],[\"系统资源消耗\",{\"0\":{\"307\":1}}],[\"系统需要加载这两个excel\",{\"1\":{\"259\":1}}],[\"系统自动抛异常\",{\"1\":{\"181\":1}}],[\"系统的实现\",{\"1\":{\"148\":1}}],[\"系统上下文图\",{\"0\":{\"40\":1}}],[\"鄙人三某\",{\"1\":{\"231\":1}}],[\"鄙人张三\",{\"1\":{\"222\":1}}],[\"子线程使用countdownlatch\",{\"1\":{\"249\":2}}],[\"子线程\",{\"1\":{\"231\":1,\"232\":1}}],[\"子类可以扩大方法的访问范围\",{\"1\":{\"197\":1}}],[\"父子线程怎么共享数据\",{\"0\":{\"231\":1}}],[\"父类不希望子类出现更多的异常\",{\"1\":{\"197\":1}}],[\"扩容\",{\"1\":{\"440\":1}}],[\"扩容优化\",{\"1\":{\"439\":1}}],[\"扩容在什么时候呢\",{\"0\":{\"436\":1}}],[\"扩容后的\",{\"1\":{\"230\":1}}],[\"扩展成一个范围更大的锁\",{\"1\":{\"387\":1}}],[\"扩展或定制某个功能或组件的实现\",{\"1\":{\"153\":1}}],[\"且任务队列为空\",{\"1\":{\"368\":1}}],[\"且空闲时间超过keepalivetime\",{\"1\":{\"341\":1}}],[\"且当前散列数组中\",{\"1\":{\"230\":1}}],[\"且b\",{\"1\":{\"216\":1}}],[\"往下执行\",{\"1\":{\"251\":1}}],[\"往后找一圈没找到就会从头开始找\",{\"1\":{\"229\":1}}],[\"往往选择zgc来确保系统的实时性和低延迟\",{\"1\":{\"116\":1}}],[\"带来的好处就是\",{\"1\":{\"228\":1}}],[\"黄金分割数\",{\"1\":{\"228\":1}}],[\"元素是按照是按照\",{\"1\":{\"448\":1}}],[\"元素比较少\",{\"1\":{\"437\":1}}],[\"元素比较多\",{\"1\":{\"437\":1}}],[\"元素数组\",{\"1\":{\"228\":1}}],[\"元空间进行垃圾回收\",{\"1\":{\"94\":1}}],[\"元空间不再位于java堆中\",{\"1\":{\"91\":1}}],[\"元空间提供更好的类加载和卸载支持\",{\"1\":{\"76\":1}}],[\"元空间设计使其更好地与分代垃圾回收器协同工作\",{\"1\":{\"76\":1}}],[\"元空间利用新的垃圾回收算法\",{\"1\":{\"76\":1}}],[\"元空间的优势\",{\"0\":{\"76\":1}}],[\"元空间在本地内存中动态扩展\",{\"1\":{\"59\":1}}],[\"元空间在本地内存中分配\",{\"1\":{\"57\":1,\"76\":1}}],[\"元空间用于存储类元数据\",{\"1\":{\"59\":1}}],[\"元空间\",{\"1\":{\"57\":1,\"91\":1,\"201\":1}}],[\"元空间使用的是本地内存而不是堆内存\",{\"1\":{\"53\":1}}],[\"及时发现线程池的异常情况\",{\"1\":{\"372\":1}}],[\"及时发现和修复这些问题是保证程序性能和稳定性的重要一环\",{\"1\":{\"84\":1}}],[\"及时调用remove\",{\"1\":{\"226\":1}}],[\"读操作频繁且对实时性要求不高的场景\",{\"1\":{\"418\":1}}],[\"读操作在原数组上\",{\"1\":{\"418\":1}}],[\"读写分离\",{\"1\":{\"418\":1}}],[\"读也是以某个threadlocal作为引用\",{\"1\":{\"224\":1}}],[\"读取\",{\"1\":{\"222\":1}}],[\"读取或写入操作使用缓冲区\",{\"1\":{\"139\":1}}],[\"存在一定空间浪费\",{\"1\":{\"411\":1}}],[\"存放token\",{\"1\":{\"223\":1}}],[\"存储结构\",{\"1\":{\"421\":1}}],[\"存储entry类型的元素\",{\"1\":{\"228\":1}}],[\"存储操作\",{\"1\":{\"220\":1}}],[\"存储方式\",{\"1\":{\"201\":1}}],[\"存储方法调用的局部变量和部分方法执行时的中间结果\",{\"1\":{\"68\":1}}],[\"存储方法调用的局部变量\",{\"1\":{\"53\":1,\"71\":1}}],[\"存储字符串\",{\"1\":{\"169\":2}}],[\"存储在栈中\",{\"1\":{\"69\":1}}],[\"存储在字符串常量池中\",{\"1\":{\"65\":1,\"70\":1}}],[\"存储过程\",{\"1\":{\"69\":1}}],[\"存储类加载时从类文件中提取的常量\",{\"1\":{\"71\":1}}],[\"存储类文件中的各种常量\",{\"1\":{\"68\":1}}],[\"存储类的元数据\",{\"1\":{\"57\":1}}],[\"存储本地方法的调用信息\",{\"1\":{\"53\":1}}],[\"存储对象实例和数组\",{\"1\":{\"53\":1}}],[\"存储已加载的类信息\",{\"1\":{\"53\":1}}],[\"​\",{\"1\":{\"220\":1}}],[\"都可以协调多线程的结束动作\",{\"1\":{\"250\":1}}],[\"都是往自己的threadlocalmap里存\",{\"1\":{\"224\":1}}],[\"都在屏障后的写操作之前被刷新到主内存中\",{\"1\":{\"220\":1}}],[\"都会检测\",{\"1\":{\"416\":1}}],[\"都会回收该对象占用的内存\",{\"1\":{\"225\":1}}],[\"都会返回一个新的\",{\"1\":{\"168\":1}}],[\"都会触发full\",{\"1\":{\"96\":1}}],[\"屏障将被拆\",{\"1\":{\"252\":1}}],[\"屏障会自动重置\",{\"1\":{\"251\":1}}],[\"屏障才会开门\",{\"1\":{\"250\":1}}],[\"屏障\",{\"1\":{\"220\":4}}],[\"屏蔽差异性\",{\"1\":{\"195\":1}}],[\"保留整数倍以下的数据\",{\"1\":{\"431\":1}}],[\"保留的是hash值的地位特征\",{\"1\":{\"430\":1}}],[\"保证一定获取锁成功\",{\"1\":{\"444\":1}}],[\"保证极端情况下的查找效率\",{\"1\":{\"435\":1}}],[\"保证了树的相对平衡\",{\"1\":{\"425\":1}}],[\"保证了操作的最坏时间复杂度为o\",{\"1\":{\"424\":1}}],[\"保证了可见性\",{\"1\":{\"418\":1}}],[\"保证了变量在多线程之间的可见性\",{\"1\":{\"392\":1}}],[\"保证的是对一个变量执行操作的原子性\",{\"1\":{\"404\":1}}],[\"保证可见性和有序性\",{\"1\":{\"218\":1}}],[\"保障系统的性能和稳定性\",{\"1\":{\"372\":1}}],[\"保持插入顺序或访问顺序\",{\"1\":{\"192\":1}}],[\"规则\",{\"1\":{\"216\":2}}],[\"规定了需要提供的功能或扩展点\",{\"1\":{\"153\":1}}],[\"那arraylist怎么序列化呢\",{\"0\":{\"415\":1}}],[\"那就重新匹配\",{\"1\":{\"249\":1}}],[\"那就接着去找空着的坑\",{\"1\":{\"229\":1}}],[\"那怎么不直接调用run\",{\"0\":{\"238\":1}}],[\"那怎么解决内存泄漏问题呢\",{\"0\":{\"226\":1}}],[\"那说说什么是指令重排\",{\"0\":{\"215\":1}}],[\"那么发生哈希冲突的概率就增加了\",{\"1\":{\"437\":1}}],[\"那么为什么选择了0\",{\"0\":{\"437\":1}}],[\"那么hash值高位是与0做\",{\"1\":{\"431\":1}}],[\"那么直接就获取到锁返回了\",{\"1\":{\"397\":1}}],[\"那么这个线程可以无需阻塞直接获取到锁\",{\"1\":{\"395\":1}}],[\"那么这种重排序并不非法\",{\"1\":{\"216\":1}}],[\"那么问题来了\",{\"1\":{\"376\":1}}],[\"那么可能可以配置较少的线程来处理任务\",{\"1\":{\"349\":1}}],[\"那么可能需要配置更多的线程来处理任务\",{\"1\":{\"349\":1}}],[\"那么可能需要更多的线程来处理任务队列中的任务\",{\"1\":{\"349\":1}}],[\"那么可以通过显式地指定serialversionuid来保持兼容性\",{\"1\":{\"177\":1}}],[\"那么你可能需要配置较多的线程数\",{\"1\":{\"349\":1}}],[\"那么你可能需要配置较少的线程数\",{\"1\":{\"349\":1}}],[\"那么它会一直阻塞\",{\"1\":{\"259\":1}}],[\"那么守护线程和用户线程有什么区别呢\",{\"1\":{\"246\":1}}],[\"那么run方法还是运行在主线程中\",{\"1\":{\"238\":1}}],[\"那么访问这个变量的每个线程都会有这个变量的一个本地拷贝\",{\"1\":{\"222\":1}}],[\"那么线程b中的任意操作\",{\"1\":{\"216\":1}}],[\"那么a线程的threadb\",{\"1\":{\"216\":1}}],[\"那么a\",{\"1\":{\"216\":1}}],[\"那么第一个操作的执行结果将对第二个操作可见\",{\"1\":{\"216\":1}}],[\"那么拷贝后对象\",{\"1\":{\"208\":1}}],[\"那么即使线程不再使用某个threadlocal实例\",{\"1\":{\"227\":1}}],[\"那么即使类的结构发生了变化\",{\"1\":{\"177\":1}}],[\"那么即使外部类不再需要\",{\"1\":{\"86\":1}}],[\"那么序列化和反序列化时可能会出现版本不一致的问题\",{\"1\":{\"177\":1}}],[\"那么自动装箱时不会new新的integer对象\",{\"1\":{\"173\":1}}],[\"那么会生成多个中间对象\",{\"1\":{\"171\":2}}],[\"第二次增加2^2\",{\"1\":{\"434\":1}}],[\"第二步和第三步就可能会重排序\",{\"1\":{\"215\":1}}],[\"第一次增加\",{\"1\":{\"434\":1}}],[\"第3和第4句其实是等效的\",{\"1\":{\"213\":1}}],[\"第2句先读i的值\",{\"1\":{\"213\":1}}],[\"第1句是基本类型赋值\",{\"1\":{\"213\":1}}],[\"序性保证了程序的执行顺序与代码的顺序一致\",{\"1\":{\"212\":1}}],[\"序列化不包含静态变量\",{\"1\":{\"177\":1}}],[\"序列化\",{\"0\":{\"176\":1},\"1\":{\"177\":1,\"208\":1}}],[\"序列图\",{\"0\":{\"29\":1}}],[\"写完将元素数组指向副本\",{\"1\":{\"418\":1}}],[\"写操作在副本上\",{\"1\":{\"418\":1}}],[\"写操作较少的情况下\",{\"1\":{\"418\":1}}],[\"写时复制\",{\"1\":{\"418\":1}}],[\"写入数据同样判断链表\",{\"1\":{\"445\":1}}],[\"写入变量\",{\"1\":{\"222\":1}}],[\"写入\",{\"1\":{\"222\":1}}],[\"写入和同步操作\",{\"1\":{\"211\":1}}],[\"写缓冲区\",{\"1\":{\"215\":1}}],[\"写共享变量的副本\",{\"1\":{\"211\":1}}],[\"拷贝被拷贝对象的成员变量的值\",{\"1\":{\"208\":1}}],[\"完整的升级过程\",{\"1\":{\"390\":1}}],[\"完整示例\",{\"0\":{\"288\":1}}],[\"完全拷贝一个对象\",{\"1\":{\"208\":1}}],[\"完成\",{\"1\":{\"271\":1}}],[\"完成后\",{\"1\":{\"269\":1}}],[\"完成后才通知\",{\"1\":{\"139\":1}}],[\"完成任务\",{\"1\":{\"251\":13}}],[\"完成对并发标记阶段遗漏对象的标记\",{\"1\":{\"103\":1}}],[\"深拷贝如何实现呢\",{\"1\":{\"208\":1}}],[\"深拷贝是安全的\",{\"1\":{\"208\":1}}],[\"深拷贝\",{\"1\":{\"208\":1}}],[\"仅拷贝被拷贝对象的成员变量的值\",{\"1\":{\"208\":1}}],[\"仅包含字符串字面值\",{\"1\":{\"66\":1}}],[\"浅拷贝如何实现呢\",{\"1\":{\"208\":1}}],[\"浅拷贝的话如果有引用类型\",{\"1\":{\"208\":1}}],[\"浅拷贝\",{\"1\":{\"208\":1}}],[\"比较内存位置\",{\"1\":{\"398\":1}}],[\"比较\",{\"1\":{\"398\":1}}],[\"比较这两个对象\",{\"1\":{\"205\":1}}],[\"比\",{\"1\":{\"391\":1}}],[\"比如copyonwritearraylist类\",{\"1\":{\"416\":1}}],[\"比如arraylist\",{\"1\":{\"416\":1}}],[\"比如jconsole\",{\"1\":{\"409\":1}}],[\"比如我们需要将纸制银行流水通过人工的方式录入成电子银行流水\",{\"1\":{\"259\":1}}],[\"比如我们熟悉的空指针\",{\"1\":{\"180\":1}}],[\"比如有玩家超时未确认\",{\"1\":{\"249\":1}}],[\"比如垃圾回收线程\",{\"1\":{\"246\":1}}],[\"比如锁还是持有不让出的\",{\"1\":{\"240\":1}}],[\"比如虚拟机异常\",{\"1\":{\"180\":1}}],[\"⽅法\",{\"1\":{\"205\":1,\"206\":1}}],[\"⽅法名\",{\"1\":{\"202\":3}}],[\"判断tab\",{\"1\":{\"427\":1}}],[\"判断tab是否位空或者长度为0\",{\"1\":{\"427\":1}}],[\"判断是否超过阈值\",{\"1\":{\"427\":1}}],[\"判断是否为可偏向状态\",{\"1\":{\"389\":1}}],[\"判断是否有空闲线程\",{\"1\":{\"354\":1}}],[\"判断两个对象是否相等\",{\"1\":{\"205\":1}}],[\"判断两个对象是不是同⼀个对象\",{\"1\":{\"205\":1}}],[\"判断哪些对象是可达的\",{\"1\":{\"88\":1}}],[\"经常被用在需要释放资源的情况下\",{\"1\":{\"204\":1}}],[\"经过处理\",{\"1\":{\"294\":1}}],[\"经过了编译器的指令重排序\",{\"1\":{\"215\":1}}],[\"经过拼接新生成了string对象\",{\"1\":{\"171\":1}}],[\"经过多次minor\",{\"1\":{\"91\":1}}],[\"必须把共享变量的最新值刷新到主内存中\",{\"1\":{\"383\":1}}],[\"必须依存于某一实例\",{\"1\":{\"202\":1}}],[\"必须在由程序运⾏期间才能决定\",{\"1\":{\"196\":1}}],[\"随时调整线程池的配置\",{\"1\":{\"372\":1}}],[\"随对象的销毁而销毁\",{\"1\":{\"201\":1}}],[\"随对象的创建而生\",{\"1\":{\"201\":1}}],[\"随着方法或代码块的执行而创建和销毁\",{\"1\":{\"201\":1}}],[\"设定为3\",{\"1\":{\"254\":1}}],[\"设定可用许可数量为3\",{\"1\":{\"253\":1}}],[\"设计层面\",{\"1\":{\"200\":1}}],[\"设置线程的\",{\"1\":{\"360\":1}}],[\"设置每个region的大小\",{\"1\":{\"105\":1}}],[\"设置在进行混合回收之前\",{\"1\":{\"105\":1}}],[\"设置目标最大gc停顿时间\",{\"1\":{\"105\":1,\"120\":1}}],[\"设置对象头\",{\"1\":{\"78\":1}}],[\"设置协议\",{\"1\":{\"11\":1}}],[\"设置应用描述\",{\"1\":{\"11\":1}}],[\"设置应用版本号\",{\"1\":{\"11\":1}}],[\"设置应用名称\",{\"1\":{\"11\":1}}],[\"抽象同步队列\",{\"1\":{\"392\":1}}],[\"抽象方法\",{\"1\":{\"392\":2}}],[\"抽象方法是为了被重写\",{\"1\":{\"200\":1}}],[\"抽象方法可以有public\",{\"1\":{\"200\":1}}],[\"抽象类是对类的抽象\",{\"1\":{\"200\":1}}],[\"抽象类\",{\"0\":{\"200\":1}}],[\"普通的二叉搜索树在最坏情况下可能会退化成链表\",{\"1\":{\"424\":1}}],[\"普通的直接引用\",{\"1\":{\"199\":1}}],[\"普通的对象引用赋值\",{\"1\":{\"89\":1}}],[\"指线程获取到的资源在自己使用完之前不能被其它线程抢占\",{\"1\":{\"408\":1}}],[\"指线程对己经获取到的资源进行排它性使用\",{\"1\":{\"408\":1}}],[\"指一个\",{\"1\":{\"408\":1}}],[\"指向持有objectmonitor对象的线程\",{\"1\":{\"381\":1}}],[\"指向对象本身的一个指针\",{\"1\":{\"199\":1}}],[\"指定加锁对象\",{\"1\":{\"378\":1}}],[\"指定自定义线程池\",{\"0\":{\"285\":1}}],[\"指定的睡眠时间到了后该函数会正常返回\",{\"1\":{\"240\":1}}],[\"指令则指向同步代码块的结束位置\",{\"1\":{\"380\":1}}],[\"指令指向同步代码块的开始位置\",{\"1\":{\"380\":1}}],[\"指令重排也是有一些限制的\",{\"1\":{\"216\":1}}],[\"指令重排有限制吗\",{\"0\":{\"216\":1}}],[\"指令级并行的重排序\",{\"1\":{\"215\":1}}],[\"指针碰撞适用于内存连续的情况\",{\"1\":{\"79\":1}}],[\"指针碰撞适用于\",{\"1\":{\"79\":1}}],[\"指针碰撞\",{\"1\":{\"79\":2}}],[\"变成无锁状态\",{\"1\":{\"389\":1}}],[\"变量\",{\"1\":{\"198\":2,\"200\":2,\"416\":1}}],[\"变为堆的一部分\",{\"1\":{\"56\":1}}],[\"若为引用数据类型则返回值为被重写方法的返回值或是其子类\",{\"1\":{\"197\":1}}],[\"参与协作的线程数\",{\"1\":{\"252\":1}}],[\"参数顺序满足任一\",{\"1\":{\"197\":1}}],[\"参数类型\",{\"1\":{\"197\":1,\"347\":1}}],[\"参数个数\",{\"1\":{\"197\":1}}],[\"参考资料\",{\"1\":{\"9\":1}}],[\"形成了一个等待环路\",{\"1\":{\"408\":1}}],[\"形参与成员变量名字重名\",{\"1\":{\"199\":1}}],[\"形参相同\",{\"1\":{\"197\":1}}],[\"形参不同\",{\"1\":{\"197\":1}}],[\"形式编写的java程序\",{\"1\":{\"131\":1}}],[\"重入多少次\",{\"1\":{\"392\":1}}],[\"重用性\",{\"1\":{\"251\":1}}],[\"重要注意事项\",{\"0\":{\"251\":1,\"255\":1,\"259\":1}}],[\"重排序可以分为编译器重排序和处理器重排序\",{\"1\":{\"220\":1}}],[\"重排序分3种类型\",{\"1\":{\"215\":1}}],[\"重写call\",{\"1\":{\"237\":1}}],[\"重写run\",{\"1\":{\"237\":2}}],[\"重写克隆方法\",{\"1\":{\"208\":2}}],[\"重写方法的访问权限可以更广\",{\"1\":{\"197\":1}}],[\"重写方法不能抛出范围更大的受控异常\",{\"1\":{\"197\":1}}],[\"重载\",{\"0\":{\"197\":1}}],[\"重新计算冲突元素的地址\",{\"1\":{\"434\":1}}],[\"重新计算各个区域的存活对象\",{\"1\":{\"103\":1}}],[\"重新标记和并发清理四个阶段\",{\"1\":{\"100\":1}}],[\"重新标记\",{\"1\":{\"100\":1}}],[\"⽽是在程序运⾏期间才确定\",{\"1\":{\"196\":1}}],[\"面向过程就是分析出解决问题所需要的步骤\",{\"1\":{\"195\":1}}],[\"面向对象有哪些特性\",{\"0\":{\"196\":1}}],[\"面向对象\",{\"0\":{\"194\":1},\"1\":{\"147\":1,\"195\":1}}],[\"⾯向对象\",{\"1\":{\"195\":1}}],[\"⾯向对象和⾯向过程的区别\",{\"0\":{\"195\":1}}],[\"⾯向过程\",{\"1\":{\"195\":1}}],[\"永久保存\",{\"1\":{\"190\":1}}],[\"永久代是java\",{\"1\":{\"91\":1}}],[\"永久代可能会填满\",{\"1\":{\"74\":1}}],[\"永久代的设计可能导致某些方法在不同jvm下表现不同\",{\"1\":{\"74\":1}}],[\"永久代的大小在jvm启动时设定\",{\"1\":{\"74\":1}}],[\"永久代的限制\",{\"1\":{\"74\":1}}],[\"永久代完全移除\",{\"1\":{\"62\":1}}],[\"永久代被元空间\",{\"1\":{\"91\":1}}],[\"永久代被完全废弃\",{\"1\":{\"75\":1}}],[\"永久代被完全移除\",{\"1\":{\"57\":1}}],[\"永久代被移除\",{\"1\":{\"59\":1}}],[\"永久代用于存储类元数据\",{\"1\":{\"59\":1}}],[\"永久代\",{\"0\":{\"59\":1},\"1\":{\"91\":1}}],[\"永久代逐步移除\",{\"1\":{\"56\":1}}],[\"没找到\",{\"1\":{\"190\":1}}],[\"没有所谓的非空闲时间\",{\"1\":{\"353\":1}}],[\"没有取到才会创建新的对象\",{\"1\":{\"173\":1}}],[\"没有逃逸出方法的作用域\",{\"1\":{\"126\":1}}],[\"没有在使用完毕后及时关闭\",{\"1\":{\"86\":1}}],[\"没有的话随便修改下master分支代码\",{\"1\":{\"21\":1}}],[\"属性上等\",{\"1\":{\"190\":1}}],[\"代替hashmap\",{\"1\":{\"442\":1}}],[\"代码是单线程执行的\",{\"1\":{\"384\":1}}],[\"代码示例\",{\"0\":{\"257\":1,\"320\":1,\"324\":1,\"328\":1,\"332\":1,\"336\":1}}],[\"代码复\",{\"1\":{\"239\":1}}],[\"代码的执行顺序可能与代码的编写顺序不一致\",{\"1\":{\"212\":1}}],[\"代码缓存区用于存放编译后的本地代码\",{\"1\":{\"91\":1}}],[\"代码缓存区\",{\"1\":{\"91\":1}}],[\"代表非公平锁\",{\"1\":{\"397\":1}}],[\"代表公平锁和非公平锁\",{\"1\":{\"397\":1}}],[\"代表公平锁\",{\"1\":{\"397\":1}}],[\"代表\",{\"1\":{\"187\":1}}],[\"键值中的\",{\"1\":{\"187\":1}}],[\"keepalive\",{\"1\":{\"356\":1}}],[\"keepalivetime默认是10\",{\"1\":{\"356\":1}}],[\"keepalivetime为0\",{\"1\":{\"355\":1}}],[\"keepalivetime单位\",{\"1\":{\"305\":1}}],[\"keepalivetime\",{\"1\":{\"304\":1,\"305\":1,\"338\":2,\"344\":1,\"359\":2}}],[\"key通过hash定位到segment\",{\"1\":{\"444\":1}}],[\"key设计成弱引用同样是为了防止内存泄漏问题\",{\"1\":{\"227\":1}}],[\"key是threadlocal的弱引用\",{\"1\":{\"224\":1}}],[\"key\",{\"1\":{\"187\":2,\"225\":1,\"228\":1,\"427\":12,\"428\":13,\"433\":4,\"445\":2,\"448\":1,\"450\":1}}],[\"k\",{\"1\":{\"187\":1,\"230\":3,\"427\":6,\"428\":6}}],[\"kit\",{\"1\":{\"148\":1}}],[\"<\",{\"1\":{\"303\":1,\"305\":1,\"373\":2,\"412\":1,\"445\":2}}],[\"<=\",{\"1\":{\"251\":1,\"253\":1,\"376\":1,\"412\":2,\"445\":1}}],[\"<p>defaults\",{\"1\":{\"190\":1}}],[\"<t>\",{\"1\":{\"186\":4}}],[\"<<\",{\"1\":{\"165\":1,\"445\":1}}],[\"泛型信息会被擦除\",{\"1\":{\"188\":1}}],[\"泛型主要是为了提供编译时类型检查\",{\"1\":{\"188\":1}}],[\"泛型常用的通配符有哪些\",{\"0\":{\"187\":1}}],[\"泛型方法\",{\"1\":{\"186\":1}}],[\"泛型接口\",{\"1\":{\"186\":1}}],[\"泛型类\",{\"1\":{\"186\":1}}],[\"泛型的使用方法\",{\"0\":{\"186\":1}}],[\"泛型\",{\"0\":{\"184\":1}}],[\"之前被刷新到主内存中\",{\"1\":{\"220\":1}}],[\"之前\",{\"1\":{\"183\":1}}],[\"了多少个对象\",{\"1\":{\"378\":1}}],[\"了解这些步骤有助于理解线程池如何管理线程和任务\",{\"1\":{\"337\":1}}],[\"了解这些情况可以帮助开发者更好地调优java应用程序的内存配置和性能\",{\"1\":{\"96\":1}}],[\"了解吗\",{\"0\":{\"249\":1,\"250\":1,\"253\":1,\"256\":1,\"416\":1}}],[\"了\",{\"1\":{\"183\":2,\"204\":1}}],[\"按钮\",{\"1\":{\"409\":1}}],[\"按finally中return的为准\",{\"1\":{\"183\":1}}],[\"按照键的自然顺序或自定义顺序进行排序\",{\"1\":{\"192\":1}}],[\"按照流的角色划分为\",{\"1\":{\"137\":1}}],[\"按照流的流向分\",{\"1\":{\"137\":1}}],[\"按照操作单元划分\",{\"1\":{\"137\":1}}],[\"题目3\",{\"1\":{\"183\":1}}],[\"题目2\",{\"1\":{\"183\":1}}],[\"题目1\",{\"1\":{\"183\":1}}],[\"语句\",{\"1\":{\"240\":1,\"247\":1}}],[\"语句中\",{\"1\":{\"204\":1}}],[\"语句块来完成\",{\"1\":{\"391\":1}}],[\"语句块\",{\"1\":{\"183\":1}}],[\"语法形式\",{\"1\":{\"201\":1}}],[\"语言\",{\"0\":{\"151\":1}}],[\"三步操作了\",{\"1\":{\"213\":1}}],[\"三道经典异常处理代码题\",{\"0\":{\"183\":1}}],[\"三分钟搭建一个博客网站\",{\"0\":{\"7\":1,\"8\":1}}],[\"此时a已经非彼a\",{\"1\":{\"400\":1}}],[\"此时持有该偏向锁的线程\",{\"1\":{\"389\":1}}],[\"此时计数器\",{\"1\":{\"381\":1}}],[\"此时会释放\",{\"1\":{\"381\":1}}],[\"此时其他线程也会收到\",{\"1\":{\"251\":1}}],[\"此时就会线性向后查找\",{\"1\":{\"229\":1}}],[\"此时finally块中的代码不会执行\",{\"1\":{\"182\":1}}],[\"此时pages页会显示访问域名\",{\"1\":{\"21\":1}}],[\"抛出异常\",{\"1\":{\"181\":1}}],[\"异或操作使得低位的特征影响到高位\",{\"1\":{\"429\":1}}],[\"异步调用\",{\"1\":{\"375\":1}}],[\"异步任务执行\",{\"0\":{\"329\":1}}],[\"异步任务链中的线程池\",{\"0\":{\"294\":1}}],[\"异步任务完成\",{\"1\":{\"288\":1}}],[\"异步任务逻辑\",{\"1\":{\"284\":1,\"287\":1}}],[\"异步非阻塞io\",{\"1\":{\"139\":1}}],[\"异常的处理机制\",{\"0\":{\"181\":1}}],[\"异常处理后的默认值\",{\"1\":{\"274\":1}}],[\"异常处理\",{\"0\":{\"179\":1},\"1\":{\"251\":1,\"347\":1}}],[\"仍然可以成功反序列化之前的序列化数据\",{\"1\":{\"177\":1}}],[\"仍然存活的对象会被移动到survivor区\",{\"1\":{\"91\":1}}],[\"兼容性\",{\"1\":{\"177\":1}}],[\"版本控制\",{\"1\":{\"177\":1}}],[\"又有什么用\",{\"1\":{\"177\":1}}],[\"方便哈希取余\",{\"1\":{\"431\":1}}],[\"方便\",{\"1\":{\"239\":1}}],[\"方便存储和传输\",{\"1\":{\"177\":1}}],[\"方法将hashmap包装成线程安全的map\",{\"1\":{\"442\":1}}],[\"方法将字符串添加到字符串常量池中\",{\"1\":{\"64\":1}}],[\"方法结合实现等待\",{\"1\":{\"391\":1}}],[\"方法配合try\",{\"1\":{\"391\":1}}],[\"方法开始执行任务\",{\"1\":{\"376\":1}}],[\"方法中\",{\"1\":{\"376\":3,\"397\":1}}],[\"方法是\",{\"1\":{\"376\":1}}],[\"方法是java中的一个特殊方法\",{\"1\":{\"90\":1}}],[\"方法不会立即停止线程池\",{\"1\":{\"348\":1}}],[\"方法用于立即关闭线程池\",{\"1\":{\"348\":1}}],[\"方法用于平缓地关闭线程池\",{\"1\":{\"348\":1}}],[\"方法用于提交不需要返回结果的任务\",{\"1\":{\"347\":1}}],[\"方法或scheduleatfixedrate\",{\"1\":{\"351\":1}}],[\"方法或shutdownnow\",{\"1\":{\"348\":2}}],[\"方法或locksupport\",{\"1\":{\"242\":1}}],[\"方法则更加灵活\",{\"1\":{\"347\":1}}],[\"方法则会唤醒所有在该共享变量上由于调用\",{\"1\":{\"240\":1}}],[\"方法除了接受runnable接口类型的任务外\",{\"1\":{\"347\":1}}],[\"方法接受runnable接口类型的任务作为参数\",{\"1\":{\"347\":1}}],[\"方法无法处理任务执行过程中抛出的异常\",{\"1\":{\"347\":1}}],[\"方法更加灵活\",{\"1\":{\"347\":1}}],[\"方法返回一个future对象\",{\"1\":{\"347\":1}}],[\"方法返回值等\",{\"1\":{\"55\":1}}],[\"方法没有返回值\",{\"1\":{\"347\":1}}],[\"方法都用于向线程池提交任务\",{\"1\":{\"347\":1}}],[\"方法关闭\",{\"1\":{\"342\":1}}],[\"方法提交给线程池执行\",{\"1\":{\"376\":1}}],[\"方法提交第一个子任务给线程池执行\",{\"1\":{\"376\":1}}],[\"方法提交定时任务或周期性任务\",{\"1\":{\"351\":1}}],[\"方法提交的任务没有返回值\",{\"1\":{\"339\":1}}],[\"方法提交到线程池\",{\"1\":{\"339\":1}}],[\"方法提供了一个在对象被垃圾回收之前进行一些清理操作的机会\",{\"1\":{\"90\":1}}],[\"方法有带超时参数的重载形式\",{\"1\":{\"259\":1}}],[\"方法响应中断\",{\"1\":{\"255\":1}}],[\"方法模拟了汽车进入停车场\",{\"1\":{\"254\":1}}],[\"方法之外\",{\"1\":{\"247\":1}}],[\"方法主动放弃\",{\"1\":{\"245\":1}}],[\"方法后\",{\"1\":{\"240\":1,\"348\":3}}],[\"方法唤醒它\",{\"1\":{\"240\":2}}],[\"方法多了一个超时参数\",{\"1\":{\"240\":1}}],[\"方法时\",{\"1\":{\"240\":2,\"347\":1,\"366\":1,\"367\":1}}],[\"方法时会执行run\",{\"0\":{\"238\":1}}],[\"方法启动线程\",{\"1\":{\"237\":1}}],[\"方法释放内存空间\",{\"1\":{\"226\":1}}],[\"方法可以安全地关闭线程池\",{\"1\":{\"348\":1}}],[\"方法可以通过future对象来捕获任务执行过程中抛出的异常\",{\"1\":{\"347\":1}}],[\"方法可以返回一个future对象\",{\"1\":{\"339\":1}}],[\"方法可以非常简单地实现对象的浅拷贝\",{\"1\":{\"208\":1}}],[\"方法可手动将字符串添加到池中\",{\"1\":{\"66\":1}}],[\"方法判断相等\",{\"1\":{\"206\":1}}],[\"方法只会被调用一次\",{\"1\":{\"204\":1}}],[\"方法和类\",{\"1\":{\"204\":1}}],[\"方法修饰符\",{\"1\":{\"200\":1}}],[\"方法实现\",{\"1\":{\"200\":1,\"391\":1}}],[\"方法重写\",{\"1\":{\"197\":1}}],[\"方法重载\",{\"1\":{\"197\":1}}],[\"方法重载和方法重写都是实现多态性的方式\",{\"1\":{\"197\":1}}],[\"方法名相同\",{\"1\":{\"197\":2}}],[\"方法上\",{\"1\":{\"190\":1}}],[\"方法会尝试中断正在执行的任务\",{\"1\":{\"348\":1}}],[\"方法会终止java虚拟机的运行\",{\"1\":{\"182\":1}}],[\"方法会无限递归调用自身\",{\"1\":{\"85\":1}}],[\"方法等待子任务的完成并合并结果\",{\"1\":{\"376\":1}}],[\"方法等待第一个子任务的执行结果\",{\"1\":{\"376\":1}}],[\"方法等\",{\"1\":{\"177\":1}}],[\"方法等信息\",{\"1\":{\"157\":1}}],[\"方法为true\",{\"1\":{\"172\":1}}],[\"方法调用之后\",{\"1\":{\"99\":1}}],[\"方法来定义具体的任务逻辑\",{\"1\":{\"376\":1}}],[\"方法来修改核心线程数\",{\"1\":{\"371\":1}}],[\"方法来处理线程执行完毕后的异常\",{\"1\":{\"359\":1}}],[\"方法来检查线程池是否已经关闭\",{\"1\":{\"348\":1}}],[\"方法来等待线程池关闭\",{\"1\":{\"348\":1}}],[\"方法来实现\",{\"1\":{\"348\":1}}],[\"方法来设置线程的中断标志为true\",{\"1\":{\"240\":1}}],[\"方法来进行资源释放和清理操作\",{\"1\":{\"90\":1}}],[\"方法来执行重要的清理工作\",{\"1\":{\"90\":1}}],[\"方法存在一些缺点\",{\"1\":{\"90\":1}}],[\"方法的重载版本来指定自定义的线程池\",{\"1\":{\"285\":1}}],[\"方法的最后\",{\"1\":{\"230\":1}}],[\"方法的返回值必须相等\",{\"1\":{\"206\":1}}],[\"方法的时间是不确定的\",{\"1\":{\"90\":1}}],[\"方法的符号引用\",{\"1\":{\"68\":1}}],[\"方法\",{\"0\":{\"238\":2},\"1\":{\"90\":1,\"174\":2,\"182\":1,\"198\":4,\"204\":1,\"237\":3,\"238\":2,\"240\":3,\"241\":1,\"242\":2,\"251\":1,\"252\":1,\"254\":2,\"255\":1,\"258\":3,\"348\":2,\"350\":1,\"376\":2,\"381\":1,\"397\":1}}],[\"方法被用来实现对象在被垃圾回收之前\",{\"1\":{\"90\":1}}],[\"方法签名\",{\"1\":{\"90\":1}}],[\"方法了解吗\",{\"0\":{\"90\":1}}],[\"方法在处理字符串常量池时可能表现出不同的性能和行为\",{\"1\":{\"74\":1}}],[\"方法行为不一致\",{\"1\":{\"74\":1}}],[\"方法引用等\",{\"1\":{\"65\":1,\"66\":1}}],[\"方法信息等\",{\"1\":{\"59\":1}}],[\"方法代码\",{\"1\":{\"55\":1}}],[\"方法出口等信息\",{\"1\":{\"53\":1}}],[\"方法区内存空间不足\",{\"1\":{\"96\":1}}],[\"方法区中的常量引用的对象\",{\"1\":{\"88\":1}}],[\"方法区中的常量引用\",{\"1\":{\"88\":1}}],[\"方法区中的静态变量引用的对象\",{\"1\":{\"88\":1}}],[\"方法区中的静态引用\",{\"1\":{\"88\":1}}],[\"方法区\",{\"1\":{\"53\":1,\"55\":1}}],[\"把冲突的元素放进去\",{\"1\":{\"434\":2}}],[\"把这些小任务放到不同的队列里\",{\"1\":{\"376\":1}}],[\"把任务添加到linkedblockingqueue阻塞队列\",{\"1\":{\"353\":1}}],[\"把元素放到空的槽中\",{\"1\":{\"229\":1}}],[\"把构成问题的事务分解成各个对象\",{\"1\":{\"195\":1}}],[\"把二进制流恢复成对象\",{\"1\":{\"177\":1}}],[\"把java对象转为二进制流\",{\"1\":{\"177\":1}}],[\"把一个表数范围小的数值或变量直接赋给另一个数范围大的变量时\",{\"1\":{\"160\":1}}],[\"到底如何做呢\",{\"1\":{\"408\":1}}],[\"到该列表\",{\"1\":{\"381\":1}}],[\"到期任务是指scheduledfuturetask的time大于等于当前时间\",{\"1\":{\"356\":1}}],[\"到\",{\"1\":{\"173\":1}}],[\"搞了个缓存池\",{\"1\":{\"173\":1}}],[\"超过则扩容\",{\"1\":{\"427\":1}}],[\"超过一定次数\",{\"1\":{\"403\":1}}],[\"超过范围\",{\"1\":{\"173\":1}}],[\"超时默认值\",{\"1\":{\"277\":1}}],[\"超时控制\",{\"0\":{\"275\":1}}],[\"超时机制\",{\"1\":{\"259\":1,\"375\":2,\"408\":1}}],[\"超时等问题时\",{\"1\":{\"252\":1}}],[\"超时等待状态\",{\"1\":{\"241\":1}}],[\"超低停顿时间\",{\"1\":{\"115\":1}}],[\"号拼接会编译成stringbuilder的append方法\",{\"1\":{\"171\":1}}],[\"两者都是\",{\"1\":{\"397\":1}}],[\"两者性能就差不多了\",{\"1\":{\"391\":1}}],[\"两种集合都需要遍历\",{\"1\":{\"411\":1}}],[\"两种情况\",{\"1\":{\"389\":1}}],[\"两种方法来确定对象是否可以被回收\",{\"1\":{\"87\":1}}],[\"两种方式的选择由java堆是否规整决定\",{\"1\":{\"79\":1}}],[\"两步操作\",{\"1\":{\"213\":1}}],[\"两个指令来实现同步\",{\"1\":{\"380\":1}}],[\"两个线程可以交换数据\",{\"1\":{\"258\":1}}],[\"两个线程互相传递数据或资源\",{\"1\":{\"256\":1}}],[\"两个线程需要在某个点交换数据\",{\"1\":{\"256\":1}}],[\"两个线程都执行了\",{\"1\":{\"235\":1}}],[\"两个线程都在执行\",{\"1\":{\"235\":1}}],[\"两个具备超时特性的方法\",{\"1\":{\"247\":1}}],[\"两个操作之间存在happens\",{\"1\":{\"216\":1}}],[\"两个\",{\"1\":{\"170\":1}}],[\"两个语句都会去字符串常量池中检查是否已经存在\",{\"1\":{\"170\":1}}],[\"影响性能\",{\"1\":{\"169\":1}}],[\"高位补0\",{\"1\":{\"431\":1}}],[\"高位\",{\"1\":{\"429\":1}}],[\"高\",{\"1\":{\"169\":1}}],[\"高吞吐量应用\",{\"1\":{\"119\":1,\"120\":1}}],[\"高吞吐量\",{\"1\":{\"119\":1}}],[\"性能更加优秀和稳定\",{\"1\":{\"424\":1}}],[\"性能更好\",{\"1\":{\"169\":1}}],[\"性能指标\",{\"1\":{\"372\":1}}],[\"性能测试\",{\"1\":{\"372\":1}}],[\"性能\",{\"1\":{\"169\":1,\"391\":1}}],[\"性能提升\",{\"1\":{\"128\":1}}],[\"再遍历链表定位到具体的元素上\",{\"1\":{\"444\":1}}],[\"再建一个数组\",{\"1\":{\"434\":1}}],[\"再哈希法\",{\"1\":{\"434\":1}}],[\"再插入时\",{\"1\":{\"412\":1}}],[\"再申请资源序号大的\",{\"1\":{\"408\":1}}],[\"再继续取\",{\"1\":{\"355\":1}}],[\"再次放行\",{\"1\":{\"251\":1}}],[\"再进行屏障后的写操作\",{\"1\":{\"220\":1}}],[\"再进行屏障后的读操作\",{\"1\":{\"220\":1}}],[\"再+1\",{\"1\":{\"213\":1}}],[\"再反序列化成拷贝对象\",{\"1\":{\"208\":1}}],[\"再输出\",{\"1\":{\"183\":1}}],[\"再catch中return\",{\"1\":{\"183\":1}}],[\"再自增\",{\"1\":{\"166\":1}}],[\"再赋值到j\",{\"1\":{\"213\":1}}],[\"再赋值\",{\"1\":{\"166\":1}}],[\"再由操作系统执行\",{\"1\":{\"151\":1}}],[\"减\",{\"1\":{\"166\":2}}],[\"减少碰撞的概率\",{\"1\":{\"439\":1}}],[\"减少不必要的cpu上下文切换\",{\"1\":{\"387\":1}}],[\"减少操作系统互斥量带来的性能消耗\",{\"1\":{\"387\":1}}],[\"减少其执行时间\",{\"1\":{\"375\":1}}],[\"减少线程间的竞争\",{\"1\":{\"349\":1}}],[\"减少连接创建和销毁的开销\",{\"1\":{\"323\":1}}],[\"减少\",{\"1\":{\"145\":1}}],[\"减少锁开销\",{\"1\":{\"128\":1}}],[\"减少停顿时间\",{\"1\":{\"120\":1}}],[\"减少手动调优的复杂性\",{\"1\":{\"114\":1}}],[\"减少内存碎片\",{\"1\":{\"114\":1}}],[\"减少内存碎片化\",{\"1\":{\"112\":1}}],[\"减少垃圾收集的停顿时间\",{\"1\":{\"109\":1}}],[\"减少碎片化\",{\"1\":{\"109\":1}}],[\"减少full\",{\"1\":{\"77\":1}}],[\"减少了扩容操作的时间和资源消耗\",{\"1\":{\"439\":1}}],[\"减少了相同低位的哈希值导致相同索引位置的情况\",{\"1\":{\"429\":1}}],[\"减少了频繁创建和销毁线程的开销\",{\"1\":{\"300\":1}}],[\"减少了gc的负担\",{\"1\":{\"128\":1}}],[\"减少了堆内存的分配和垃圾收集\",{\"1\":{\"128\":1}}],[\"减少了对垃圾收集器的复杂调优需求\",{\"1\":{\"115\":1}}],[\"减少了手动调优的复杂性\",{\"1\":{\"109\":1}}],[\"减少了full\",{\"1\":{\"76\":1}}],[\"减少了因类加载过多而导致的内存不足问题\",{\"1\":{\"76\":1}}],[\"减少配置复杂性\",{\"1\":{\"76\":1}}],[\"减少outofmemoryerror的发生\",{\"1\":{\"62\":1,\"77\":1}}],[\"先读取i的值\",{\"1\":{\"213\":1}}],[\"先finally\",{\"1\":{\"183\":1}}],[\"先赋值\",{\"1\":{\"166\":1}}],[\"先自增\",{\"1\":{\"166\":1}}],[\"先对\",{\"1\":{\"145\":1}}],[\"继续处理已提交和队列中的任务\",{\"1\":{\"366\":1}}],[\"继续等待新的任务\",{\"1\":{\"350\":1}}],[\"继续执行第2步\",{\"1\":{\"398\":1}}],[\"继续执行\",{\"1\":{\"353\":1}}],[\"继续执行后续任务\",{\"1\":{\"251\":15}}],[\"继续执行下次循环\",{\"1\":{\"164\":1}}],[\"继承关\",{\"1\":{\"239\":1}}],[\"继承thread类\",{\"1\":{\"237\":2}}],[\"继承是使⽤已存在的类的定义作为基础创建新的类\",{\"1\":{\"196\":1}}],[\"继承\",{\"1\":{\"147\":1,\"196\":2}}],[\"跳出本次循环\",{\"1\":{\"164\":1}}],[\"跳出整个循环\",{\"1\":{\"164\":1}}],[\"结合监控告警机制\",{\"1\":{\"372\":1}}],[\"结合监控机制建立告警机制\",{\"1\":{\"372\":1}}],[\"结合实际测试和调优\",{\"1\":{\"122\":1}}],[\"结果为直接保留hash值对\",{\"1\":{\"431\":1}}],[\"结果正确\",{\"0\":{\"405\":1}}],[\"结果合并\",{\"1\":{\"376\":1}}],[\"结果3\",{\"1\":{\"271\":1,\"279\":1}}],[\"结果2\",{\"1\":{\"271\":1,\"279\":1}}],[\"结果1\",{\"1\":{\"271\":1,\"279\":1}}],[\"结果\",{\"1\":{\"183\":1,\"263\":1,\"276\":1,\"277\":1,\"279\":1,\"284\":1,\"287\":1,\"288\":2}}],[\"结束当前的方法\",{\"1\":{\"164\":1}}],[\"结束当前的循环体\",{\"1\":{\"164\":1}}],[\"结束正在执行的循环\",{\"1\":{\"164\":1}}],[\"逻辑\",{\"1\":{\"230\":1}}],[\"逻辑与\",{\"1\":{\"162\":1}}],[\"逻辑上属于方法区\",{\"1\":{\"60\":1,\"61\":1}}],[\"短路与\",{\"1\":{\"162\":1}}],[\"装箱\",{\"1\":{\"161\":1}}],[\"封箱\",{\"0\":{\"161\":1}}],[\"封装把⼀个对象的属性私有化\",{\"1\":{\"196\":1}}],[\"封装\",{\"1\":{\"147\":1,\"196\":1}}],[\"强制终止一个或多个进程\",{\"1\":{\"409\":1}}],[\"强制关闭\",{\"1\":{\"342\":1}}],[\"强制类型转换\",{\"0\":{\"160\":1},\"1\":{\"160\":1}}],[\"强引用是最常见的引用类型\",{\"1\":{\"89\":1}}],[\"强引用\",{\"1\":{\"89\":1}}],[\"位虚拟机\",{\"1\":{\"386\":1}}],[\"位运算\",{\"1\":{\"165\":1}}],[\"位数\",{\"1\":{\"159\":1}}],[\"位置\",{\"1\":{\"64\":1,\"65\":1,\"66\":1}}],[\"布尔型默认为false\",{\"1\":{\"201\":1}}],[\"布尔型\",{\"1\":{\"159\":1}}],[\"浮点类型\",{\"1\":{\"159\":1}}],[\"浮点数\",{\"1\":{\"65\":1,\"68\":1}}],[\"反序列化\",{\"1\":{\"177\":1}}],[\"反射的实现原理\",{\"0\":{\"157\":1}}],[\"反射的应用场景\",{\"0\":{\"156\":1}}],[\"反射相关类\",{\"1\":{\"155\":1}}],[\"反射\",{\"0\":{\"154\":1},\"1\":{\"155\":1,\"175\":1}}],[\"反之就尾插法\",{\"1\":{\"445\":1}}],[\"反之\",{\"1\":{\"87\":1,\"160\":1,\"349\":1}}],[\"接到任务\",{\"1\":{\"354\":1}}],[\"接收到生产者的数据\",{\"1\":{\"257\":1}}],[\"接收生产者的数据并返回处理后的数据\",{\"1\":{\"257\":1}}],[\"接着参与\",{\"1\":{\"240\":1}}],[\"接着\",{\"1\":{\"153\":1}}],[\"接口自身可以通过extends关键字扩展多个接口\",{\"1\":{\"200\":1}}],[\"接口中只能包含静态\",{\"1\":{\"200\":1}}],[\"接口中的方法默认修饰符是public\",{\"1\":{\"200\":1}}],[\"接口中的方法默认是公开的\",{\"1\":{\"200\":1}}],[\"接口中的方法可以有默认实现\",{\"1\":{\"200\":1}}],[\"接口也可以定义静态方法\",{\"1\":{\"200\":1}}],[\"接口或方法的参数和返回值的类型\",{\"1\":{\"185\":1}}],[\"接口\",{\"1\":{\"159\":1,\"198\":2,\"237\":1,\"411\":2}}],[\"接口可以包含默认方法和静态方法\",{\"1\":{\"141\":1}}],[\"接口的默认方法和静态方法\",{\"1\":{\"141\":1}}],[\"描述了服务提供者需要实现的接口或抽象类\",{\"1\":{\"153\":1}}],[\"向应用程序注入实现了特定接口的服务提供者\",{\"1\":{\"153\":1}}],[\"文件操作等\",{\"1\":{\"349\":1}}],[\"文件操作和计算等\",{\"1\":{\"318\":1}}],[\"文件上传等\",{\"1\":{\"330\":1}}],[\"文件名为服务接口的全限定名\",{\"1\":{\"153\":1}}],[\"文件\",{\"1\":{\"151\":1,\"190\":3}}],[\"文档所在分支\",{\"1\":{\"23\":1}}],[\"机器指令的执行顺序\",{\"1\":{\"215\":1}}],[\"机器码\",{\"1\":{\"150\":1}}],[\"机制来保证修改的原子性\",{\"1\":{\"392\":1}}],[\"机制是java标准库提供的一种服务发现机制\",{\"1\":{\"153\":1}}],[\"机制\",{\"1\":{\"109\":1}}],[\"跨平台的数据交换\",{\"1\":{\"177\":1}}],[\"跨平台\",{\"1\":{\"149\":1}}],[\"原子操作类的优点在于\",{\"1\":{\"406\":1}}],[\"原子操作类一般都是通过底层的cas\",{\"1\":{\"406\":1}}],[\"原子操作类是java提供的一组线程安全的工具类\",{\"1\":{\"406\":1}}],[\"原子操作类了解多少\",{\"0\":{\"406\":1}}],[\"原子性保证了对共享变量的操作是原子的\",{\"1\":{\"212\":1}}],[\"原子性是指一个操作是不可分割的\",{\"1\":{\"212\":1}}],[\"原子性\",{\"0\":{\"214\":1},\"1\":{\"212\":2,\"214\":1}}],[\"原子性操作\",{\"1\":{\"81\":1}}],[\"原理很简单\",{\"1\":{\"232\":1}}],[\"原理\",{\"0\":{\"174\":1},\"1\":{\"174\":1,\"416\":2}}],[\"原理是什么\",{\"0\":{\"149\":1}}],[\"还额外有cas操作的开销\",{\"1\":{\"387\":1}}],[\"还可以节省内存空间\",{\"1\":{\"414\":1}}],[\"还可以利用图形化工具\",{\"1\":{\"409\":1}}],[\"还可以存活60秒\",{\"1\":{\"354\":1}}],[\"还可以接受callable接口类型的任务作为参数\",{\"1\":{\"347\":1}}],[\"还需要考虑任务的执行时间\",{\"1\":{\"349\":1}}],[\"还提供了join\",{\"1\":{\"247\":1}}],[\"还有什么其它办法\",{\"0\":{\"233\":1}}],[\"还有编译器\",{\"1\":{\"148\":1}}],[\"还是引用传递\",{\"0\":{\"207\":1}}],[\"还会通过\",{\"1\":{\"170\":1}}],[\"还支持并行回收\",{\"1\":{\"109\":1}}],[\"切\",{\"1\":{\"148\":1}}],[\"命令和其他的⼀些基础构件\",{\"1\":{\"148\":1}}],[\"运算\",{\"1\":{\"228\":1,\"431\":1}}],[\"运算符放在变量之前时\",{\"1\":{\"166\":1}}],[\"运算符可以放在变量之前\",{\"1\":{\"166\":1}}],[\"运⾏时环境\",{\"1\":{\"148\":1}}],[\"运行\",{\"1\":{\"241\":1}}],[\"运行状态\",{\"1\":{\"241\":1}}],[\"运行时异常\",{\"1\":{\"180\":1}}],[\"运行时数据区\",{\"1\":{\"133\":1}}],[\"运行时常量池中的字面值\",{\"1\":{\"69\":1}}],[\"运行时常量池和栈中的局部变量\",{\"0\":{\"68\":1}}],[\"运行时常量池和字符串常量池迁移到java堆中\",{\"1\":{\"62\":1}}],[\"运行时常量池和字符串常量池等\",{\"1\":{\"62\":1}}],[\"运行时常量池在类加载时从类文件的常量池\",{\"1\":{\"65\":1}}],[\"运行时常量池在永久代中\",{\"1\":{\"61\":1}}],[\"运行时常量池包含类加载后所需的各种常量\",{\"1\":{\"65\":1}}],[\"运行时常量池被移到java堆\",{\"1\":{\"65\":1}}],[\"运行时常量池也位于永久代\",{\"1\":{\"65\":1}}],[\"运行时常量池移到java堆中\",{\"1\":{\"61\":1}}],[\"运行时常量池\",{\"0\":{\"61\":1,\"65\":1},\"1\":{\"56\":1,\"65\":1,\"66\":4,\"67\":1,\"68\":1,\"71\":1}}],[\"运行在任何地方\",{\"1\":{\"131\":1}}],[\"运行环境和性能目标\",{\"1\":{\"111\":1}}],[\"台\",{\"1\":{\"148\":1}}],[\"针对不同\",{\"1\":{\"148\":1}}],[\"缩小\",{\"1\":{\"145\":1}}],[\"返回值类型为\",{\"1\":{\"376\":1}}],[\"返回值类型\",{\"1\":{\"347\":1}}],[\"返回值是\",{\"1\":{\"145\":1}}],[\"返回\",{\"1\":{\"240\":1,\"247\":1,\"398\":2}}],[\"返回前先执行\",{\"1\":{\"183\":1}}],[\"返回对象引用\",{\"1\":{\"78\":1}}],[\"开发者可以继承forkjointask类来定义自己的任务\",{\"1\":{\"376\":1}}],[\"开放地址解决冲突\",{\"1\":{\"230\":1}}],[\"开放定址法就是从冲突的位置再接着往下找\",{\"1\":{\"434\":1}}],[\"开放定址法\",{\"1\":{\"229\":1,\"434\":1}}],[\"开始\",{\"1\":{\"163\":2}}],[\"开始移除永久代\",{\"1\":{\"62\":1}}],[\"开头的\",{\"1\":{\"145\":2}}],[\"匹配到第一个\",{\"1\":{\"145\":1}}],[\"匹配\",{\"1\":{\"145\":1}}],[\"转换\",{\"1\":{\"145\":1}}],[\"亦或是\",{\"1\":{\"145\":1}}],[\"注意\",{\"1\":{\"198\":2,\"416\":1}}],[\"注解生命周期\",{\"1\":{\"190\":1}}],[\"注解可以标记在类上\",{\"1\":{\"190\":1}}],[\"注解\",{\"0\":{\"189\":1}}],[\"注解的接口\",{\"1\":{\"143\":1}}],[\"注册回调处理结果\",{\"1\":{\"288\":1}}],[\"注册\",{\"1\":{\"139\":1}}],[\"注册了监听器或回调函数\",{\"1\":{\"86\":1}}],[\"添加了\",{\"1\":{\"143\":1}}],[\"表明这是该类的⼀个静态资源\",{\"1\":{\"378\":1}}],[\"表示该锁对象已经被其他线程抢占\",{\"1\":{\"390\":1}}],[\"表示锁重入\",{\"1\":{\"390\":1}}],[\"表示进⼊同步代码前要获得\",{\"1\":{\"378\":1}}],[\"表示进⼊同步代码库前要获得给定对象的锁\",{\"1\":{\"378\":1}}],[\"表示要计算斐波那契数列的第10个数\",{\"1\":{\"376\":1}}],[\"表示要计算斐波那契数列的第\",{\"1\":{\"376\":1}}],[\"表示这是一个有返回值的递归任务\",{\"1\":{\"376\":1}}],[\"表示有3个停车位\",{\"1\":{\"253\":1,\"254\":1}}],[\"表示当前线程已经执行完毕\",{\"1\":{\"241\":1}}],[\"表示线程池已经完全终止\",{\"1\":{\"369\":1}}],[\"表示线程进入等待状态\",{\"1\":{\"241\":1}}],[\"表示线程阻塞于锁\",{\"1\":{\"241\":1}}],[\"表示具体的一个\",{\"1\":{\"187\":1}}],[\"表示不确定的\",{\"1\":{\"187\":1}}],[\"表示式\",{\"1\":{\"142\":1}}],[\"表达式了解多少\",{\"0\":{\"142\":1}}],[\"表达式最好不要超过3行\",{\"1\":{\"141\":1}}],[\"表达式使代码更加简洁\",{\"1\":{\"141\":1}}],[\"表达式本质上是一段匿名内部类\",{\"1\":{\"141\":1,\"142\":1}}],[\"表达式和函数式接口\",{\"1\":{\"141\":1}}],[\"才会返回插入的值\",{\"1\":{\"450\":1}}],[\"才会抛出outofmemoryerror异常\",{\"1\":{\"89\":1}}],[\"才能缩写成\",{\"1\":{\"142\":1}}],[\"聚合等操作\",{\"1\":{\"141\":1}}],[\"排序\",{\"1\":{\"141\":1,\"145\":1}}],[\"映射\",{\"1\":{\"141\":1}}],[\"否则向链表中插入数据\",{\"1\":{\"427\":1}}],[\"否则需要覆盖\",{\"1\":{\"427\":1}}],[\"否则抛出异常\",{\"1\":{\"416\":1}}],[\"否则执行6\",{\"1\":{\"390\":1}}],[\"否则执行\",{\"1\":{\"390\":1}}],[\"否则进入步骤\",{\"1\":{\"389\":1}}],[\"否则会报错\",{\"1\":{\"200\":1}}],[\"否则会有可读性等问题\",{\"1\":{\"141\":1}}],[\"否则\",{\"1\":{\"170\":1,\"172\":1,\"341\":1,\"354\":1,\"376\":1,\"428\":2}}],[\"否则重试\",{\"1\":{\"81\":1}}],[\"允许一个线程二次请求自己持有对象锁的临界资源\",{\"1\":{\"385\":1}}],[\"允许键和值为null\",{\"1\":{\"192\":1}}],[\"允许把函数作为一个方法的参数\",{\"1\":{\"141\":1}}],[\"允许用户通过参数\",{\"1\":{\"109\":1}}],[\"服务使用\",{\"1\":{\"153\":1}}],[\"服务加载\",{\"1\":{\"153\":1}}],[\"服务加载器\",{\"1\":{\"153\":1}}],[\"服务提供者配置文件\",{\"1\":{\"153\":1}}],[\"服务提供者\",{\"1\":{\"153\":1}}],[\"服务接口\",{\"1\":{\"153\":1}}],[\"服务端程序启动线程去处理\",{\"1\":{\"139\":1}}],[\"服务器端得到通知\",{\"1\":{\"139\":1}}],[\"服务器端用一个线程处理多个连接\",{\"1\":{\"139\":1}}],[\"回收空闲线程等\",{\"1\":{\"299\":1}}],[\"回收其占用的内存\",{\"1\":{\"100\":1}}],[\"回调\",{\"1\":{\"139\":1}}],[\"加锁\",{\"1\":{\"418\":1}}],[\"加版本号\",{\"1\":{\"401\":1}}],[\"加强代码的重用\",{\"1\":{\"195\":1}}],[\"加入到已注册的通道列表\",{\"1\":{\"139\":1}}],[\"加载操作\",{\"1\":{\"220\":1}}],[\"加载\",{\"1\":{\"134\":1}}],[\"加载代码\",{\"1\":{\"132\":1}}],[\"加载到运行时常量池中\",{\"1\":{\"69\":1}}],[\"发现是a就会执行修改\",{\"1\":{\"400\":1}}],[\"发送邮件给\",{\"1\":{\"332\":1}}],[\"发起进攻\",{\"1\":{\"249\":1}}],[\"发起连接请求\",{\"1\":{\"139\":1}}],[\"发生哈希碰撞的概率就降低了\",{\"1\":{\"437\":1}}],[\"发生概率仅为0\",{\"1\":{\"435\":1}}],[\"发生异常\",{\"1\":{\"273\":1,\"274\":1}}],[\"发生下面几种情况才会返回\",{\"1\":{\"240\":1}}],[\"发生在具有继承关系的父子类中\",{\"1\":{\"197\":1}}],[\"发生在同一个类中\",{\"1\":{\"197\":1}}],[\"发布完成后\",{\"1\":{\"21\":1}}],[\"发布到github\",{\"0\":{\"15\":1}}],[\"客户端发送的连接请求会注册到多路复用器上\",{\"1\":{\"139\":1}}],[\"客户端有连接请求时服务器端就需要启动一个线程进行处理\",{\"1\":{\"139\":1}}],[\"客观原因\",{\"0\":{\"74\":1}}],[\"尤其是当涉及到国际化和本地化时\",{\"1\":{\"138\":1}}],[\"尤其在大堆内存环境下\",{\"1\":{\"108\":1}}],[\"视频等\",{\"1\":{\"138\":1}}],[\"音频\",{\"1\":{\"138\":1}}],[\"后继节点和插入节点的指向就行了\",{\"1\":{\"411\":1}}],[\"后被其他进入的线程获得\",{\"1\":{\"381\":1}}],[\"后\",{\"1\":{\"204\":1,\"397\":1}}],[\"后缀\",{\"1\":{\"166\":1}}],[\"后解释两个步骤\",{\"1\":{\"151\":1}}],[\"后者是字符输出流\",{\"1\":{\"137\":1}}],[\"后者是字符输入流\",{\"1\":{\"137\":1}}],[\"后台任务等对响应时间不敏感的应用\",{\"1\":{\"119\":1}}],[\"前阻塞\",{\"1\":{\"251\":1}}],[\"前两种面向字节\",{\"1\":{\"247\":1}}],[\"前会先执行\",{\"1\":{\"183\":1}}],[\"前缀\",{\"1\":{\"166\":1}}],[\"前者是字节输出流\",{\"1\":{\"137\":1}}],[\"前者是字节输入流\",{\"1\":{\"137\":1}}],[\"前端\",{\"2\":{\"25\":1}}],[\"输出流主要包括了如下4种具体实现\",{\"1\":{\"247\":1}}],[\"输出流不同之处在于\",{\"1\":{\"247\":1}}],[\"输出流或者网络输入\",{\"1\":{\"247\":1}}],[\"输出流和普通的文件输入\",{\"1\":{\"247\":1}}],[\"输出流\",{\"1\":{\"137\":1,\"247\":1}}],[\"输入流\",{\"1\":{\"137\":1}}],[\"流中的元素总数\",{\"1\":{\"145\":1}}],[\"流\",{\"1\":{\"145\":2}}],[\"流用过吗\",{\"0\":{\"145\":1}}],[\"流分为几种\",{\"0\":{\"137\":1}}],[\"流程图\",{\"0\":{\"28\":1}}],[\"库和函数\",{\"1\":{\"133\":1}}],[\"非公平锁让获取锁的时间变得更加不确定\",{\"1\":{\"397\":1}}],[\"非公平锁会有更好的性能\",{\"1\":{\"397\":1}}],[\"非公平锁会直接\",{\"1\":{\"397\":1}}],[\"非公平锁会尝试去获取锁\",{\"1\":{\"396\":1}}],[\"非公平锁在\",{\"1\":{\"397\":1}}],[\"非公平锁在调用\",{\"1\":{\"397\":1}}],[\"非公平锁和公平锁的两处不同\",{\"1\":{\"397\":1}}],[\"非公平锁的优点是可以减少唤起线程的开销\",{\"1\":{\"395\":1}}],[\"非公平锁是多个线程加锁时直接尝试获取锁\",{\"1\":{\"395\":1}}],[\"非公平锁\",{\"0\":{\"395\":1}}],[\"非核心线程空闲存活时间为60秒\",{\"1\":{\"354\":1}}],[\"非final修饰的成员变量具有默认值\",{\"1\":{\"201\":1}}],[\"非线程安全\",{\"1\":{\"169\":1}}],[\"非java\",{\"1\":{\"133\":1}}],[\"非常适合需要双向数据传递的场景\",{\"1\":{\"259\":1}}],[\"非常适合对响应时间有严格要求的应用\",{\"1\":{\"115\":1}}],[\"非常大堆内存\",{\"1\":{\"120\":1}}],[\"负责自动回收不再使用的内存\",{\"1\":{\"133\":1}}],[\"负责执行字节码\",{\"1\":{\"133\":1}}],[\"负责加载\",{\"1\":{\"133\":1}}],[\"降低了哈希冲突的概率\",{\"1\":{\"429\":1}}],[\"降低了垃圾收集的停顿时间\",{\"1\":{\"112\":1}}],[\"降低系统性能\",{\"1\":{\"312\":1}}],[\"降低gc压力\",{\"1\":{\"128\":1}}],[\"同步是锁住的什么东西\",{\"1\":{\"381\":1}}],[\"同步移交队列是一种特殊的队列\",{\"1\":{\"346\":1}}],[\"同步移交队列\",{\"1\":{\"346\":1}}],[\"同步开销\",{\"0\":{\"312\":1}}],[\"同步屏障\",{\"0\":{\"250\":1}}],[\"同步非阻塞io\",{\"1\":{\"139\":1}}],[\"同步阻塞io\",{\"1\":{\"139\":1}}],[\"同步消除减少了不必要的锁开销\",{\"1\":{\"128\":1}}],[\"同步消除\",{\"1\":{\"125\":1}}],[\"同时也可以在创建锁构造函数中传入具体参数创建公平锁\",{\"1\":{\"397\":1}}],[\"同时该等待线程进入\",{\"1\":{\"381\":1}}],[\"同时提供⼀些可以被外界访问的属性的⽅法\",{\"1\":{\"196\":1}}],[\"同时针对新生代和老年代进行回收\",{\"1\":{\"94\":1}}],[\"同时清空原来的eden区和使用过的survivor区\",{\"1\":{\"93\":1}}],[\"同时执行效率不稳定\",{\"1\":{\"92\":1}}],[\"同时可以避免一些内存泄漏问题\",{\"1\":{\"89\":1}}],[\"编写服务提供者配置文件\",{\"1\":{\"153\":1}}],[\"编写服务提供者\",{\"1\":{\"153\":2}}],[\"编写的程序需要先经过编译步骤\",{\"1\":{\"151\":1}}],[\"编写一次\",{\"1\":{\"131\":1}}],[\"编译器在生成字节码时\",{\"1\":{\"220\":1}}],[\"编译器在不改变单线程程序语义的前提下\",{\"1\":{\"215\":1}}],[\"编译器\",{\"1\":{\"217\":1}}],[\"编译器和处理器不会对存在数据依赖关系的操作做重排序\",{\"1\":{\"217\":1}}],[\"编译器和处理器为了提高并行度\",{\"1\":{\"217\":1}}],[\"编译器和处理器常常会对指令做重排序\",{\"1\":{\"215\":1}}],[\"编译器优化的重排序\",{\"1\":{\"215\":1}}],[\"编译器会强制检查并要求处理的异常\",{\"1\":{\"180\":1}}],[\"编译器可以将对象的成员变量直接分配在栈上\",{\"1\":{\"125\":1}}],[\"编译\",{\"1\":{\"150\":1}}],[\"编译与解释并存\",{\"0\":{\"151\":1},\"1\":{\"147\":1}}],[\"编辑此页\",{\"0\":{\"23\":1}}],[\"标志是否等于预期标志\",{\"1\":{\"401\":1}}],[\"标量替换\",{\"1\":{\"125\":1}}],[\"标记不支持随机访问\",{\"1\":{\"411\":1}}],[\"标记字段\",{\"1\":{\"386\":1}}],[\"标记字段记录着锁的状态\",{\"1\":{\"386\":1}}],[\"标记符来实现同步\",{\"1\":{\"380\":1}}],[\"标记自身也可以设置一些值\",{\"1\":{\"190\":1}}],[\"标记从根对象直接可达的对象\",{\"1\":{\"103\":1}}],[\"标记所有可达对象\",{\"1\":{\"103\":1}}],[\"标记所有可达的对象\",{\"1\":{\"100\":1}}],[\"标记所有存活的对象\",{\"1\":{\"92\":1}}],[\"标记所有能够被访问到的对象\",{\"1\":{\"92\":1}}],[\"标记阶段和清除阶段\",{\"1\":{\"92\":1}}],[\"标记\",{\"1\":{\"92\":5}}],[\"逃逸分析的优势\",{\"0\":{\"128\":1}}],[\"逃逸分析的应用示例\",{\"0\":{\"126\":1}}],[\"逃逸分析是一种编译时技术\",{\"1\":{\"125\":1}}],[\"逃逸分析\",{\"0\":{\"125\":1}}],[\"栈上分配\",{\"1\":{\"125\":1}}],[\"栈用于存储局部变量和方法调用栈帧\",{\"1\":{\"124\":1}}],[\"栈内存的分配和释放由jvm自动管理\",{\"1\":{\"124\":1}}],[\"栈内存\",{\"1\":{\"124\":1}}],[\"栈中的变量是线程私有的\",{\"1\":{\"53\":1}}],[\"下面是对代码示例的解释\",{\"1\":{\"376\":1}}],[\"下面是对答案的一些完善和补充\",{\"1\":{\"371\":1}}],[\"下面是一个简单的示例代码\",{\"1\":{\"376\":1}}],[\"下面是阻塞队列的基本实现原理\",{\"1\":{\"296\":1}}],[\"下面详细说明这些概念\",{\"1\":{\"123\":1}}],[\"下载地址\",{\"1\":{\"9\":1}}],[\"硬件资源和gc特性的过程\",{\"1\":{\"122\":1}}],[\"考虑应用未来的增长和变化\",{\"1\":{\"121\":1}}],[\"考虑未来需求\",{\"1\":{\"121\":1}}],[\"监控机制可以帮助及时发现线程池的问题\",{\"1\":{\"372\":1}}],[\"监控机制\",{\"1\":{\"372\":1}}],[\"监控和分析gc性能\",{\"1\":{\"121\":1}}],[\"监视器锁规则\",{\"1\":{\"216\":1}}],[\"监听器和回调\",{\"1\":{\"86\":1}}],[\"吞吐量和内存使用情况\",{\"1\":{\"121\":1}}],[\"确定合适的线程池配置\",{\"1\":{\"372\":1}}],[\"确定应用的堆内存大小\",{\"1\":{\"121\":1}}],[\"确定应用对停顿时间和吞吐量的要求\",{\"1\":{\"121\":1}}],[\"确实是一种常见的方式\",{\"1\":{\"371\":1}}],[\"确保任务操作是原子性的\",{\"1\":{\"374\":1}}],[\"确保程序的稳定运行\",{\"1\":{\"363\":1}}],[\"确保cpu在长期被工作线程使用的情况下\",{\"1\":{\"353\":1}}],[\"确保所有任务得到正确处理\",{\"1\":{\"348\":1}}],[\"确保所有可达对象都被正确标记\",{\"1\":{\"100\":1}}],[\"确保交换操作是同步和线程安全的\",{\"1\":{\"259\":1}}],[\"确保系统资源的有效利用和安全性\",{\"1\":{\"255\":1}}],[\"确保线程安全\",{\"1\":{\"417\":1}}],[\"确保线程安全和性能的平衡\",{\"1\":{\"81\":1}}],[\"确保线程按请求顺序获取许可\",{\"1\":{\"255\":1}}],[\"确保不会出现资源争用\",{\"1\":{\"253\":1}}],[\"确保子线程能够正确获取父线程最新的值\",{\"1\":{\"233\":1}}],[\"确保在屏障前的所有读操作都完成之后\",{\"1\":{\"220\":2}}],[\"确保在屏障前的所有写操作在屏障后的所有读操作\",{\"1\":{\"220\":1}}],[\"确保在屏障前的所有写操作\",{\"1\":{\"220\":1}}],[\"确保操作是不可分割的\",{\"1\":{\"214\":1}}],[\"确保字节码文件的正确性和一致性\",{\"1\":{\"134\":1}}],[\"确保代码不会进行非法操作\",{\"1\":{\"132\":1}}],[\"确保对象在内存中被正确地创建和初始化\",{\"1\":{\"78\":1}}],[\"确保相同的字符串字面值在内存中只有一个副本\",{\"1\":{\"66\":1,\"71\":1}}],[\"确保这是你正在使用的分支名称\",{\"1\":{\"16\":1}}],[\"侧重于高吞吐量\",{\"1\":{\"120\":1}}],[\"多数情况下\",{\"1\":{\"411\":1}}],[\"多余的空闲线程在终止前等待新任务的最长时间\",{\"1\":{\"304\":1}}],[\"多个线程可以共享同一实\",{\"1\":{\"239\":1}}],[\"多个线程共用进程的堆和方法区资源\",{\"1\":{\"236\":1}}],[\"多个线程操作这个变量的时候\",{\"1\":{\"222\":1}}],[\"多个⼦类对同⼀⽅法的重写\",{\"1\":{\"196\":1}}],[\"多操作系统运行\",{\"1\":{\"149\":1}}],[\"多态\",{\"1\":{\"147\":1,\"196\":1}}],[\"多路复用器轮询到连接有io请求就进行处理\",{\"1\":{\"139\":1}}],[\"多线程的put可能导致元素的丢失\",{\"1\":{\"441\":1}}],[\"多线程下扩容死循环\",{\"1\":{\"441\":1}}],[\"多线程下会有什么问题\",{\"0\":{\"441\":1}}],[\"多线程限量操作\",{\"1\":{\"253\":1}}],[\"多线程调度\",{\"1\":{\"175\":1}}],[\"多线程环境下操作大量的数据\",{\"1\":{\"169\":1}}],[\"多线程\",{\"1\":{\"120\":1}}],[\"多处理器环境\",{\"1\":{\"120\":1}}],[\"多核处理器可以利用并行gc和并发gc\",{\"1\":{\"119\":1}}],[\"单机线程池执行断电了应该怎么处理\",{\"0\":{\"374\":1}}],[\"单线程的程序能保证最终结果是有序的\",{\"1\":{\"384\":1}}],[\"单线程的程序一定是顺序的吗\",{\"0\":{\"217\":1}}],[\"单线程线程池只包含一个线程\",{\"1\":{\"351\":1}}],[\"单线程线程池\",{\"0\":{\"355\":1},\"1\":{\"302\":1,\"351\":1}}],[\"单线程池\",{\"0\":{\"292\":1}}],[\"单线程程序的执行结果不能被改变\",{\"1\":{\"217\":1}}],[\"单线程环境下操作大量的数据\",{\"1\":{\"169\":1}}],[\"单线程\",{\"1\":{\"120\":1}}],[\"单处理器或低并发应用\",{\"1\":{\"120\":1}}],[\"小堆内存\",{\"1\":{\"120\":1}}],[\"小到中等堆内存\",{\"1\":{\"119\":1}}],[\"低位是与1做位运算\",{\"1\":{\"431\":1}}],[\"低\",{\"1\":{\"169\":2}}],[\"低延迟应用\",{\"1\":{\"119\":1}}],[\"低停顿时间\",{\"1\":{\"104\":1,\"119\":1,\"120\":1}}],[\"低停顿\",{\"1\":{\"100\":1}}],[\"几十gb到几tb\",{\"1\":{\"119\":1}}],[\"几百mb到几gb\",{\"1\":{\"119\":1}}],[\"几乎没有直接作用\",{\"1\":{\"89\":1}}],[\"关闭调度器\",{\"1\":{\"336\":1}}],[\"关闭线程池\",{\"1\":{\"288\":1,\"303\":1,\"305\":1,\"373\":1}}],[\"关键字或其他同步机制\",{\"1\":{\"442\":1}}],[\"关键字synchronized可以修饰方法或者以同步块的形式来进行使用\",{\"1\":{\"247\":1}}],[\"关键字volatile可以用来修饰字段\",{\"1\":{\"247\":1}}],[\"关键字的作用是让被修饰的成员属性不被序列化\",{\"1\":{\"413\":1}}],[\"关键字的作用\",{\"1\":{\"177\":1}}],[\"关键字修饰\",{\"1\":{\"177\":1}}],[\"关键参数\",{\"1\":{\"120\":1}}],[\"关键考虑因素\",{\"0\":{\"119\":1}}],[\"关键是要根据应用的具体需求和运行环境来做出决策\",{\"1\":{\"117\":1}}],[\"关于作者\",{\"0\":{\"2\":1},\"1\":{\"2\":1}}],[\"关于网站\",{\"0\":{\"1\":1}}],[\"证券交易所\",{\"1\":{\"116\":1}}],[\"金融机构\",{\"1\":{\"116\":1}}],[\"成本平衡的考虑\",{\"1\":{\"437\":1}}],[\"成本和\",{\"1\":{\"437\":1}}],[\"成对使用\",{\"1\":{\"259\":1}}],[\"成功\",{\"1\":{\"273\":1,\"274\":1}}],[\"成功后进入停车场\",{\"1\":{\"254\":1}}],[\"成功进入停车场\",{\"1\":{\"253\":1}}],[\"成熟度不如g1和cms\",{\"1\":{\"112\":1}}],[\"成员变量的默认值根据其类型而定\",{\"1\":{\"201\":1}}],[\"成员变量包括实例变量和静态变量\",{\"1\":{\"201\":1}}],[\"成员变量是在类中声明的变量\",{\"1\":{\"201\":1}}],[\"成员变量与局部变量的区别有哪些\",{\"0\":{\"201\":1}}],[\"成员变量\",{\"1\":{\"82\":1,\"201\":1,\"247\":1}}],[\"相比于链表的o\",{\"1\":{\"439\":1}}],[\"相比于平衡二叉树\",{\"1\":{\"425\":1}}],[\"相比synchronized的加锁方式来解决共享变量的内存可见性问题\",{\"1\":{\"219\":1}}],[\"相反\",{\"1\":{\"240\":1}}],[\"相对来说\",{\"1\":{\"397\":1}}],[\"相对重量级锁\",{\"1\":{\"387\":1}}],[\"相对较高\",{\"1\":{\"239\":2}}],[\"相对较低\",{\"1\":{\"239\":2}}],[\"相对新\",{\"1\":{\"112\":1}}],[\"相当于顺序执行\",{\"1\":{\"238\":1}}],[\"相当于取余\",{\"1\":{\"228\":1}}],[\"相等吗\",{\"0\":{\"173\":1}}],[\"相应的栈帧和局部变量会被释放\",{\"1\":{\"124\":1}}],[\"相关信息等\",{\"1\":{\"82\":1}}],[\"极低停顿时间\",{\"1\":{\"112\":1,\"120\":1}}],[\"初期调优可能需要一定时间\",{\"1\":{\"112\":1}}],[\"初始状态\",{\"1\":{\"241\":1}}],[\"初始标记\",{\"1\":{\"100\":1,\"103\":1}}],[\"初始化数组\",{\"1\":{\"445\":1}}],[\"初始化时\",{\"1\":{\"432\":1}}],[\"初始化线程池\",{\"1\":{\"343\":1}}],[\"初始化\",{\"1\":{\"78\":1,\"134\":1,\"337\":1}}],[\"初始化零值\",{\"1\":{\"78\":1}}],[\"现在位置=原先位置+oldcap\",{\"1\":{\"438\":1}}],[\"现在位置=原先位置\",{\"1\":{\"438\":1}}],[\"现代处理器采用了指令级并行技术\",{\"1\":{\"215\":1}}],[\"现代化的java应用\",{\"1\":{\"112\":1}}],[\"现象指的是在执行垃圾回收时\",{\"1\":{\"99\":1}}],[\"曾广泛用于响应时间要求高的应用\",{\"1\":{\"112\":1}}],[\"你能自己设计实现一个hashmap吗\",{\"0\":{\"440\":1}}],[\"你能设计实现一个线程池吗\",{\"0\":{\"373\":1}}],[\"你还知道哪些哈希函数的构造方法呢\",{\"0\":{\"433\":1}}],[\"你还可以在异步任务链中的不同部分使用不同的线程池\",{\"1\":{\"294\":1}}],[\"你还可以调用这些方法和属性\",{\"1\":{\"155\":1}}],[\"你对红黑树了解多少\",{\"0\":{\"422\":1}}],[\"你需要确保你的线程池的线程数不要超过系统资源的限制\",{\"1\":{\"349\":1}}],[\"你可以根据实际需求和场景进一步扩展和优化这个线程池的实现\",{\"1\":{\"373\":1}}],[\"你可以精细控制线程池的各种参数\",{\"1\":{\"305\":1}}],[\"你可以更好地控制\",{\"1\":{\"294\":1}}],[\"你可以使用threadpoolexecutor来创建自定义线程池\",{\"1\":{\"305\":1}}],[\"你可以使用\",{\"1\":{\"285\":1,\"286\":1}}],[\"你可以使用静态工厂方法来创建\",{\"1\":{\"263\":1}}],[\"你必须在构造中指定\",{\"1\":{\"252\":1}}],[\"你在工作中用到过threadlocal吗\",{\"0\":{\"223\":1}}],[\"你们线上用的什么垃圾收集器\",{\"0\":{\"111\":1}}],[\"你想要创建什么类型的项目\",{\"1\":{\"11\":1}}],[\"虽然java对象通常分配在堆中\",{\"1\":{\"129\":1}}],[\"虽然cms在降低停顿时间方面表现优秀\",{\"1\":{\"110\":1}}],[\"虽然可以通过\",{\"1\":{\"74\":1}}],[\"自旋超过次数就阻塞获取\",{\"1\":{\"444\":1}}],[\"自旋cas\",{\"1\":{\"402\":1}}],[\"自旋一定次数后\",{\"1\":{\"392\":1}}],[\"自旋等待\",{\"1\":{\"390\":1}}],[\"自旋锁\",{\"1\":{\"387\":1}}],[\"自定义线程池\",{\"0\":{\"305\":1,\"359\":1}}],[\"自然也就走不到\",{\"1\":{\"183\":1}}],[\"自动装箱的时候会去缓存池里取integer对象\",{\"1\":{\"173\":1}}],[\"自动类型转换\",{\"1\":{\"160\":1}}],[\"自动调优\",{\"1\":{\"109\":1,\"112\":1,\"114\":1}}],[\"自我清理或释放资源的操作\",{\"1\":{\"90\":1}}],[\"显著减少了内存碎片化问题\",{\"1\":{\"109\":1,\"114\":1}}],[\"调度线程池\",{\"0\":{\"293\":1}}],[\"调用\",{\"1\":{\"376\":2}}],[\"调用设置超时时间\",{\"1\":{\"375\":1}}],[\"调用进行限流\",{\"1\":{\"375\":1}}],[\"调用改为异步调用\",{\"1\":{\"375\":1}}],[\"调用shutdownnow\",{\"1\":{\"348\":1}}],[\"调用shutdown\",{\"1\":{\"348\":1}}],[\"调用start\",{\"1\":{\"237\":1}}],[\"调用future对象的get\",{\"1\":{\"347\":1}}],[\"调用者运行策略\",{\"1\":{\"345\":1}}],[\"调用await方法等待其他线程\",{\"1\":{\"251\":1}}],[\"调用方法不同\",{\"1\":{\"197\":1}}],[\"调用类方法这时候就要用到反射\",{\"1\":{\"155\":1}}],[\"调用时机\",{\"1\":{\"90\":1}}],[\"调整gc参数以优化性能\",{\"1\":{\"121\":1}}],[\"调优参数\",{\"1\":{\"121\":1}}],[\"调优复杂\",{\"1\":{\"108\":1,\"112\":1}}],[\"进⼊同步代码前要获得当前\",{\"1\":{\"378\":1}}],[\"进入阻塞状态\",{\"1\":{\"392\":1}}],[\"进入同步代码前要获得\",{\"1\":{\"378\":1}}],[\"进入该状态表示当前线\",{\"1\":{\"241\":1}}],[\"进入下一个循环条件\",{\"1\":{\"164\":1}}],[\"进程id\",{\"1\":{\"409\":1}}],[\"进程中的多个线程共享进程的资源\",{\"1\":{\"236\":1}}],[\"进程是代码在数据集合上的一次运行活动\",{\"1\":{\"236\":1}}],[\"进程\",{\"1\":{\"236\":1}}],[\"进而产生问题\",{\"1\":{\"204\":1}}],[\"进而用到了integercache\",{\"1\":{\"173\":1}}],[\"进而导致长时间的停顿\",{\"1\":{\"108\":1}}],[\"进行了一系列判断\",{\"1\":{\"450\":1}}],[\"进行一次抢锁\",{\"1\":{\"397\":1}}],[\"进行加锁操作时\",{\"1\":{\"390\":1}}],[\"进行阻塞\",{\"1\":{\"249\":2}}],[\"进行倒数计数\",{\"1\":{\"249\":2}}],[\"进行过滤\",{\"1\":{\"145\":1}}],[\"进行相应的处理\",{\"1\":{\"139\":1}}],[\"进行垃圾回收和区域回收\",{\"1\":{\"103\":1}}],[\"进行垃圾回收操作\",{\"1\":{\"99\":1}}],[\"进行对象的初始化\",{\"1\":{\"78\":1}}],[\"碎片化会导致分配大对象时频繁触发full\",{\"1\":{\"108\":1}}],[\"碎片化问题\",{\"1\":{\"100\":1}}],[\"毫秒\",{\"1\":{\"105\":1}}],[\"启用同步消除优化\",{\"1\":{\"127\":1}}],[\"启用标量替换优化\",{\"1\":{\"127\":1}}],[\"启用逃逸分析\",{\"1\":{\"127\":1}}],[\"启用方式\",{\"1\":{\"120\":6}}],[\"启用g1垃圾收集器\",{\"1\":{\"105\":1}}],[\"启动另一个\",{\"1\":{\"269\":1}}],[\"启动时会调用\",{\"1\":{\"246\":1}}],[\"启动线程b\",{\"1\":{\"216\":1}}],[\"启动\",{\"1\":{\"204\":1}}],[\"启动成功后\",{\"1\":{\"11\":1}}],[\"启动开发服务器\",{\"1\":{\"11\":1}}],[\"涉及将存活对象从一个区域复制到另一个区域\",{\"1\":{\"103\":1}}],[\"涉及的是字面值\",{\"1\":{\"67\":1}}],[\"清理过期entry\",{\"1\":{\"230\":1}}],[\"清理\",{\"1\":{\"103\":1}}],[\"清除\",{\"1\":{\"100\":1}}],[\"清除和复制算法的优点\",{\"1\":{\"92\":1}}],[\"清除所有未标记的对象\",{\"1\":{\"92\":1}}],[\"清除算法存在的问题是产生大量的内存碎片\",{\"1\":{\"92\":1}}],[\"清除算法是最基本的垃圾收集算法之一\",{\"1\":{\"92\":1}}],[\"清除算法\",{\"1\":{\"92\":1,\"108\":1}}],[\"遍历node数组\",{\"1\":{\"445\":1}}],[\"遍历hashentry\",{\"1\":{\"444\":1}}],[\"遍历hashmap的几种方法\",{\"0\":{\"193\":1}}],[\"遍历链表查找\",{\"1\":{\"428\":1}}],[\"遍历下一个元素之前\",{\"1\":{\"416\":1}}],[\"遍历完成之后\",{\"1\":{\"230\":1}}],[\"遍历对象图\",{\"1\":{\"103\":1}}],[\"遍历整个对象图\",{\"1\":{\"100\":1}}],[\"扫描在初始标记阶段确定的根区域\",{\"1\":{\"103\":1}}],[\"一直不成功\",{\"1\":{\"402\":1}}],[\"一直找到\",{\"1\":{\"229\":1}}],[\"一般跟finally配合释放锁\",{\"1\":{\"391\":1}}],[\"一般是lock\",{\"1\":{\"391\":1}}],[\"一般适用于连接数较多且连接时间较长的应用\",{\"1\":{\"139\":1}}],[\"一次只能被一个线程拥有\",{\"1\":{\"384\":1}}],[\"一次编译\",{\"1\":{\"149\":1}}],[\"一开始会创建一定数量的线程\",{\"1\":{\"350\":1}}],[\"一个任务一个任务地执行\",{\"1\":{\"355\":1}}],[\"一个用于在两个线程之间交换数据的同步点\",{\"1\":{\"258\":1}}],[\"一个共享变量上可能会有多个线程在等待\",{\"1\":{\"240\":1}}],[\"一个线程使用共享方式获取了资源\",{\"1\":{\"392\":1}}],[\"一个线程使用独占方式获取了资源\",{\"1\":{\"392\":1}}],[\"一个线程执行任务\",{\"1\":{\"355\":1}}],[\"一个线程生成任务\",{\"1\":{\"256\":1}}],[\"一个线程a调用共享对象的\",{\"1\":{\"240\":1}}],[\"一个线程中的每个操作\",{\"1\":{\"216\":1}}],[\"一个进程中至少有一个线程\",{\"1\":{\"236\":1}}],[\"一个进程中有多个线程\",{\"1\":{\"236\":1}}],[\"一个table数组\",{\"1\":{\"228\":1}}],[\"一个变量被声明为volatile时\",{\"1\":{\"219\":1}}],[\"一个抽象概念\",{\"1\":{\"211\":1}}],[\"一个对象的\",{\"1\":{\"204\":1}}],[\"一个类不管创建多少个对象\",{\"1\":{\"202\":1}}],[\"一个类可以实现多个接口\",{\"1\":{\"200\":1}}],[\"一个或两个\",{\"1\":{\"170\":1}}],[\"一个方法\",{\"1\":{\"144\":1}}],[\"一旦超出这个范围就不再有效\",{\"1\":{\"201\":1}}],[\"一旦创建就不能修改其值\",{\"1\":{\"169\":1}}],[\"一旦应用加载了大量类或使用了大量字符串常量\",{\"1\":{\"74\":1}}],[\"一部分需要stw\",{\"1\":{\"103\":1}}],[\"一起执行\",{\"1\":{\"103\":1}}],[\"暂停时间可控\",{\"1\":{\"102\":1}}],[\"传的不是2的倍数时\",{\"1\":{\"432\":1}}],[\"传一个17的值\",{\"0\":{\"432\":1}}],[\"传递性\",{\"1\":{\"216\":1}}],[\"传递的是该引用的副本\",{\"1\":{\"207\":1}}],[\"传递的是该值的副本\",{\"1\":{\"207\":1}}],[\"传统方法通常分为年轻代收集和老年代收集\",{\"1\":{\"102\":1}}],[\"传送门\",{\"1\":{\"1\":1}}],[\"称为混合回收\",{\"1\":{\"102\":1}}],[\"混合回收\",{\"1\":{\"102\":1}}],[\"五个子阶段\",{\"1\":{\"102\":1}}],[\"根节点是黑色的\",{\"1\":{\"423\":1}}],[\"根节点和叶子节点\",{\"1\":{\"423\":1}}],[\"根据哈希值计算下标\",{\"1\":{\"427\":1}}],[\"根据任务执行日志来回滚已经执行成功但未持久化的任务\",{\"1\":{\"374\":1}}],[\"根据实际情况动态调整线程池的配置\",{\"1\":{\"372\":1}}],[\"根据需要创建新线程的线程池\",{\"1\":{\"302\":1}}],[\"根据逃逸分析的结果\",{\"1\":{\"125\":1}}],[\"根据测量结果\",{\"1\":{\"121\":1}}],[\"根据对象的存活周期将java堆划分为新生代和老年代两个部分\",{\"1\":{\"92\":1}}],[\"根据对象的引用强度和生命周期的不同\",{\"1\":{\"89\":1}}],[\"根区域扫描\",{\"1\":{\"102\":1,\"103\":1}}],[\"采用安全失败机制的集合容器\",{\"1\":{\"416\":1}}],[\"采用ab岗两人进行录入\",{\"1\":{\"259\":1}}],[\"采用clone机制\",{\"1\":{\"209\":1}}],[\"采用字节码的好处是什么\",{\"0\":{\"150\":1}}],[\"采用了并发标记的策略\",{\"1\":{\"102\":1}}],[\"采用复制算法进行垃圾回收\",{\"1\":{\"93\":1}}],[\"目前无法直接保证操作的原子性的\",{\"1\":{\"404\":1}}],[\"目前主流的访问方式有使用句柄和直接指针两种\",{\"1\":{\"83\":1}}],[\"目的是为了写出通用的代码\",{\"1\":{\"195\":1}}],[\"目录下的配置文件\",{\"1\":{\"153\":1}}],[\"目录下\",{\"1\":{\"153\":2}}],[\"目标是实现高吞吐量与低停顿时间之间的平衡\",{\"1\":{\"101\":1}}],[\"旨在提高性能并优化资源使用\",{\"1\":{\"298\":1}}],[\"旨在替代cms\",{\"1\":{\"101\":1}}],[\"旨在最小化应用程序的停顿时间\",{\"1\":{\"100\":1}}],[\"尽可能的少的分配线程\",{\"1\":{\"353\":1}}],[\"尽管字节流可以处理所有类型的数据\",{\"1\":{\"138\":1}}],[\"尽管cms\",{\"1\":{\"107\":1}}],[\"尽管cms降低了停顿时间\",{\"1\":{\"100\":1}}],[\"尽量减少垃圾收集对应用程序的影响\",{\"1\":{\"100\":1}}],[\"算法进行full\",{\"1\":{\"108\":1}}],[\"算法\",{\"1\":{\"100\":1,\"109\":1}}],[\"应尽量减少线程上下文切换的次数\",{\"1\":{\"244\":1}}],[\"应用场景\",{\"1\":{\"253\":1,\"259\":1}}],[\"应用程序可以复用一组数据库连接\",{\"1\":{\"323\":1}}],[\"应用程序可以在不修改源代码的情况下\",{\"1\":{\"153\":1}}],[\"应用程序可以在缓冲区中读取或写入数据\",{\"1\":{\"139\":1}}],[\"应用程序定义一个接口\",{\"1\":{\"153\":1}}],[\"应用程序\",{\"1\":{\"139\":1}}],[\"应用类型\",{\"1\":{\"119\":1}}],[\"应用线程和垃圾收集线程并发运行\",{\"1\":{\"100\":1}}],[\"应谨慎使用\",{\"1\":{\"90\":1}}],[\"安其拉\",{\"1\":{\"249\":4}}],[\"安全失败\",{\"1\":{\"416\":1}}],[\"安全问题\",{\"1\":{\"222\":1}}],[\"安全性和可靠性\",{\"1\":{\"168\":1}}],[\"安全性等功能的关键组件\",{\"1\":{\"135\":1}}],[\"安全性管理\",{\"1\":{\"132\":1}}],[\"安全点\",{\"1\":{\"99\":1}}],[\"安装依赖\",{\"1\":{\"11\":1}}],[\"安装pnpm\",{\"1\":{\"9\":1}}],[\"安装nodejs\",{\"1\":{\"9\":1}}],[\"z\",{\"1\":{\"98\":1,\"112\":1,\"120\":1,\"145\":2}}],[\"zgc适合需要极低停顿时间和处理超大堆内存的应用\",{\"1\":{\"117\":1}}],[\"zgc的自动管理和优化能力强\",{\"1\":{\"115\":1}}],[\"zgc的设计目标是实现极低的停顿时间\",{\"1\":{\"115\":1}}],[\"zgc能够处理数tb的堆内存\",{\"1\":{\"115\":1}}],[\"zgc是一种低延迟的垃圾收集器\",{\"1\":{\"98\":1}}],[\"zgc\",{\"1\":{\"98\":1,\"112\":1,\"120\":1}}],[\"zh\",{\"1\":{\"17\":1}}],[\"就使用synchronized写入数据\",{\"1\":{\"445\":1}}],[\"就使用了自旋加锁的方式\",{\"1\":{\"387\":1}}],[\"就通过cas+自旋的方式初始化数组\",{\"1\":{\"445\":1}}],[\"就需要把插入位置后的元素都向前或者向后移动\",{\"1\":{\"411\":1}}],[\"就需要老年代进行分配担保\",{\"1\":{\"97\":1}}],[\"就停止自旋\",{\"1\":{\"403\":1}}],[\"就释放锁了\",{\"1\":{\"385\":1}}],[\"就可得到原问题的解\",{\"1\":{\"376\":1}}],[\"就新建一个线程执行\",{\"1\":{\"354\":1}}],[\"就去取出任务执行\",{\"1\":{\"354\":1}}],[\"就起不到多线程的效果\",{\"1\":{\"238\":1}}],[\"就把它赋给当前线程\",{\"1\":{\"232\":1}}],[\"就开始执行\",{\"1\":{\"230\":1}}],[\"就判断下一个位置\",{\"1\":{\"229\":1}}],[\"就会导致后一个key覆盖前一个key\",{\"1\":{\"441\":1}}],[\"就会改变\",{\"1\":{\"416\":1}}],[\"就会造成了内存泄漏问题\",{\"1\":{\"225\":1}}],[\"就会出现这种情况\",{\"1\":{\"225\":1}}],[\"就会触发扩容\",{\"1\":{\"436\":1,\"438\":1}}],[\"就会触发full\",{\"1\":{\"96\":1}}],[\"就会触发minor\",{\"1\":{\"95\":1}}],[\"就会触发自动发布\",{\"1\":{\"21\":1}}],[\"就是和hashmap一样\",{\"1\":{\"444\":1}}],[\"就是由加载因子和当前容器的容量大小来确定的\",{\"1\":{\"436\":1}}],[\"就是告知程序任何对该变量的访问均需要从共享内存中获取\",{\"1\":{\"247\":1}}],[\"就是这个坑被人占了\",{\"1\":{\"229\":1}}],[\"就是通过分别限制这两种类型的重排序\",{\"1\":{\"220\":1}}],[\"就是注解在编译期的运行\",{\"1\":{\"190\":1}}],[\"就是\",{\"1\":{\"139\":1}}],[\"年龄大于或等于该年龄的对象就可以直接进入老年代\",{\"1\":{\"97\":1}}],[\"占用部分资源的线程进一步申请其他资源时\",{\"1\":{\"408\":1}}],[\"占用大量连续内存空间的对象\",{\"1\":{\"97\":1}}],[\"占个位\",{\"0\":{\"3\":1},\"1\":{\"3\":1}}],[\"大于1\",{\"1\":{\"376\":1}}],[\"大任务拆成了若干个小任务\",{\"1\":{\"376\":1}}],[\"大乔\",{\"1\":{\"249\":4}}],[\"大数据处理\",{\"1\":{\"119\":1}}],[\"大数据处理和金融系统\",{\"1\":{\"112\":1}}],[\"大堆内存\",{\"1\":{\"119\":1,\"120\":2}}],[\"大型互联网公司\",{\"1\":{\"116\":1}}],[\"大公司和常见应用中的选择\",{\"0\":{\"116\":1}}],[\"大部分的垃圾收集工作与应用程序并发进行\",{\"1\":{\"100\":1}}],[\"大对象\",{\"1\":{\"97\":1}}],[\"大多数对象都会被分配到eden区\",{\"1\":{\"93\":1}}],[\"大多数对象从新生代晋升到老年代\",{\"1\":{\"91\":1}}],[\"大多数对象在被分配时会被分配在eden区\",{\"1\":{\"91\":1}}],[\"长时间存活的缓存对象等\",{\"1\":{\"97\":1}}],[\"长时间运行的程序可能会持续产生新对象而不释放旧对象\",{\"1\":{\"86\":1}}],[\"长时间运行的程序\",{\"1\":{\"86\":1}}],[\"长时间运行的程序中如果存在内存泄漏\",{\"1\":{\"84\":1}}],[\"长期存活的对象\",{\"1\":{\"97\":2}}],[\"说明需要扩容\",{\"1\":{\"445\":1}}],[\"说明内存位置\",{\"1\":{\"398\":2}}],[\"说明\",{\"1\":{\"241\":1}}],[\"说明本次young\",{\"1\":{\"96\":1}}],[\"说说有哪些常见集合\",{\"0\":{\"452\":1}}],[\"说说有哪些常见的序列化方式\",{\"0\":{\"178\":1}}],[\"说说synchronized和reentrantlock的区别\",{\"0\":{\"391\":1}}],[\"说说阻塞队列是怎么实现的\",{\"0\":{\"296\":1}}],[\"说说你对completablefuture的理解\",{\"0\":{\"260\":1}}],[\"说说你对原子性\",{\"0\":{\"212\":1}}],[\"说说线程有几种创建方式\",{\"0\":{\"237\":1}}],[\"说说什么是进程和线程\",{\"0\":{\"236\":1}}],[\"说说什么是跨平台性\",{\"0\":{\"149\":1}}],[\"说说自增自减运算\",{\"0\":{\"166\":1}}],[\"说下什么是java的spi机制\",{\"0\":{\"153\":1}}],[\"说一下你对java内存模型\",{\"0\":{\"211\":1}}],[\"说一下你对注解的理解\",{\"0\":{\"190\":1}}],[\"说一下新生代的区域划分\",{\"0\":{\"93\":1}}],[\"说一下对象有哪几种引用\",{\"0\":{\"89\":1}}],[\"说一下jdk1\",{\"0\":{\"54\":1}}],[\"手动调用system\",{\"1\":{\"96\":1}}],[\"空位比较多的时候就扩容了\",{\"1\":{\"437\":1}}],[\"空位比较少的时候才扩容\",{\"1\":{\"437\":1}}],[\"空间成本就增加了\",{\"1\":{\"437\":1}}],[\"空间\",{\"1\":{\"437\":1}}],[\"空间分配担保\",{\"1\":{\"97\":1}}],[\"空间分配担保失败\",{\"1\":{\"96\":1}}],[\"空闲核心线程执行任务\",{\"1\":{\"340\":1,\"343\":1}}],[\"空闲线程在被终止前等待新任务的最长时间\",{\"1\":{\"344\":1}}],[\"空闲线程存活时间\",{\"1\":{\"338\":1}}],[\"空闲线程的存活时间\",{\"1\":{\"304\":1}}],[\"空闲列表适用于\",{\"1\":{\"79\":1}}],[\"空闲列表\",{\"1\":{\"79\":2}}],[\"什么也不写\",{\"1\":{\"198\":1}}],[\"什么时候会触发full\",{\"0\":{\"96\":1}}],[\"什么是红黑树\",{\"0\":{\"423\":1}}],[\"什么是cas\",{\"0\":{\"398\":1}}],[\"什么是线程池\",{\"0\":{\"298\":1}}],[\"什么是线程上下文切换\",{\"0\":{\"244\":1}}],[\"什么是深拷贝和浅拷贝\",{\"0\":{\"208\":1}}],[\"什么是hashcode\",{\"1\":{\"206\":1}}],[\"什么是泛型擦除\",{\"0\":{\"188\":1}}],[\"什么是泛型\",{\"0\":{\"185\":1}}],[\"什么是反序列化\",{\"0\":{\"177\":1}}],[\"什么是反射\",{\"0\":{\"155\":1}}],[\"什么是序列化\",{\"0\":{\"177\":1}}],[\"什么是integer缓存\",{\"1\":{\"173\":1}}],[\"什么是自动拆箱\",{\"0\":{\"161\":1}}],[\"什么是自动类型转换\",{\"0\":{\"160\":1}}],[\"什么是字节码\",{\"0\":{\"150\":1}}],[\"什么是jvm\",{\"0\":{\"131\":1}}],[\"什么是安全点\",{\"0\":{\"99\":1}}],[\"什么是\",{\"0\":{\"99\":1}}],[\"什么是stop\",{\"0\":{\"99\":1}}],[\"什么是内存溢出\",{\"0\":{\"84\":1}}],[\"什么是tlab\",{\"0\":{\"80\":1}}],[\"什么是空闲列表\",{\"0\":{\"79\":1}}],[\"什么是指针碰撞\",{\"0\":{\"79\":1}}],[\"新hash值保留了高低位的特征\",{\"1\":{\"430\":1}}],[\"新建线程执行任务\",{\"1\":{\"355\":1}}],[\"新任务将在任务队列中等待\",{\"1\":{\"351\":2}}],[\"新任务将被拒绝\",{\"1\":{\"346\":1}}],[\"新任务会被拒绝\",{\"1\":{\"346\":1}}],[\"新任务会触发创建额外的线程\",{\"1\":{\"344\":1}}],[\"新任务也可以被放入队列等待执行\",{\"1\":{\"346\":1}}],[\"新类的定义可以增加新的属性或新的方法\",{\"1\":{\"196\":1}}],[\"新的任务会被放入一个队列中等待执行\",{\"1\":{\"299\":1}}],[\"新的api解决了旧的date和calendar类在处理日期和时间时的一些问题\",{\"1\":{\"141\":1}}],[\"新的日期和时间api\",{\"1\":{\"141\":1}}],[\"新对象通常会被分配到eden区\",{\"1\":{\"95\":1}}],[\"新生代的一部分\",{\"1\":{\"95\":1}}],[\"新生代的垃圾回收可以避免内存碎片的产生\",{\"1\":{\"93\":1}}],[\"新生代垃圾回收\",{\"1\":{\"93\":1}}],[\"新生代通常使用复制算法\",{\"1\":{\"92\":1}}],[\"新生代通常被划分为三个区域\",{\"1\":{\"91\":1,\"93\":1}}],[\"新生代是java堆的一部分\",{\"1\":{\"91\":1,\"93\":1}}],[\"新生代\",{\"1\":{\"91\":1}}],[\"新生代又可以进一步划分为伊甸园区\",{\"1\":{\"53\":1}}],[\"被窃取任务线程永远从双端队列的头部拿\",{\"1\":{\"376\":1}}],[\"被销毁\",{\"1\":{\"354\":1}}],[\"被垃圾回收器回收了\",{\"1\":{\"225\":1}}],[\"被定义出来屏蔽各种硬件和操作系统的内存访问差异\",{\"1\":{\"211\":1}}],[\"被调用不一定会立即回收该对象\",{\"1\":{\"204\":1}}],[\"被final修饰的变量必须被显式第指定初始值\",{\"1\":{\"203\":1}}],[\"被final修饰的变量不可变\",{\"1\":{\"203\":1}}],[\"被final修饰的方法不可以被重写\",{\"1\":{\"203\":1}}],[\"被final修饰的类不可以被继承\",{\"1\":{\"203\":1}}],[\"被\",{\"1\":{\"177\":1}}],[\"被推荐使用的做法\",{\"1\":{\"144\":1}}],[\"被新对象填满时\",{\"1\":{\"95\":1}}],[\"被取出并赋值给局部变量\",{\"1\":{\"69\":1}}],[\"其次要考虑的是你的系统资源\",{\"1\":{\"349\":1}}],[\"其中n是树中节点的数量\",{\"1\":{\"424\":1}}],[\"其中\",{\"1\":{\"408\":1}}],[\"其中的线程会等待\",{\"1\":{\"252\":1}}],[\"其中每个线程都有自己的控制器和运算器\",{\"1\":{\"211\":1}}],[\"其实都是基于对象的内置锁\",{\"1\":{\"381\":1}}],[\"其实就体现了分治思想\",{\"1\":{\"376\":1}}],[\"其实在jvm\",{\"1\":{\"246\":1}}],[\"其实是会生成新的对象\",{\"1\":{\"171\":1}}],[\"其含义是\",{\"1\":{\"240\":1,\"247\":1}}],[\"其内部调用的是\",{\"1\":{\"240\":1}}],[\"其它的原子操作类基本都是大同小异\",{\"1\":{\"407\":1}}],[\"其它获取该锁的线程会被阻塞而被放入该锁的阻塞队列里面\",{\"1\":{\"393\":1}}],[\"其它线程就会在获取失败后被阻塞\",{\"1\":{\"392\":1}}],[\"其它线程无法获取主内存中的共享变量\",{\"1\":{\"383\":1}}],[\"其它\",{\"0\":{\"152\":1}}],[\"其工作过程可以概括为以下几个阶段\",{\"1\":{\"101\":1}}],[\"其过程比较耗时\",{\"1\":{\"94\":1}}],[\"其他⽅法都是直接调⽤\",{\"1\":{\"450\":1}}],[\"其他线程必须等待该线程释放锁后才能获取锁\",{\"1\":{\"381\":1}}],[\"其他线程不\",{\"1\":{\"252\":1}}],[\"其他线程调用了线程a的\",{\"1\":{\"240\":1}}],[\"其他线程调用了线程a共享对象\",{\"1\":{\"240\":1}}],[\"其他线程能够立即看到这个修改\",{\"1\":{\"212\":1}}],[\"其他线程无法访问\",{\"1\":{\"80\":1}}],[\"其他jvm如j9和jrockit不会因为固定大小的永久代而遭遇内存溢出问题\",{\"1\":{\"74\":1}}],[\"其他jvm的优势\",{\"1\":{\"74\":1}}],[\"其他内存区域\",{\"1\":{\"57\":1}}],[\"或称为监视器锁\",{\"1\":{\"381\":1}}],[\"或在\",{\"1\":{\"368\":1}}],[\"或shutdownnow\",{\"1\":{\"342\":1,\"348\":1}}],[\"或submit\",{\"1\":{\"339\":1}}],[\"或\",{\"1\":{\"240\":2,\"285\":1,\"358\":1}}],[\"或与底层设备进行通信时\",{\"1\":{\"138\":1}}],[\"或老年代\",{\"1\":{\"102\":1}}],[\"或使用类似jmap\",{\"1\":{\"96\":1}}],[\"或元空间\",{\"1\":{\"94\":1}}],[\"或者等很久才会获得锁\",{\"1\":{\"395\":1}}],[\"或者等待时间到期\",{\"1\":{\"240\":1}}],[\"或者已经不再存活\",{\"1\":{\"389\":1}}],[\"或者通过轮询isterminated\",{\"1\":{\"348\":1}}],[\"或者\",{\"1\":{\"240\":1,\"446\":1}}],[\"或者使用json序列化\",{\"1\":{\"209\":1}}],[\"或者新生代对象的gc年龄到达阈值需要晋升到老年代\",{\"1\":{\"96\":1}}],[\"或者老年代中的对象存活时间过长\",{\"1\":{\"96\":1}}],[\"或者当长时间存活的对象需要晋升到老年代时\",{\"1\":{\"94\":1}}],[\"或者是持有对某些对象的引用却未能及时释放这些引用\",{\"1\":{\"84\":1}}],[\"或者出现异常错误\",{\"1\":{\"84\":1}}],[\"该如何避免死锁呢\",{\"1\":{\"408\":1}}],[\"该如何避免\",{\"0\":{\"408\":1}}],[\"该状态达到阈值40则执行批量撤销\",{\"1\":{\"389\":1}}],[\"该状态达到阈值20则执行批量重偏向\",{\"1\":{\"389\":1}}],[\"该状态不同于\",{\"1\":{\"241\":1}}],[\"该线程将被终止\",{\"1\":{\"341\":1}}],[\"该方法返回一个包装后的线程安全list\",{\"1\":{\"417\":1}}],[\"该方法会阻塞\",{\"1\":{\"258\":1}}],[\"该方法如果发现当前线程被中断\",{\"1\":{\"240\":1}}],[\"该实例也无法被垃圾回收\",{\"1\":{\"227\":1}}],[\"该引⽤变量发出的⽅法调⽤到底是哪个类中实现的⽅法\",{\"1\":{\"196\":1}}],[\"该对象又不需要被回收了\",{\"1\":{\"204\":1}}],[\"该对象被回收的时候被调用\",{\"1\":{\"204\":1}}],[\"该对象包含了类的名称\",{\"1\":{\"157\":1}}],[\"该对象就被认为是存活的\",{\"1\":{\"87\":1}}],[\"该文件位于\",{\"1\":{\"153\":1}}],[\"该文件包含了服务接口的实现类的全限定名\",{\"1\":{\"153\":1}}],[\"该阶段和应用线程并发运行\",{\"1\":{\"103\":1}}],[\"该算法将内存空间分为两个相等大小的区域\",{\"1\":{\"93\":1}}],[\"弱分代假设\",{\"1\":{\"92\":1}}],[\"弱引用很容易被回收\",{\"1\":{\"225\":1}}],[\"弱引用可以防止内存泄漏\",{\"1\":{\"89\":1}}],[\"弱引用都会被回收\",{\"1\":{\"89\":1}}],[\"弱引用的生命周期比软引用更短\",{\"1\":{\"89\":1}}],[\"弱引用\",{\"1\":{\"89\":1,\"225\":1}}],[\"适用场景\",{\"1\":{\"120\":6,\"353\":1,\"354\":1,\"355\":1,\"356\":1}}],[\"适用于串行执行任务的场景\",{\"1\":{\"355\":1}}],[\"适用于短时任务较多\",{\"1\":{\"351\":1}}],[\"适用于已知线程数固定的场景\",{\"1\":{\"302\":1}}],[\"适用于已知固定数量的并发任务\",{\"1\":{\"290\":1}}],[\"适用于需要执行定时任务和周期性任务的场景\",{\"1\":{\"351\":1}}],[\"适用于需要保证任务按照顺序执行\",{\"1\":{\"351\":1}}],[\"适用于需要限制线程数量的场景\",{\"1\":{\"351\":1}}],[\"适用于需要定期执行任务的场景\",{\"1\":{\"293\":1}}],[\"适用于需要顺序执行任务的场景\",{\"1\":{\"292\":1,\"302\":1}}],[\"适用于需要处理大量数据的应用场景\",{\"1\":{\"115\":1}}],[\"适用于大量短生命周期任务\",{\"1\":{\"302\":1}}],[\"适用于大量短生命周期的并发任务\",{\"1\":{\"291\":1}}],[\"适用于大堆内存\",{\"1\":{\"112\":1}}],[\"适用于处理cpu密集型的任务\",{\"1\":{\"353\":1}}],[\"适用于处理文本数据\",{\"1\":{\"138\":1}}],[\"适用于处理二进制数据\",{\"1\":{\"138\":1}}],[\"适用于openjdk\",{\"1\":{\"120\":1}}],[\"适用于批处理\",{\"1\":{\"119\":1}}],[\"适用于对响应时间敏感的应用\",{\"1\":{\"119\":1}}],[\"适用于对响应时间有要求的应用\",{\"1\":{\"98\":1}}],[\"适用于具有中等堆大小的应用\",{\"1\":{\"112\":1}}],[\"适用于多核服务器上的应用\",{\"1\":{\"98\":1}}],[\"适用于简单的客户端应用或者测试目的\",{\"1\":{\"98\":2}}],[\"适用于老年代的垃圾回收\",{\"1\":{\"92\":1}}],[\"适合大堆内存\",{\"1\":{\"114\":1}}],[\"适合用于缓存的场景\",{\"1\":{\"89\":1}}],[\"适应现代应用的需求\",{\"1\":{\"109\":1}}],[\"适应性强\",{\"1\":{\"104\":1}}],[\"整体的吞吐效率高\",{\"1\":{\"395\":1}}],[\"整数类型\",{\"1\":{\"159\":1}}],[\"整理\",{\"1\":{\"108\":1}}],[\"整理和清理来实现高吞吐和低停顿\",{\"1\":{\"98\":1}}],[\"整理算法结合了标记\",{\"1\":{\"92\":1}}],[\"整理算法\",{\"1\":{\"92\":2,\"98\":2}}],[\"整合jrockit功能\",{\"1\":{\"75\":1,\"77\":1}}],[\"复制原数组元素到新数组\",{\"1\":{\"412\":1}}],[\"复制成功之后\",{\"1\":{\"390\":1}}],[\"复制和压缩回收\",{\"1\":{\"114\":1}}],[\"复制\",{\"1\":{\"103\":1,\"109\":1}}],[\"复制的开销较小\",{\"1\":{\"92\":1}}],[\"复制算法和多线程并行的方式实现高吞吐量的垃圾收集\",{\"1\":{\"98\":1}}],[\"复制算法适用于新生代的垃圾回收\",{\"1\":{\"92\":1}}],[\"复制算法将内存空间划分为两个相等大小的区域\",{\"1\":{\"92\":1}}],[\"复制算法\",{\"1\":{\"92\":1,\"98\":2}}],[\"将添加的元素作为key\",{\"1\":{\"450\":1}}],[\"将扩容操作分散到多次进行\",{\"1\":{\"439\":1}}],[\"将新键值对插入链表或红黑树末尾\",{\"1\":{\"439\":1}}],[\"将已经产生hash碰撞的元素完美的转移到新的table中去\",{\"1\":{\"431\":1}}],[\"将链表转换为红黑树\",{\"1\":{\"421\":1}}],[\"将原数组拷贝一份\",{\"1\":{\"418\":1}}],[\"将这些资源分配给其他等待进程\",{\"1\":{\"409\":1}}],[\"将会看到线程的死锁信息\",{\"1\":{\"409\":1}}],[\"将多个变量封装成一个对象\",{\"1\":{\"404\":1}}],[\"将多个连续的加锁\",{\"1\":{\"387\":1}}],[\"将内存位置\",{\"1\":{\"398\":1}}],[\"将清空工作内存中共享变量的值\",{\"1\":{\"383\":1}}],[\"将问题拆分成两个子任务并使用fork\",{\"1\":{\"376\":1}}],[\"将一个规模为n的问题分解为k个规模较小的子问题\",{\"1\":{\"376\":1}}],[\"将耗时的操作拆分为多个小任务\",{\"1\":{\"375\":1}}],[\"将耗时的\",{\"1\":{\"375\":1}}],[\"将线程池的参数配置在外部的配置文件或者配置中心中\",{\"1\":{\"371\":1}}],[\"将任务队列中的任务持久化到可靠的存储介质中\",{\"1\":{\"374\":1}}],[\"将任务加到阻塞队列\",{\"1\":{\"355\":1}}],[\"将任务放入任务队列中\",{\"1\":{\"350\":1}}],[\"将创建新的线程来处理新任务\",{\"1\":{\"351\":1}}],[\"将自定义线程池传递给\",{\"1\":{\"287\":1}}],[\"将\",{\"1\":{\"245\":1,\"431\":1,\"433\":1}}],[\"将对象序列化为hessian格式\",{\"1\":{\"178\":1}}],[\"将对象序列化为protobuf格式\",{\"1\":{\"178\":1}}],[\"将对象序列化为xml格式\",{\"1\":{\"178\":1}}],[\"将对象序列化为json格式\",{\"1\":{\"178\":1}}],[\"将此string对象添加到池中\",{\"1\":{\"172\":1}}],[\"将包装类型转换为基本数据类型\",{\"1\":{\"161\":1}}],[\"将基本类型用它们对应的引用类型包装起来\",{\"1\":{\"161\":1}}],[\"将通道\",{\"1\":{\"139\":1}}],[\"将某些对象分配在栈上或者进行标量替换\",{\"1\":{\"129\":1}}],[\"将point对象分配在栈上而不是堆上\",{\"1\":{\"126\":1}}],[\"将survivor区无法容纳的对象直接送入老年代\",{\"1\":{\"97\":1}}],[\"将eden区和其中一个survivor区的存活对象复制到另一个survivor区\",{\"1\":{\"93\":1}}],[\"将eden区中存活的对象复制到survivor区\",{\"1\":{\"93\":1}}],[\"将它们移动到内存的一端\",{\"1\":{\"92\":1}}],[\"将存活对象压缩\",{\"1\":{\"92\":1}}],[\"将存活的对象复制到to区\",{\"1\":{\"92\":1}}],[\"将指针向空闲空间方向挪动与对象大小相等的距离即可\",{\"1\":{\"79\":1}}],[\"容量大小为原数组1\",{\"1\":{\"412\":1}}],[\"容易导致内存分配失败\",{\"1\":{\"92\":1}}],[\"容器图\",{\"0\":{\"41\":1}}],[\"释放它们持有的资源\",{\"1\":{\"409\":1}}],[\"释放它们所占用的内存空间\",{\"1\":{\"92\":1}}],[\"释放多少次\",{\"1\":{\"392\":1}}],[\"释放资源的时候\",{\"1\":{\"392\":1}}],[\"释放资源等\",{\"1\":{\"90\":1}}],[\"释放锁并进入等待队列\",{\"1\":{\"296\":1}}],[\"释放许可\",{\"1\":{\"253\":1}}],[\"释放出连续的内存空间\",{\"1\":{\"92\":1}}],[\"等待队列中除第一个线程以外的所有线程都会阻塞\",{\"1\":{\"394\":1}}],[\"等待队列状态改变的线程会进入等待状态\",{\"1\":{\"296\":1}}],[\"等待次数达到阈值仍未获取到锁\",{\"1\":{\"390\":1}}],[\"等待被唤醒\",{\"1\":{\"381\":1}}],[\"等待已提交任务完成或立即终止\",{\"1\":{\"343\":1}}],[\"等待所有任务完成\",{\"1\":{\"279\":1,\"281\":1}}],[\"等待所有子线程运行结束\",{\"1\":{\"249\":1}}],[\"等待其他线程\",{\"1\":{\"251\":13}}],[\"等待latch降为0\",{\"1\":{\"249\":2}}],[\"等待主线程完成\",{\"1\":{\"249\":1}}],[\"等待子线程完成\",{\"1\":{\"249\":1}}],[\"等待\",{\"1\":{\"247\":1,\"445\":1}}],[\"等待状态\",{\"1\":{\"241\":1}}],[\"等\",{\"1\":{\"206\":1,\"296\":1,\"338\":1,\"386\":1,\"406\":1}}],[\"等价于通过\",{\"1\":{\"205\":1}}],[\"等等框架中都大量使用了反射机制\",{\"1\":{\"156\":1}}],[\"等命令触发\",{\"1\":{\"96\":1}}],[\"等方法来确保资源的释放\",{\"1\":{\"90\":1}}],[\"等原子性操作来确保对共享数据的原子性访问\",{\"1\":{\"81\":1}}],[\"推荐使用try\",{\"1\":{\"90\":1}}],[\"推送新分支到github\",{\"0\":{\"19\":1}}],[\"缺点是处于等待队列中的线程可能会饿死\",{\"1\":{\"395\":1}}],[\"缺点是整体吞吐效率相对非公平锁要低\",{\"1\":{\"394\":1}}],[\"缺点\",{\"1\":{\"90\":1,\"112\":3,\"188\":1,\"416\":1,\"418\":1}}],[\"有其它线程写入数据怎么办\",{\"0\":{\"419\":1}}],[\"有\",{\"1\":{\"389\":1}}],[\"有一块结构\",{\"1\":{\"386\":1}}],[\"有一个私有的成员变量\",{\"1\":{\"376\":1}}],[\"有的线程干活慢\",{\"1\":{\"376\":1}}],[\"有的线程干活块\",{\"1\":{\"376\":1}}],[\"有个调用特别耗时\",{\"0\":{\"375\":1}}],[\"有哪几种常见的线程池\",{\"0\":{\"351\":1}}],[\"有界队列可以有效地控制线程池中任务的数量\",{\"1\":{\"346\":1}}],[\"有界队列有限制存储的任务数量\",{\"1\":{\"346\":1}}],[\"有界队列\",{\"1\":{\"346\":1}}],[\"有以下几个原因\",{\"1\":{\"306\":1}}],[\"有多种重载形式\",{\"1\":{\"255\":1}}],[\"有两个主要的子类\",{\"1\":{\"376\":1}}],[\"有两个常见的应用场景\",{\"1\":{\"249\":1}}],[\"有两个规则\",{\"1\":{\"216\":1}}],[\"有序性都应该怎么保证呢\",{\"0\":{\"214\":1}}],[\"有序性\",{\"0\":{\"382\":1},\"1\":{\"212\":2,\"214\":1}}],[\"有序性的理解\",{\"0\":{\"212\":1}}],[\"有序性和原子性\",{\"1\":{\"211\":1}}],[\"有可能调用\",{\"1\":{\"204\":1}}],[\"有可能在对象被回收时调用\",{\"1\":{\"90\":1}}],[\"有了标记之后\",{\"1\":{\"190\":1}}],[\"有了cms\",{\"0\":{\"107\":1}}],[\"有什么办法能解决hashmap线程不安全的问题呢\",{\"0\":{\"442\":1}}],[\"有什么问题\",{\"0\":{\"399\":1}}],[\"有什么区别\",{\"0\":{\"148\":1,\"162\":1,\"200\":1}}],[\"有什么作用\",{\"0\":{\"90\":1}}],[\"有读或写事件时\",{\"1\":{\"139\":1}}],[\"有些架构还有一个共享的二级缓存\",{\"1\":{\"211\":1}}],[\"有些情况下\",{\"1\":{\"123\":1}}],[\"有些图渲染不出来\",{\"1\":{\"27\":1}}],[\"有没有了解逃逸分析技术\",{\"0\":{\"123\":1}}],[\"有时可能会出现比预期更长的停顿\",{\"1\":{\"100\":1}}],[\"虚引用的唯一目的是在对象被垃圾回收器回收时收到一个系统通知\",{\"1\":{\"89\":1}}],[\"虚引用是最弱的引用\",{\"1\":{\"89\":1}}],[\"虚引用\",{\"1\":{\"89\":1}}],[\"虚拟机即时编译器在运行时\",{\"1\":{\"387\":1}}],[\"虚拟机执行java字节码\",{\"1\":{\"150\":1}}],[\"虚拟机会执行垃圾回收操作\",{\"1\":{\"99\":1}}],[\"虚拟机栈\",{\"1\":{\"88\":1}}],[\"虚拟机栈中的引用\",{\"1\":{\"88\":1}}],[\"虚拟机栈溢出\",{\"1\":{\"85\":2}}],[\"虚拟机\",{\"1\":{\"80\":1,\"148\":1}}],[\"软引用是一种比强引用弱一些的引用\",{\"1\":{\"89\":1}}],[\"软引用\",{\"1\":{\"89\":1}}],[\"垃圾收集线程清理那些没有被标记为可达的对象\",{\"1\":{\"100\":1}}],[\"垃圾收集线程从初始标记阶段标记的对象开始\",{\"1\":{\"100\":1}}],[\"垃圾收集器\",{\"1\":{\"124\":1}}],[\"垃圾收集器应该如何选择\",{\"0\":{\"118\":1}}],[\"垃圾收集器在降低垃圾收集停顿时间方面取得了显著成功\",{\"1\":{\"107\":1}}],[\"垃圾收集器可以在这些位置暂停用户程序的执行\",{\"1\":{\"99\":1}}],[\"垃圾收集器可能会选择执行mixed\",{\"1\":{\"94\":1}}],[\"垃圾收集器会遍历整个堆\",{\"1\":{\"92\":1}}],[\"垃圾收集算法是java虚拟机用来回收不再使用的内存空间的一种技术\",{\"1\":{\"92\":1}}],[\"垃圾收集算法了解吗\",{\"0\":{\"92\":1}}],[\"垃圾对象\",{\"1\":{\"87\":1}}],[\"垃圾回收过程中的\",{\"1\":{\"99\":1}}],[\"垃圾回收时垃圾收集器会遍历整个堆\",{\"1\":{\"92\":1}}],[\"垃圾回收器\",{\"1\":{\"133\":1}}],[\"垃圾回收器调用finalize\",{\"1\":{\"90\":1}}],[\"垃圾回收器在回收对象之前会调用其finalize\",{\"1\":{\"90\":1}}],[\"垃圾回收器会尝试回收软引用指向的对象\",{\"1\":{\"89\":1}}],[\"垃圾回收器不会回收它\",{\"1\":{\"89\":1}}],[\"垃圾回收器从这些对象开始进行可达性分析\",{\"1\":{\"88\":1}}],[\"垃圾回收\",{\"0\":{\"314\":1},\"1\":{\"82\":1,\"132\":1,\"175\":1}}],[\"计算hash\",{\"1\":{\"444\":1}}],[\"计算数组下标\",{\"1\":{\"428\":1}}],[\"计算新数组容量\",{\"1\":{\"412\":1}}],[\"计算密集型\",{\"1\":{\"349\":1}}],[\"计算存活对象和各区域的存活数据\",{\"1\":{\"103\":1}}],[\"计数器就会\",{\"1\":{\"385\":1}}],[\"计数器\",{\"1\":{\"381\":1}}],[\"计数器减一\",{\"1\":{\"87\":1}}],[\"计数\",{\"1\":{\"145\":1}}],[\"计划将jrockit中的优秀功能\",{\"1\":{\"75\":1}}],[\"每当迭代器使用hashnext\",{\"1\":{\"416\":1}}],[\"每当有一个新的引用指向对象时\",{\"1\":{\"87\":1}}],[\"每重入一次\",{\"1\":{\"392\":1}}],[\"每种状态都表示线程池当前的不同运行阶段\",{\"1\":{\"364\":1}}],[\"每种垃圾收集器都有其自己的特点和适用场景\",{\"1\":{\"98\":1}}],[\"每隔5秒执行一次\",{\"1\":{\"336\":1}}],[\"每次切换执行线程时\",{\"1\":{\"311\":1}}],[\"每创建一个threadlocal对象\",{\"1\":{\"228\":1}}],[\"每个节点要么是红色\",{\"1\":{\"423\":1}}],[\"每个键值对根据哈希函数计算得到一个桶的索引\",{\"1\":{\"421\":1}}],[\"每个桶存储一个键值对\",{\"1\":{\"421\":1}}],[\"每个对象都有一个内置锁\",{\"1\":{\"381\":1}}],[\"每个对象都会被分配一块内存空间\",{\"1\":{\"82\":1}}],[\"每个工作线程会不断地从任务队列中获取任务并执行\",{\"1\":{\"376\":1}}],[\"每个请求可能涉及复杂的处理逻辑\",{\"1\":{\"318\":1}}],[\"每个threadlocal实例都对应着一个threadlocalmap对象\",{\"1\":{\"227\":1}}],[\"每个entry代表一个完整的对象\",{\"1\":{\"224\":1}}],[\"每个类都有一个对应的class对象\",{\"1\":{\"157\":1}}],[\"每个服务提供者将自己的实现类配置到一个特定的配置文件中\",{\"1\":{\"153\":1}}],[\"每个实现类占据一行\",{\"1\":{\"153\":1}}],[\"每个区域可以是年轻代\",{\"1\":{\"102\":1}}],[\"每个区域都有其特定的用途和生命周期\",{\"1\":{\"53\":1}}],[\"每个阶段只收集部分对象\",{\"1\":{\"92\":1}}],[\"每个线程的堆栈大小可能是1mb或者更大\",{\"1\":{\"308\":1}}],[\"每个线程在创建时需要分配内存\",{\"1\":{\"308\":1}}],[\"每个线程在往threadlocal里设置值的时候\",{\"1\":{\"224\":1}}],[\"每个线程需要创建新实\",{\"1\":{\"239\":1}}],[\"每个线程有自己的程序计数器和栈\",{\"1\":{\"236\":1}}],[\"每个线程有一个独立的程序计数器\",{\"1\":{\"55\":1}}],[\"每个线程有一个独立的java栈\",{\"1\":{\"53\":1,\"55\":1}}],[\"每个线程分配自己的\",{\"1\":{\"80\":1}}],[\"每个线程都有自己的工作队列\",{\"1\":{\"346\":1}}],[\"每个线程都有一个属于自己的threadlocalmap\",{\"1\":{\"224\":1}}],[\"每个线程都有一个私有的\",{\"1\":{\"211\":1}}],[\"每个线程都有一个java栈\",{\"1\":{\"68\":1}}],[\"每个线程都有独立的程序计数器\",{\"1\":{\"53\":1}}],[\"每个部分有其特定的用途和生命周期\",{\"1\":{\"53\":1}}],[\"综上所述\",{\"1\":{\"86\":1,\"347\":1,\"349\":1,\"374\":1,\"375\":1}}],[\"定位到segment\",{\"1\":{\"444\":1}}],[\"定位到table中的位置\",{\"1\":{\"229\":1}}],[\"定期执行任务\",{\"1\":{\"336\":1}}],[\"定时数据同步等\",{\"1\":{\"351\":1}}],[\"定时备份数据库等\",{\"1\":{\"334\":1}}],[\"定时任务线程池用于执行定时任务和周期性任务\",{\"1\":{\"351\":1}}],[\"定时任务线程池\",{\"0\":{\"356\":1},\"1\":{\"351\":1}}],[\"定时任务\",{\"0\":{\"333\":1}}],[\"定时或周期性执行任务的线程池\",{\"1\":{\"302\":1}}],[\"定要记得使用remove方法来进行清除\",{\"1\":{\"86\":1}}],[\"定义三个异步任务\",{\"1\":{\"279\":1}}],[\"定义服务接口\",{\"1\":{\"153\":1}}],[\"定义了服务的契约\",{\"1\":{\"153\":1}}],[\"定义在object类中\",{\"1\":{\"90\":1}}],[\"定义\",{\"1\":{\"64\":1,\"65\":1,\"240\":1,\"253\":1}}],[\"外部类的实例也无法被垃圾回收\",{\"1\":{\"86\":1}}],[\"静态内部类\",{\"1\":{\"397\":1}}],[\"静态方法里不能访问类的非静态成员变量和方法\",{\"1\":{\"202\":1}}],[\"静态方法\",{\"0\":{\"202\":1},\"1\":{\"202\":1}}],[\"静态集合\",{\"1\":{\"86\":1}}],[\"静态变量可以实现让多个对象共享内存\",{\"1\":{\"202\":1}}],[\"静态变量在内存中有且仅有一个副本\",{\"1\":{\"202\":1}}],[\"静态变量在类被加载至数据区后\",{\"1\":{\"201\":1}}],[\"静态变量和实例变量的区别\",{\"0\":{\"202\":1}}],[\"静态变量存储在方法区\",{\"1\":{\"201\":1}}],[\"静态变量属于类的状态信息\",{\"1\":{\"177\":1}}],[\"静态变量\",{\"1\":{\"53\":1,\"75\":1,\"91\":1,\"201\":1,\"202\":1}}],[\"缓存结果和优化算法等策略\",{\"1\":{\"375\":1}}],[\"缓存结果\",{\"1\":{\"375\":1}}],[\"缓存线程池可以根据需要创建新线程\",{\"1\":{\"351\":1}}],[\"缓存线程池\",{\"0\":{\"291\":1,\"354\":1},\"1\":{\"351\":1}}],[\"缓存通常用于临时存储对象以提高访问速度\",{\"1\":{\"86\":1}}],[\"缓存导致的引用保留\",{\"1\":{\"86\":1}}],[\"网络连接等资源后\",{\"1\":{\"86\":1}}],[\"未清理到任何数据\",{\"1\":{\"230\":1}}],[\"未及时释放资源\",{\"1\":{\"86\":1}}],[\"未来发展规划\",{\"1\":{\"75\":1}}],[\"递归调用自身\",{\"1\":{\"85\":1}}],[\"递归调用层次过深\",{\"1\":{\"84\":1}}],[\"然后把它们的叠加和作为映射的位置\",{\"1\":{\"433\":1}}],[\"然后与哈希值本身异或\",{\"1\":{\"429\":1}}],[\"然后再将哈希值右移16位\",{\"1\":{\"429\":1}}],[\"然后将键值对存储在该桶中\",{\"1\":{\"421\":1}}],[\"然后将第一个子任务和第二个子任务的结果相加\",{\"1\":{\"376\":1}}],[\"然后重新尝试\",{\"1\":{\"408\":1}}],[\"然后直接返回\",{\"1\":{\"396\":1}}],[\"然后设置当前锁的拥有者为当前线程\",{\"1\":{\"396\":1}}],[\"然后当前线程栈帧中增加一个锁记录第一部分\",{\"1\":{\"390\":1}}],[\"然后被阻塞在安全点的线程继续往下执行同步代码块\",{\"1\":{\"389\":1}}],[\"然后执行\",{\"1\":{\"389\":1}}],[\"然后执行这些代码\",{\"1\":{\"132\":1}}],[\"然后继续执行任务队列中的任务\",{\"1\":{\"374\":1}}],[\"然后逐个调用线程的interrupt方法来中断线程\",{\"1\":{\"348\":1}}],[\"然后恢复即将执行线程的状态\",{\"1\":{\"311\":1}}],[\"然后恢复下一个线程的上下文\",{\"1\":{\"244\":1}}],[\"然后又开始执行\",{\"1\":{\"251\":1}}],[\"然后进行相应的操作\",{\"1\":{\"247\":1}}],[\"然后table引用指向\",{\"1\":{\"230\":1}}],[\"然后放到新的newtab\",{\"1\":{\"230\":1}}],[\"然后遍历老的table数组\",{\"1\":{\"230\":1}}],[\"然后还要根据条件判断size\",{\"1\":{\"230\":1}}],[\"然后判断该槽位entry对象中的key是否和get的key一致\",{\"1\":{\"229\":1}}],[\"然后和table数组长度减一\",{\"1\":{\"228\":1}}],[\"然后到了真正要被回收的时候\",{\"1\":{\"204\":1}}],[\"然后用函数把这些步骤一步一步实现\",{\"1\":{\"195\":1}}],[\"然后搞一些事情\",{\"1\":{\"190\":1}}],[\"然后\",{\"1\":{\"183\":1,\"287\":1}}],[\"然后让程序继续执行\",{\"1\":{\"92\":1}}],[\"然后清空from区\",{\"1\":{\"92\":1}}],[\"然后经过一次minor\",{\"1\":{\"91\":1}}],[\"然后尝试不断地向其中添加1mb大小的字节数组对象\",{\"1\":{\"85\":1}}],[\"然而\",{\"1\":{\"67\":1,\"100\":1,\"123\":1}}],[\"甚至还有可能触发扩容\",{\"1\":{\"411\":1}}],[\"甚至系统崩溃\",{\"1\":{\"84\":1}}],[\"甚至耗尽系统的可用内存\",{\"1\":{\"84\":1}}],[\"可实现选择性通知\",{\"1\":{\"391\":1}}],[\"可实现公平锁\",{\"1\":{\"391\":1}}],[\"可重入性怎么实现\",{\"0\":{\"382\":1}}],[\"可控性\",{\"1\":{\"239\":1}}],[\"可见性和有序性\",{\"1\":{\"212\":1}}],[\"可见性保证了共享变量的修改对其他线程是可见的\",{\"1\":{\"212\":1}}],[\"可见性是指当一个线程对共享变量进行修改后\",{\"1\":{\"212\":1}}],[\"可见性是并发编程中非常重要的基础概念\",{\"1\":{\"212\":1}}],[\"可见性\",{\"0\":{\"212\":1,\"214\":1},\"1\":{\"212\":1,\"214\":1}}],[\"可变\",{\"1\":{\"169\":2}}],[\"可变性\",{\"1\":{\"169\":1}}],[\"可预测停顿时间和自动调优等特性\",{\"1\":{\"110\":1}}],[\"可预测的低停顿时间\",{\"1\":{\"114\":1}}],[\"可预测的停顿时间\",{\"1\":{\"109\":1,\"112\":1,\"120\":1}}],[\"可预测的特点\",{\"1\":{\"106\":1}}],[\"可预测性\",{\"1\":{\"104\":1}}],[\"可能导致get操作返回null\",{\"1\":{\"441\":1}}],[\"可能导致get为null\",{\"1\":{\"441\":1}}],[\"可能不会执行的情况\",{\"1\":{\"182\":1}}],[\"可能是\",{\"1\":{\"144\":1}}],[\"可能继续使用cms或转向g1\",{\"1\":{\"116\":1}}],[\"可能抛出异常的位置等\",{\"1\":{\"99\":1}}],[\"可能会带来较高的内存开销和延迟\",{\"1\":{\"418\":1}}],[\"可能会影响到整个线程池的性能和响应速度\",{\"1\":{\"375\":1}}],[\"可能会因为无限创建线程\",{\"1\":{\"354\":1}}],[\"可能会有空的内存空间\",{\"1\":{\"411\":1}}],[\"可能会有较长的停顿时间\",{\"1\":{\"120\":1}}],[\"可能会有新创建或删除的对象\",{\"1\":{\"100\":1}}],[\"可能会触发full\",{\"1\":{\"94\":1}}],[\"可能会导致环形链表的出现\",{\"1\":{\"441\":1}}],[\"可能会导致在阻塞队列中的线程长期处于饥饿状态\",{\"1\":{\"397\":1}}],[\"可能会导致oom\",{\"1\":{\"353\":1,\"355\":1}}],[\"可能会导致线程间上下文切换的开销增加\",{\"1\":{\"349\":1}}],[\"可能会导致不再需要的对象一直被保留在内存中\",{\"1\":{\"86\":1}}],[\"可能会导致系统性能下降\",{\"1\":{\"84\":1}}],[\"可能执行效率降低\",{\"1\":{\"92\":1}}],[\"可达性分析从一组称为\",{\"1\":{\"87\":1}}],[\"可达性分析\",{\"1\":{\"87\":2}}],[\"可以按照插入顺序或访问顺序进行遍历\",{\"1\":{\"447\":1}}],[\"可以获得较高的读取性能\",{\"1\":{\"418\":1}}],[\"可以直接使用它来替代arraylist\",{\"1\":{\"417\":1}}],[\"可以直接通过数组下标获取\",{\"1\":{\"411\":1}}],[\"可以靠按序申请资源来预防\",{\"1\":{\"408\":1}}],[\"可以主动释放它占有的资源\",{\"1\":{\"408\":1}}],[\"可以一次性请求所有的资源\",{\"1\":{\"408\":1}}],[\"可以保证对变量的操作是线程安全的\",{\"1\":{\"406\":1}}],[\"可以考虑使用\",{\"1\":{\"446\":1}}],[\"可以考虑合并多个变量\",{\"1\":{\"404\":1}}],[\"可以考虑以下几种策略\",{\"1\":{\"375\":1}}],[\"可以确保单机线程池在断电情况下的任务一致性和可靠性\",{\"1\":{\"374\":1}}],[\"可以有效优化线程池中调用特别耗时的\",{\"1\":{\"375\":1}}],[\"可以有效地管理和调优线程池的配置\",{\"1\":{\"372\":1}}],[\"可以有效控制对资源的并发访问\",{\"1\":{\"255\":1}}],[\"可以提供可视化界面让用户方便地修改线程池的参数\",{\"1\":{\"371\":1}}],[\"可以实现在不修改代码的情况下动态修改线程池的参数\",{\"1\":{\"371\":1}}],[\"可以实现更灵活的控制\",{\"1\":{\"371\":1}}],[\"可以动态地调整线程池的参数\",{\"1\":{\"371\":1}}],[\"可以动态调整线程数量以适应任务量的变化\",{\"1\":{\"351\":1}}],[\"可以处理队列中的任务\",{\"1\":{\"365\":1}}],[\"可以处理需要返回结果的任务\",{\"1\":{\"347\":1}}],[\"可以接受新任务\",{\"1\":{\"365\":1}}],[\"可以继续活下去\",{\"1\":{\"354\":1}}],[\"可以用来获取任务的执行结果或者监控任务的执行状态\",{\"1\":{\"347\":1}}],[\"可以调度定时任务\",{\"1\":{\"335\":1}}],[\"可以并行处理数据块\",{\"1\":{\"327\":1}}],[\"可以限制并发线程的数量\",{\"1\":{\"300\":1}}],[\"可以不指定线程池\",{\"1\":{\"294\":1}}],[\"可以简化两个线程之间的数据交换逻辑\",{\"1\":{\"259\":1}}],[\"可以指定最大等待时间\",{\"1\":{\"259\":1}}],[\"可以再次使用\",{\"1\":{\"251\":1}}],[\"可以再次进入runnable状态\",{\"1\":{\"243\":1}}],[\"可以重新加载持久化的任务队列\",{\"1\":{\"374\":1}}],[\"可以重新安排语句的执行顺序\",{\"1\":{\"215\":1}}],[\"可以重复使用\",{\"1\":{\"251\":1}}],[\"可以与其他接口组合\",{\"1\":{\"239\":1}}],[\"可以先讲原对象序列化\",{\"1\":{\"208\":1}}],[\"可以快速定位对象\",{\"1\":{\"206\":1}}],[\"可以阻断\",{\"1\":{\"204\":1}}],[\"可以访问类的所有成员变量和方法\",{\"1\":{\"202\":1}}],[\"可以使⽤\",{\"1\":{\"202\":1}}],[\"可以使用collections工具类的synchronizedlist方法将arraylist转换为线程安全的list\",{\"1\":{\"417\":1}}],[\"可以使用图算法如找环算法来检测死锁\",{\"1\":{\"409\":1}}],[\"可以使用jdk自带的命令行工具排查\",{\"1\":{\"409\":1}}],[\"可以使用更高效的算法\",{\"1\":{\"375\":1}}],[\"可以使用信号量或者线程池的控制参数来实现并发数的限制\",{\"1\":{\"375\":1}}],[\"可以使用事务管理的机制来实现这一点\",{\"1\":{\"374\":1}}],[\"可以使用\",{\"1\":{\"362\":1,\"371\":1,\"442\":2}}],[\"可以使用优先级队列来根据任务的优先级高低来执行任务\",{\"1\":{\"346\":1}}],[\"可以使用自定义线程池\",{\"1\":{\"284\":1}}],[\"可以使用stringbuilder类以\",{\"1\":{\"169\":1}}],[\"可以使用stringbuffer类\",{\"1\":{\"169\":1}}],[\"可以使用string类\",{\"1\":{\"169\":1}}],[\"可以使用连接池优化\",{\"1\":{\"139\":1}}],[\"可以修饰类\",{\"1\":{\"198\":1}}],[\"可以修饰变量\",{\"1\":{\"198\":2}}],[\"可以修饰在类\",{\"1\":{\"198\":1}}],[\"可以在多线程下并发使用\",{\"1\":{\"416\":1}}],[\"可以在指定的时间点执行任务\",{\"1\":{\"351\":1}}],[\"可以在后台执行\",{\"1\":{\"330\":1}}],[\"可以在编写代码时指定类\",{\"1\":{\"185\":1}}],[\"可以在类中显式地定义serialversionuid字段\",{\"1\":{\"177\":1}}],[\"可以被public\",{\"1\":{\"201\":1}}],[\"可以被继承吗\",{\"0\":{\"168\":1}}],[\"可以被回收\",{\"1\":{\"87\":2}}],[\"可以将调用结果缓存起来\",{\"1\":{\"375\":1}}],[\"可以将异步任务提交到线程池中执行\",{\"1\":{\"331\":1}}],[\"可以将数据分割成多个块\",{\"1\":{\"326\":1}}],[\"可以将java对象序列化为二进制格式\",{\"1\":{\"178\":1}}],[\"可以将结构化的数据序列化为紧凑的二进制格式\",{\"1\":{\"178\":1}}],[\"可以将\",{\"1\":{\"144\":1}}],[\"可以将对象的引用分为以下几种类型\",{\"1\":{\"89\":1}}],[\"可以传递一段代码\",{\"1\":{\"141\":1}}],[\"可以划分为\",{\"1\":{\"137\":1}}],[\"可以分为\",{\"1\":{\"137\":1}}],[\"可以分为新生代\",{\"1\":{\"53\":1}}],[\"可以选择最适合的垃圾收集器来优化java应用的性能和稳定性\",{\"1\":{\"122\":1}}],[\"可以根据具体的需求选择合适的队列类型来优化线程池的性能和行为\",{\"1\":{\"346\":1}}],[\"可以根据具体的业务需求和系统特性选择合适的拒绝策略\",{\"1\":{\"345\":1}}],[\"可以根据通过设置\",{\"1\":{\"173\":1}}],[\"可以根据运行时的表现自动调整垃圾收集策略\",{\"1\":{\"114\":1}}],[\"可以根据需要动态增长\",{\"1\":{\"76\":1}}],[\"可以整理内存\",{\"1\":{\"109\":1}}],[\"可以控制垃圾收集的频率和停顿时间\",{\"1\":{\"100\":1}}],[\"可以采用不同的垃圾回收算法和策略来对各个区域进行回收\",{\"1\":{\"91\":1}}],[\"可以通过同步机制\",{\"1\":{\"417\":1}}],[\"可以通过自定义\",{\"1\":{\"361\":1}}],[\"可以通过自定义threadfactory来指定线程的名称\",{\"1\":{\"344\":1}}],[\"可以通过向线程池提交任务的方式\",{\"1\":{\"350\":1}}],[\"可以通过监控系统资源的使用情况和线程池的运行状态来动态调整线程数配置\",{\"1\":{\"349\":1}}],[\"可以通过java内置的等待\",{\"1\":{\"247\":1}}],[\"可以通过线程池管理\",{\"1\":{\"239\":1}}],[\"可以通过反射获取注解信息\",{\"1\":{\"190\":1}}],[\"可以通过调用awaittermination\",{\"1\":{\"348\":1}}],[\"可以通过调用string类的intern\",{\"1\":{\"64\":1}}],[\"可以通过调整\",{\"1\":{\"97\":2}}],[\"可以通过垃圾回收器来判断对象是否仍然存活\",{\"1\":{\"87\":1}}],[\"可以清晰地看出字符串常量池和运行时常量池在用途\",{\"1\":{\"66\":1}}],[\"可以看提交记录\",{\"1\":{\"24\":1}}],[\"最后的结果是\",{\"1\":{\"450\":1}}],[\"最后所有元素处理完成后\",{\"1\":{\"427\":1}}],[\"最后赋值到i\",{\"1\":{\"213\":1}}],[\"最大线程数以及任务队列等参数\",{\"1\":{\"371\":1}}],[\"最大线程数也为1\",{\"1\":{\"355\":1}}],[\"最大线程数为integer\",{\"1\":{\"354\":1,\"356\":1}}],[\"最大线程数\",{\"1\":{\"304\":1,\"338\":1,\"344\":1,\"372\":2}}],[\"最大值\",{\"1\":{\"159\":1}}],[\"最小值改不了\",{\"1\":{\"173\":1}}],[\"最小值\",{\"1\":{\"159\":1}}],[\"最终汇总每个小任务结果后得到大任务结果的框架\",{\"1\":{\"376\":1}}],[\"最终结果\",{\"1\":{\"281\":1,\"294\":1}}],[\"最终一定被执行\",{\"1\":{\"204\":1}}],[\"最终返回的还是之前暂存起来的结果\",{\"1\":{\"183\":1}}],[\"最终都调用parseint\",{\"1\":{\"174\":1}}],[\"最终的选择应根据应用的性能需求\",{\"1\":{\"117\":1}}],[\"最终标记\",{\"1\":{\"102\":1,\"103\":1}}],[\"最终抛出stackoverflowerror异常\",{\"1\":{\"85\":1}}],[\"最终抛出outofmemoryerror\",{\"1\":{\"85\":1}}],[\"最终导致程序占用的内存越来越多\",{\"1\":{\"84\":1}}],[\"最初存储在运行时常量池中\",{\"1\":{\"69\":1}}],[\"导致资源浪费\",{\"1\":{\"435\":1}}],[\"导致资源未被释放\",{\"1\":{\"86\":1}}],[\"导致插入和删除操作的效率较低\",{\"1\":{\"425\":1}}],[\"导致插入\",{\"1\":{\"424\":1}}],[\"导致oom\",{\"1\":{\"354\":1}}],[\"导致程序直接退出\",{\"1\":{\"182\":1}}],[\"导致长时间的应用停顿\",{\"1\":{\"108\":1}}],[\"导致老年代的内存使用率达到阈值时\",{\"1\":{\"96\":1}}],[\"导致内存逐渐耗尽\",{\"1\":{\"86\":1}}],[\"导致内存泄漏\",{\"1\":{\"86\":1}}],[\"导致对象仍然被引用\",{\"1\":{\"86\":1}}],[\"导致虚拟机栈溢出\",{\"1\":{\"85\":1}}],[\"导致该内存无法被再次使用\",{\"1\":{\"84\":1}}],[\"导致无法正常执行程序\",{\"1\":{\"84\":1}}],[\"句柄中包含了对象实例数据与类型数据各自具体的地址信息\",{\"1\":{\"83\":1}}],[\"句柄访问方式\",{\"1\":{\"83\":1}}],[\"引⽤数据类型==比较的是内存地址\",{\"1\":{\"205\":1}}],[\"引言\",{\"0\":{\"130\":1,\"261\":1,\"451\":1}}],[\"引用类型变量单独克隆\",{\"1\":{\"208\":1}}],[\"引用类型变量修改\",{\"1\":{\"208\":1}}],[\"引用类型默认为null\",{\"1\":{\"201\":1}}],[\"引用类型则存储指向实际对象数据的指针\",{\"1\":{\"82\":1}}],[\"引用本类的构造函数\",{\"1\":{\"199\":1}}],[\"引用数据类型\",{\"1\":{\"159\":1,\"168\":1}}],[\"引用\",{\"1\":{\"88\":1}}],[\"引用计数器就加一\",{\"1\":{\"87\":1}}],[\"引用计数\",{\"1\":{\"87\":2}}],[\"引入了tlab\",{\"1\":{\"78\":1}}],[\"基础\",{\"0\":{\"234\":1}}],[\"基础语法\",{\"0\":{\"158\":1}}],[\"基本概念\",{\"0\":{\"262\":1}}],[\"基本类型\",{\"1\":{\"159\":1}}],[\"基本数据类型==比较的是值\",{\"1\":{\"205\":1}}],[\"基本数据类型相同\",{\"1\":{\"197\":1}}],[\"基本数据类型吗\",{\"0\":{\"168\":1}}],[\"基本数据类型\",{\"1\":{\"159\":1}}],[\"基本数据类型直接存储其值\",{\"1\":{\"82\":1}}],[\"基于拷贝内容的优点是避免了concurrent\",{\"1\":{\"416\":1}}],[\"基于cas来操作int类型变量\",{\"1\":{\"407\":1}}],[\"基于jvm实现\",{\"1\":{\"391\":1}}],[\"基于java虚拟机\",{\"1\":{\"157\":1}}],[\"基于红黑树实现的有序map\",{\"1\":{\"192\":1}}],[\"基于哈希表实现的线程安全的map\",{\"1\":{\"192\":1}}],[\"基于哈希表实现的map\",{\"1\":{\"192\":2}}],[\"基于哈希表和双向链表实现的map\",{\"1\":{\"192\":1}}],[\"基于vuepress\",{\"1\":{\"8\":1}}],[\"通知机制\",{\"1\":{\"247\":2,\"391\":1}}],[\"通知或中断\",{\"1\":{\"241\":1}}],[\"通常任务会使用双端队列\",{\"1\":{\"376\":1}}],[\"通常为秒\",{\"1\":{\"344\":1}}],[\"通常是因为调用了wait\",{\"1\":{\"242\":1}}],[\"通常是因为等待获取锁\",{\"1\":{\"242\":1}}],[\"通常位于meta\",{\"1\":{\"153\":1}}],[\"通常用于动态分配对象\",{\"1\":{\"124\":1}}],[\"通常会与年轻代的垃圾收集\",{\"1\":{\"103\":1}}],[\"通常需要根据具体的场景进行选择和调优\",{\"1\":{\"98\":1}}],[\"通常在1\",{\"1\":{\"112\":1,\"115\":1,\"120\":1}}],[\"通常在以下情况下会触发\",{\"1\":{\"96\":1}}],[\"通常在32位jvm中占用4个字节\",{\"1\":{\"82\":1}}],[\"通常情况下\",{\"1\":{\"95\":1,\"349\":1}}],[\"通常存放在老年代的对象经过多次垃圾回收后仍然存活\",{\"1\":{\"91\":1}}],[\"通过atomicreference来保证原子性\",{\"1\":{\"404\":1}}],[\"通过native方法实现以原子方式将引用值和印戳标志的值更新为给定的更新值\",{\"1\":{\"401\":1}}],[\"通过lock\",{\"1\":{\"391\":1}}],[\"通过cas操作竞争锁\",{\"1\":{\"389\":1}}],[\"通过异步调用\",{\"1\":{\"375\":1}}],[\"通过持久化任务队列\",{\"1\":{\"374\":1}}],[\"通过以上评估方案\",{\"1\":{\"372\":1}}],[\"通过测试可以验证线程池的配置是否合理\",{\"1\":{\"372\":1}}],[\"通过对系统负载\",{\"1\":{\"372\":1}}],[\"通过对象之间的引用关系进行遍历\",{\"1\":{\"87\":1}}],[\"通过覆盖\",{\"1\":{\"359\":1}}],[\"通过调用\",{\"1\":{\"371\":1}}],[\"通过调用schedule\",{\"1\":{\"351\":1}}],[\"通过调用shutdown\",{\"1\":{\"348\":1}}],[\"通过调整这个参数\",{\"1\":{\"100\":1}}],[\"通过使用锁分段技术和cas操作来实现高效的并发性能\",{\"1\":{\"442\":1}}],[\"通过使用scheduledthreadpoolexecutor\",{\"1\":{\"335\":1}}],[\"通过使用数据库连接池\",{\"1\":{\"323\":1}}],[\"通过使用线程池\",{\"1\":{\"319\":1,\"327\":1,\"331\":1}}],[\"通过使用泛型\",{\"1\":{\"185\":1}}],[\"通过自定义线程池\",{\"1\":{\"305\":1}}],[\"通过设置自定义线程池\",{\"1\":{\"294\":1}}],[\"通过设置线程的中断标志并不能直接终止该线程的执行\",{\"1\":{\"240\":1}}],[\"通过在代理类中封装线程池\",{\"1\":{\"371\":1}}],[\"通过在构造函数中传入\",{\"1\":{\"255\":1}}],[\"通过在classpath中提供配置文件\",{\"1\":{\"153\":1}}],[\"通过\",{\"1\":{\"229\":1,\"258\":1}}],[\"通过禁止特定类型的编译器重排序和处理器重排序\",{\"1\":{\"215\":1}}],[\"通过序列化机制\",{\"1\":{\"209\":1}}],[\"通过继承可以很方便地进行代码复用\",{\"1\":{\"196\":1}}],[\"通过实现serializable接口和externalizable接口来实现对象的序列化和反序列化\",{\"1\":{\"178\":1}}],[\"通过反射机制\",{\"1\":{\"209\":1}}],[\"通过反射\",{\"1\":{\"157\":1}}],[\"通过反射你可以获取任意一个类的所有属性和方法\",{\"1\":{\"155\":1}}],[\"通过入参的\",{\"1\":{\"145\":1}}],[\"通过optional类\",{\"1\":{\"141\":1}}],[\"通过stream\",{\"1\":{\"141\":1}}],[\"通过选择器\",{\"1\":{\"139\":1}}],[\"通过类加载器将\",{\"1\":{\"134\":1}}],[\"通过垃圾回收机制回收不再使用的对象\",{\"1\":{\"132\":1}}],[\"通过逃逸分析\",{\"1\":{\"126\":1}}],[\"通过评估应用的停顿时间需求\",{\"1\":{\"122\":1}}],[\"通过压缩阶段\",{\"1\":{\"109\":1}}],[\"通过分区和并发标记\",{\"1\":{\"104\":1}}],[\"通过并发的方式来实现在非常短的停顿时间内完成垃圾收集\",{\"1\":{\"98\":1}}],[\"通过并发标记\",{\"1\":{\"98\":1}}],[\"通过多线程并行收集实现高吞吐量\",{\"1\":{\"98\":1}}],[\"通过将不同类型的对象放置在不同的区域中\",{\"1\":{\"91\":1}}],[\"通过虚引用可以跟踪对象被垃圾回收的状态\",{\"1\":{\"89\":1}}],[\"通过栈上的reference数据来操作堆上的具体对象\",{\"1\":{\"83\":1}}],[\"通过这个链表\",{\"1\":{\"447\":1}}],[\"通过这个引用\",{\"1\":{\"78\":1}}],[\"通过这些方法\",{\"1\":{\"363\":1}}],[\"通过这些对象可以遍历到所有活动对象\",{\"1\":{\"88\":1}}],[\"通过这些解决方案\",{\"1\":{\"81\":1}}],[\"通过移动指针来分配内存\",{\"1\":{\"79\":1}}],[\"通过动态调整减少配置的复杂性\",{\"1\":{\"77\":1}}],[\"通过上述对比\",{\"1\":{\"66\":1}}],[\"首先计算hash\",{\"1\":{\"445\":1}}],[\"首先进行哈希值的扰动\",{\"1\":{\"427\":1}}],[\"首先就会调用\",{\"1\":{\"397\":1}}],[\"首先判断当前要计算的斐波那契数列的位置\",{\"1\":{\"376\":1}}],[\"首先需要理解两个点\",{\"1\":{\"376\":1}}],[\"首先要考虑的是你的任务的性质\",{\"1\":{\"349\":1}}],[\"首先\",{\"1\":{\"153\":1,\"286\":1}}],[\"首先尝试在自己的\",{\"1\":{\"81\":1}}],[\"首先会在自己的\",{\"1\":{\"80\":1}}],[\"本地内存是jmm的\",{\"1\":{\"211\":1}}],[\"本地内存中存储了该线程以读\",{\"1\":{\"211\":1}}],[\"本地内存\",{\"1\":{\"211\":1}}],[\"本地方法接口\",{\"1\":{\"133\":1}}],[\"本地方法栈中的jni\",{\"1\":{\"88\":1}}],[\"本地方法栈仍然保留\",{\"1\":{\"57\":1}}],[\"本地方法栈\",{\"1\":{\"53\":1,\"55\":1}}],[\"本地线程分配缓冲\",{\"1\":{\"81\":1}}],[\"常用于web应用中\",{\"1\":{\"178\":2}}],[\"常用类\",{\"0\":{\"167\":1}}],[\"常见参数包括\",{\"1\":{\"304\":1}}],[\"常见垃圾收集器选项\",{\"0\":{\"120\":1}}],[\"常见的同步移交队列包括synchronousqueue\",{\"1\":{\"346\":1}}],[\"常见的有界队列包括arrayblockingqueue\",{\"1\":{\"346\":1}}],[\"常见的无界队列包括linkedblockingqueue\",{\"1\":{\"346\":1}}],[\"常见的线程池包括以下几种\",{\"1\":{\"351\":1}}],[\"常见的线程池工作队列包括\",{\"1\":{\"346\":1}}],[\"常见的线程池类型\",{\"0\":{\"302\":1}}],[\"常见的任务队列包括有界队列\",{\"1\":{\"344\":1}}],[\"常见的拒绝策略包括抛出异常\",{\"1\":{\"340\":1,\"344\":1}}],[\"常见的阻塞队列有\",{\"1\":{\"296\":1}}],[\"常见的垃圾收集器\",{\"0\":{\"112\":1}}],[\"常见的垃圾收集器有cms\",{\"1\":{\"111\":1}}],[\"常见的内存溢出场景包括\",{\"1\":{\"84\":1}}],[\"常见的解决方案包括\",{\"1\":{\"81\":1}}],[\"常常使用g1或zgc来处理大规模服务和数据处理系统\",{\"1\":{\"116\":1}}],[\"常量池等\",{\"1\":{\"91\":1}}],[\"常量表\",{\"1\":{\"65\":1}}],[\"常量\",{\"1\":{\"53\":1}}],[\"操作来实现的\",{\"1\":{\"406\":1}}],[\"操作成功\",{\"1\":{\"398\":1}}],[\"操作成功返回\",{\"1\":{\"216\":1}}],[\"操作失败\",{\"1\":{\"398\":1}}],[\"操作包含三个操作数\",{\"1\":{\"398\":1}}],[\"操作系统通过线程调度器在多个线程之间切换执行\",{\"1\":{\"311\":1}}],[\"操作系统为每个线程分配了一些内核对象和数据结构\",{\"1\":{\"309\":1}}],[\"操作系统资源\",{\"0\":{\"309\":1}}],[\"操作系统会将\",{\"1\":{\"245\":2}}],[\"操作系统会强制进行线程上下文切换\",{\"1\":{\"245\":1}}],[\"操作系统会保存当前线程的上下文\",{\"1\":{\"244\":1}}],[\"操作happens\",{\"1\":{\"216\":1}}],[\"操作的数据量较小\",{\"1\":{\"169\":1}}],[\"操作可以比较并交换共享变量的值\",{\"1\":{\"81\":1}}],[\"操作创建对象时\",{\"1\":{\"81\":1}}],[\"操作数栈\",{\"1\":{\"53\":1,\"55\":1}}],[\"里面包含一个segment数组\",{\"1\":{\"444\":1}}],[\"里面的\",{\"1\":{\"183\":1}}],[\"里定义的方法\",{\"1\":{\"204\":1}}],[\"里不按套路出牌\",{\"1\":{\"183\":1}}],[\"里的\",{\"1\":{\"183\":1}}],[\"里\",{\"0\":{\"81\":1}}],[\"技术的使用可以减少多线程情况下的内存分配竞争\",{\"1\":{\"80\":1}}],[\"只不过实现不同锁语义\",{\"1\":{\"397\":1}}],[\"只是在mark\",{\"1\":{\"387\":1}}],[\"只是用于线程之间的任务传递\",{\"1\":{\"346\":1}}],[\"只能保证一个变量的原子操作\",{\"0\":{\"404\":1},\"1\":{\"399\":1}}],[\"只能有一个线程可以获取该锁\",{\"1\":{\"393\":1}}],[\"只能有一个线程处于方法或者同步块中\",{\"1\":{\"247\":1}}],[\"只能完成自己的任务\",{\"1\":{\"252\":1}}],[\"只能继承thread类\",{\"1\":{\"239\":1}}],[\"只能定义\",{\"1\":{\"200\":1}}],[\"只能修饰变量\",{\"1\":{\"177\":1}}],[\"只能是\",{\"1\":{\"163\":1}}],[\"只需要有对应平台的jvm即可\",{\"1\":{\"135\":1}}],[\"只需修改句柄中的实例数据指针\",{\"1\":{\"83\":1}}],[\"只有在key在table数组中不存在的时候\",{\"1\":{\"450\":1}}],[\"只有在自己使用完毕后才由自己释放该资源\",{\"1\":{\"408\":1}}],[\"只有遇到其他线程竞争时才会执行撤销\",{\"1\":{\"389\":1}}],[\"只有⼀份\",{\"1\":{\"378\":1}}],[\"只有一个执行\",{\"1\":{\"235\":1}}],[\"只有函数式接口\",{\"1\":{\"142\":1}}],[\"只有新生代被回收\",{\"1\":{\"94\":1}}],[\"只有当程序结束时才会被销毁\",{\"1\":{\"201\":1}}],[\"只有当\",{\"1\":{\"80\":1,\"81\":1}}],[\"只要垃圾回收机制一运行\",{\"1\":{\"225\":1}}],[\"只要存在一条从gc\",{\"1\":{\"87\":1}}],[\"只要总内存没有达到系统限制\",{\"1\":{\"74\":1}}],[\"无锁化读取\",{\"1\":{\"445\":1}}],[\"无锁\",{\"1\":{\"388\":1,\"418\":1}}],[\"无界队列可以存储无限数量的任务\",{\"1\":{\"346\":1}}],[\"无界队列\",{\"1\":{\"346\":1}}],[\"无序\",{\"1\":{\"192\":1}}],[\"无需复杂调优\",{\"1\":{\"112\":1,\"115\":1,\"120\":1}}],[\"无需进行同步操作\",{\"1\":{\"80\":1}}],[\"无论内存是否充足\",{\"1\":{\"89\":1}}],[\"无限循环创建对象等\",{\"1\":{\"84\":1}}],[\"无法继续执行\",{\"1\":{\"242\":1}}],[\"无法被垃圾回收器回收\",{\"1\":{\"86\":1}}],[\"无法获得足够的内存空间\",{\"1\":{\"84\":1}}],[\"无法动态调整\",{\"1\":{\"74\":1}}],[\"区时\",{\"1\":{\"381\":1}}],[\"区别在于前者实现的是编译时的多态性\",{\"1\":{\"197\":1}}],[\"区别\",{\"0\":{\"170\":1,\"198\":1}}],[\"区别总结\",{\"0\":{\"66\":1}}],[\"区域不够大或者无法分配时\",{\"1\":{\"80\":1}}],[\"区域中进行分配\",{\"1\":{\"80\":1}}],[\"区域内分配对象时\",{\"1\":{\"80\":1}}],[\"区域\",{\"1\":{\"80\":2}}],[\"能简单说一下线程池的工作流程吗\",{\"0\":{\"337\":1}}],[\"能说说工作中线程池的应用吗\",{\"0\":{\"316\":1}}],[\"能说一下concurrenthashmap的具体实现吗\",{\"0\":{\"443\":1}}],[\"能说一下hashmap的数据结构吗\",{\"0\":{\"421\":1}}],[\"能说一下线程池有几种状态吗\",{\"0\":{\"364\":1}}],[\"能说一下四种常见线程池的原理吗\",{\"0\":{\"352\":1}}],[\"能说一下对象的内存布局吗\",{\"0\":{\"82\":1}}],[\"能说一下jvm的内存区域吗\",{\"0\":{\"53\":1}}],[\"能够正确地工作并保持一致性\",{\"1\":{\"206\":1}}],[\"能够在执行代码前对其进行验证\",{\"1\":{\"132\":1}}],[\"能够高效地处理大堆内存中的垃圾\",{\"1\":{\"114\":1}}],[\"能够高效管理和回收大堆内存中的垃圾\",{\"1\":{\"109\":1}}],[\"能够根据应用的运行状况自动调整垃圾收集的行为和策略\",{\"1\":{\"109\":1}}],[\"能够自动调整行为以满足用户设定的停顿时间目标\",{\"1\":{\"106\":1}}],[\"能够有效地处理多线程环境下的堆内存分配问题\",{\"1\":{\"81\":1}}],[\"能高效管理和利用资源\",{\"1\":{\"104\":1}}],[\"能详细说一下cms收集器的垃圾收集过程吗\",{\"0\":{\"100\":1}}],[\"能手写内存溢出的例子吗\",{\"0\":{\"85\":1}}],[\"能更好地处理内存碎片化的情况\",{\"1\":{\"79\":1}}],[\"划分给对象实例\",{\"1\":{\"79\":1}}],[\"已经明示了它的原理\",{\"1\":{\"418\":1}}],[\"已经有了\",{\"1\":{\"229\":1}}],[\"已经被修改为\",{\"1\":{\"183\":1}}],[\"已被使用的内存和空闲的内存相互交错\",{\"1\":{\"79\":1}}],[\"已移出永久代\",{\"1\":{\"75\":1}}],[\"总不能为了某个玩家等到天荒地老\",{\"1\":{\"249\":1}}],[\"总之\",{\"1\":{\"90\":1,\"348\":1}}],[\"总体而言\",{\"1\":{\"82\":1}}],[\"总的来说\",{\"1\":{\"78\":1,\"296\":1}}],[\"总结来说\",{\"1\":{\"100\":1,\"135\":1}}],[\"总结\",{\"0\":{\"62\":1,\"71\":1,\"77\":1,\"106\":1,\"110\":1,\"117\":1,\"122\":1,\"129\":1,\"282\":1}}],[\"会根据返回值是否为空来判断是否插入元素成功\",{\"1\":{\"450\":1}}],[\"会根据配置参数创建一定数量的核心线程\",{\"1\":{\"338\":1}}],[\"会发生链表和红黑树的不断转换\",{\"1\":{\"435\":1}}],[\"会带来一定的内存开销\",{\"1\":{\"418\":1}}],[\"会有一个自旋次数的限制\",{\"1\":{\"403\":1}}],[\"会给cpu带来非常大的执行开销\",{\"1\":{\"402\":1}}],[\"会使用cas操作将state修改为0\",{\"1\":{\"392\":1}}],[\"会使用locksupport\",{\"1\":{\"392\":1}}],[\"会作⽤于类的所有对象实例\",{\"1\":{\"378\":1}}],[\"会进入\",{\"1\":{\"368\":1,\"369\":1}}],[\"会执行任务的run\",{\"1\":{\"350\":1}}],[\"会执行以下步骤\",{\"1\":{\"78\":1}}],[\"会不断地从任务队列中取出任务来执行\",{\"1\":{\"350\":1}}],[\"会将内存位置\",{\"1\":{\"398\":1}}],[\"会将其结果合并到大任务的结果中\",{\"1\":{\"376\":1}}],[\"会将异常包装在executionexception中重新抛出\",{\"1\":{\"347\":1}}],[\"会将该通道标记为就绪状态\",{\"1\":{\"139\":1}}],[\"会丢弃任务队列中最旧的任务\",{\"1\":{\"345\":1}}],[\"会默默地丢弃被拒绝的任务\",{\"1\":{\"345\":1}}],[\"会在调用线程中直接执行被拒绝的任务\",{\"1\":{\"345\":1}}],[\"会在指令序列中插入内存屏障来禁止特定类型的处理器重排序\",{\"1\":{\"220\":1}}],[\"会对热点代码进行优化\",{\"1\":{\"315\":1}}],[\"会对整个java堆进行回收\",{\"1\":{\"94\":1}}],[\"会抛出rejectedexecutionexception异常\",{\"1\":{\"345\":1}}],[\"会抛出\",{\"1\":{\"251\":1,\"255\":1,\"259\":1}}],[\"会继续往下执行\",{\"1\":{\"240\":1}}],[\"会唤醒一个在这个共享变量上调用\",{\"1\":{\"240\":1}}],[\"会先创建一条线程\",{\"1\":{\"238\":1}}],[\"会先去清理过期的entry\",{\"1\":{\"230\":1}}],[\"会先将\",{\"1\":{\"183\":1}}],[\"会从主内存重新获取最新值\",{\"1\":{\"219\":1}}],[\"会从列表中找到一块足够大的空间\",{\"1\":{\"79\":1}}],[\"会影响原对象\",{\"1\":{\"208\":1}}],[\"会影响性能等\",{\"1\":{\"90\":1}}],[\"会写入\",{\"1\":{\"190\":2}}],[\"会返回之前暂存的结果\",{\"1\":{\"183\":1}}],[\"会返回一个指向新创建对象的引用\",{\"1\":{\"78\":1}}],[\"会比较序列化类的版本号和当前类的版本号是否一致\",{\"1\":{\"177\":1}}],[\"会产生大量的临时对象\",{\"1\":{\"169\":1}}],[\"会处理这个事件\",{\"1\":{\"139\":1}}],[\"会负责回收堆内存中的对象\",{\"1\":{\"124\":1}}],[\"会退化为单线程的标记\",{\"1\":{\"108\":1}}],[\"会直接进入老年代\",{\"1\":{\"97\":1}}],[\"会逐渐晋升到老年代\",{\"1\":{\"97\":1}}],[\"会触发条件变量的通知操作\",{\"1\":{\"296\":1}}],[\"会触发full\",{\"1\":{\"96\":1}}],[\"会触发minor\",{\"1\":{\"95\":1}}],[\"会导致较长时间的应用程序暂停\",{\"1\":{\"94\":1}}],[\"会被加入\",{\"1\":{\"381\":1}}],[\"会被加入到\",{\"1\":{\"381\":1}}],[\"会被移动到老年代\",{\"1\":{\"93\":1}}],[\"会被垃圾回收器回收\",{\"1\":{\"89\":1}}],[\"会尝试为该线程重新分配更大的\",{\"1\":{\"80\":1}}],[\"会为其分配一个\",{\"1\":{\"80\":1}}],[\"构造函数默认创建的是非公平锁\",{\"1\":{\"393\":1,\"397\":1}}],[\"构造函数中传入的参数表示可以同时访问的资源数量\",{\"1\":{\"254\":1}}],[\"构造函数执行等步骤\",{\"1\":{\"78\":1}}],[\"构造函数会对对象的实例变量进行初始化\",{\"1\":{\"78\":1}}],[\"构造函数可以是类的直接构造函数\",{\"1\":{\"78\":1}}],[\"也达到了取余的效果\",{\"1\":{\"431\":1}}],[\"也可能有问题\",{\"1\":{\"400\":1}}],[\"也可以按照固定的时间间隔执行任务\",{\"1\":{\"351\":1}}],[\"也可以提交需要返回结果的任务\",{\"1\":{\"347\":1}}],[\"也可以叫同步点\",{\"1\":{\"250\":1}}],[\"也可以使⽤\",{\"1\":{\"202\":1}}],[\"也可以继承父类的属性和方法\",{\"1\":{\"196\":1}}],[\"也可以将hessian格式\",{\"1\":{\"178\":1}}],[\"也可以将protobuf格式的数据反序列化为java对象\",{\"1\":{\"178\":1}}],[\"也可以将xml格式的数据反序列化为java对象\",{\"1\":{\"178\":1}}],[\"也可以将json格式的数据反序列化为java对象\",{\"1\":{\"178\":1}}],[\"也可以将对象序列化为json\",{\"1\":{\"178\":1}}],[\"也可以放在变量之后\",{\"1\":{\"166\":1}}],[\"也可以是\",{\"1\":{\"163\":1}}],[\"也可以是一段可以传递的代码\",{\"1\":{\"142\":1}}],[\"也可以是从父类继承而来的构造函数\",{\"1\":{\"78\":1}}],[\"也不处理队列中的任务\",{\"1\":{\"367\":1}}],[\"也不会被回收\",{\"1\":{\"344\":1}}],[\"也不会回收强引用的对象\",{\"1\":{\"89\":1}}],[\"也有oom的风险\",{\"1\":{\"356\":1}}],[\"也有可能非空的时候\",{\"1\":{\"144\":1}}],[\"也有可能非\",{\"1\":{\"144\":1}}],[\"也有可能不会被调用\",{\"1\":{\"90\":1}}],[\"也叫\",{\"1\":{\"228\":1}}],[\"也被称为类方法\",{\"1\":{\"202\":1}}],[\"也就是支持16个线程的并发写\",{\"1\":{\"444\":1}}],[\"也就是给当前类加锁\",{\"1\":{\"378\":1}}],[\"也就是说\",{\"1\":{\"385\":1}}],[\"也就是说一个线程可以根据一个threadlocal对象查询到绑定在这个线程上的一个值\",{\"1\":{\"247\":1}}],[\"也就是说守护线程是否结束并不影响\",{\"1\":{\"246\":1}}],[\"也就是\",{\"1\":{\"230\":1}}],[\"也就是线程本地变量\",{\"1\":{\"222\":1}}],[\"也就是基本数据类型变量的值\",{\"1\":{\"208\":1}}],[\"也就是运行的时候就没这个信息了\",{\"1\":{\"190\":1}}],[\"也就是内容一样\",{\"1\":{\"172\":1}}],[\"也能在性能方面接近手动内存管理的编程语言\",{\"1\":{\"129\":1}}],[\"也会根据threadlocal对象的hash值\",{\"1\":{\"229\":1}}],[\"也会生成oopmap\",{\"1\":{\"99\":1}}],[\"也会触发full\",{\"1\":{\"96\":1}}],[\"也是取余的效果\",{\"1\":{\"431\":1}}],[\"也是使用标记\",{\"1\":{\"98\":1}}],[\"也是线程私有的\",{\"1\":{\"53\":1}}],[\"也使用标记\",{\"1\":{\"98\":1}}],[\"也称为类变量\",{\"1\":{\"202\":1}}],[\"也称为throughput\",{\"1\":{\"120\":1}}],[\"也称为old\",{\"1\":{\"94\":1}}],[\"也称为young\",{\"1\":{\"94\":1,\"95\":1}}],[\"执行扩容\",{\"1\":{\"445\":1}}],[\"执行同步代码\",{\"1\":{\"389\":1}}],[\"执行完一个\",{\"1\":{\"355\":1}}],[\"执行完任务的线程\",{\"1\":{\"354\":1}}],[\"执行完任务后\",{\"1\":{\"350\":1}}],[\"执行完毕后\",{\"1\":{\"183\":1}}],[\"执行定时任务\",{\"1\":{\"336\":1}}],[\"执行异步任务\",{\"1\":{\"294\":1}}],[\"执行结果\",{\"1\":{\"183\":3}}],[\"执行顺序\",{\"1\":{\"183\":1}}],[\"执行java字节码\",{\"1\":{\"135\":1}}],[\"执行\",{\"1\":{\"134\":1,\"150\":1,\"204\":1,\"303\":1,\"305\":1}}],[\"执行引擎\",{\"1\":{\"133\":1}}],[\"执行代码\",{\"1\":{\"132\":1}}],[\"执行对象的构造函数\",{\"1\":{\"78\":1}}],[\"执行构造函数\",{\"1\":{\"78\":1}}],[\"来映射到对应的数组位置\",{\"1\":{\"433\":1}}],[\"来计算存储位置\",{\"1\":{\"421\":1}}],[\"来存储数据\",{\"1\":{\"421\":1}}],[\"来存储字符串\",{\"1\":{\"169\":1}}],[\"来进行序列化和反序列化\",{\"1\":{\"415\":1}}],[\"来表示同步状态\",{\"1\":{\"392\":1}}],[\"来实现原子性\",{\"1\":{\"405\":1}}],[\"来实现这个机制\",{\"1\":{\"391\":1}}],[\"来实现方法区\",{\"1\":{\"72\":1,\"75\":1}}],[\"来捕获和处理异常\",{\"1\":{\"363\":1}}],[\"来处理异常情况\",{\"1\":{\"361\":1}}],[\"来处理数据\",{\"1\":{\"139\":1}}],[\"来决定是否需要扩容\",{\"1\":{\"230\":1}}],[\"来约束\",{\"1\":{\"216\":1}}],[\"来将多条指令重叠执行\",{\"1\":{\"215\":1}}],[\"来保证程序执行的顺序与代码的顺序一致\",{\"1\":{\"214\":1}}],[\"来保证对共享变量的修改对其他线程是可见的\",{\"1\":{\"214\":1}}],[\"来控制对arraylist的读写操作\",{\"1\":{\"417\":1}}],[\"来控制对共享变量的访问和操作\",{\"1\":{\"214\":1}}],[\"来控制线程的访问和操作\",{\"1\":{\"212\":1}}],[\"来确保多线程程序的可见性\",{\"1\":{\"211\":1}}],[\"来包装它\",{\"1\":{\"144\":1}}],[\"来提高内存分配的效率\",{\"1\":{\"78\":1}}],[\"分段锁\",{\"0\":{\"444\":1},\"1\":{\"443\":1}}],[\"分割成位数相同的几段\",{\"1\":{\"433\":1}}],[\"分而治之\",{\"1\":{\"376\":1}}],[\"分而治之和工作窃取算法\",{\"1\":{\"376\":1}}],[\"分析线程池的问题或者可优化点\",{\"1\":{\"372\":1}}],[\"分析下面几行代码的原子性\",{\"0\":{\"213\":1}}],[\"分钟等\",{\"1\":{\"344\":1}}],[\"分布非常均匀\",{\"1\":{\"228\":1}}],[\"分区管理\",{\"1\":{\"120\":1}}],[\"分区区域\",{\"1\":{\"102\":1}}],[\"分代式垃圾收集\",{\"1\":{\"109\":1}}],[\"分代算法基于\",{\"1\":{\"92\":1}}],[\"分代算法\",{\"1\":{\"92\":1}}],[\"分别计算第\",{\"1\":{\"376\":1}}],[\"分别为\",{\"1\":{\"246\":1}}],[\"分别代表\",{\"1\":{\"187\":1}}],[\"分别称为from区和to区\",{\"1\":{\"93\":1}}],[\"分别采用不同的垃圾回收算法和策略\",{\"1\":{\"92\":1}}],[\"分为两个阶段\",{\"1\":{\"92\":1}}],[\"分为新生代和老年代\",{\"1\":{\"55\":1}}],[\"分配原则\",{\"1\":{\"80\":1}}],[\"分配内存空间\",{\"1\":{\"215\":1}}],[\"分配内存\",{\"1\":{\"78\":1}}],[\"准备执行下一个任务\",{\"1\":{\"341\":1}}],[\"准备处理数据并与生产者交换\",{\"1\":{\"258\":1}}],[\"准备和解析步骤\",{\"1\":{\"134\":1}}],[\"准备\",{\"1\":{\"78\":1}}],[\"准备运行环境\",{\"0\":{\"9\":1}}],[\"验证\",{\"1\":{\"78\":1,\"145\":2}}],[\"对hashmap进行加锁\",{\"1\":{\"442\":1}}],[\"对该对象的操作会自动进行同步\",{\"1\":{\"442\":1}}],[\"对该list的所有操作都会进行同步处理\",{\"1\":{\"417\":1}}],[\"对i++操作加锁\",{\"1\":{\"405\":1}}],[\"对i++操作加锁lock\",{\"1\":{\"405\":1}}],[\"对一些代码上要求同步\",{\"1\":{\"387\":1}}],[\"对一个volatile域的写\",{\"1\":{\"216\":1}}],[\"对一个锁的解锁\",{\"1\":{\"216\":1}}],[\"对一个包含一个或多个元素的集合做各种操作\",{\"1\":{\"145\":1}}],[\"对给定对象\",{\"1\":{\"378\":1}}],[\"对耗时的操作进行算法上的优化\",{\"1\":{\"375\":1}}],[\"对耗时的\",{\"1\":{\"375\":2}}],[\"对结果进行处理并返回新的结果\",{\"1\":{\"265\":1}}],[\"对应的jvm指令分为三步\",{\"1\":{\"215\":1}}],[\"对应的操作系统执行二进制机器码\",{\"1\":{\"150\":1}}],[\"对形参引用的修改不会影响实参引用的指向\",{\"1\":{\"207\":1}}],[\"对形参的修改不会影响实参\",{\"1\":{\"207\":1}}],[\"对同一包内的类和所有子类可见\",{\"1\":{\"198\":1}}],[\"对所有类可见\",{\"1\":{\"198\":1}}],[\"对类的静态变量和静态代码块进行初始化\",{\"1\":{\"134\":1}}],[\"对停顿时间敏感的应用\",{\"1\":{\"120\":1}}],[\"对停顿时间要求极高\",{\"1\":{\"116\":1}}],[\"对于\",{\"1\":{\"408\":3}}],[\"对于频繁调用且结果稳定的耗时\",{\"1\":{\"375\":1}}],[\"对于频繁的字符串拼接操作\",{\"1\":{\"169\":1}}],[\"对于需要处理异步任务的情况\",{\"1\":{\"362\":1}}],[\"对于一个对象\",{\"1\":{\"87\":1}}],[\"对于hotspot\",{\"1\":{\"53\":1}}],[\"对齐填充\",{\"1\":{\"82\":2}}],[\"对象列表\",{\"1\":{\"381\":1}}],[\"对象相等性原则\",{\"1\":{\"206\":1}}],[\"对象名\",{\"1\":{\"202\":2}}],[\"对象转字符串\",{\"1\":{\"175\":1}}],[\"对象拷贝\",{\"1\":{\"175\":1}}],[\"对象比较\",{\"1\":{\"175\":1}}],[\"对象创建过程\",{\"1\":{\"170\":1}}],[\"对象创建的过程包括类加载\",{\"1\":{\"78\":1}}],[\"对象创建的过程了解吗\",{\"0\":{\"78\":1}}],[\"对象\",{\"1\":{\"155\":1,\"168\":1,\"170\":1,\"263\":1,\"376\":1,\"381\":1}}],[\"对象分配的基本概念\",{\"0\":{\"124\":1}}],[\"对象可以被分配在栈上或者通过逃逸分析技术进行优化\",{\"1\":{\"123\":1}}],[\"对象一定分配在堆中吗\",{\"0\":{\"123\":1}}],[\"对象将被移入老年代\",{\"1\":{\"97\":1}}],[\"对象的线程进入\",{\"1\":{\"381\":1}}],[\"对象的操作\",{\"1\":{\"168\":1}}],[\"对象的迭代年龄会在每次young\",{\"1\":{\"97\":1}}],[\"对象的内存分配通常是在堆中进行的\",{\"1\":{\"123\":1}}],[\"对象的内存分配是连续的\",{\"1\":{\"78\":1}}],[\"对象的内存布局可以用以下示意图表示\",{\"1\":{\"82\":1}}],[\"对象什么时候会进入老年代\",{\"0\":{\"97\":1}}],[\"对象经过几次minor\",{\"1\":{\"95\":1}}],[\"对象怎么访问定位\",{\"0\":{\"83\":1}}],[\"对象头的大小在不同的jvm实现中会有所不同\",{\"1\":{\"82\":1}}],[\"对象头的大小取决于虚拟机的具体实现和运行环境\",{\"1\":{\"78\":1}}],[\"对象头存储了一些元数据\",{\"1\":{\"82\":1}}],[\"对象头\",{\"1\":{\"82\":2}}],[\"对象时\",{\"0\":{\"81\":1}}],[\"稳定性和可维护性方面都有显著提升\",{\"1\":{\"77\":1}}],[\"特征\",{\"1\":{\"365\":1,\"366\":1,\"367\":1,\"368\":1,\"369\":1}}],[\"特别适用于需要频繁调整参数的情况\",{\"1\":{\"371\":1}}],[\"特别适用于大内存和多处理器的现代应用环境\",{\"1\":{\"110\":1}}],[\"特别是在高并发或多线程应用程序中\",{\"1\":{\"357\":1}}],[\"特别是在高并发和需要处理大量任务的场景中\",{\"1\":{\"316\":1}}],[\"特别是在长时间运行\",{\"1\":{\"84\":1}}],[\"特别是确定对象是否会逃逸出方法的作用域\",{\"1\":{\"125\":1}}],[\"特别是当需要平衡响应时间和吞吐量时\",{\"1\":{\"116\":1}}],[\"特别是大堆内存环境\",{\"1\":{\"112\":1}}],[\"特别是对于大量动态生成和卸载类的应用\",{\"1\":{\"76\":1}}],[\"特点\",{\"1\":{\"53\":5,\"120\":6,\"239\":1,\"418\":1}}],[\"使线程和队列解耦\",{\"1\":{\"350\":1}}],[\"使线程在屏障点等待\",{\"1\":{\"251\":1}}],[\"使其他被阻塞的线程可以继续执行\",{\"1\":{\"254\":1}}],[\"使其成为监视对象\",{\"1\":{\"139\":1}}],[\"使java程序能够调用本地\",{\"1\":{\"133\":1}}],[\"使得每个线程都在等待下一个线程占有的资源\",{\"1\":{\"408\":1}}],[\"使得任务能够动态地分配给空闲的线程\",{\"1\":{\"376\":1}}],[\"使得线程池成为并发编程中重要的工具\",{\"1\":{\"343\":1}}],[\"使得java程序能够在各种硬件和操作系统上稳定运行\",{\"1\":{\"135\":1}}],[\"使得垃圾回收器无法回收这些对象\",{\"1\":{\"84\":1}}],[\"使得内存使用更加高效和一致\",{\"1\":{\"76\":1}}],[\"使用的是哈希表的数据结构\",{\"1\":{\"446\":1}}],[\"使用的时候再一个一个的一次调用就可以\",{\"1\":{\"195\":1}}],[\"使用reentrantlock加锁\",{\"1\":{\"444\":1}}],[\"使用线程安全的并发容器\",{\"1\":{\"442\":1}}],[\"使用线程安全的包装类\",{\"1\":{\"442\":1}}],[\"使用随机哈希码\",{\"1\":{\"435\":1}}],[\"使用扰动函数\",{\"1\":{\"428\":1}}],[\"使用链表存储键值对\",{\"1\":{\"421\":1}}],[\"使用copyonwritearraylist代替arraylist\",{\"1\":{\"417\":1}}],[\"使用collections\",{\"1\":{\"417\":1}}],[\"使用countdownlatch时\",{\"1\":{\"252\":1}}],[\"使用自旋+cas实现\",{\"1\":{\"407\":1}}],[\"使用自定义\",{\"0\":{\"361\":1}}],[\"使用自定义线程池\",{\"0\":{\"287\":1}}],[\"使用synchronized\",{\"1\":{\"405\":1}}],[\"使用stringbuilder可以获得更好的性能\",{\"1\":{\"169\":1}}],[\"使用stringbuffer可以保证线程安全\",{\"1\":{\"169\":1}}],[\"使用循环原子类\",{\"1\":{\"405\":1}}],[\"使用atomicstampreference类\",{\"1\":{\"401\":1}}],[\"使用一个\",{\"1\":{\"392\":1}}],[\"使用管理平台是一种更高级的方式\",{\"1\":{\"371\":1}}],[\"使用配置文件是一种常见的方式\",{\"1\":{\"371\":1}}],[\"使用动态代理也是一种有效的方式\",{\"1\":{\"371\":1}}],[\"使用可调整的线程池\",{\"1\":{\"371\":1}}],[\"使用连接池管理数据库连接\",{\"1\":{\"324\":1}}],[\"使用默认线程池\",{\"0\":{\"284\":1}}],[\"使用示例\",{\"1\":{\"257\":1}}],[\"使用threadlocal\",{\"1\":{\"247\":1}}],[\"使用thread\",{\"1\":{\"247\":1}}],[\"使用typora或者其他markdown软件就能渲染出来\",{\"1\":{\"27\":1}}],[\"使用完threadlocal后\",{\"1\":{\"226\":1}}],[\"使用完threadlocal一\",{\"1\":{\"86\":1}}],[\"使用volatile关键字或者同步机制\",{\"1\":{\"214\":2}}],[\"使用同步机制控制arraylist的读写\",{\"1\":{\"417\":1}}],[\"使用同步机制\",{\"1\":{\"214\":1,\"442\":1}}],[\"使用jstack查看线程堆栈信息\",{\"1\":{\"409\":1}}],[\"使用jps查找运行的java进程\",{\"1\":{\"409\":1}}],[\"使用juc包下的锁\",{\"1\":{\"405\":1}}],[\"使用java\",{\"1\":{\"193\":1}}],[\"使用jvm提供的工具\",{\"1\":{\"121\":1}}],[\"使用for\",{\"1\":{\"193\":2}}],[\"使用迭代器遍历\",{\"1\":{\"193\":1}}],[\"使用注解作为切点就是运行期注解的应用\",{\"1\":{\"190\":1}}],[\"使用建议\",{\"1\":{\"169\":1}}],[\"使用不同的gc选项运行应用\",{\"1\":{\"121\":1}}],[\"使用不同类型的引用可以更灵活地管理对象的生命周期和内存使用情况\",{\"1\":{\"89\":1}}],[\"使用zgc的理由\",{\"0\":{\"115\":1}}],[\"使用g1的理由\",{\"0\":{\"114\":1}}],[\"使用场景\",{\"1\":{\"112\":3}}],[\"使用标记\",{\"1\":{\"98\":3}}],[\"使用\",{\"0\":{\"360\":1,\"362\":1,\"363\":1},\"1\":{\"81\":1,\"141\":1,\"145\":1,\"169\":2,\"177\":1,\"255\":1,\"283\":1,\"284\":1,\"294\":2,\"376\":2,\"442\":1}}],[\"使用指针碰撞或空闲列表实现\",{\"1\":{\"78\":1}}],[\"使用元空间\",{\"1\":{\"77\":1}}],[\"使用元空间替代永久代的原因\",{\"0\":{\"73\":1}}],[\"使用元空间替代\",{\"1\":{\"62\":1}}],[\"使用永久代来存储类元数据\",{\"1\":{\"62\":1}}],[\"更高效\",{\"1\":{\"439\":1}}],[\"更高的回收效率\",{\"1\":{\"76\":1}}],[\"更多的是一种兜底的策略\",{\"1\":{\"435\":1}}],[\"更多对象分配在栈上或优化掉\",{\"1\":{\"128\":1}}],[\"更新失败\",{\"1\":{\"390\":1}}],[\"更新成功\",{\"1\":{\"390\":1}}],[\"更新博客只在master分支上改\",{\"0\":{\"22\":1}}],[\"更易于并行处理数据集合的方式\",{\"1\":{\"141\":1}}],[\"更好的大堆支持\",{\"1\":{\"109\":1}}],[\"更好的类加载和卸载支持\",{\"1\":{\"76\":1}}],[\"改进性能和内存管理\",{\"1\":{\"77\":1}}],[\"改进的性能和垃圾回收\",{\"1\":{\"76\":1}}],[\"改用元空间\",{\"1\":{\"75\":1}}],[\"避免重复调用同一个耗时操作\",{\"1\":{\"375\":1}}],[\"避免线程池中的任务过多导致资源耗尽和性能下降\",{\"1\":{\"375\":1}}],[\"避免问题进一步恶化\",{\"1\":{\"372\":1}}],[\"避免了环形链表的问题\",{\"1\":{\"441\":1}}],[\"避免了一次性重新计算所有键的哈希值和索引位置\",{\"1\":{\"439\":1}}],[\"避免了这种退化情况\",{\"1\":{\"424\":1}}],[\"避免了频繁创建和销毁线程的开销\",{\"1\":{\"298\":1}}],[\"避免了线程\",{\"1\":{\"222\":1}}],[\"避免了永久代空间不足的问题\",{\"1\":{\"61\":1}}],[\"避免碎片化\",{\"1\":{\"109\":1}}],[\"避免永久代空间不足问题\",{\"1\":{\"77\":1}}],[\"避免oom错误\",{\"1\":{\"76\":1}}],[\"逐步改用本地内存\",{\"1\":{\"75\":1}}],[\"移植工作面临诸多困难\",{\"1\":{\"75\":1}}],[\"移植到hotspot虚拟机中\",{\"1\":{\"75\":1}}],[\"xstream等\",{\"1\":{\"178\":1}}],[\"xml\",{\"1\":{\"178\":1}}],[\"xml序列化\",{\"1\":{\"178\":1}}],[\"xml等格式\",{\"1\":{\"178\":1}}],[\"x\",{\"1\":{\"126\":4,\"407\":3}}],[\"xx\",{\"1\":{\"74\":1,\"76\":1,\"97\":2,\"102\":1,\"105\":4,\"109\":1,\"120\":7,\"121\":1,\"127\":6,\"173\":1}}],[\"xy\",{\"0\":{\"49\":1}}],[\"简称\",{\"1\":{\"392\":1}}],[\"简略的锁升级过程\",{\"1\":{\"390\":1}}],[\"简单来说\",{\"1\":{\"145\":1,\"148\":1,\"229\":1}}],[\"简单\",{\"1\":{\"120\":1}}],[\"简化编程\",{\"1\":{\"300\":1}}],[\"简化内存管理\",{\"1\":{\"77\":1}}],[\"简化内存管理等\",{\"1\":{\"72\":1}}],[\"简化了并发编程的复杂性\",{\"1\":{\"300\":1}}],[\"简化了jvm的内存管理\",{\"1\":{\"76\":1}}],[\"简化了内存管理\",{\"1\":{\"76\":1}}],[\"简化管理\",{\"1\":{\"76\":1}}],[\"简体中文\",{\"1\":{\"11\":1}}],[\"提交任务\",{\"1\":{\"353\":1,\"354\":1,\"355\":1,\"373\":1}}],[\"提交异步任务\",{\"1\":{\"332\":1}}],[\"提交异步任务并使用自定义线程池\",{\"1\":{\"288\":1}}],[\"提交多个任务\",{\"1\":{\"303\":1,\"305\":1}}],[\"提升了synchronized的性能\",{\"1\":{\"387\":1}}],[\"提升应用程序的响应速度和用户体验\",{\"1\":{\"100\":1}}],[\"提升jvm的性能和稳定性\",{\"1\":{\"62\":1}}],[\"提供了统一的接口来管理和调度线程\",{\"1\":{\"300\":1}}],[\"提供了更好的日期和时间处理方式\",{\"1\":{\"141\":1}}],[\"提供了最基本的输入输出操作\",{\"1\":{\"138\":1}}],[\"提供了可预测的低停顿时间和自动调优能力\",{\"1\":{\"117\":1}}],[\"提供了一种简洁而强大的方式来处理异\",{\"1\":{\"282\":1}}],[\"提供了一种平衡高吞吐量和低停顿时间的垃圾收集解决方案\",{\"1\":{\"106\":1}}],[\"提供了一个更加高效和灵活的垃圾收集解决方案\",{\"1\":{\"110\":1}}],[\"提供足够的空间给新对象分配\",{\"1\":{\"94\":2}}],[\"提供更好的类加载和卸载支持\",{\"1\":{\"77\":1}}],[\"提示java堆内存溢出\",{\"1\":{\"85\":1}}],[\"提高插入操作的效率\",{\"1\":{\"439\":1}}],[\"提高线程池的性能和响应速度\",{\"1\":{\"375\":1}}],[\"提高线程池的响应速度\",{\"1\":{\"375\":1}}],[\"提高线程池的并发能力\",{\"1\":{\"375\":1}}],[\"提高任务的并发性和执行效率\",{\"1\":{\"375\":1}}],[\"提高系统的性能和响应速度\",{\"1\":{\"375\":1}}],[\"提高系统的可靠性和可维护性\",{\"1\":{\"372\":1}}],[\"提高系统的响应速度\",{\"1\":{\"92\":1}}],[\"提高并发编程的效率和资源利用率\",{\"1\":{\"337\":1}}],[\"提高数据处理的速度\",{\"1\":{\"327\":1}}],[\"提高垃圾回收的效率\",{\"1\":{\"93\":1}}],[\"提高垃圾回收效率\",{\"1\":{\"77\":1}}],[\"提高内存利用率和性能\",{\"1\":{\"77\":1}}],[\"提高了插入和删除操作的效率\",{\"1\":{\"425\":1}}],[\"提高了线程的利用率和任务的并行性\",{\"1\":{\"376\":1}}],[\"提高了代码的运行效率和与旧版本\",{\"1\":{\"188\":1}}],[\"提高了代码的可读性和简洁性\",{\"1\":{\"141\":1}}],[\"提高了程序的运行性能\",{\"1\":{\"128\":1}}],[\"提高了垃圾回收的效率\",{\"1\":{\"97\":1}}],[\"提高了内存回收效率\",{\"1\":{\"109\":1}}],[\"提高了内存分配的效率\",{\"1\":{\"81\":1}}],[\"提高了内存利用率和性能\",{\"1\":{\"76\":1}}],[\"提高了并发性能\",{\"1\":{\"81\":1,\"128\":1}}],[\"提高了\",{\"1\":{\"80\":1}}],[\"提高了分配对象的效率\",{\"1\":{\"80\":1}}],[\"提高了回收效率\",{\"1\":{\"76\":1}}],[\"提高整体性能\",{\"1\":{\"76\":1}}],[\"提高性能\",{\"1\":{\"72\":1,\"300\":1}}],[\"替换等\",{\"1\":{\"168\":1}}],[\"替换为元空间\",{\"1\":{\"53\":1,\"57\":1}}],[\"替代永久代\",{\"1\":{\"77\":1}}],[\"替代了永久代\",{\"1\":{\"72\":1}}],[\"而平衡二叉树要求更严格的平衡条件\",{\"1\":{\"425\":1}}],[\"而红黑树通过自平衡的特性\",{\"1\":{\"424\":1}}],[\"而新资源己被其它线程占有\",{\"1\":{\"408\":1}}],[\"而synchronized不用手动释放锁\",{\"1\":{\"391\":1}}],[\"而synchronized只能是非公平锁\",{\"1\":{\"391\":1}}],[\"而submit\",{\"1\":{\"339\":1,\"347\":1}}],[\"而窃取任务的线程永远从双端队列的尾部拿任务执行\",{\"1\":{\"376\":1}}],[\"而cyclicbarrier中的各个线程可以等待其他线程\",{\"1\":{\"252\":1}}],[\"而cyclicbarrier则可以多次设置屏障\",{\"1\":{\"252\":1}}],[\"而后两种面向字\",{\"1\":{\"247\":1}}],[\"而后者实现的是运行时的多态性\",{\"1\":{\"197\":1}}],[\"而传输的媒介为内存\",{\"1\":{\"247\":1}}],[\"而另一个线程感知到了变化\",{\"1\":{\"247\":1}}],[\"而对它的改变必须同步刷新回共享内存\",{\"1\":{\"247\":1}}],[\"而对于引用类型变量指向的堆中的对象不会拷贝\",{\"1\":{\"208\":1}}],[\"而被阻塞时\",{\"1\":{\"245\":1}}],[\"而terminated状态是永久的\",{\"1\":{\"243\":1}}],[\"而terminated状态表示线程已经执行完毕\",{\"1\":{\"243\":1}}],[\"而threadlocalmap使用threadlocal实例作为键\",{\"1\":{\"227\":1}}],[\"而等待状态是等待其他线程的通知或中断\",{\"1\":{\"242\":1}}],[\"而runnable接口适合定义线程要执行的任务\",{\"1\":{\"239\":1}}],[\"而且entry数据的key和当前不相等\",{\"1\":{\"229\":1}}],[\"而且第一个操作的执行顺序排在第二个操作之前\",{\"1\":{\"216\":1}}],[\"而槽位\",{\"1\":{\"229\":1}}],[\"而局部变量没有默认值\",{\"1\":{\"201\":1}}],[\"而静态变量是类共享的\",{\"1\":{\"201\":1}}],[\"而接口是对行为的抽象\",{\"1\":{\"200\":1}}],[\"而抽象类中可以包含任意类型的变量\",{\"1\":{\"200\":1}}],[\"而抽象类可以包含非抽象的方法\",{\"1\":{\"200\":1}}],[\"而建立对象的目的也不是为了完成一个个步骤\",{\"1\":{\"195\":1}}],[\"而在运行时\",{\"1\":{\"188\":1}}],[\"而在64位jvm中占用8个字节\",{\"1\":{\"82\":1}}],[\"而中间操作会返回一个\",{\"1\":{\"145\":1}}],[\"而字节流则需要手动处理\",{\"1\":{\"138\":1}}],[\"而永久代的空间不足时\",{\"1\":{\"96\":1}}],[\"而老年代放不下时\",{\"1\":{\"96\":1}}],[\"而是先复制原有集合内容\",{\"1\":{\"416\":1}}],[\"而是只对需要进行原子操作的代码进行了保护\",{\"1\":{\"406\":1}}],[\"而是回线程池中\",{\"1\":{\"350\":1}}],[\"而是等待所有已提交的任务执行完成后再关闭线程池\",{\"1\":{\"348\":1}}],[\"而是将任务直接移交给线程池中的线程进行执行\",{\"1\":{\"346\":1}}],[\"而是被重用来处理下一个任务\",{\"1\":{\"299\":1}}],[\"而是被中断的线程根据中断状态自行处理\",{\"1\":{\"240\":1}}],[\"而是会把值刷新回主内存\",{\"1\":{\"219\":1}}],[\"而是为了描述某个事件在解决整个问题的过程所发生的行为\",{\"1\":{\"195\":1}}],[\"而是直接引用缓存池中的integer对象\",{\"1\":{\"173\":1}}],[\"而是位于本地内存中\",{\"1\":{\"91\":1}}],[\"而是抛出outofmemoryerror异常\",{\"1\":{\"89\":1}}],[\"而不需要额外的同步措施\",{\"1\":{\"418\":1}}],[\"而不需修改reference本身\",{\"1\":{\"83\":1}}],[\"而不管当前是否存在守护线程\",{\"1\":{\"246\":1}}],[\"而不是按照插入顺序进行存储\",{\"1\":{\"446\":1}}],[\"而不是头插法\",{\"1\":{\"439\":1}}],[\"而不是8\",{\"1\":{\"435\":1}}],[\"而不是防止指令重排的有序性\",{\"1\":{\"384\":1}}],[\"而不是使用当前线程的本地内存中的值\",{\"1\":{\"219\":1}}],[\"而不是对象本身\",{\"1\":{\"207\":1}}],[\"而不是返回\",{\"1\":{\"183\":1}}],[\"而不是句柄地址\",{\"1\":{\"83\":1}}],[\"而不会修改原始对象的值\",{\"1\":{\"168\":1}}],[\"而不会导致程序状态的不一致\",{\"1\":{\"99\":1}}],[\"而不分配整个对象\",{\"1\":{\"125\":1}}],[\"而不再留在survivor区\",{\"1\":{\"93\":1}}],[\"而空闲列表适用于内存不规整的情况\",{\"1\":{\"79\":1}}],[\"而\",{\"1\":{\"71\":1}}],[\"专门用于在两个线程之间交换数据\",{\"1\":{\"256\":1}}],[\"专门用于存储字符串字面值\",{\"1\":{\"66\":1}}],[\"专门存储字符串字面值\",{\"1\":{\"71\":1}}],[\"时不能再使用\",{\"1\":{\"252\":1}}],[\"时被阻塞\",{\"1\":{\"250\":1}}],[\"时间\",{\"1\":{\"437\":1}}],[\"时间复杂度都是o\",{\"1\":{\"411\":1}}],[\"时间复杂度是o\",{\"1\":{\"411\":2}}],[\"时间单位\",{\"1\":{\"338\":1,\"344\":1}}],[\"时间片时\",{\"1\":{\"245\":1}}],[\"时间片分配给另一个处于就绪状态的线程\",{\"1\":{\"245\":3}}],[\"时间线图\",{\"0\":{\"46\":1}}],[\"时机\",{\"1\":{\"230\":1}}],[\"时必须重写\",{\"1\":{\"206\":1}}],[\"时的\",{\"0\":{\"198\":1}}],[\"时\",{\"1\":{\"69\":1,\"97\":1,\"207\":1,\"375\":1}}],[\"局部变量在使用前必须显式地进行初始化\",{\"1\":{\"201\":1}}],[\"局部变量只在方法或代码块内有效\",{\"1\":{\"201\":1}}],[\"局部变量存在栈内存中\",{\"1\":{\"201\":1}}],[\"局部变量是在方法中或代码块中声明的变量\",{\"1\":{\"201\":1}}],[\"局部变量a存储在java栈中\",{\"1\":{\"70\":1}}],[\"局部变量\",{\"1\":{\"69\":2}}],[\"作者\",{\"1\":{\"141\":1}}],[\"作为映射的位置\",{\"1\":{\"433\":1}}],[\"作为该锁的锁记录\",{\"1\":{\"390\":1}}],[\"作为默认线程池来执行异步任务\",{\"1\":{\"283\":1}}],[\"作为方法区的实现带来了以下好处\",{\"1\":{\"77\":1}}],[\"作为常量被存储在运行时常量池中\",{\"1\":{\"71\":1}}],[\"作为字面值\",{\"1\":{\"69\":1}}],[\"作用于当前对象实例加锁\",{\"1\":{\"378\":1}}],[\"作用\",{\"1\":{\"53\":5,\"90\":1}}],[\"解锁操作连接在一起\",{\"1\":{\"387\":1}}],[\"解决哈希冲突有哪些方法呢\",{\"0\":{\"434\":1}}],[\"解决方案\",{\"0\":{\"319\":1,\"323\":1,\"327\":1,\"331\":1,\"335\":1}}],[\"解决了线程池等场景下inheritablethreadlocal\",{\"1\":{\"233\":1}}],[\"解决了字符串常量池引起的内存管理问题\",{\"1\":{\"60\":1}}],[\"解决了因为permgen空间不足导致的outofmemoryerror的问题\",{\"1\":{\"56\":1}}],[\"解析\",{\"1\":{\"183\":2}}],[\"解析和初始化阶段\",{\"1\":{\"78\":1}}],[\"解耦了服务的实现和调用方\",{\"1\":{\"153\":1}}],[\"解释成操作系统能识别的机器码\",{\"1\":{\"151\":1}}],[\"解释\",{\"0\":{\"69\":1,\"254\":1,\"258\":1},\"1\":{\"135\":1,\"150\":1}}],[\"我们设的比较小的话\",{\"1\":{\"437\":1}}],[\"我们来看看它的状态变化\",{\"1\":{\"386\":1}}],[\"我们定义了一个继承自recursivetask<integer>的fibonaccitask类\",{\"1\":{\"376\":1}}],[\"我们重写了\",{\"1\":{\"376\":1}}],[\"我们就可以在编译或者运行阶段去识别这些标记\",{\"1\":{\"190\":1}}],[\"我们就可以考虑用\",{\"1\":{\"144\":1}}],[\"我们能够将\",{\"1\":{\"145\":1}}],[\"我们可以使用同步机制\",{\"1\":{\"212\":1}}],[\"我们可以获取到class对象信息\",{\"1\":{\"157\":1}}],[\"我们可以避免空指针异常\",{\"1\":{\"141\":1}}],[\"我们可以对集合进行过滤\",{\"1\":{\"141\":1}}],[\"我们创建了一个arraylist\",{\"1\":{\"85\":1}}],[\"我们需要澄清几点\",{\"1\":{\"67\":1}}],[\"我们无法正确输出子进程的进度条\",{\"1\":{\"11\":1}}],[\"为null\",{\"1\":{\"390\":1}}],[\"为\",{\"1\":{\"225\":1}}],[\"为程序员提供一致的内存可见性保证\",{\"1\":{\"215\":1}}],[\"为java应用提供更好的性能和可预测性\",{\"1\":{\"110\":1}}],[\"为什么\",{\"0\":{\"439\":1}}],[\"为什么扩容因子是0\",{\"0\":{\"436\":1}}],[\"为什么hashmap链表转红黑树的阈值为8呢\",{\"0\":{\"435\":1}}],[\"为什么hashmap的容量是2的倍数呢\",{\"0\":{\"431\":1}}],[\"为什么哈希\",{\"0\":{\"430\":1}}],[\"为什么不用平衡二叉树\",{\"0\":{\"425\":1}}],[\"为什么不用二叉树\",{\"0\":{\"422\":1,\"424\":1}}],[\"为什么最arraylist不直接序列化元素数组呢\",{\"0\":{\"414\":1}}],[\"为什么用transient修饰数组\",{\"0\":{\"413\":1}}],[\"为什么我们不能直接调用run\",{\"1\":{\"238\":1}}],[\"为什么调用start\",{\"0\":{\"238\":1}}],[\"为什么key还要设计成弱引用\",{\"0\":{\"227\":1}}],[\"为什么重写\",{\"1\":{\"206\":1}}],[\"为什么说频繁创建和销毁线程的开销大\",{\"0\":{\"306\":1}}],[\"为什么说\",{\"0\":{\"151\":1}}],[\"为什么还要有字符流\",{\"0\":{\"138\":1}}],[\"为什么还要引入g1\",{\"0\":{\"107\":1}}],[\"为什么选择某种垃圾收集器\",{\"0\":{\"113\":1}}],[\"为什么要用它\",{\"0\":{\"111\":1}}],[\"为什么使用元空间替代永久代作为方法区的实现\",{\"0\":{\"72\":1}}],[\"为每个线程预先分配一小块内存空间作为本地线程分配缓冲\",{\"1\":{\"81\":1}}],[\"为了减少哈希冲突发生的概率\",{\"1\":{\"436\":1,\"438\":1}}],[\"为了减少窃取任务线程和被窃取任务线程之间的竞争\",{\"1\":{\"376\":1}}],[\"为了优化这种情况\",{\"1\":{\"375\":1}}],[\"为了避免错误\",{\"1\":{\"259\":1}}],[\"为了避免这种问题\",{\"1\":{\"177\":1}}],[\"为了实现volatile的内存语义\",{\"1\":{\"220\":1}}],[\"为了遵守as\",{\"1\":{\"217\":1}}],[\"为了提高性能\",{\"1\":{\"215\":1}}],[\"为了保证原子性\",{\"1\":{\"212\":1}}],[\"为了保证线程安全性\",{\"1\":{\"169\":1}}],[\"为了应对碎片化\",{\"1\":{\"100\":1}}],[\"为了解决多线程环境下的堆内存分配竞争问题\",{\"1\":{\"81\":1}}],[\"为了hotspot未来的发展\",{\"1\":{\"75\":1}}],[\"为了更好地解释它们的区别\",{\"1\":{\"67\":1}}],[\"为change\",{\"1\":{\"20\":1}}],[\"因争夺资源而造成的互相等待的现象\",{\"1\":{\"408\":1}}],[\"因为除了clone\",{\"1\":{\"450\":1}}],[\"因为任意数\",{\"1\":{\"431\":1}}],[\"因为哈希值\",{\"1\":{\"430\":1}}],[\"因为每次写操作都会创建一个新的副本\",{\"1\":{\"418\":1}}],[\"因为每个线程都会占用较多的cpu资源\",{\"1\":{\"349\":1}}],[\"因为用锁为的就是互斥\",{\"1\":{\"408\":1}}],[\"因为线程有几率不阻塞直接获得锁\",{\"1\":{\"395\":1}}],[\"因为线程在执行任务时会阻塞等待i\",{\"1\":{\"349\":1}}],[\"因为as\",{\"1\":{\"384\":1}}],[\"因为静态成员不属于任何⼀个实例对象\",{\"1\":{\"378\":1}}],[\"因为斐波那契数列的第一个数和第二个数都是1\",{\"1\":{\"376\":1}}],[\"因为没有核心线程\",{\"1\":{\"354\":1}}],[\"因为它用于提交不需要返回结果的任务\",{\"1\":{\"347\":1}}],[\"因为它的吞吐量比较大\",{\"1\":{\"397\":1}}],[\"因为它的不可变性保证了多个线程可以安全地共享string对象\",{\"1\":{\"169\":1}}],[\"因为它的哈希值是固定的\",{\"1\":{\"168\":1}}],[\"因为调用线程需要承担执行任务的负责\",{\"1\":{\"345\":1}}],[\"因为操作系统需要保存和恢复线程的上下文信息\",{\"1\":{\"244\":1}}],[\"因为切换的时间特别短\",{\"1\":{\"235\":1}}],[\"因为前面调用过一次\",{\"1\":{\"204\":1}}],[\"因为根据实践发现大部分的数据操作都集中在值比较小的范围\",{\"1\":{\"173\":1}}],[\"因为\",{\"1\":{\"151\":1,\"446\":1}}],[\"因为栈上的对象在方法结束时自动释放\",{\"1\":{\"125\":1}}],[\"因为这种重排序会改变执行结果\",{\"1\":{\"217\":1}}],[\"因为这些垃圾收集器能够在保持高吞吐量的同时提供可预测的低停顿时间\",{\"1\":{\"116\":1}}],[\"因为这个区域是私有的\",{\"1\":{\"80\":1}}],[\"因为只需要标记gc\",{\"1\":{\"100\":1}}],[\"因为minor\",{\"1\":{\"95\":1}}],[\"因为新生代中的对象存活时间短\",{\"1\":{\"92\":1}}],[\"因为该算法无法处理循环引用的情况\",{\"1\":{\"87\":1}}],[\"因为避免了一次指针定位的时间开销\",{\"1\":{\"83\":1}}],[\"因为不要求内存是连续的\",{\"1\":{\"79\":1}}],[\"因为指针碰到对象后会被挪动到下一个可用位置\",{\"1\":{\"79\":1}}],[\"因为str1和str2指向同一个字符串常量池中的对象\",{\"1\":{\"64\":1}}],[\"因此适用于写操作较少\",{\"1\":{\"418\":1}}],[\"因此可以通过键值来遍历\",{\"1\":{\"448\":1}}],[\"因此可以在多线程环境下安全地进行读操作\",{\"1\":{\"418\":1}}],[\"因此可以暂停执行进行垃圾回收操作\",{\"1\":{\"99\":1}}],[\"因此要等到safepoint时执行\",{\"1\":{\"389\":1}}],[\"因此需要一些机制来处理这种情况\",{\"1\":{\"374\":1}}],[\"因此java语言可以实现跨平\",{\"1\":{\"148\":1}}],[\"因此java程序无需修改即可在不同操作系统上运行\",{\"1\":{\"135\":1}}],[\"因此容易导致堆内存碎片化\",{\"1\":{\"108\":1}}],[\"因此不推荐使用\",{\"1\":{\"204\":1}}],[\"因此不再受到java堆的大小限制\",{\"1\":{\"91\":1}}],[\"因此不能依赖于finalize\",{\"1\":{\"90\":1}}],[\"因此对象的访问方式由虚拟机实现而定\",{\"1\":{\"83\":1}}],[\"因此在遍历集合时使用的迭代器可能不反映最新的修改\",{\"1\":{\"418\":1}}],[\"因此在读多写少的场景中\",{\"1\":{\"417\":1}}],[\"因此在并发环境下可以安全地进行读写操作\",{\"1\":{\"417\":1}}],[\"因此在开发过程中需要仔细管理和释放对象和资源\",{\"1\":{\"86\":1}}],[\"因此在实例数据之后可能会添加一些填充字节\",{\"1\":{\"82\":1}}],[\"因此在多线程环境下可能会发生堆内存的抢占现象\",{\"1\":{\"81\":1}}],[\"因此在jdk\",{\"1\":{\"77\":1}}],[\"因此\",{\"1\":{\"67\":1,\"69\":1,\"87\":1,\"90\":1,\"95\":1,\"126\":1,\"173\":1,\"207\":1,\"244\":1,\"296\":1,\"416\":1}}],[\"并重试或采取其他措施\",{\"1\":{\"408\":1}}],[\"并设置\",{\"1\":{\"396\":1}}],[\"并设置屏障点操作\",{\"1\":{\"251\":1}}],[\"并使用locksupport\",{\"1\":{\"392\":1}}],[\"并使用交叉规则得出2个交配结果\",{\"1\":{\"259\":1}}],[\"并指向mark\",{\"1\":{\"390\":1}}],[\"并输出结果\",{\"1\":{\"376\":1}}],[\"并直接在当前线程中执行第二个子任务的\",{\"1\":{\"376\":1}}],[\"并采取相应的措施进行处理\",{\"1\":{\"372\":1}}],[\"并针对性地配置线程池\",{\"1\":{\"372\":1}}],[\"并实时查看线程池的状态和性能指标\",{\"1\":{\"371\":1}}],[\"并处理已经在队列中的任务\",{\"1\":{\"365\":1}}],[\"并释放线程池所占用的资源\",{\"1\":{\"348\":1}}],[\"并释放许可\",{\"1\":{\"254\":1}}],[\"并尝试重新提交当前任务\",{\"1\":{\"345\":1}}],[\"并返回未执行的任务列表\",{\"1\":{\"342\":1,\"348\":1}}],[\"并返回string对象的引用\",{\"1\":{\"172\":1}}],[\"并准备好任务队列\",{\"1\":{\"338\":1}}],[\"并提高数据库操作的效率\",{\"1\":{\"323\":1}}],[\"并提供了具体的功能实现\",{\"1\":{\"153\":1}}],[\"并提供了更多的功能和灵活性\",{\"1\":{\"141\":1}}],[\"并结合了锁和条件等待机制来实现线程的阻塞和唤醒\",{\"1\":{\"296\":1}}],[\"并在后台执行耗时的操作\",{\"1\":{\"375\":1}}],[\"并在代理类中提供方法来动态修改线程池的参数\",{\"1\":{\"371\":1}}],[\"并在所有已提交任务执行完成后关闭线程池\",{\"1\":{\"342\":1}}],[\"并在所有数据获取完成后进行处理\",{\"1\":{\"281\":1}}],[\"并在运行时动态地操作类和对象\",{\"1\":{\"157\":1}}],[\"并对两个excel数据进行校对\",{\"1\":{\"259\":1}}],[\"并可以选择性地做一些特定的动作\",{\"1\":{\"252\":1}}],[\"并可以与其他接口组合使用\",{\"1\":{\"239\":1}}],[\"并继续执行\",{\"1\":{\"251\":1}}],[\"并立即返回\",{\"1\":{\"240\":1}}],[\"并行处理每个块\",{\"1\":{\"326\":1}}],[\"并行数据处理\",{\"0\":{\"325\":1}}],[\"并行获取数据\",{\"0\":{\"281\":1}}],[\"并行执行多个任务\",{\"0\":{\"278\":1}}],[\"并行执行\",{\"1\":{\"261\":1}}],[\"并行就是同一时刻\",{\"1\":{\"235\":1}}],[\"并行跟并发有什么区别\",{\"0\":{\"235\":1}}],[\"并成功返回\",{\"1\":{\"216\":1}}],[\"并不意味着java平台的具体实现必须要按照\",{\"1\":{\"216\":1}}],[\"并不真实存在\",{\"1\":{\"211\":1}}],[\"并通过join\",{\"1\":{\"376\":1}}],[\"并通过\",{\"1\":{\"363\":1}}],[\"并通过http协议进行传输\",{\"1\":{\"178\":1}}],[\"并通过配置文件等方式注册到spi框架中\",{\"1\":{\"153\":1}}],[\"并确保在类的修改后\",{\"1\":{\"177\":1}}],[\"并根据任务执行日志来恢复任务的执行状态\",{\"1\":{\"374\":1}}],[\"并根据文件中指定的实现类\",{\"1\":{\"153\":1}}],[\"并根据配置文件中指定的实现类实例化相应的对象\",{\"1\":{\"153\":1}}],[\"并更好地处理可能为空的值\",{\"1\":{\"141\":1}}],[\"并更新列表上的记录\",{\"1\":{\"79\":1}}],[\"并执行相应的读取或写入操作\",{\"1\":{\"139\":1}}],[\"并将锁记录里的owner指针指向对象头的markword\",{\"1\":{\"390\":1}}],[\"并将这些小任务分配给线程池中的多个线程并行执行\",{\"1\":{\"375\":1}}],[\"并将它们放入线程池中\",{\"1\":{\"350\":1}}],[\"并将新的通道\",{\"1\":{\"139\":1}}],[\"并将其转换为jvm可以使用的内部数据结构\",{\"1\":{\"133\":1}}],[\"并将其转换成可以执行的机器码\",{\"1\":{\"132\":1}}],[\"并非所有对象都必须分配在堆中\",{\"1\":{\"123\":1}}],[\"并发修改\",{\"1\":{\"416\":1}}],[\"并发环境下\",{\"1\":{\"400\":1}}],[\"并发包中的锁就是基于aqs实现的\",{\"1\":{\"392\":1}}],[\"并发送告警通知给相关人员进行处理\",{\"1\":{\"372\":1}}],[\"并发队列\",{\"0\":{\"295\":1}}],[\"并发工具类\",{\"0\":{\"248\":1}}],[\"并发的实现依赖于cpu切换线程\",{\"1\":{\"235\":1}}],[\"并发就是同一时刻\",{\"1\":{\"235\":1}}],[\"并发压缩\",{\"1\":{\"120\":1}}],[\"并发线程数\",{\"1\":{\"119\":1}}],[\"并发与并行\",{\"1\":{\"109\":1}}],[\"并发模式失效\",{\"1\":{\"108\":1}}],[\"并发性\",{\"1\":{\"100\":1}}],[\"并发清理\",{\"1\":{\"100\":1}}],[\"并发标记和压缩回收\",{\"1\":{\"120\":1}}],[\"并发标记和清理\",{\"1\":{\"120\":1}}],[\"并发标记和混合回收\",{\"1\":{\"106\":1}}],[\"并发标记开始前\",{\"1\":{\"103\":1}}],[\"并发标记阶段分为初始标记\",{\"1\":{\"102\":1}}],[\"并发标记\",{\"1\":{\"100\":2,\"102\":2,\"103\":1}}],[\"并发整理和并发回收来实现低停顿时间\",{\"1\":{\"98\":1}}],[\"并记录下栈上和寄存器里哪些位置是引用\",{\"1\":{\"99\":1}}],[\"并清空eden区\",{\"1\":{\"93\":1}}],[\"并尽量避免过度依赖\",{\"1\":{\"90\":1}}],[\"并未具体定义如何定位和访问堆中对象的具体位置\",{\"1\":{\"83\":1}}],[\"并引用运行时常量池中的\",{\"1\":{\"69\":1}}],[\"并用于程序运行时的各种操作\",{\"1\":{\"68\":1}}],[\"并动态解析符号引用\",{\"1\":{\"66\":1}}],[\"并且当前印戳\",{\"1\":{\"401\":1}}],[\"并且当前线程之前没有获取过该锁\",{\"1\":{\"396\":1}}],[\"并且对象markword锁标志设置为\",{\"1\":{\"390\":1}}],[\"并且将锁对象markword复制到该锁记录中\",{\"1\":{\"390\":1}}],[\"并且将存活对象向一端移动\",{\"1\":{\"92\":1}}],[\"并且会尝试中断正在进行的任务\",{\"1\":{\"367\":1}}],[\"并且可以配合其他配置管理工具来实现自动化管理\",{\"1\":{\"371\":1}}],[\"并且可以处理任务执行过程中抛出的异常\",{\"1\":{\"347\":1}}],[\"并且可以从其他线程的队列中窃取任务来执行\",{\"1\":{\"346\":1}}],[\"并且可以直接使用接口名调用\",{\"1\":{\"200\":1}}],[\"并且任务队列已满时\",{\"1\":{\"344\":1}}],[\"并且这两个线程在此方法处阻塞\",{\"1\":{\"258\":1}}],[\"并且在遍历过程中使用一个modcount\",{\"1\":{\"416\":1}}],[\"并且在获取锁之前\",{\"1\":{\"240\":1}}],[\"并且在运行时为常量池中的符号引用进行解析\",{\"1\":{\"65\":1}}],[\"并且重新尝试获取对象的锁\",{\"1\":{\"240\":1}}],[\"并且接口中定义了相同的默认方法\",{\"1\":{\"200\":1}}],[\"并且生命周期比外部类长\",{\"1\":{\"86\":1}}],[\"并且是该线程私有的\",{\"1\":{\"80\":1}}],[\"并且字符串常量池的引用在运行时常量池中\",{\"1\":{\"65\":1}}],[\"由线程\",{\"1\":{\"303\":1,\"305\":1}}],[\"由创建出来的新线程去执行thread的run方法\",{\"1\":{\"238\":1}}],[\"由\",{\"1\":{\"151\":1}}],[\"由执行引擎将字节码解释或编译为机器码并执行\",{\"1\":{\"134\":1}}],[\"由于扩容过程中元素迁移的不可见性\",{\"1\":{\"441\":1}}],[\"由于哈希函数的计算结果可能会出现冲突\",{\"1\":{\"421\":1}}],[\"由于copyonwritearraylist在每次写操作时都会创建副本\",{\"1\":{\"418\":1}}],[\"由于copyonwritearraylist在写操作时会创建副本\",{\"1\":{\"418\":1}}],[\"由于读操作不需要加锁\",{\"1\":{\"417\":1}}],[\"由于迭代时是对原集合的拷贝进行遍历\",{\"1\":{\"416\":1}}],[\"由于撤销需要知道当前持有该偏向锁的线程栈状态\",{\"1\":{\"389\":1}}],[\"由于处理器使用缓存和读\",{\"1\":{\"215\":1}}],[\"由于指令重排序和编译器优化的存在\",{\"1\":{\"212\":1}}],[\"由于每个线程都有自己的本地内存\",{\"1\":{\"212\":1}}],[\"由于同步的开销\",{\"1\":{\"169\":1}}],[\"由于不可变性的特性\",{\"1\":{\"169\":1}}],[\"由于字符串是不可变的\",{\"1\":{\"168\":1}}],[\"由于是并发进行\",{\"1\":{\"100\":1}}],[\"由于并发标记阶段和应用线程并发运行\",{\"1\":{\"100\":1}}],[\"由于与应用线程并发运行\",{\"1\":{\"100\":1}}],[\"由于没有对添加的对象进行释放\",{\"1\":{\"85\":1}}],[\"由于对象访问在java中非常频繁\",{\"1\":{\"83\":1}}],[\"由于虚拟机内存访问要求数据存储在特定的内存地址上\",{\"1\":{\"82\":1}}],[\"由jvm自动管理\",{\"1\":{\"66\":1}}],[\"由永久代\",{\"1\":{\"55\":1}}],[\"包括线程池的初始化\",{\"1\":{\"373\":2}}],[\"包括监控线程池的运行状态\",{\"1\":{\"372\":1}}],[\"包括功能测试\",{\"1\":{\"372\":1}}],[\"包括cpu核心数\",{\"1\":{\"349\":1}}],[\"包括数据库访问\",{\"1\":{\"318\":1}}],[\"包括数值常量\",{\"1\":{\"65\":1}}],[\"包括任务的串行执行\",{\"1\":{\"261\":1}}],[\"包括寄存器状态\",{\"1\":{\"244\":1}}],[\"包括java\",{\"1\":{\"148\":1}}],[\"包括验证\",{\"1\":{\"134\":1}}],[\"包括解释器\",{\"1\":{\"133\":1}}],[\"包括方法区\",{\"1\":{\"133\":1}}],[\"包括方法执行的中间结果\",{\"1\":{\"71\":1}}],[\"包括堆\",{\"1\":{\"132\":1}}],[\"包括对象的移动等\",{\"1\":{\"99\":1}}],[\"包括对象的哈希码\",{\"1\":{\"78\":1}}],[\"包括eden区和survivor区\",{\"1\":{\"95\":1}}],[\"包括无法保证及时执行\",{\"1\":{\"90\":1}}],[\"包括设置初始值或通过参数传递的值\",{\"1\":{\"78\":1}}],[\"包括规避内存溢出问题\",{\"1\":{\"72\":1}}],[\"包括字面值和符号引用\",{\"1\":{\"71\":1}}],[\"包括字面值\",{\"1\":{\"68\":1}}],[\"包含数值常量\",{\"1\":{\"66\":1}}],[\"内部节点的顺序是无序的\",{\"1\":{\"446\":1}}],[\"内部节点是有序的吗\",{\"0\":{\"446\":1}}],[\"内部捕获并处理异常\",{\"1\":{\"358\":1}}],[\"内部同时还启动了很多守护线程\",{\"1\":{\"246\":1}}],[\"内部错误\",{\"1\":{\"180\":1}}],[\"内部类持有外部类的引用\",{\"1\":{\"86\":1}}],[\"内存空间不连续\",{\"1\":{\"411\":1}}],[\"内存占用\",{\"1\":{\"411\":1}}],[\"内存位置\",{\"1\":{\"398\":1}}],[\"内存等\",{\"1\":{\"349\":1}}],[\"内存开销\",{\"0\":{\"308\":1}}],[\"内存泄露是怎么回事\",{\"0\":{\"225\":1}}],[\"内存泄漏通常是由于程序中持续保留了不再需要的对象或资源而引起的\",{\"1\":{\"86\":1}}],[\"内存泄漏通常发生在程序中频繁动态分配内存却未及时释放\",{\"1\":{\"84\":1}}],[\"内存泄漏可能由以下几种常见原因导致\",{\"1\":{\"86\":1}}],[\"内存泄漏可能由哪些原因导致呢\",{\"0\":{\"86\":1}}],[\"内存泄漏指的是程序中已经不再使用的内存没有被正确释放\",{\"1\":{\"84\":1}}],[\"内存泄漏\",{\"0\":{\"84\":1},\"1\":{\"84\":1}}],[\"内存系统的重排序\",{\"1\":{\"215\":1}}],[\"内存碎片化问题\",{\"1\":{\"112\":1}}],[\"内存碎片化\",{\"1\":{\"108\":1}}],[\"内存溢出和内存泄漏都是需要注意和及时解决的内存管理问题\",{\"1\":{\"84\":1}}],[\"内存溢出可能会导致程序崩溃\",{\"1\":{\"84\":1}}],[\"内存溢出指的是程序在申请内存时\",{\"1\":{\"84\":1}}],[\"内存溢出\",{\"1\":{\"84\":2}}],[\"内存溢出问题\",{\"1\":{\"74\":1}}],[\"内存分配的方式通常是指针碰撞和空闲列表两种\",{\"1\":{\"79\":1}}],[\"内存分配\",{\"1\":{\"78\":1}}],[\"内存管理\",{\"0\":{\"52\":1},\"1\":{\"132\":1,\"135\":1}}],[\"内容\",{\"1\":{\"66\":1}}],[\"支持随机访问\",{\"1\":{\"411\":1}}],[\"支持高并发操作\",{\"1\":{\"192\":1}}],[\"支持多线程\",{\"1\":{\"147\":1}}],[\"支持超大堆内存\",{\"1\":{\"120\":1}}],[\"支持超大堆\",{\"1\":{\"112\":1,\"115\":1}}],[\"支持hotspot的未来发展\",{\"1\":{\"77\":1}}],[\"支持更多类加载和卸载\",{\"1\":{\"76\":1}}],[\"支持类和方法的运行\",{\"1\":{\"66\":1}}],[\"支持native方法调用\",{\"1\":{\"53\":1}}],[\"数字分析法\",{\"1\":{\"433\":1}}],[\"数字的二进制位左移三位相当于乘以2的三次方\",{\"1\":{\"165\":1}}],[\"数\",{\"1\":{\"252\":1}}],[\"数组+链表+红黑树\",{\"1\":{\"445\":1}}],[\"数组中key和hash一样就直接替换\",{\"1\":{\"444\":1}}],[\"数组中的每个元素称为一个桶\",{\"1\":{\"421\":1}}],[\"数组大小为2的倍数\",{\"1\":{\"431\":1}}],[\"数组大小\",{\"1\":{\"431\":6}}],[\"数组长度\",{\"1\":{\"430\":1}}],[\"数组可能长度100\",{\"1\":{\"414\":1}}],[\"数组满了\",{\"1\":{\"412\":1}}],[\"数组下标越界等等\",{\"1\":{\"180\":1}}],[\"数组\",{\"1\":{\"159\":1,\"421\":2}}],[\"数值型\",{\"1\":{\"159\":1}}],[\"数值常量10存储在运行时常量池中\",{\"1\":{\"65\":1,\"70\":1}}],[\"数百gb到数tb\",{\"1\":{\"120\":1}}],[\"数tb\",{\"1\":{\"112\":1}}],[\"数据拷贝在add方法中进行\",{\"1\":{\"419\":1}}],[\"数据拷贝的过程中\",{\"0\":{\"419\":1}}],[\"数据结构和hashmap是一样的\",{\"1\":{\"445\":1}}],[\"数据结构\",{\"1\":{\"439\":1,\"445\":1}}],[\"数据结构示意图\",{\"1\":{\"421\":1}}],[\"数据结构不同\",{\"1\":{\"411\":1}}],[\"数据结构或者并行计算等技术来优化耗时操作的执行效率\",{\"1\":{\"375\":1}}],[\"数据即使成功修改\",{\"1\":{\"400\":1}}],[\"数据处理通常可以并行化以提高效率\",{\"1\":{\"326\":1}}],[\"数据都已经放入到\",{\"1\":{\"230\":1}}],[\"数据库操作通常是io密集型的\",{\"1\":{\"322\":1}}],[\"数据库驱动\",{\"1\":{\"153\":1}}],[\"数据库连接池\",{\"0\":{\"321\":1}}],[\"数据库连接\",{\"1\":{\"86\":1}}],[\"数据包图\",{\"0\":{\"51\":1}}],[\"类加锁\",{\"1\":{\"378\":1}}],[\"类加载器子系统\",{\"1\":{\"133\":1}}],[\"类加载器会将类文件的常量池中的字面值\",{\"1\":{\"69\":1}}],[\"类加载过程包括加载\",{\"1\":{\"78\":1}}],[\"类加载\",{\"1\":{\"78\":1}}],[\"类自身的构造函数创建两个新的任务对象\",{\"1\":{\"376\":1}}],[\"类的抽象方法\",{\"1\":{\"376\":1}}],[\"类的常见方法\",{\"0\":{\"175\":1}}],[\"类中\",{\"1\":{\"376\":2}}],[\"类中的\",{\"1\":{\"254\":1}}],[\"类继承了\",{\"1\":{\"376\":1}}],[\"类定义了五种线程池状态\",{\"1\":{\"364\":1}}],[\"类变量\",{\"1\":{\"201\":2}}],[\"类名\",{\"1\":{\"169\":1,\"202\":1}}],[\"类可以继承吗\",{\"1\":{\"168\":1}}],[\"类库\",{\"1\":{\"148\":1}}],[\"类型的成员变量\",{\"1\":{\"392\":1}}],[\"类型\",{\"1\":{\"145\":1,\"163\":1,\"187\":2}}],[\"类\",{\"1\":{\"141\":1,\"159\":1,\"258\":2,\"376\":1,\"378\":1,\"416\":1}}],[\"类元数据存储在本地内存中\",{\"1\":{\"76\":1}}],[\"类和接口的符号引用\",{\"1\":{\"65\":1,\"66\":1}}],[\"类图\",{\"0\":{\"30\":1}}],[\"=key\",{\"1\":{\"427\":1}}],[\"=expectedmodcount\",{\"1\":{\"416\":1}}],[\"=128\",{\"0\":{\"173\":1}}],[\"=serviceloader\",{\"1\":{\"153\":2}}],[\"==null\",{\"1\":{\"450\":1}}],[\"==和\",{\"0\":{\"205\":1}}],[\"==\",{\"1\":{\"64\":1,\"205\":2,\"230\":1,\"232\":1,\"359\":1,\"397\":1,\"412\":1,\"427\":9,\"428\":5,\"445\":11,\"450\":1}}],[\"=\",{\"0\":{\"67\":1,\"69\":1,\"170\":2,\"173\":1},\"1\":{\"64\":3,\"65\":2,\"67\":1,\"69\":2,\"70\":2,\"71\":1,\"85\":1,\"89\":1,\"126\":3,\"144\":1,\"145\":6,\"170\":2,\"183\":3,\"201\":1,\"213\":3,\"222\":1,\"228\":2,\"230\":14,\"231\":2,\"232\":6,\"249\":12,\"251\":3,\"253\":3,\"255\":3,\"257\":7,\"259\":1,\"263\":2,\"265\":1,\"269\":1,\"270\":3,\"271\":7,\"273\":1,\"274\":2,\"276\":1,\"277\":1,\"279\":5,\"281\":8,\"284\":1,\"286\":1,\"287\":1,\"288\":2,\"290\":1,\"291\":1,\"292\":1,\"293\":1,\"294\":2,\"302\":4,\"303\":3,\"305\":3,\"320\":3,\"324\":4,\"328\":2,\"332\":1,\"336\":1,\"338\":1,\"339\":1,\"358\":1,\"359\":4,\"360\":3,\"361\":2,\"363\":4,\"373\":12,\"376\":8,\"381\":16,\"397\":3,\"407\":1,\"412\":3,\"427\":17,\"428\":14,\"445\":18,\"450\":3}}],[\"示例代码\",{\"1\":{\"253\":1}}],[\"示例\",{\"0\":{\"279\":1},\"1\":{\"64\":1,\"65\":1}}],[\"则为一个全是1的二进制数\",{\"1\":{\"431\":1}}],[\"则需要把链表转换为红黑树\",{\"1\":{\"427\":1}}],[\"则异常不会抛出\",{\"1\":{\"416\":1}}],[\"则释放已持有的资源\",{\"1\":{\"408\":1}}],[\"则请求者只能等待\",{\"1\":{\"408\":1}}],[\"则以原子方式将引用值和印戳标志的值更新为给定的更新值\",{\"1\":{\"401\":1}}],[\"则调用该方法线程会被放入\",{\"1\":{\"396\":1}}],[\"则这次只是简单地把aqs\",{\"1\":{\"396\":1}}],[\"则当前线程会获取到该锁\",{\"1\":{\"396\":1}}],[\"则当前线程持有该对象锁\",{\"1\":{\"390\":1}}],[\"则\",{\"1\":{\"390\":1}}],[\"则进行\",{\"1\":{\"390\":1}}],[\"则进入步骤\",{\"1\":{\"389\":1}}],[\"则执行\",{\"1\":{\"389\":1,\"390\":1}}],[\"则查看线程id是否为当前线程\",{\"1\":{\"389\":1}}],[\"则直接插入即可\",{\"1\":{\"427\":1}}],[\"则直接撤销偏向锁\",{\"1\":{\"389\":1}}],[\"则直接返回n\",{\"1\":{\"376\":1}}],[\"则直接由核心线程执行任务\",{\"1\":{\"340\":1}}],[\"则将t线程的偏向锁\",{\"1\":{\"389\":1}}],[\"则将markword中线程id设置为当前线程id\",{\"1\":{\"389\":1}}],[\"则将问题拆分成两个子任务\",{\"1\":{\"376\":1}}],[\"则将任务分配给该线程执行\",{\"1\":{\"351\":1}}],[\"则将任务分配给空闲线程执行\",{\"1\":{\"351\":2}}],[\"则将任务放入任务队列等待执行\",{\"1\":{\"340\":1}}],[\"则取消调用并释放资源\",{\"1\":{\"375\":1}}],[\"则线程会被终止\",{\"1\":{\"344\":1}}],[\"则线程会被唤醒\",{\"1\":{\"240\":1}}],[\"则根据设置的拒绝策略处理新任务\",{\"1\":{\"340\":1}}],[\"则创建新的非核心线程执行任务\",{\"1\":{\"340\":1}}],[\"则使用默认的\",{\"1\":{\"294\":1}}],[\"则处于await的线程都会\",{\"1\":{\"252\":1}}],[\"则必\",{\"1\":{\"252\":1}}],[\"则必须重写方法\",{\"1\":{\"200\":1}}],[\"则阻塞\",{\"1\":{\"251\":1}}],[\"则会抛出concurrent\",{\"1\":{\"416\":1}}],[\"则会抛出invalidclassexception异常\",{\"1\":{\"177\":1}}],[\"则会在当前线程栈帧中划出一块空间\",{\"1\":{\"390\":1}}],[\"则会递归调用\",{\"1\":{\"376\":1}}],[\"则会放行\",{\"1\":{\"251\":1}}],[\"则会清除中断标志\",{\"1\":{\"240\":1}}],[\"则该class\",{\"1\":{\"206\":1}}],[\"则它们的\",{\"1\":{\"206\":1}}],[\"则视为重载\",{\"1\":{\"197\":1}}],[\"则是一个\",{\"1\":{\"170\":1}}],[\"则对象可以在栈上分配而不是在堆上\",{\"1\":{\"125\":1}}],[\"则被认为是可回收的垃圾对象\",{\"1\":{\"87\":1}}],[\"则说明该对象不可达\",{\"1\":{\"87\":1}}],[\"则说明对象没有被引用\",{\"1\":{\"87\":1}}],[\"则更新为新值\",{\"1\":{\"81\":1}}],[\"则先执行类加载过程\",{\"1\":{\"78\":1}}],[\"则在池中创建该字符串并返回引用\",{\"1\":{\"64\":1}}],[\"则返回该字符串的引用\",{\"1\":{\"64\":1}}],[\"当多个线程同时进行扩容操作时\",{\"1\":{\"441\":1}}],[\"当多个线程同时执行put操作时\",{\"1\":{\"441\":1}}],[\"当多个线程同时执行\",{\"1\":{\"81\":1}}],[\"当插入新的键值对时\",{\"1\":{\"439\":1}}],[\"当发生哈希碰撞时\",{\"1\":{\"439\":1}}],[\"当哈希冲突较多时\",{\"1\":{\"439\":1}}],[\"当桶中的元素较多时\",{\"1\":{\"421\":1}}],[\"当桶中的元素较少时\",{\"1\":{\"421\":1}}],[\"当且仅当预期值\",{\"1\":{\"398\":1}}],[\"当达到safepoint时获得偏向锁的线程被挂起\",{\"1\":{\"389\":1}}],[\"当系统重新启动时\",{\"1\":{\"374\":1}}],[\"当系统发生断电时\",{\"1\":{\"374\":1}}],[\"当系统内存不足时\",{\"1\":{\"89\":1}}],[\"当单机线程池执行断电时\",{\"1\":{\"374\":1}}],[\"当调用\",{\"1\":{\"366\":1,\"367\":1}}],[\"当前hashmap的元素个数达到一个临界值的时候\",{\"1\":{\"436\":1,\"438\":1}}],[\"当前节点是否为树节点\",{\"1\":{\"428\":1}}],[\"当前节点和key匹配\",{\"1\":{\"428\":1}}],[\"当前\",{\"1\":{\"378\":1}}],[\"当前对象实例的锁\",{\"1\":{\"378\":1}}],[\"当前的唯一线程\",{\"1\":{\"355\":1}}],[\"当前线程执行轻量级锁状态下的锁获取步骤\",{\"1\":{\"389\":1}}],[\"当前线程执行的字节码的行号指示器\",{\"1\":{\"53\":1}}],[\"当前线程是最后一个到达的线程await时\",{\"1\":{\"251\":1}}],[\"当前线程a等待thread线程终止之后才从thread\",{\"1\":{\"247\":1}}],[\"当前线程a等待thread线程终止之后从thread\",{\"1\":{\"240\":1}}],[\"当任务无法被执行时\",{\"1\":{\"345\":3}}],[\"当任务无法被接受执行时的处理策略\",{\"1\":{\"344\":1}}],[\"当核心线程都在忙碌\",{\"1\":{\"344\":1}}],[\"当所有线程都在忙碌时\",{\"1\":{\"299\":1}}],[\"当所有等待线程都被释放后\",{\"1\":{\"251\":1}}],[\"当队列已满时\",{\"1\":{\"296\":1,\"346\":1}}],[\"当队列为空时\",{\"1\":{\"296\":1}}],[\"当线程池中存在一个调用特别耗时的\",{\"1\":{\"375\":1}}],[\"当线程池中的线程数超过核心线程数时\",{\"1\":{\"304\":1}}],[\"当线程池在\",{\"1\":{\"368\":1,\"369\":1}}],[\"当线程取出任务后\",{\"1\":{\"350\":1}}],[\"当线程数超过核心线程数时\",{\"1\":{\"344\":1}}],[\"当线程a运行时\",{\"1\":{\"240\":1}}],[\"当线程需要分配对象时\",{\"1\":{\"80\":1}}],[\"当其它线程读取该共享变量\",{\"1\":{\"219\":1}}],[\"当传递对象引用时\",{\"1\":{\"207\":1}}],[\"当传递基本数据类型\",{\"1\":{\"207\":1}}],[\"当对象被反序列化时\",{\"1\":{\"177\":1}}],[\"当对象被移动时\",{\"1\":{\"83\":1}}],[\"当反序列化时\",{\"1\":{\"177\":1}}],[\"当运算符放在变量之后时\",{\"1\":{\"166\":1}}],[\"当我们定义了\",{\"1\":{\"144\":1}}],[\"当有任务需要执行时\",{\"1\":{\"350\":1}}],[\"当有新任务提交时\",{\"1\":{\"344\":1,\"351\":3}}],[\"当有新的连接请求到达时\",{\"1\":{\"139\":1}}],[\"当有其他线程向队列中添加或取出元素时\",{\"1\":{\"296\":1}}],[\"当有事件触发时\",{\"1\":{\"139\":1}}],[\"当某个通道\",{\"1\":{\"139\":1}}],[\"当方法调用结束时\",{\"1\":{\"124\":1}}],[\"当cms收集器无法获取足够的内存空间时\",{\"1\":{\"108\":1}}],[\"当类加载完成时\",{\"1\":{\"99\":1}}],[\"当迭代年龄达到一定阈值\",{\"1\":{\"97\":1}}],[\"当要进行young\",{\"1\":{\"96\":1}}],[\"当老年代的内存空间不足以容纳新对象\",{\"1\":{\"96\":1}}],[\"当老年代的内存空间不足时\",{\"1\":{\"94\":1}}],[\"当新生代的to区放不下从eden和from区拷贝过来的对象\",{\"1\":{\"96\":1}}],[\"当新生代的survivor区也无法容纳存活对象时\",{\"1\":{\"95\":1}}],[\"当新生代的eden区满时\",{\"1\":{\"94\":1}}],[\"当eden区没有足够的空间来分配新对象时\",{\"1\":{\"95\":1}}],[\"当eden区\",{\"1\":{\"95\":1}}],[\"当eden区满时\",{\"1\":{\"93\":1}}],[\"当然可以\",{\"1\":{\"373\":1}}],[\"当然\",{\"1\":{\"92\":1,\"397\":1}}],[\"当垃圾回收器进行垃圾回收时\",{\"1\":{\"89\":1}}],[\"当引用被移除时\",{\"1\":{\"87\":1}}],[\"当一个大任务到来时\",{\"1\":{\"376\":1}}],[\"当一个任务被提交到线程池后\",{\"1\":{\"340\":1}}],[\"当一个执行中的线程a调用了thread的sleep方法后\",{\"1\":{\"240\":1}}],[\"当一个线程执行put操作导致扩容时\",{\"1\":{\"441\":1}}],[\"当一个线程执行完一个小任务后\",{\"1\":{\"376\":1}}],[\"当一个线程获取了对象的内置锁时\",{\"1\":{\"381\":1}}],[\"当一个线程因为等待某些事件\",{\"1\":{\"245\":1}}],[\"当一个线程的时间片用完时\",{\"1\":{\"245\":1}}],[\"当一个线程调用了\",{\"1\":{\"245\":1}}],[\"当一个线程调用\",{\"1\":{\"240\":1}}],[\"当一个线程a调用一个共享变量的\",{\"1\":{\"240\":1}}],[\"当一个线程开始执行时\",{\"1\":{\"80\":1}}],[\"当一个类的实例被序列化后\",{\"1\":{\"177\":1}}],[\"当一个类被序列化后\",{\"1\":{\"177\":1}}],[\"当一个字符串字面值被创建时\",{\"1\":{\"64\":1}}],[\"当构造函数执行完毕后\",{\"1\":{\"78\":1}}],[\"当创建一个对象时\",{\"1\":{\"78\":1}}],[\"当执行完退出后\",{\"1\":{\"381\":1}}],[\"当执行\",{\"1\":{\"69\":1}}],[\"但hashmap的实际容量是32\",{\"1\":{\"432\":1}}],[\"但同样地\",{\"1\":{\"416\":1}}],[\"但实际只用了50\",{\"1\":{\"414\":1}}],[\"但阻塞\",{\"1\":{\"408\":1}}],[\"但又提出了新的资源请求\",{\"1\":{\"408\":1}}],[\"但如果此时锁刚好可用\",{\"1\":{\"395\":1}}],[\"但如果没有正确管理缓存\",{\"1\":{\"86\":1}}],[\"但需要一些额外的编码工作\",{\"1\":{\"371\":1}}],[\"但并不保证所有任务都能被成功中断\",{\"1\":{\"348\":1}}],[\"但并不能保证在某个时刻被保留\",{\"1\":{\"89\":1}}],[\"但会继续执行已提交的任务和队列中等待的任务\",{\"1\":{\"366\":1}}],[\"但会继续执行已提交的任务\",{\"1\":{\"348\":1}}],[\"但会增加垃圾回收器的复杂度\",{\"1\":{\"92\":1}}],[\"但不会通知调用者\",{\"1\":{\"347\":1}}],[\"但不能通过虚引用获取对象本身\",{\"1\":{\"89\":1}}],[\"但频繁的线程创建和销毁会导致代码路径的变化\",{\"1\":{\"315\":1}}],[\"但在读操作频繁\",{\"1\":{\"418\":1}}],[\"但在空闲时会重用先前创建的线程\",{\"1\":{\"302\":1}}],[\"但在需要更多控制或资源隔离时\",{\"1\":{\"284\":1}}],[\"但在对象不再需要时未能正确注销\",{\"1\":{\"86\":1}}],[\"但你可以指定自定义的线程池来满足特殊需求\",{\"1\":{\"283\":1}}],[\"但还没有调用start\",{\"1\":{\"241\":1}}],[\"但可以通过引用修改对象的状态\",{\"1\":{\"207\":1}}],[\"但只能继承一个抽象类\",{\"1\":{\"200\":1}}],[\"但为了更方便地处理文本数据\",{\"1\":{\"138\":1}}],[\"但为native方法服务\",{\"1\":{\"53\":1}}],[\"但通过逃逸分析技术\",{\"1\":{\"129\":1}}],[\"但存在内存碎片化问题\",{\"1\":{\"120\":1}}],[\"但适合内存使用较小且对gc停顿不敏感的应用\",{\"1\":{\"120\":1}}],[\"但随着时间推移越来越成熟\",{\"1\":{\"112\":1}}],[\"但其内存碎片化\",{\"1\":{\"110\":1}}],[\"但它的性能很低\",{\"1\":{\"417\":1}}],[\"但它们之间有一些细微的差别\",{\"1\":{\"348\":1}}],[\"但它们之间存在一些区别\",{\"1\":{\"347\":1}}],[\"但它们在java虚拟机\",{\"1\":{\"63\":1}}],[\"但它也存在一些局限性和缺点\",{\"1\":{\"107\":1}}],[\"但大部分是并发进行\",{\"1\":{\"103\":1}}],[\"但优化了停顿时间\",{\"1\":{\"103\":1}}],[\"但时间较短\",{\"1\":{\"103\":1}}],[\"但老年代没有足够的内存空间存放这些对象\",{\"1\":{\"96\":1}}],[\"但由于碎片化问题和并发的复杂性\",{\"1\":{\"100\":1}}],[\"但由于其不确定性和性能问题\",{\"1\":{\"90\":1}}],[\"但由于hotspot和jrockit对方法区实现的差异\",{\"1\":{\"75\":1}}],[\"但是就需要更多的空间去存储元素\",{\"1\":{\"437\":1}}],[\"但是如果插入中间的位置\",{\"1\":{\"411\":1}}],[\"但是看到的虽然是a\",{\"1\":{\"400\":1}}],[\"但是公平锁会判断等待队列是否有线程处于等待状态\",{\"1\":{\"397\":1}}],[\"但是jdk6开始\",{\"1\":{\"391\":1}}],[\"但是被检测到不可能存在共享数据竞争的锁进行消除\",{\"1\":{\"387\":1}}],[\"但是不保证不会指令重排\",{\"1\":{\"384\":1}}],[\"但是可以设置超时时间\",{\"1\":{\"249\":1}}],[\"但是线程调度器可以无条件忽略这个暗示\",{\"1\":{\"240\":1}}],[\"但是线程a所拥有的监视器资源\",{\"1\":{\"240\":1}}],[\"但是它不会重新尝试获取锁\",{\"1\":{\"240\":1}}],[\"但是一个时间段内\",{\"1\":{\"235\":1}}],[\"但是threadlocalmap生命周期和thread是一样的\",{\"1\":{\"225\":1}}],[\"但是仍然希望能够反序列化之前的序列化数据\",{\"1\":{\"177\":1}}],[\"但是长整型\",{\"1\":{\"163\":1}}],[\"但是也不要滥用\",{\"1\":{\"141\":1}}],[\"但是并不保证会调用它\",{\"1\":{\"90\":1}}],[\"但是\",{\"1\":{\"87\":1,\"148\":1,\"349\":1,\"387\":1}}],[\"但这增加了内存管理的复杂性\",{\"1\":{\"74\":1}}],[\"物理上存放在堆中\",{\"1\":{\"60\":1,\"61\":1}}],[\"详细变化对比\",{\"0\":{\"58\":1}}],[\"功能特点\",{\"1\":{\"391\":1}}],[\"功能\",{\"1\":{\"220\":3}}],[\"功能基本不变\",{\"1\":{\"57\":1}}],[\"功能链接跳转不对问题\",{\"0\":{\"23\":1}}],[\"字节\",{\"1\":{\"159\":1}}],[\"字节码能够被虚拟机识别\",{\"1\":{\"150\":1}}],[\"字节流通常用于处理文件和网络连接中的数据传输\",{\"1\":{\"138\":1}}],[\"字节流以字节为单位进行输入输出\",{\"1\":{\"138\":1}}],[\"字节流则更适合处理二进制数据\",{\"1\":{\"138\":1}}],[\"字节流\",{\"1\":{\"137\":1,\"138\":1}}],[\"字符型\",{\"1\":{\"159\":1}}],[\"字符流会自动处理字符编码和解码\",{\"1\":{\"138\":1}}],[\"字符流以字符为单位进行输入输出\",{\"1\":{\"138\":1}}],[\"字符流更适合读取和写入文本文件\",{\"1\":{\"138\":1}}],[\"字符流\",{\"1\":{\"137\":1,\"138\":1}}],[\"字符串拼接是如何实现的\",{\"0\":{\"171\":1}}],[\"字符串对象实例\",{\"1\":{\"170\":1}}],[\"字符串的不可变性\",{\"1\":{\"168\":1}}],[\"字符串字面值\",{\"1\":{\"65\":1,\"70\":1}}],[\"字符串常量\",{\"1\":{\"65\":1,\"66\":1}}],[\"字符串常量池的优化\",{\"1\":{\"168\":1}}],[\"字符串常量池被移到java堆\",{\"1\":{\"64\":1}}],[\"字符串常量池被移到java堆中\",{\"1\":{\"56\":1}}],[\"字符串常量池位于永久代\",{\"1\":{\"64\":1}}],[\"字符串常量池和运行时常量池虽然名称相似\",{\"1\":{\"63\":1}}],[\"字符串常量池和运行时常量池有啥区别\",{\"0\":{\"63\":1}}],[\"字符串常量池和运行时常量池继续在java堆中\",{\"1\":{\"62\":1}}],[\"字符串常量池移到java堆中\",{\"1\":{\"60\":1}}],[\"字符串常量池在永久代中\",{\"1\":{\"60\":1}}],[\"字符串常量池\",{\"0\":{\"60\":1,\"64\":1},\"1\":{\"64\":1,\"66\":4,\"71\":1}}],[\"字符串池移出永久代\",{\"1\":{\"56\":1}}],[\"字面值\",{\"1\":{\"69\":1}}],[\"字段引用\",{\"1\":{\"65\":1,\"66\":1}}],[\"字段\",{\"1\":{\"55\":1,\"68\":1,\"157\":1}}],[\"以平衡性能和空间的消耗\",{\"1\":{\"439\":1}}],[\"以atomicinteger的添加方法为例\",{\"1\":{\"407\":1}}],[\"以apache\",{\"1\":{\"324\":1}}],[\"以上代码示例演示了如何使用fork\",{\"1\":{\"376\":1}}],[\"以上是一些常见的垃圾收集算法\",{\"1\":{\"92\":1}}],[\"以适应系统的动态变化和优化性能\",{\"1\":{\"372\":1}}],[\"以满足系统的性能需求和稳定性要求\",{\"1\":{\"372\":1}}],[\"以满足不同应用场景的需求\",{\"1\":{\"305\":1}}],[\"以避免任务被拒绝\",{\"1\":{\"349\":1}}],[\"以避免任务等待时间过长\",{\"1\":{\"349\":1}}],[\"以避免内存泄漏问题的发生\",{\"1\":{\"86\":1}}],[\"以优化线程池的性能和资源利用率\",{\"1\":{\"344\":1}}],[\"以更灵活地控制线程池的行为\",{\"1\":{\"305\":1}}],[\"以及一级缓存\",{\"1\":{\"211\":1}}],[\"以及不写\",{\"0\":{\"198\":1}}],[\"以及无法使用基本类型作为泛型参数等\",{\"1\":{\"188\":1}}],[\"以前\",{\"1\":{\"163\":1}}],[\"以接口的全限定名命名\",{\"1\":{\"153\":1}}],[\"以备后续操作\",{\"1\":{\"139\":1}}],[\"以便更快地停止线程池\",{\"1\":{\"348\":1}}],[\"以便该线程可以继续执行\",{\"1\":{\"244\":1}}],[\"以便选择器可以监听多个通道的事件\",{\"1\":{\"139\":1}}],[\"以便为新对象的分配提供足够的空间\",{\"1\":{\"95\":1}}],[\"以尽量满足这个目标\",{\"1\":{\"109\":1}}],[\"以确保任务的一致性和可靠性\",{\"1\":{\"374\":1}}],[\"以确保线程安全\",{\"1\":{\"417\":1}}],[\"以确保线程池能够始终保持良好的性能和稳定性\",{\"1\":{\"372\":1}}],[\"以确保线程状态的一致性\",{\"1\":{\"312\":1}}],[\"以确保在不同工作负载下的良好表现\",{\"1\":{\"108\":1}}],[\"以确保内存的正确回收和整理\",{\"1\":{\"99\":1}}],[\"以减少停顿时间\",{\"1\":{\"103\":1}}],[\"以减少应用停顿时间\",{\"1\":{\"102\":1}}],[\"以保证任务的一致性和可靠性\",{\"1\":{\"374\":1}}],[\"以保证线程池的性能和稳定性\",{\"1\":{\"349\":1}}],[\"以保证系统的稳定性和可靠性\",{\"1\":{\"345\":1}}],[\"以保证合理的使用公共资源\",{\"1\":{\"253\":1}}],[\"以保证整个堆的空间利用率\",{\"1\":{\"94\":1}}],[\"以保证对象在内存中的起始地址是按照要求对齐的\",{\"1\":{\"82\":1}}],[\"以提高查找\",{\"1\":{\"421\":1,\"439\":1}}],[\"以提高系统的性能和效率\",{\"1\":{\"244\":1}}],[\"以提高性能和节省内存\",{\"1\":{\"168\":1}}],[\"以提高性能\",{\"1\":{\"125\":1}}],[\"以提高整体的垃圾回收效率\",{\"1\":{\"94\":1}}],[\"以提高垃圾回收的效率和内存利用率\",{\"1\":{\"91\":1}}],[\"以提高执行效率\",{\"1\":{\"83\":1}}],[\"以下示例展示如何并行获取多个远程数据源的数据\",{\"1\":{\"281\":1}}],[\"以下对象可以作为gc\",{\"1\":{\"88\":1}}],[\"以下是处理单机线程池断电情况的一般策略\",{\"1\":{\"374\":1}}],[\"以下是线程池状态的转换图\",{\"1\":{\"370\":1}}],[\"以下是线程池在各种工作场景中的一些典型应用\",{\"1\":{\"316\":1}}],[\"以下是详细的线程池状态\",{\"1\":{\"364\":1}}],[\"以下是常见的线程池拒绝策略\",{\"1\":{\"345\":1}}],[\"以下是如何设置和使用自定义线程池的详细指南\",{\"1\":{\"283\":1}}],[\"以下是一些处理线程池异常的常见方法和技巧\",{\"1\":{\"357\":1}}],[\"以下是一些大公司和常见应用场景中使用的垃圾收集器及其原因\",{\"1\":{\"111\":1}}],[\"以下是一个使用调度线程池执行定时任务的示例\",{\"1\":{\"336\":1}}],[\"以下是一个使用线程池执行异步任务的示例\",{\"1\":{\"332\":1}}],[\"以下是一个使用线程池并行处理数据块的示例\",{\"1\":{\"328\":1}}],[\"以下是一个使用线程池处理http请求的简单示例\",{\"1\":{\"320\":1}}],[\"以下是一个使用固定大小线程池执行多个任务的示例\",{\"1\":{\"303\":1}}],[\"以下是一个完整的示例\",{\"1\":{\"288\":1}}],[\"以下是一个简单的线程池的设计和实现\",{\"1\":{\"373\":1}}],[\"以下是一个简单的\",{\"1\":{\"257\":1}}],[\"以下是选择gc时需要考虑的几个关键因素和常见的垃圾收集器选项\",{\"1\":{\"118\":1}}],[\"以下是引入g1垃圾收集器的主要原因\",{\"1\":{\"107\":1}}],[\"以下是它们的主要区别\",{\"1\":{\"63\":1}}],[\"以下是jdk\",{\"1\":{\"54\":1}}],[\"以节省内存\",{\"1\":{\"66\":1}}],[\"以解决permgen空间不足的问题\",{\"1\":{\"56\":1}}],[\"如使用synchronized关键字或lock\",{\"1\":{\"417\":1}}],[\"如getandincrement\",{\"1\":{\"406\":1}}],[\"如google\",{\"1\":{\"116\":1}}],[\"如atomicboolean\",{\"1\":{\"406\":1}}],[\"如arrayblockingqueue\",{\"1\":{\"344\":1}}],[\"如reentrantlock\",{\"1\":{\"405\":1,\"442\":1}}],[\"如何做到的\",{\"1\":{\"408\":1}}],[\"如何保证多线程下i++\",{\"0\":{\"405\":1}}],[\"如何解决\",{\"0\":{\"399\":1}}],[\"如何判断对象仍然存活\",{\"0\":{\"87\":1}}],[\"如等待可中断\",{\"1\":{\"391\":1}}],[\"如增加了适应性自旋\",{\"1\":{\"387\":1}}],[\"如哈希码\",{\"1\":{\"386\":1}}],[\"如线程池过载\",{\"1\":{\"372\":1}}],[\"如监控\",{\"1\":{\"371\":1}}],[\"如网络请求\",{\"1\":{\"349\":1}}],[\"如linkedblockingqueue\",{\"1\":{\"344\":1}}],[\"如无空闲核心线程则将任务加入队列\",{\"1\":{\"343\":1}}],[\"如创建新线程\",{\"1\":{\"299\":1}}],[\"如数组或者链表\",{\"1\":{\"296\":1}}],[\"如数据库连接池\",{\"1\":{\"253\":1}}],[\"如数据处理系统和大规模微服务架构\",{\"1\":{\"112\":1}}],[\"如提高性能或控制资源使用\",{\"1\":{\"283\":1}}],[\"如双缓冲区交换\",{\"1\":{\"256\":1}}],[\"如生产者和消费者模式中的数据交换\",{\"1\":{\"256\":1}}],[\"如控制多个线程对某个资源的访问\",{\"1\":{\"253\":1}}],[\"如限制同时处理的请求数量\",{\"1\":{\"253\":1}}],[\"如再次await\",{\"1\":{\"251\":1}}],[\"如i\",{\"1\":{\"245\":1}}],[\"如int\",{\"1\":{\"207\":1}}],[\"如int类型的0\",{\"1\":{\"78\":1}}],[\"如上图所示\",{\"1\":{\"229\":1}}],[\"如synchronized关键字\",{\"1\":{\"214\":3}}],[\"如锁\",{\"1\":{\"212\":1}}],[\"如hessian\",{\"1\":{\"178\":1}}],[\"如拼接\",{\"1\":{\"168\":1}}],[\"如\",{\"1\":{\"148\":1}}],[\"如jaxb\",{\"1\":{\"178\":1}}],[\"如jackson\",{\"1\":{\"178\":1}}],[\"如java\",{\"1\":{\"75\":1}}],[\"如jvisualvm\",{\"1\":{\"121\":1}}],[\"如批处理\",{\"1\":{\"119\":1}}],[\"如金融交易\",{\"1\":{\"119\":1}}],[\"如银行\",{\"1\":{\"116\":1}}],[\"如实时系统\",{\"1\":{\"112\":1,\"119\":1}}],[\"如web服务器和交易系统\",{\"1\":{\"112\":1}}],[\"如启动阈值\",{\"1\":{\"108\":1}}],[\"如通过\",{\"1\":{\"102\":1}}],[\"如内存碎片化问题和某些情况下的长停顿时间\",{\"1\":{\"100\":1}}],[\"如大数组或长字符串\",{\"1\":{\"97\":1}}],[\"如全局变量\",{\"1\":{\"97\":1}}],[\"如永久代\",{\"1\":{\"94\":1}}],[\"如垃圾收集时\",{\"1\":{\"83\":1}}],[\"如32位或64位jvm\",{\"1\":{\"78\":1}}],[\"如字符串常量池中的字符串对象\",{\"1\":{\"88\":1}}],[\"如字符串常量池\",{\"1\":{\"75\":1}}],[\"如类\",{\"1\":{\"68\":1}}],[\"如整数\",{\"1\":{\"68\":1}}],[\"如果都不满足\",{\"1\":{\"445\":1}}],[\"如果hash==moved\",{\"1\":{\"445\":1}}],[\"如果正在初始化或者扩容\",{\"1\":{\"445\":1}}],[\"如果数组是空的话\",{\"1\":{\"445\":1}}],[\"如果获取锁失败则尝试自旋\",{\"1\":{\"444\":1}}],[\"如果计算出来的索引位置相同\",{\"1\":{\"441\":1}}],[\"如果计数器为零\",{\"1\":{\"87\":1}}],[\"如果初始化hashmap\",{\"0\":{\"432\":1}}],[\"如果链表中插入节点的时候\",{\"1\":{\"427\":1}}],[\"如果写操作频繁或对实时性要求较高\",{\"1\":{\"418\":1}}],[\"如果集合发生变化时修改modcount值刚好又设置为了expectedmodcount值\",{\"1\":{\"416\":1}}],[\"如果超过一定时间没有获取到资源\",{\"1\":{\"408\":1}}],[\"如果申请不到\",{\"1\":{\"408\":1}}],[\"如果此时还有其它线程请求获取获取该资源\",{\"1\":{\"408\":1}}],[\"如果对应下标正好没有存放数据\",{\"1\":{\"427\":1}}],[\"如果对多个变量操作时\",{\"1\":{\"404\":1}}],[\"如果对象不会逃逸并且可以分解为多个标量变量\",{\"1\":{\"125\":1}}],[\"如果一直循环执行\",{\"1\":{\"402\":1}}],[\"如果一个线程a执行了thread\",{\"1\":{\"240\":1,\"247\":1}}],[\"如果一个操作happens\",{\"1\":{\"216\":1}}],[\"如果一个对象具有强引用\",{\"1\":{\"89\":1}}],[\"如果全部相等\",{\"1\":{\"401\":1}}],[\"如果相等\",{\"1\":{\"398\":1}}],[\"如果发现锁这个时候被释放了\",{\"1\":{\"397\":1}}],[\"如果发现老年代可用的连续内存空间小于新生代历次young\",{\"1\":{\"96\":1}}],[\"如果这个时候恰巧锁没有被占用\",{\"1\":{\"397\":1}}],[\"如果锁当前没有被其它线程占用\",{\"1\":{\"396\":1}}],[\"如果共享资源被占用\",{\"1\":{\"392\":1}}],[\"如果成功\",{\"1\":{\"390\":1}}],[\"如果竞争成功\",{\"1\":{\"389\":1}}],[\"如果n的值小于等于1\",{\"1\":{\"376\":1}}],[\"如果需要有序的存储和遍历元素\",{\"1\":{\"446\":1}}],[\"如果需要继续拆分任务\",{\"1\":{\"376\":1}}],[\"如果需要低停顿时间和大堆内存支持\",{\"1\":{\"117\":1}}],[\"如果\",{\"1\":{\"376\":1}}],[\"如果是则进行扩容操作\",{\"1\":{\"427\":1}}],[\"如果是则执行\",{\"1\":{\"390\":1}}],[\"如果是可偏向状态\",{\"1\":{\"389\":1}}],[\"如果是\",{\"1\":{\"376\":1,\"389\":1}}],[\"如果调用超过预设的时间仍未返回结果\",{\"1\":{\"375\":1}}],[\"如果测试发现线程池存在性能瓶颈或者稳定性问题\",{\"1\":{\"372\":1}}],[\"如果你的任务执行时间较长\",{\"1\":{\"349\":1}}],[\"如果你的任务是i\",{\"1\":{\"349\":1}}],[\"如果你的任务是cpu密集型的\",{\"1\":{\"349\":1}}],[\"如果任务被拒绝执行\",{\"1\":{\"361\":1}}],[\"如果任务队列容量较大\",{\"1\":{\"349\":1}}],[\"如果任务队列容量较小\",{\"1\":{\"349\":1}}],[\"如果任务队列已满且线程数未达到最大线程数\",{\"1\":{\"340\":1}}],[\"如果任务抛出了异常\",{\"1\":{\"347\":1}}],[\"如果任务抛出了未捕获的异常\",{\"1\":{\"347\":1}}],[\"如果任务执行完成且当前线程数超过核心线程数\",{\"1\":{\"341\":1}}],[\"如果线程a遍历过程中\",{\"1\":{\"416\":1}}],[\"如果线程a执行操作threadb\",{\"1\":{\"216\":2}}],[\"如果线程调用了\",{\"1\":{\"381\":1}}],[\"如果线程执行完任务\",{\"1\":{\"353\":1}}],[\"如果线程正在执行任务\",{\"1\":{\"351\":1}}],[\"如果线程池中的线程空闲\",{\"1\":{\"351\":1}}],[\"如果线程池中的线程都在执行任务\",{\"1\":{\"351\":2}}],[\"如果线程池中有空闲的线程\",{\"1\":{\"351\":2}}],[\"如果线程池无法接受新任务\",{\"1\":{\"345\":1}}],[\"如果线程数等于核心线程\",{\"1\":{\"353\":1}}],[\"如果线程数少于核心线程\",{\"1\":{\"353\":1}}],[\"如果线程数过多\",{\"1\":{\"349\":1}}],[\"如果线程数已达到最大线程数且任务队列已满\",{\"1\":{\"340\":1}}],[\"如果线程空闲时间超过该值\",{\"1\":{\"344\":1}}],[\"如果线程在等待交换数据时被中断\",{\"1\":{\"259\":1}}],[\"如果线程在等待许可时被中断\",{\"1\":{\"255\":1}}],[\"如果某\",{\"1\":{\"252\":1}}],[\"如果某个线程遇到了中\",{\"1\":{\"252\":1}}],[\"如果某个线程在等待时被中断\",{\"1\":{\"251\":1}}],[\"如果某个对象无法通过任何引用链与gc\",{\"1\":{\"87\":1}}],[\"如果使用带超时参数的\",{\"1\":{\"251\":1}}],[\"如果等待时间到期而线程没有获取到锁\",{\"1\":{\"240\":1}}],[\"如果直接调用thread的run\",{\"1\":{\"238\":1}}],[\"如果父线程的\",{\"1\":{\"232\":1}}],[\"如果执行完启发式清理工作后\",{\"1\":{\"230\":1}}],[\"如果我们插入一个value=27的数据\",{\"1\":{\"229\":1}}],[\"如果将threadlocal实例作为强引用存储在threadlocalmap中\",{\"1\":{\"227\":1}}],[\"如果将对象添加到静态集合中\",{\"1\":{\"86\":1}}],[\"如果threadlocal\",{\"1\":{\"225\":1}}],[\"如果try块中的代码导致了线程死锁\",{\"1\":{\"182\":1}}],[\"如果try块中的代码导致了无限循环或无限递归\",{\"1\":{\"182\":1}}],[\"如果操作之间不存在数据依赖关系\",{\"1\":{\"217\":1}}],[\"如果a\",{\"1\":{\"216\":1}}],[\"如果重排序之后的执行结果\",{\"1\":{\"216\":1}}],[\"如果没有\",{\"1\":{\"355\":1}}],[\"如果没有空闲线程\",{\"1\":{\"354\":1}}],[\"如果没有空闲线程可用\",{\"1\":{\"346\":1}}],[\"如果没有空闲的核心线程且任务队列未满\",{\"1\":{\"340\":1}}],[\"如果没有可用许可\",{\"1\":{\"254\":1}}],[\"如果没有重写\",{\"1\":{\"206\":1}}],[\"如果没有则会在常量池中创建\",{\"1\":{\"170\":1}}],[\"如果两个对象根据\",{\"1\":{\"206\":1}}],[\"如果同时实现两个接口\",{\"1\":{\"200\":1}}],[\"如果新版本的类和旧版本的类具有相同的serialversionuid\",{\"1\":{\"177\":1}}],[\"如果新生代仍有大量对象存活\",{\"1\":{\"97\":1}}],[\"如果不相等\",{\"1\":{\"398\":1}}],[\"如果不是\",{\"1\":{\"390\":1}}],[\"如果不一致\",{\"1\":{\"177\":1,\"229\":1}}],[\"如果不存在数据依赖性\",{\"1\":{\"215\":1}}],[\"如果不存在\",{\"1\":{\"64\":1}}],[\"如果后续对该类进行了修改\",{\"1\":{\"177\":1}}],[\"如果整型字面量的值在\",{\"1\":{\"173\":1}}],[\"如果当前数组位置是空则直接通过cas自旋写入数据\",{\"1\":{\"445\":1}}],[\"如果当前线程之前己经获取过该锁\",{\"1\":{\"396\":1}}],[\"如果当前线程是最后一个到达的线程\",{\"1\":{\"251\":1}}],[\"如果当前线程正在执行的是本地方法\",{\"1\":{\"53\":1}}],[\"如果当前字符串内容存在于字符串常量池\",{\"1\":{\"172\":1}}],[\"如果拼接多次\",{\"1\":{\"171\":1}}],[\"如果字符串常量池已经有\",{\"1\":{\"170\":1}}],[\"如果有则不去抢锁\",{\"1\":{\"397\":1}}],[\"如果有则直接使用\",{\"1\":{\"170\":1}}],[\"如果有\",{\"1\":{\"354\":1,\"355\":1}}],[\"如果有空闲的核心线程\",{\"1\":{\"340\":1}}],[\"如果有一个线程没有配对线程来交换数据\",{\"1\":{\"259\":1}}],[\"如果有一批对象需要放入老年代\",{\"1\":{\"96\":1}}],[\"如果有些变量不想序列化\",{\"1\":{\"177\":1}}],[\"如果通过逃逸分析确定对象不会逃逸到多个线程中\",{\"1\":{\"125\":1}}],[\"如果通过逃逸分析确定对象不会逃逸出当前方法\",{\"1\":{\"125\":1}}],[\"如果在这期间\",{\"1\":{\"354\":1}}],[\"如果在后续的版本中对该类进行了修改\",{\"1\":{\"177\":1}}],[\"如果在cms的并发阶段内没有足够的空闲内存\",{\"1\":{\"108\":1}}],[\"如果在survivor空间中相同年龄所有对象大小的总和大于survivor空间的一半\",{\"1\":{\"97\":1}}],[\"如果方法区由永久代实现\",{\"1\":{\"96\":1}}],[\"如果堆中包含大量对象\",{\"1\":{\"92\":1}}],[\"如果回收后还是没有足够的内存\",{\"1\":{\"89\":1}}],[\"如果内部类持有对外部类的引用\",{\"1\":{\"86\":1}}],[\"如果期望值与当前值一致\",{\"1\":{\"81\":1}}],[\"如果该锁己经被其他线程持有\",{\"1\":{\"396\":1}}],[\"如果该区域空间不足\",{\"1\":{\"80\":1}}],[\"如果该类尚未加载\",{\"1\":{\"78\":1}}],[\"如果存在锁竞争\",{\"1\":{\"387\":1}}],[\"如果存在\",{\"1\":{\"64\":1}}],[\"如运行时常量池\",{\"1\":{\"56\":1}}],[\"部分数据\",{\"1\":{\"75\":1}}],[\"部分数据迁移到堆中\",{\"1\":{\"56\":1}}],[\"部署图\",{\"0\":{\"44\":1}}],[\"实际上就是相当于每个segment都是一个hashmap\",{\"1\":{\"444\":1}}],[\"实际上是存储在栈中的\",{\"1\":{\"69\":1}}],[\"实际直接使用两个流\",{\"1\":{\"415\":1}}],[\"实际就是在暗示线程调度器当前线程请求让出自己的cpu\",{\"1\":{\"240\":1}}],[\"实际是操作自己本地内存里面的变量\",{\"1\":{\"222\":1}}],[\"实际的线程工作模型如下图所示\",{\"1\":{\"211\":1}}],[\"实例⽅法\",{\"1\":{\"202\":1}}],[\"实例方法呢\",{\"0\":{\"202\":1}}],[\"实例变量即对象变量\",{\"1\":{\"201\":1}}],[\"实例变量存储在堆内存中\",{\"1\":{\"201\":1}}],[\"实例变量是每个对象独有的\",{\"1\":{\"201\":1}}],[\"实例变量\",{\"1\":{\"201\":1,\"202\":1}}],[\"实例化对应的服务提供者对象\",{\"1\":{\"153\":1}}],[\"实例数据存储了对象的成员变量值\",{\"1\":{\"82\":1}}],[\"实例数据\",{\"1\":{\"82\":2}}],[\"实现的\",{\"1\":{\"450\":1}}],[\"实现的原理是int\",{\"1\":{\"173\":1}}],[\"实现arraylist线程安全有哪几种方法\",{\"0\":{\"417\":1}}],[\"实现i++原子操作\",{\"1\":{\"405\":1}}],[\"实现了多线程环境下的线程安全\",{\"1\":{\"296\":1}}],[\"实现了服务接口的具体类\",{\"1\":{\"153\":1}}],[\"实现重复利用\",{\"1\":{\"252\":1}}],[\"实现一个线程修改一个对象的值\",{\"1\":{\"247\":1}}],[\"实现callable接口\",{\"1\":{\"237\":2}}],[\"实现runnable接口\",{\"1\":{\"237\":1}}],[\"实现类和实例不能调用静态方法\",{\"1\":{\"200\":1}}],[\"实现接⼝并覆盖接⼝中同⼀⽅法\",{\"1\":{\"196\":1}}],[\"实现数据的持久化和\",{\"1\":{\"177\":1}}],[\"实现serializable接口的类可以将对象转换为字节流进行传输和存储\",{\"1\":{\"177\":1}}],[\"实现服务接口\",{\"1\":{\"153\":1}}],[\"实现原理\",{\"1\":{\"149\":1}}],[\"实现和管理机制上的不同\",{\"1\":{\"66\":1}}],[\"实现\",{\"1\":{\"55\":1,\"64\":1,\"65\":1,\"200\":1,\"237\":1,\"443\":2}}],[\"实体关系图\",{\"0\":{\"32\":1}}],[\"用vector代替arraylist\",{\"1\":{\"417\":1}}],[\"用\",{\"1\":{\"239\":1,\"252\":1}}],[\"用来保存objectwaiter\",{\"1\":{\"381\":1}}],[\"用来做用户信息上下文的存储\",{\"1\":{\"223\":1}}],[\"用来表示对象的唯一标识\",{\"1\":{\"206\":1}}],[\"用this来区分\",{\"1\":{\"199\":1}}],[\"用最有效率的方法计算2乘以8\",{\"0\":{\"165\":1}}],[\"用户线程\",{\"1\":{\"246\":1}}],[\"用户程序的状态是可预期的\",{\"1\":{\"99\":1}}],[\"用户旅程图\",{\"0\":{\"33\":1}}],[\"用尽时才会竞争堆内存\",{\"1\":{\"81\":1}}],[\"用元空间\",{\"1\":{\"72\":1}}],[\"用途\",{\"1\":{\"66\":1}}],[\"用于实现多线程环境下的同步操作\",{\"1\":{\"398\":1}}],[\"用于计算斐波那契数列的值\",{\"1\":{\"376\":1}}],[\"用于并发执行大量短期的小任务\",{\"1\":{\"354\":1}}],[\"用于创建新线程的工厂\",{\"1\":{\"344\":1}}],[\"用于指定keepalivetime的时间单位\",{\"1\":{\"344\":1}}],[\"用于获取任务的执行结果\",{\"1\":{\"339\":1}}],[\"用于其堆栈空间和线程本地存储\",{\"1\":{\"308\":1}}],[\"用于保存等待执行的任务\",{\"1\":{\"304\":1}}],[\"用于为异步操作设定超时\",{\"1\":{\"276\":1}}],[\"用于等待所有给定的\",{\"1\":{\"271\":1}}],[\"用于将两个独立的\",{\"1\":{\"270\":1}}],[\"用于在多线程环境下保证共享变量的操作是原子性的\",{\"1\":{\"406\":1}}],[\"用于在超时时返回默认值\",{\"1\":{\"277\":1}}],[\"用于在异步任务完成或发生异常时对结果进行处理\",{\"1\":{\"274\":1}}],[\"用于在异步任务发生异常时提供一个默认值\",{\"1\":{\"273\":1}}],[\"用于在一个\",{\"1\":{\"269\":1}}],[\"用于在任务完成后执行一个没有返回值的操作\",{\"1\":{\"267\":1}}],[\"用于在任务完成后\",{\"1\":{\"265\":1,\"266\":1}}],[\"用于在编译时期提供类型安全的参数化类型\",{\"1\":{\"185\":1}}],[\"用于执行fork\",{\"1\":{\"376\":1}}],[\"用于执行没有返回值的异步任务\",{\"1\":{\"263\":1}}],[\"用于执行有返回值的异步任务\",{\"1\":{\"263\":1}}],[\"用于处理异步任务的结果和执行流程\",{\"1\":{\"261\":1}}],[\"用于描述多线程环境下的内存访问行为\",{\"1\":{\"212\":1}}],[\"用于修饰变量\",{\"1\":{\"204\":1}}],[\"用于标识类可以被序列化\",{\"1\":{\"177\":1}}],[\"用于表示一个值可能存在或不存在\",{\"1\":{\"141\":1}}],[\"用于确定对象的作用域\",{\"1\":{\"125\":1}}],[\"用于记录元素的插入顺序或访问顺序\",{\"1\":{\"447\":1}}],[\"用于记录对象内的偏移量上存储的数据类型\",{\"1\":{\"99\":1}}],[\"用于记录当前线程执行的字节码行号\",{\"1\":{\"55\":1}}],[\"用于存放类的元数据\",{\"1\":{\"91\":1}}],[\"用于存放新创建的对象\",{\"1\":{\"91\":1,\"93\":1}}],[\"用于存储等待执行的任务的队列\",{\"1\":{\"344\":1}}],[\"用于存储元素\",{\"1\":{\"296\":1}}],[\"用于存储线程局部变量的值\",{\"1\":{\"227\":1}}],[\"用于存储类加载后所需的各种常量和符号引用\",{\"1\":{\"66\":1}}],[\"用于存储类元数据\",{\"1\":{\"62\":1}}],[\"用于存储类结构\",{\"1\":{\"55\":1}}],[\"用于存储局部变量\",{\"1\":{\"55\":1}}],[\"用于存储对象实例\",{\"1\":{\"55\":1}}],[\"用于线程独立地分配对象\",{\"1\":{\"80\":1}}],[\"用于替代永久代\",{\"1\":{\"57\":1}}],[\"用于支持native方法的执行\",{\"1\":{\"55\":1}}],[\"中会将竞争共享资源失败的线程添加到队列中\",{\"1\":{\"392\":1}}],[\"中断处理\",{\"1\":{\"259\":1}}],[\"中断\",{\"1\":{\"255\":1}}],[\"中断线程\",{\"1\":{\"240\":1}}],[\"中了\",{\"1\":{\"230\":1}}],[\"中所有的\",{\"1\":{\"230\":1}}],[\"中有两种形式可以实现多态\",{\"1\":{\"196\":1}}],[\"中异常层级结构\",{\"0\":{\"180\":1}}],[\"中引入了枚举类型\",{\"1\":{\"163\":1}}],[\"中文翻译为\",{\"1\":{\"145\":1}}],[\"中字符串开头为\",{\"1\":{\"145\":1}}],[\"中间可能发生了a变b\",{\"1\":{\"400\":1}}],[\"中间操作\",{\"1\":{\"145\":1}}],[\"中间有一个指针作为分界点指示器\",{\"1\":{\"79\":1}}],[\"中通道的读写事件\",{\"1\":{\"139\":1}}],[\"中等到大堆内存\",{\"1\":{\"120\":2}}],[\"中小型web应用\",{\"1\":{\"116\":1}}],[\"中一种相对现代的垃圾收集器\",{\"1\":{\"101\":1}}],[\"中一种用于提高多线程并发性能的技术\",{\"1\":{\"80\":1}}],[\"中用于垃圾收集的一种算法\",{\"1\":{\"100\":1}}],[\"中常见的垃圾收集器包括\",{\"1\":{\"98\":1}}],[\"中分配内存\",{\"1\":{\"81\":1}}],[\"中的⽅法\",{\"1\":{\"450\":1}}],[\"中的一个同步辅助类\",{\"1\":{\"256\":1}}],[\"中的线程中断是一种线程间的协作模式\",{\"1\":{\"240\":1}}],[\"中的集合类\",{\"1\":{\"206\":1}}],[\"中的本地变量表和操作栈中的引用\",{\"1\":{\"88\":1}}],[\"中的\",{\"1\":{\"71\":1}}],[\"中的用途和实现方式有所不同\",{\"1\":{\"63\":1}}],[\"中提取\",{\"1\":{\"65\":1}}],[\"中\",{\"0\":{\"137\":1},\"1\":{\"54\":1,\"69\":1,\"79\":1,\"81\":1,\"139\":1,\"145\":2,\"163\":1,\"211\":1,\"381\":1,\"446\":1,\"448\":1}}],[\"与消费者交换数据\",{\"1\":{\"257\":1}}],[\"与\",{\"1\":{\"240\":1}}],[\"与按happens\",{\"1\":{\"216\":1}}],[\"与异常类型更没关系\",{\"1\":{\"197\":1}}],[\"与返回值和修饰符无关\",{\"1\":{\"197\":1}}],[\"与分代垃圾回收协同工作\",{\"1\":{\"76\":1}}],[\"与元空间\",{\"0\":{\"59\":1}}],[\"与java栈类似\",{\"1\":{\"53\":1}}],[\"与线程相同\",{\"1\":{\"53\":3}}],[\"它实现线程安全的关键点在于put流程\",{\"1\":{\"445\":1}}],[\"它实际上不存储任何元素\",{\"1\":{\"346\":1}}],[\"它会怎么处理\",{\"0\":{\"432\":1}}],[\"它会在等待队列中等待\",{\"1\":{\"240\":1}}],[\"它使用\",{\"1\":{\"413\":1}}],[\"它使得java具有跨平台特性\",{\"1\":{\"131\":1}}],[\"它没有实现randmoaccess\",{\"1\":{\"411\":1}}],[\"它没有上下文切换的额外开销成本\",{\"1\":{\"219\":1}}],[\"它也实现了randmoaccess\",{\"1\":{\"411\":1}}],[\"它去其它线程的队列里窃取一个任务来执行\",{\"1\":{\"376\":1}}],[\"它提供了更加灵活的异常处理方式\",{\"1\":{\"362\":1}}],[\"它提供了一种简洁而强大的方式来处理异步操作\",{\"1\":{\"261\":1}}],[\"它不存储任务\",{\"1\":{\"346\":1}}],[\"它不能⽤于创建新程序\",{\"1\":{\"148\":1}}],[\"它基于数组实现\",{\"1\":{\"346\":1}}],[\"它基于链表实现\",{\"1\":{\"346\":1}}],[\"它和countdownlatch类似\",{\"1\":{\"250\":1}}],[\"它要做的事情是\",{\"1\":{\"250\":1}}],[\"它主要用于线程之间的数据传输\",{\"1\":{\"247\":1}}],[\"它主要确保多个线程在同一个时刻\",{\"1\":{\"247\":1}}],[\"它保证了线程对变量访问的可见性和排他性\",{\"1\":{\"247\":1}}],[\"它能保证所有线程对变量访问的可见性\",{\"1\":{\"247\":1}}],[\"它能够创建和编译程序\",{\"1\":{\"148\":1}}],[\"它能够统计\",{\"1\":{\"145\":1}}],[\"它能够运行以字节码\",{\"1\":{\"131\":1}}],[\"它还提供了自定义初始化方法和支持传递不可序列化对象的功能\",{\"1\":{\"233\":1}}],[\"它就会新增\",{\"1\":{\"228\":1}}],[\"它这时候如果不被回收\",{\"1\":{\"225\":1}}],[\"它只是作为一个key来让线程往threadlocalmap里存取值\",{\"1\":{\"224\":1}}],[\"它确保在不同的编译器和不同的处理器平台之上\",{\"1\":{\"215\":1}}],[\"它属于类\",{\"1\":{\"202\":1}}],[\"它可以被用作map的键\",{\"1\":{\"168\":1}}],[\"它存储了所有字符串字面量的唯一实例\",{\"1\":{\"168\":1}}],[\"它真正的功能实现就是利用反射\",{\"1\":{\"156\":1}}],[\"它允许多个线程在队列为空或者队列已满时进行阻塞等待\",{\"1\":{\"296\":1}}],[\"它允许第三方组件在不修改源代码的情况下\",{\"1\":{\"153\":1}}],[\"它允许在对象被回收之前执行一些特定的清理工作\",{\"1\":{\"90\":1}}],[\"它拥有\",{\"1\":{\"148\":1}}],[\"它适用于现代大内存和多处理器的环境\",{\"1\":{\"106\":1}}],[\"它决定了当老年代使用率达到多少时\",{\"1\":{\"100\":1}}],[\"它通过哈希函数将键映射到桶\",{\"1\":{\"446\":1}}],[\"它通过在修改时创建副本来实现并发访问\",{\"1\":{\"417\":1}}],[\"它通过在java线程运行的情况下执行并发标记\",{\"1\":{\"98\":1}}],[\"它通过协调各个线程\",{\"1\":{\"253\":1}}],[\"它通过加载\",{\"1\":{\"135\":1}}],[\"它通过并发标记和并发清除来实现低停顿时间的垃圾收集\",{\"1\":{\"98\":1}}],[\"它将堆内存划分为多个区域\",{\"1\":{\"98\":1}}],[\"它关注的是吞吐量\",{\"1\":{\"98\":1}}],[\"它是可重入的独占锁\",{\"1\":{\"393\":1}}],[\"它是可以在指定\",{\"1\":{\"241\":1}}],[\"它是java并发包的根基\",{\"1\":{\"392\":1}}],[\"它是斐波那契数\",{\"1\":{\"228\":1}}],[\"它是功能⻬全的\",{\"1\":{\"148\":1}}],[\"它是运⾏已编译\",{\"1\":{\"148\":1}}],[\"它是单线程的收集器\",{\"1\":{\"98\":1}}],[\"它是线程私有的\",{\"1\":{\"53\":1}}],[\"它们在空间占用上都有一些额外的消耗\",{\"1\":{\"411\":1}}],[\"它们提供了一种更高效的线程安全机制\",{\"1\":{\"406\":1}}],[\"它们会访问同一个队列\",{\"1\":{\"376\":1}}],[\"它们会竞争堆内存的分配\",{\"1\":{\"81\":1}}],[\"它们是处理数据的底层工具\",{\"1\":{\"138\":1}}],[\"它们表示不同类型的垃圾回收操作\",{\"1\":{\"94\":1}}],[\"它们之间会进行对象的交换\",{\"1\":{\"93\":1}}],[\"它们仍然会被集合保留\",{\"1\":{\"86\":1}}],[\"它的名字叫\",{\"1\":{\"418\":1}}],[\"它的compareandset方法首先检查当前的对象引用值是否等于预期引用\",{\"1\":{\"401\":1}}],[\"它的原理是遍历线程池中的工作线程\",{\"1\":{\"348\":1}}],[\"它的主要应用场景包括\",{\"1\":{\"256\":1}}],[\"它的生命周期与程序的生命周期相同\",{\"1\":{\"201\":1}}],[\"它的方法没有使用synchronized关键字进行同步\",{\"1\":{\"169\":1}}],[\"它的值可以被修改\",{\"1\":{\"169\":1}}],[\"它的返回类型是\",{\"1\":{\"145\":1}}],[\"它的工作过程可以分为以下几个阶段\",{\"1\":{\"100\":1}}],[\"它的目标是清理新生代中的垃圾对象\",{\"1\":{\"95\":1}}],[\"它的作用在于减少线程间因为对象分配而频繁竞争内存分配的情况\",{\"1\":{\"80\":1}}],[\"它的一部分也被称为永久代\",{\"1\":{\"53\":1}}],[\"它相对于指针碰撞更加灵活\",{\"1\":{\"79\":1}}],[\"它在运行时查找并加载meta\",{\"1\":{\"153\":1}}],[\"它在系统即将发生内存溢出之前\",{\"1\":{\"89\":1}}],[\"它在方法调用时存储在当前线程的java栈的当前栈帧中\",{\"1\":{\"69\":1}}],[\"它在编译时会被存储在类文件的常量池中\",{\"1\":{\"69\":1}}],[\"它包含类中所有字面值和符号引用\",{\"1\":{\"65\":1}}],[\"这块结构会随着锁的状态变化而变化\",{\"1\":{\"386\":1}}],[\"这块内存空间包括三个主要部分\",{\"1\":{\"82\":1}}],[\"这包括调整核心线程数\",{\"1\":{\"372\":1}}],[\"这包括确定核心线程数\",{\"1\":{\"372\":1}}],[\"这包括基本类型的零值\",{\"1\":{\"78\":1}}],[\"这可以防止异常传播到线程池外部\",{\"1\":{\"358\":1}}],[\"这可能导致内存碎片\",{\"1\":{\"100\":1}}],[\"这可能需要数分钟\",{\"1\":{\"11\":1}}],[\"这两种方法都是用来关闭线程池的\",{\"1\":{\"348\":1}}],[\"这两种状态的区别在于阻塞状态是等待获取锁\",{\"1\":{\"242\":1}}],[\"这对于大多数情况已经足够\",{\"1\":{\"284\":1}}],[\"这对于需要保证响应时间的应用非常重要\",{\"1\":{\"114\":1}}],[\"这时候会交换两人的数据\",{\"1\":{\"259\":1}}],[\"这时会触发full\",{\"1\":{\"96\":1}}],[\"这才起到多线程的效果\",{\"1\":{\"238\":1}}],[\"这就要求有两个cpu去分别执行两个线程\",{\"1\":{\"235\":1}}],[\"这就是所谓的工作窃取\",{\"1\":{\"376\":1}}],[\"这就是注解的用处\",{\"1\":{\"190\":1}}],[\"这就是泛型擦除\",{\"1\":{\"188\":1}}],[\"这就是通过字符串常量池来实现的\",{\"1\":{\"168\":1}}],[\"这\",{\"1\":{\"225\":1}}],[\"这使得submit\",{\"1\":{\"347\":1}}],[\"这使得加载和存储操作看上去可能是在乱序执行\",{\"1\":{\"215\":1}}],[\"这使得字符流在处理文本数据时更方便和高效\",{\"1\":{\"138\":1}}],[\"这里异常的抛出条件是检测到\",{\"1\":{\"416\":1}}],[\"这里的threadlocalhashcode计算有点东西\",{\"1\":{\"228\":1}}],[\"这里的不可变指的是变量的引用不可变\",{\"1\":{\"203\":1}}],[\"这里可能会涉及多层递归\",{\"1\":{\"208\":1}}],[\"这意味着它不能被继承\",{\"1\":{\"168\":1}}],[\"这也是在\",{\"1\":{\"144\":1}}],[\"这减少了gc的压力\",{\"1\":{\"125\":1}}],[\"这增加了维护和管理的复杂性\",{\"1\":{\"108\":1}}],[\"这促使了g1垃圾收集器的引入\",{\"1\":{\"107\":1}}],[\"这与传统的分代垃圾收集器不同\",{\"1\":{\"102\":1}}],[\"这一阶段就是为了重新标记这些对象\",{\"1\":{\"100\":1}}],[\"这一阶段需要再次暂停所有应用线程\",{\"1\":{\"100\":1}}],[\"这一阶段会暂停所有应用线程\",{\"1\":{\"100\":1}}],[\"这一变化有多方面的原因和好处\",{\"1\":{\"72\":1}}],[\"这是对\",{\"1\":{\"437\":1}}],[\"这是线程池的最终状态\",{\"1\":{\"369\":1}}],[\"这是线程池的初始状态\",{\"1\":{\"365\":1}}],[\"这是java的规定\",{\"1\":{\"206\":1}}],[\"这是java垃圾回收器实际使用的方法\",{\"1\":{\"87\":1}}],[\"这是垃圾收集的核心操作\",{\"1\":{\"103\":1}}],[\"这是最早的收集器之一\",{\"1\":{\"98\":1}}],[\"这样使得哈希值的分布更加均匀\",{\"1\":{\"430\":1}}],[\"这样的设计增加了哈希值的随机性\",{\"1\":{\"429\":1}}],[\"这样的局部变量的值确实存储在java栈中\",{\"1\":{\"67\":1}}],[\"这样线性化后就不存在环路了\",{\"1\":{\"408\":1}}],[\"这样不可抢占这个条件就破坏掉了\",{\"1\":{\"408\":1}}],[\"这样就保证了同一时间只有一个线程能够访问该对象的同步代码块或同步方法\",{\"1\":{\"381\":1}}],[\"这样可以提高序列化和反序列化的效率\",{\"1\":{\"414\":1}}],[\"这样可以减少对耗时\",{\"1\":{\"375\":1}}],[\"这样可以利用多个线程同时执行任务\",{\"1\":{\"375\":1}}],[\"这样可以避免线程被长时间阻塞\",{\"1\":{\"375\":1}}],[\"这样可以避免阻塞线程池中的其他任务\",{\"1\":{\"375\":1}}],[\"这样可以避免使用锁\",{\"1\":{\"81\":1}}],[\"这样可以避免了多线程情况下的锁竞争\",{\"1\":{\"80\":1}}],[\"这样即使发生断电\",{\"1\":{\"374\":1}}],[\"这样设计的原因\",{\"1\":{\"168\":1}}],[\"这样做可以减少链表或红黑树的重新排序次数\",{\"1\":{\"439\":1}}],[\"这样做可以减少线程间因为堆内存分配而发生的竞争\",{\"1\":{\"81\":1}}],[\"这样做可能会导致调用线程的性能下降\",{\"1\":{\"345\":1}}],[\"这样做的目的是简化内存管理和优化垃圾收集\",{\"1\":{\"102\":1}}],[\"这样\",{\"1\":{\"93\":1,\"350\":1}}],[\"这种查找\",{\"1\":{\"411\":1}}],[\"这种锁被称之为重量级锁\",{\"1\":{\"387\":1}}],[\"这种任务可以返回结果\",{\"1\":{\"347\":1}}],[\"这种任务不返回结果\",{\"1\":{\"347\":1}}],[\"这种字节码必须再经过jvm\",{\"1\":{\"151\":1}}],[\"这种情况称为可重入锁\",{\"1\":{\"385\":1}}],[\"这种情况被称为并发模式失效\",{\"1\":{\"108\":1}}],[\"这种情况也会触发minor\",{\"1\":{\"95\":1}}],[\"这种情况通常发生在程序需要的内存超过了系统实际可用内存的情况下\",{\"1\":{\"84\":1}}],[\"这种算法可以减少垃圾回收的停顿时间\",{\"1\":{\"92\":1}}],[\"这种方法通过给对象添加一个引用计数器来跟踪对象的引用数量\",{\"1\":{\"87\":1}}],[\"这种方式使得参数的修改更加便捷\",{\"1\":{\"371\":1}}],[\"这种方式可以通过反射机制来实现\",{\"1\":{\"371\":1}}],[\"这种方式可以通过futuretask获取任务执行的返回值\",{\"1\":{\"237\":1}}],[\"这种方式可以节省大量的执行成本\",{\"1\":{\"83\":1}}],[\"这种方式的优势在于速度更快\",{\"1\":{\"83\":1}}],[\"这种方式的优势在于稳定性\",{\"1\":{\"83\":1}}],[\"这种方式称为\",{\"1\":{\"79\":1}}],[\"这种分配方式称为\",{\"1\":{\"79\":1}}],[\"这些方法都是原子性的\",{\"1\":{\"406\":1}}],[\"这些类都提供了一些原子操作方法\",{\"1\":{\"406\":1}}],[\"这些子问题相互独立且与原问题性质相同\",{\"1\":{\"376\":1}}],[\"这些状态有助于管理线程池的生命周期和行为\",{\"1\":{\"364\":1}}],[\"这些不同类型的工作队列具有不同的特性和适用场景\",{\"1\":{\"346\":1}}],[\"这些参数可以根据应用场景的需求进行调整和配置\",{\"1\":{\"344\":1}}],[\"这些参数可以在启动jvm时配置\",{\"1\":{\"127\":1}}],[\"这些参数通常包括核心线程数\",{\"1\":{\"338\":1}}],[\"这些任务不需要立即完成\",{\"1\":{\"330\":1}}],[\"这些短生命周期的对象会加大垃圾回收的压力\",{\"1\":{\"314\":1}}],[\"这些同步操作会导致锁的竞争和开销\",{\"1\":{\"312\":1}}],[\"这些结构用于线程调度和管理\",{\"1\":{\"309\":1}}],[\"这些线程会一直相互等待而无法继续运行下去\",{\"1\":{\"408\":1}}],[\"这些线程在处理完一个任务后不会被销毁\",{\"1\":{\"299\":1}}],[\"这些线程必须调用await\",{\"1\":{\"252\":1}}],[\"这些操作就可能被编译器和处理器重排序\",{\"1\":{\"217\":1}}],[\"这些操作可能是\",{\"1\":{\"145\":1}}],[\"这些硬件组件对应着jmm中的工作内存\",{\"1\":{\"211\":1}}],[\"这些优化技术使得java在保持易用性的同时\",{\"1\":{\"129\":1}}],[\"这些安全点通常出现在循环的末尾\",{\"1\":{\"99\":1}}],[\"这些情况都反映了java应用程序在运行过程中内存管理的一些具体场景\",{\"1\":{\"96\":1}}],[\"这些对象就会被晋升到老年代\",{\"1\":{\"95\":1}}],[\"这些对象是垃圾回收器进行可达性分析的起点\",{\"1\":{\"88\":1}}],[\"这些术语都与java堆的垃圾回收相关\",{\"1\":{\"94\":1}}],[\"这些填充字节的大小取决于jvm实现和操作系统的要求\",{\"1\":{\"82\":1}}],[\"这些成员变量按其声明顺序存放在内存中\",{\"1\":{\"82\":1}}],[\"这些改进使得jvm在性能\",{\"1\":{\"77\":1}}],[\"这些常量在类加载时被加载到内存中\",{\"1\":{\"68\":1}}],[\"这些变化主要是为了改进内存管理\",{\"1\":{\"62\":1}}],[\"这个问题在jdk1\",{\"1\":{\"441\":2}}],[\"这个\",{\"1\":{\"436\":1}}],[\"这个异常只建议用于检测并发修改的bug\",{\"1\":{\"416\":1}}],[\"这个接口只是用来标识是否支持随机访问\",{\"1\":{\"411\":1}}],[\"这个接口是服务的契约\",{\"1\":{\"153\":1}}],[\"这个条件\",{\"1\":{\"408\":3,\"416\":1}}],[\"这个方向基本上是不可逆的\",{\"1\":{\"388\":1}}],[\"这个方法返回一个线程安全的map对象\",{\"1\":{\"442\":1}}],[\"这个方法返回的对象可能是空\",{\"1\":{\"144\":1}}],[\"这个方法相比\",{\"1\":{\"240\":1}}],[\"这个方法在\",{\"1\":{\"204\":1}}],[\"这个标识指明了该方法是一个同步方法\",{\"1\":{\"380\":1}}],[\"这个过程也是递归的\",{\"1\":{\"376\":1}}],[\"这个过程是递归的\",{\"1\":{\"376\":1}}],[\"这个过程会导致显著的停顿时间\",{\"1\":{\"108\":1}}],[\"这个简单的线程池实现了基本的功能\",{\"1\":{\"373\":1}}],[\"这个流程保证了线程资源的高效利用和任务的有效调度\",{\"1\":{\"343\":1}}],[\"这个结构被附带在线程上\",{\"1\":{\"247\":1}}],[\"这个数字\",{\"1\":{\"228\":1}}],[\"这个值很特殊\",{\"1\":{\"228\":1}}],[\"这个阶段不需要暂停应用线程\",{\"1\":{\"103\":1}}],[\"这个阶段不会造成显著的停顿\",{\"1\":{\"100\":1}}],[\"这个阶段再次与应用线程并发运行\",{\"1\":{\"100\":1}}],[\"这个阶段也会标记由于并发标记阶段遗漏的对象\",{\"1\":{\"100\":1}}],[\"这个阶段时间较短\",{\"1\":{\"100\":1}}],[\"这个暂停的目的是为了保证对象引用更新的正确性\",{\"1\":{\"99\":1}}],[\"这个机制避免了频繁将存活对象从新生代复制到survivor区\",{\"1\":{\"97\":1}}],[\"这个内存布局在不同的jvm实现中可能会有所不同\",{\"1\":{\"82\":1}}],[\"这个区域在堆内存中是连续的\",{\"1\":{\"80\":1}}],[\"这个局部变量本身存储在java栈中\",{\"1\":{\"71\":1}}],[\"这个局部变量\",{\"1\":{\"69\":1}}],[\"这个字面值\",{\"1\":{\"69\":1}}],[\"这个常量的存储位置和引用机制\",{\"1\":{\"67\":1}}],[\"这个示例中提到的\",{\"1\":{\"67\":1}}],[\"这个计数器的值是未定义的\",{\"1\":{\"53\":1}}],[\"不存在就再插入链表\",{\"1\":{\"444\":1}}],[\"不存在与其他线程的竞争\",{\"1\":{\"80\":1}}],[\"不过其他三个条件都是有办法破坏掉的\",{\"1\":{\"408\":1}}],[\"不可剥夺\",{\"1\":{\"408\":1}}],[\"不可剥夺条件\",{\"1\":{\"408\":1}}],[\"不可变\",{\"1\":{\"169\":1}}],[\"不需要移动元素\",{\"1\":{\"411\":1}}],[\"不需要像synchronized关键字那样对整个代码块进行加锁\",{\"1\":{\"406\":1}}],[\"不需要并发执行的场景\",{\"1\":{\"351\":1}}],[\"不必唤醒所有线程\",{\"1\":{\"395\":1}}],[\"不处理队列中的任务\",{\"1\":{\"367\":1}}],[\"不接受新任务\",{\"1\":{\"366\":1,\"367\":1}}],[\"不方便\",{\"1\":{\"239\":1}}],[\"不为空\",{\"1\":{\"232\":1}}],[\"不擅技术\",{\"1\":{\"231\":1}}],[\"不管\",{\"1\":{\"378\":1}}],[\"不管jvm的内存空间是否充足\",{\"1\":{\"225\":1}}],[\"不管怎么重排序\",{\"1\":{\"217\":1}}],[\"不推荐使用\",{\"1\":{\"204\":1,\"417\":1}}],[\"不属于类的任何一个对象\",{\"1\":{\"202\":1}}],[\"不能在多线程下发生并发修改\",{\"1\":{\"416\":1}}],[\"不能依赖于这个异常是否抛出而进行并发操作的编程\",{\"1\":{\"416\":1}}],[\"不能保证原子性\",{\"1\":{\"213\":2}}],[\"不能被访问控制修饰符及static所修饰\",{\"1\":{\"201\":1}}],[\"不能有其他类型的变量\",{\"1\":{\"200\":1}}],[\"不能实现\",{\"1\":{\"200\":1}}],[\"不能修饰外部类\",{\"1\":{\"198\":2}}],[\"不能修饰类和方法\",{\"1\":{\"177\":1}}],[\"不使用任何修饰符\",{\"1\":{\"198\":1}}],[\"不允许键和值为null\",{\"1\":{\"192\":1}}],[\"不包含静态变量\",{\"1\":{\"177\":1}}],[\"不行\",{\"1\":{\"168\":1}}],[\"不是通过插入顺序遍历\",{\"1\":{\"448\":1}}],[\"不是线程安全的\",{\"1\":{\"441\":1}}],[\"不是引用指向的内容的不可变\",{\"1\":{\"203\":1}}],[\"不是\",{\"1\":{\"168\":1}}],[\"不同于在共享变量上调用\",{\"1\":{\"240\":1}}],[\"不同系统安装不同java虚拟机\",{\"1\":{\"149\":1}}],[\"不同的线程在同一个计数器上\",{\"1\":{\"252\":1}}],[\"不同的是\",{\"1\":{\"240\":1}}],[\"不同的jvm\",{\"1\":{\"148\":1}}],[\"不同的gc适用于不同的应用场景和需求\",{\"1\":{\"118\":1}}],[\"不同的算法适用于不同的场景和需求\",{\"1\":{\"92\":1}}],[\"不断监听通道列表\",{\"1\":{\"139\":1}}],[\"不会抛出异常也不会进行任何处理\",{\"1\":{\"345\":1}}],[\"不会被其他线程中断\",{\"1\":{\"212\":1}}],[\"不会写入\",{\"1\":{\"190\":1}}],[\"不会出现线程安全问题\",{\"1\":{\"168\":1}}],[\"不会出现线程间的数据共享问题\",{\"1\":{\"53\":1}}],[\"不会移动存活对象\",{\"1\":{\"108\":1}}],[\"不会导致应用线程停顿\",{\"1\":{\"100\":1}}],[\"不建议过度依赖finalize\",{\"1\":{\"90\":1}}],[\"不确定性高\",{\"1\":{\"90\":1}}],[\"不再有任何活动线程\",{\"1\":{\"369\":1}}],[\"不再执行任何代码\",{\"1\":{\"243\":1}}],[\"不再执行下面的代码\",{\"1\":{\"164\":1}}],[\"不再执行循环\",{\"1\":{\"164\":1}}],[\"不再需要手动调整类似\",{\"1\":{\"76\":1}}],[\"不再使用堆内存\",{\"1\":{\"57\":1}}],[\"不受堆内存大小的限制\",{\"1\":{\"76\":1}}],[\"不受堆内存大小限制\",{\"1\":{\"59\":1}}],[\"不要动gh\",{\"0\":{\"22\":1}}],[\"动态调整链表和红黑树的阈值\",{\"1\":{\"439\":1}}],[\"动态调整内存大小\",{\"1\":{\"76\":1}}],[\"动态地替换\",{\"1\":{\"153\":1}}],[\"动态年龄判断\",{\"1\":{\"97\":1}}],[\"动态链接\",{\"1\":{\"53\":1}}],[\"动态图\",{\"0\":{\"43\":1}}],[\"所谓按序申请\",{\"1\":{\"408\":1}}],[\"所谓的公平锁就是先等待的线程先获得锁\",{\"1\":{\"391\":1}}],[\"所谓多态就是指程序中定义的引⽤变量所指向的具体类型和通过该引⽤变量发出的⽅法调⽤在编程时并不确定\",{\"1\":{\"196\":1}}],[\"所以get是不需要加锁的\",{\"1\":{\"444\":1}}],[\"所以转红黑树\",{\"1\":{\"435\":1}}],[\"所以传入17\",{\"1\":{\"432\":1}}],[\"所以对扰动函数通过对哈希值进行变换\",{\"1\":{\"430\":1}}],[\"所以在遍历过程中对原集合所作的修改并不能被迭代器检测到\",{\"1\":{\"416\":1}}],[\"所以每个节点会占用更多的空间\",{\"1\":{\"411\":1}}],[\"所以它没法根据序号直接获取元素\",{\"1\":{\"411\":1}}],[\"所以它可以根据下标查找\",{\"1\":{\"411\":1}}],[\"所以当前线程会被阻塞\",{\"1\":{\"408\":1}}],[\"所以synchronized保证的有序是执行结果的有序性\",{\"1\":{\"384\":1}}],[\"所以synchronized保证同一时刻\",{\"1\":{\"384\":1}}],[\"所以我们就知道了\",{\"1\":{\"381\":1}}],[\"所以任务直接加到synchronousqueue队列\",{\"1\":{\"354\":1}}],[\"所以无法响应中断的任务可能永远无法终止\",{\"1\":{\"348\":1}}],[\"所以基本对于用户是无感知的\",{\"1\":{\"235\":1}}],[\"所以不会触发concurrent\",{\"1\":{\"416\":1}}],[\"所以不会再次调用\",{\"1\":{\"204\":1}}],[\"所以不能使用private修饰符\",{\"1\":{\"200\":1}}],[\"所以即使\",{\"1\":{\"183\":1}}],[\"所以是先输出\",{\"1\":{\"183\":1}}],[\"所以进程可能会看似未响应\",{\"1\":{\"11\":1}}],[\"所拥有的⼀\",{\"1\":{\"148\":1}}],[\"所取代\",{\"1\":{\"91\":1}}],[\"所有任务都已完成\",{\"1\":{\"368\":1}}],[\"所有任务按照顺序在这个线程中执行\",{\"1\":{\"351\":1}}],[\"所有的线程完成任务\",{\"1\":{\"252\":1}}],[\"所有的输入流的基类\",{\"1\":{\"137\":1}}],[\"所有线程到达屏障点后执行的代码\",{\"1\":{\"251\":1}}],[\"所有线程到达屏障点时执行\",{\"1\":{\"251\":1}}],[\"所有线程已到达屏障点\",{\"1\":{\"251\":5}}],[\"所有被屏障拦截的线程才会继续运行\",{\"1\":{\"250\":1}}],[\"所有玩家已经就位\",{\"1\":{\"249\":1}}],[\"所有对象共享同一份静态变量的拷贝\",{\"1\":{\"201\":1}}],[\"所有对象都在堆上分配\",{\"1\":{\"53\":1}}],[\"所有输出流的基类\",{\"1\":{\"137\":1}}],[\"所有已被使用的内存和空闲的内存分别放在堆的两端\",{\"1\":{\"79\":1}}],[\"堆栈指针等信息\",{\"1\":{\"244\":1}}],[\"堆内存\",{\"1\":{\"124\":1}}],[\"堆内存大小和并发能力\",{\"1\":{\"122\":1}}],[\"堆内存大小和停顿时间要求来确定\",{\"1\":{\"117\":1}}],[\"堆内存大小\",{\"1\":{\"119\":1}}],[\"堆内存被划分为多个大小相等的区域\",{\"1\":{\"102\":1}}],[\"堆内存会逐渐耗尽\",{\"1\":{\"85\":1}}],[\"堆内存的分配是线程共享的\",{\"1\":{\"81\":1}}],[\"堆会发生抢占吗\",{\"0\":{\"81\":1}}],[\"堆中的对象也会拷贝一份\",{\"1\":{\"208\":1}}],[\"堆中的内存不规整的情况\",{\"1\":{\"79\":1}}],[\"堆中内存是绝对规整的情况\",{\"1\":{\"79\":1}}],[\"堆是垃圾回收的主要区域\",{\"1\":{\"53\":1}}],[\"堆\",{\"1\":{\"53\":2,\"55\":1,\"57\":1,\"133\":1}}],[\"从冲突的位置x开始\",{\"1\":{\"434\":1}}],[\"从冲突的位置开始\",{\"1\":{\"434\":1}}],[\"从任一节点到其每个叶子节点的路径上\",{\"1\":{\"423\":1}}],[\"从一些死锁进程中剥夺资源\",{\"1\":{\"409\":1}}],[\"从一个线程转而执行另一个线程的过程\",{\"1\":{\"244\":1}}],[\"从队列取任务\",{\"1\":{\"355\":1}}],[\"从父线程中取出inheritablethreadlocals\",{\"1\":{\"232\":1}}],[\"从\",{\"1\":{\"163\":2}}],[\"从根节点出发\",{\"1\":{\"92\":1}}],[\"从而保证线程安全\",{\"1\":{\"442\":1}}],[\"从而导致元素的丢失\",{\"1\":{\"441\":1}}],[\"从而导致java\",{\"1\":{\"74\":1}}],[\"从而形成死循环\",{\"1\":{\"441\":1}}],[\"从而形成循环等待\",{\"1\":{\"408\":1}}],[\"从而降低哈希碰撞的概率\",{\"1\":{\"430\":1}}],[\"从而降低系统的性能\",{\"1\":{\"349\":1}}],[\"从而降低系统的性能和稳定性\",{\"1\":{\"349\":1}}],[\"从而使用共享变量时需要从主内存中重新读取最新的值\",{\"1\":{\"383\":1}}],[\"从而避免线程池中的线程因未处理的异常而终止\",{\"1\":{\"358\":1}}],[\"从而让调用者能够捕获和处理异常\",{\"1\":{\"347\":1}}],[\"从而减少了线程创建和销毁的开销\",{\"1\":{\"319\":1}}],[\"从而影响jit的优化效果\",{\"1\":{\"315\":1}}],[\"从而增加cpu的负担\",{\"1\":{\"311\":1}}],[\"从而增加内存管理的开销\",{\"1\":{\"308\":1}}],[\"从而增加代码的可读性和安全性\",{\"1\":{\"185\":1}}],[\"从而为多线程编程提供了便利和高效的同步与通信机制\",{\"1\":{\"296\":1}}],[\"从而确保操作的原子性和线程安全性\",{\"1\":{\"296\":1}}],[\"从而可能导致内存泄漏\",{\"1\":{\"227\":1}}],[\"从而可以避免permgen空间不足的问题\",{\"1\":{\"57\":1}}],[\"从而实现线程之间的同步与通信\",{\"1\":{\"296\":1}}],[\"从而实现了线程隔离\",{\"1\":{\"224\":1}}],[\"从而实现java程序的跨平台性\",{\"1\":{\"150\":1}}],[\"从而起到线程隔离的作用\",{\"1\":{\"222\":1}}],[\"从而提高了程序的并发性能\",{\"1\":{\"406\":1}}],[\"从而提高了系统效率\",{\"1\":{\"298\":1}}],[\"从而提高并发性能\",{\"1\":{\"80\":1}}],[\"从而提升性能和减少gc的压力\",{\"1\":{\"129\":1}}],[\"从而进行垃圾回收\",{\"1\":{\"88\":1}}],[\"从jdk6开始hotspot虚拟机开发团队对java中的锁进行优化\",{\"1\":{\"387\":1}}],[\"从jdk6开始\",{\"1\":{\"387\":1}}],[\"从jdk\",{\"1\":{\"64\":1,\"65\":1,\"66\":2,\"200\":1}}],[\"从java\",{\"1\":{\"53\":1,\"91\":1}}],[\"从永久代移出\",{\"1\":{\"56\":1}}],[\"从master新建分支gh\",{\"0\":{\"19\":1}}],[\"生产了数据\",{\"1\":{\"257\":1}}],[\"生产的数据\",{\"1\":{\"257\":1}}],[\"生产者\",{\"1\":{\"257\":1}}],[\"生存周期\",{\"1\":{\"201\":1}}],[\"生命周期不受方法调用结束的影响\",{\"1\":{\"124\":1}}],[\"生命周期\",{\"1\":{\"53\":5}}],[\"生成数据并与消费者交换\",{\"1\":{\"258\":1}}],[\"生成字节码\",{\"1\":{\"151\":1}}],[\"生成模板\",{\"1\":{\"11\":1}}],[\"生成\",{\"1\":{\"11\":1}}],[\"即保留了低位hash值\",{\"1\":{\"431\":1}}],[\"即保证了代码的串行语义\",{\"1\":{\"212\":1}}],[\"即不同的键计算得到相同的桶索引\",{\"1\":{\"421\":1}}],[\"即迭代器创建时的集合状态\",{\"1\":{\"418\":1}}],[\"即该资源同时只由一个线程占用\",{\"1\":{\"408\":1}}],[\"即表示此对象处于轻量级锁状态\",{\"1\":{\"390\":1}}],[\"即将任务提交到线程池后立即返回\",{\"1\":{\"375\":1}}],[\"即要么任务执行成功\",{\"1\":{\"374\":1}}],[\"即无限大\",{\"1\":{\"354\":1}}],[\"即适用执行长期的任务\",{\"1\":{\"353\":1}}],[\"即keepalivetime为0\",{\"1\":{\"353\":1}}],[\"即在指定延迟时间之后才能被消费\",{\"1\":{\"346\":1}}],[\"即线程变量\",{\"1\":{\"247\":1}}],[\"即防止读操作重排序到写操作之后\",{\"1\":{\"220\":1}}],[\"即防止写操作重排序到读操作之后\",{\"1\":{\"220\":1}}],[\"即确保第一个加载操作的结果对后续的加载操作可见\",{\"1\":{\"220\":1}}],[\"即确保第一个存储操作的结果对后续的存储操作可见\",{\"1\":{\"220\":1}}],[\"即能够正确读取到最新的值\",{\"1\":{\"212\":1}}],[\"即默认\",{\"1\":{\"198\":1}}],[\"即⼀个引⽤变量到底会指向哪个类的实例对象\",{\"1\":{\"196\":1}}],[\"即equals\",{\"1\":{\"172\":1}}],[\"即eden区和survivor区\",{\"1\":{\"94\":1}}],[\"即返回\",{\"1\":{\"145\":1}}],[\"即\",{\"1\":{\"131\":1,\"416\":1}}],[\"即大多数对象的生命周期很短\",{\"1\":{\"92\":1}}],[\"即使线程池中的线程都在忙碌\",{\"1\":{\"346\":1}}],[\"即使线程处于空闲状态\",{\"1\":{\"344\":1}}],[\"即使这两个对象指向相同的数据\",{\"1\":{\"206\":1}}],[\"即使系统出现内存溢出\",{\"1\":{\"89\":1}}],[\"即使在程序的其他部分不再需要这些对象\",{\"1\":{\"86\":1}}],[\"即java代码调用本地方法时传递的对象引用\",{\"1\":{\"88\":1}}],[\"即静态成员变量\",{\"1\":{\"88\":1}}],[\"即为\",{\"1\":{\"87\":1}}],[\"即reference中存储的是稳定的句柄地址\",{\"1\":{\"83\":1}}],[\"即时编译器编译后的代码等\",{\"1\":{\"53\":1}}],[\"即gh\",{\"1\":{\"22\":1}}],[\"主线程可以继续处理其他工作\",{\"1\":{\"331\":1}}],[\"主线程继续执行其他操作\",{\"1\":{\"279\":1,\"288\":2,\"332\":2}}],[\"主线程使用countdownlatch\",{\"1\":{\"249\":2}}],[\"主线程\",{\"1\":{\"231\":1}}],[\"主内存\",{\"1\":{\"211\":1}}],[\"主观原因\",{\"0\":{\"75\":1}}],[\"主要是因为线程的创建和销毁涉及操作系统和jvm层面的多种资源管理和调度\",{\"1\":{\"306\":1}}],[\"主要通过executors工具类来创建\",{\"1\":{\"301\":1}}],[\"主要目的是确保\",{\"1\":{\"206\":1}}],[\"主要在年轻代gc和混合gc中执行\",{\"1\":{\"103\":1}}],[\"主要标记从根集合\",{\"1\":{\"100\":1}}],[\"主要包括以下几个部分\",{\"1\":{\"91\":1}}],[\"主要用于新生代的收集\",{\"1\":{\"98\":1}}],[\"主要用于存放对象实例\",{\"1\":{\"91\":1}}],[\"主要用于清理前的资源释放工作\",{\"1\":{\"89\":1}}],[\"主要用于实现对象的规范映射\",{\"1\":{\"89\":1}}],[\"主要变化是永久代\",{\"1\":{\"56\":1}}],[\"主要的内存区域包括\",{\"1\":{\"53\":1}}],[\"主页\",{\"0\":{\"5\":1}}],[\"渲染失败了\",{\"1\":{\"51\":1}}],[\"u\",{\"1\":{\"407\":1,\"445\":2}}],[\"unchecked\",{\"1\":{\"445\":1}}],[\"uncaughtexceptionhandler\",{\"0\":{\"360\":1},\"1\":{\"360\":1}}],[\"unpark\",{\"1\":{\"392\":1}}],[\"unbounded\",{\"1\":{\"346\":1}}],[\"unit\",{\"1\":{\"249\":1,\"359\":2}}],[\"uffff\",{\"1\":{\"159\":1}}],[\"u0000\",{\"1\":{\"159\":2}}],[\"username\",{\"1\":{\"324\":1}}],[\"user\",{\"1\":{\"246\":1,\"332\":1}}],[\"users\",{\"1\":{\"11\":2}}],[\"use\",{\"1\":{\"126\":1,\"230\":1}}],[\"util包下的集合类都是快速失败的\",{\"1\":{\"416\":1}}],[\"util\",{\"1\":{\"85\":2,\"145\":1,\"257\":1,\"279\":4,\"281\":4,\"286\":2,\"288\":4,\"301\":1,\"303\":3,\"305\":3,\"320\":2,\"328\":5,\"332\":2,\"336\":3,\"363\":1,\"373\":2,\"376\":1,\"416\":1}}],[\"urgent\",{\"1\":{\"51\":1}}],[\"urg\",{\"1\":{\"51\":1}}],[\"框图文档\",{\"0\":{\"50\":1}}],[\"桑基图\",{\"0\":{\"48\":1}}],[\"图\",{\"0\":{\"39\":1}}],[\"图表\",{\"0\":{\"38\":1,\"49\":1}}],[\"需求图\",{\"0\":{\"37\":1}}],[\"需要更多的旋转操作来保持平衡\",{\"1\":{\"425\":1}}],[\"需要存储前驱和后继\",{\"1\":{\"411\":1}}],[\"需要遍历链表\",{\"1\":{\"411\":1}}],[\"需要一定的阻塞等待唤醒机制来保证锁的分配\",{\"1\":{\"392\":1}}],[\"需要子类自行实现\",{\"1\":{\"392\":2}}],[\"需要子类来实现\",{\"1\":{\"376\":1}}],[\"需要仔细观察线程池的运行情况\",{\"1\":{\"372\":1}}],[\"需要及时调整配置并重新测试\",{\"1\":{\"372\":1}}],[\"需要限制线程数量的场景\",{\"1\":{\"356\":1}}],[\"需要考虑以下几个因素\",{\"1\":{\"349\":1}}],[\"需要定期执行一些任务\",{\"1\":{\"334\":1}}],[\"需要执行一些异步任务\",{\"1\":{\"330\":1}}],[\"需要消耗较多的时间\",{\"1\":{\"322\":1}}],[\"需要保存当前线程的状态\",{\"1\":{\"311\":1}}],[\"需要保证线程安全\",{\"1\":{\"169\":1}}],[\"需要处理可能的\",{\"1\":{\"251\":1}}],[\"需要手动管理线程\",{\"1\":{\"239\":1}}],[\"需要使用锁来保护对队列数据结构的访问\",{\"1\":{\"296\":1}}],[\"需要使用\",{\"1\":{\"202\":1}}],[\"需要先创建对象然后通过对象才能访问到它\",{\"1\":{\"202\":1}}],[\"需要先进入项目目录\",{\"1\":{\"14\":1}}],[\"需要自行保证线程安全\",{\"1\":{\"169\":1}}],[\"需要强制转换\",{\"1\":{\"160\":1}}],[\"需要逃逸分析\",{\"1\":{\"127\":2}}],[\"需要低停顿时间的应用\",{\"1\":{\"120\":1}}],[\"需要极低停顿时间\",{\"1\":{\"120\":1}}],[\"需要极低停顿时间的应用\",{\"1\":{\"112\":1}}],[\"需要可预测的低停顿时间\",{\"1\":{\"120\":1}}],[\"需要stw\",{\"1\":{\"103\":2}}],[\"需要在使用时根据具体应用场景进行调优\",{\"1\":{\"100\":1}}],[\"需要暂停所有的用户线程\",{\"1\":{\"99\":1}}],[\"需要注意的是value是volatile的\",{\"1\":{\"444\":1}}],[\"需要注意的是\",{\"1\":{\"82\":1}}],[\"需要维护一个列表\",{\"1\":{\"79\":1}}],[\"需要build成html文件和js才行\",{\"1\":{\"22\":1}}],[\"象限图\",{\"0\":{\"36\":1}}],[\"9允许在接口中定义私有方法\",{\"1\":{\"200\":1}}],[\"9e\",{\"1\":{\"159\":1}}],[\"99\",{\"1\":{\"51\":1}}],[\"96\",{\"1\":{\"51\":1}}],[\"95\",{\"1\":{\"51\":1}}],[\"9\",{\"0\":{\"36\":1,\"282\":1},\"1\":{\"328\":1}}],[\"饼图\",{\"0\":{\"35\":1}}],[\"甘特图\",{\"0\":{\"34\":1}}],[\"5倍\",{\"1\":{\"412\":1}}],[\"5引入的一个特性\",{\"1\":{\"185\":1}}],[\"5\",{\"0\":{\"32\":1,\"272\":1,\"273\":1,\"274\":1,\"294\":1,\"304\":1,\"333\":1,\"342\":1,\"362\":1,\"369\":1},\"1\":{\"163\":1,\"249\":1,\"273\":1,\"274\":1,\"293\":1,\"294\":1,\"302\":1,\"303\":1,\"305\":1,\"324\":1,\"328\":1,\"332\":1,\"336\":1,\"338\":1,\"373\":1,\"389\":2,\"390\":1}}],[\"在冲突的位置拉一个链表\",{\"1\":{\"434\":1}}],[\"在扩容时保持链表元素原本的顺序\",{\"1\":{\"441\":1}}],[\"在扩容时\",{\"1\":{\"431\":1,\"439\":1}}],[\"在使用arraylist时\",{\"1\":{\"417\":1}}],[\"在使用cyclicbarrier时\",{\"1\":{\"252\":1}}],[\"在遍历期间原集合发生的修改迭代器是不知道的\",{\"1\":{\"416\":1}}],[\"在遍历时不是直接在集合内容上访问的\",{\"1\":{\"416\":1}}],[\"在拷贝的集合上进行遍历\",{\"1\":{\"416\":1}}],[\"在用迭代器遍历一个集合对象时\",{\"1\":{\"416\":1}}],[\"在获取资源时设置超时\",{\"1\":{\"408\":1}}],[\"在无外力作用的情况下\",{\"1\":{\"408\":1}}],[\"在无竞争的情况下\",{\"1\":{\"387\":1}}],[\"在轻量级锁升级为重量级锁时\",{\"1\":{\"387\":1}}],[\"在没有多线程竞争时\",{\"1\":{\"387\":1}}],[\"在判断拥有同步标识\",{\"1\":{\"381\":1}}],[\"在上线之后建立完善的线程池监控机制\",{\"1\":{\"372\":1}}],[\"在上线之前进行充分的测试\",{\"1\":{\"372\":1}}],[\"在上线之前\",{\"1\":{\"372\":1}}],[\"在上述示例中\",{\"1\":{\"71\":1}}],[\"在该状态下\",{\"1\":{\"365\":1,\"366\":1,\"367\":1,\"368\":1}}],[\"在任务内部使用\",{\"1\":{\"363\":1}}],[\"在任务\",{\"1\":{\"358\":1}}],[\"在调用了shutdown\",{\"1\":{\"348\":1}}],[\"在线程池上线之后\",{\"1\":{\"372\":1}}],[\"在线程池中\",{\"1\":{\"346\":1,\"350\":1}}],[\"在线游戏\",{\"1\":{\"119\":1}}],[\"在线游戏等\",{\"1\":{\"119\":1}}],[\"在指定时间或周期性执行\",{\"1\":{\"335\":1}}],[\"在许多应用中\",{\"1\":{\"330\":1}}],[\"在大数据处理和计算任务中\",{\"1\":{\"326\":1}}],[\"在典型的jvm中\",{\"1\":{\"308\":1}}],[\"在对队列进行添加或移除元素的操作时\",{\"1\":{\"296\":1}}],[\"在对象经过多次minor\",{\"1\":{\"93\":1}}],[\"在队列为空或已满时\",{\"1\":{\"296\":1}}],[\"在多线程编程中起着重要作用\",{\"1\":{\"296\":1}}],[\"在多线程环境下使用stringbuilder\",{\"1\":{\"169\":1}}],[\"在多线程环境下\",{\"1\":{\"169\":1,\"212\":3}}],[\"在所有任务完成后处理结果\",{\"1\":{\"279\":1}}],[\"在compute\",{\"1\":{\"376\":1}}],[\"在countdownlatch中\",{\"1\":{\"252\":1}}],[\"在cyclicbarrier中\",{\"1\":{\"252\":1}}],[\"在它们结束后都可以执行特定动作\",{\"1\":{\"250\":1}}],[\"在此等待信号再继续\",{\"1\":{\"249\":1}}],[\"在编写多线程应用程序时\",{\"1\":{\"244\":1}}],[\"在编译时候就确定了类型信息\",{\"1\":{\"155\":1}}],[\"在等待时间内没有其他线程调用相同对象的\",{\"1\":{\"240\":1}}],[\"在子线程中就可以拿到了\",{\"1\":{\"231\":1}}],[\"在主线程的inheritablethreadlocal实例设置值\",{\"1\":{\"231\":1}}],[\"在get的时候\",{\"1\":{\"229\":1}}],[\"在tryacquire\",{\"1\":{\"397\":1}}],[\"在try块中发生了线程死锁\",{\"1\":{\"182\":1}}],[\"在try块中发生了死循环或无限递归\",{\"1\":{\"182\":1}}],[\"在try块中调用了system\",{\"1\":{\"182\":1}}],[\"在thread的构造函数中\",{\"1\":{\"232\":1}}],[\"在thread类里还有另外一个变量\",{\"1\":{\"232\":1}}],[\"在threadlocalmap\",{\"1\":{\"230\":1}}],[\"在threadlocal中\",{\"1\":{\"227\":1}}],[\"在自己的map里找对应的key\",{\"1\":{\"224\":1}}],[\"在自动装箱的时候会调用integer\",{\"1\":{\"173\":1}}],[\"在每个volatile读操作的后面插入一个\",{\"1\":{\"220\":2}}],[\"在每个volatile写操作的后面插入一个\",{\"1\":{\"220\":1}}],[\"在每个volatile写操作的前面插入一个\",{\"1\":{\"220\":1}}],[\"在外部调⽤静态⽅法时\",{\"1\":{\"202\":1}}],[\"在同一类内可见\",{\"1\":{\"198\":1}}],[\"在同一包内可见\",{\"1\":{\"198\":1}}],[\"在类加载阶段丢弃\",{\"1\":{\"190\":1}}],[\"在类加载时从类文件常量池中提取\",{\"1\":{\"66\":1}}],[\"在执行完对应的代码块之后\",{\"1\":{\"385\":1}}],[\"在执行第二个子任务的过程中\",{\"1\":{\"376\":1}}],[\"在执行任务之前和之后\",{\"1\":{\"374\":1}}],[\"在执行任务时\",{\"1\":{\"374\":1}}],[\"在执行过程中会经历多个状态\",{\"1\":{\"364\":1}}],[\"在执行程序时\",{\"1\":{\"215\":1}}],[\"在执行\",{\"1\":{\"183\":1}}],[\"在执行young\",{\"1\":{\"96\":1}}],[\"在序列化时不需要保存\",{\"1\":{\"177\":1}}],[\"在静态块中会初始化好缓存值\",{\"1\":{\"173\":1}}],[\"在堆里创建一个\",{\"1\":{\"170\":1}}],[\"在堆内存中为对象分配内存空间\",{\"1\":{\"78\":1}}],[\"在单线程环境下\",{\"1\":{\"169\":1}}],[\"在单次gc中同时处理年轻代和老年代的对象\",{\"1\":{\"109\":1}}],[\"在目前所有的版本中都是不可以的\",{\"1\":{\"163\":1}}],[\"在应用程序运行时\",{\"1\":{\"153\":1}}],[\"在选择垃圾收集器时\",{\"1\":{\"117\":1}}],[\"在生产环境中\",{\"1\":{\"111\":1}}],[\"在即时编译过程中\",{\"1\":{\"99\":1}}],[\"在hotspot虚拟机中\",{\"1\":{\"99\":1}}],[\"在实际应用中\",{\"1\":{\"98\":1}}],[\"在young\",{\"1\":{\"97\":1}}],[\"在什么时候触发取决于新生代的内存分配情况\",{\"1\":{\"95\":1}}],[\"在某些情况下\",{\"1\":{\"94\":2}}],[\"在minor\",{\"1\":{\"93\":1,\"94\":1}}],[\"在markdown中使用mermaid画图\",{\"0\":{\"27\":1}}],[\"在新生代中\",{\"1\":{\"93\":1,\"95\":1}}],[\"在整理阶段\",{\"1\":{\"92\":1}}],[\"在垃圾回收时\",{\"1\":{\"92\":1}}],[\"在清除阶段\",{\"1\":{\"92\":1}}],[\"在标记阶段\",{\"1\":{\"92\":2}}],[\"在并发场景下的性能表现\",{\"1\":{\"80\":1}}],[\"在分配内存时\",{\"1\":{\"79\":1}}],[\"在这些特定位置上\",{\"1\":{\"99\":1}}],[\"在这个过程中\",{\"1\":{\"244\":1}}],[\"在这个例子中\",{\"1\":{\"126\":1,\"254\":1}}],[\"在这个阶段\",{\"1\":{\"100\":1}}],[\"在这个暂停期间\",{\"1\":{\"99\":1}}],[\"在这个示例中\",{\"1\":{\"85\":2,\"376\":1}}],[\"在这种方式下\",{\"1\":{\"83\":2}}],[\"在这种情况下\",{\"1\":{\"79\":2}}],[\"在这段代码中\",{\"1\":{\"69\":1}}],[\"在\",{\"1\":{\"79\":1,\"81\":1,\"183\":1,\"196\":1,\"204\":1,\"376\":4,\"448\":1}}],[\"在运行时获取泛型类型信息\",{\"1\":{\"188\":1}}],[\"在运行时动态地获取类信息\",{\"1\":{\"155\":1}}],[\"在运行时\",{\"1\":{\"69\":1}}],[\"在运行时的表示形式\",{\"1\":{\"65\":1}}],[\"在代码\",{\"1\":{\"69\":1}}],[\"在java的线程池中\",{\"1\":{\"347\":1}}],[\"在java8时jdk对\",{\"1\":{\"171\":1}}],[\"在java\",{\"1\":{\"94\":2,\"141\":1}}],[\"在java程序中\",{\"1\":{\"83\":1}}],[\"在java中\",{\"1\":{\"67\":1,\"82\":1,\"87\":1,\"88\":1,\"89\":2,\"123\":1,\"157\":1,\"403\":1}}],[\"在jdk1\",{\"1\":{\"171\":1,\"387\":2,\"391\":1,\"441\":1,\"443\":1}}],[\"在jdk\",{\"1\":{\"55\":1,\"56\":1,\"57\":1,\"64\":1,\"65\":1,\"66\":2,\"72\":1,\"75\":2,\"78\":2,\"200\":1,\"439\":2}}],[\"在jvm\",{\"1\":{\"246\":1}}],[\"在jvm退出时销毁\",{\"1\":{\"53\":2}}],[\"在jvm启动时创建\",{\"1\":{\"53\":2}}],[\"在不同版本的java开发工具包\",{\"1\":{\"54\":1}}],[\"在actions菜单栏中应该会触发自动发布\",{\"1\":{\"21\":1}}],[\"jstack\",{\"1\":{\"409\":1}}],[\"json序列化\",{\"1\":{\"178\":1}}],[\"json\",{\"1\":{\"11\":1}}],[\"jps\",{\"1\":{\"409\":1}}],[\"join任务\",{\"1\":{\"376\":1}}],[\"join框架来计算斐波那契数列的值\",{\"1\":{\"376\":2}}],[\"join框架中表示任务的抽象类\",{\"1\":{\"376\":1}}],[\"join框架会将这个大任务拆分成若干个小任务\",{\"1\":{\"376\":1}}],[\"join框架的线程池实现\",{\"1\":{\"376\":1}}],[\"join框架的关键组件包括\",{\"1\":{\"376\":1}}],[\"join框架的工作原理如下\",{\"1\":{\"376\":1}}],[\"join框架的定义\",{\"1\":{\"376\":1}}],[\"join框架\",{\"1\":{\"376\":1}}],[\"join框架是java7提供的一个用于并行执行任务的框架\",{\"1\":{\"376\":1}}],[\"join框架了解吗\",{\"0\":{\"376\":1}}],[\"join\",{\"1\":{\"216\":3,\"240\":3,\"242\":1,\"247\":3,\"279\":1,\"281\":1,\"376\":3}}],[\"josh\",{\"1\":{\"141\":1}}],[\"j\",{\"0\":{\"454\":1},\"1\":{\"213\":1}}],[\"jmm属于语言级的内存模型\",{\"1\":{\"215\":1}}],[\"jmm的很多技术都是围绕着这三大特性展开\",{\"1\":{\"212\":1}}],[\"jmm定义了线程和主内存之间的抽象关系\",{\"1\":{\"211\":1}}],[\"jmm\",{\"0\":{\"211\":1},\"1\":{\"211\":1}}],[\"jdbc\",{\"1\":{\"324\":1}}],[\"jdb\",{\"1\":{\"148\":1}}],[\"jdk5之前是没有泛型\",{\"1\":{\"188\":1}}],[\"jdk包含jre\",{\"1\":{\"148\":1}}],[\"jdk11使用byte\",{\"1\":{\"169\":1}}],[\"jdk1\",{\"0\":{\"140\":1,\"141\":1,\"439\":1,\"444\":1,\"445\":1},\"1\":{\"139\":1,\"421\":2,\"441\":1,\"444\":1}}],[\"jdk\",{\"0\":{\"55\":1,\"56\":1,\"57\":1,\"148\":1},\"1\":{\"54\":1,\"59\":2,\"60\":2,\"61\":2,\"62\":3,\"148\":1,\"200\":1,\"439\":3}}],[\"jre包含jvm\",{\"1\":{\"148\":1}}],[\"jre\",{\"0\":{\"148\":1},\"1\":{\"148\":2}}],[\"jit优化\",{\"0\":{\"315\":1}}],[\"jit\",{\"1\":{\"133\":1,\"315\":1}}],[\"just\",{\"1\":{\"133\":1,\"445\":1}}],[\"jni引用的对象\",{\"1\":{\"88\":1}}],[\"java集合\",{\"0\":{\"458\":1}}],[\"java并发\",{\"0\":{\"457\":1}}],[\"java基础\",{\"0\":{\"456\":1}}],[\"java有哪些保证原子性的方法\",{\"0\":{\"405\":1}}],[\"java有哪些数据类型\",{\"0\":{\"159\":1}}],[\"java提供了atomicstampreference类\",{\"1\":{\"401\":1}}],[\"java提供了字符流\",{\"1\":{\"138\":1}}],[\"java对象头里\",{\"1\":{\"386\":1}}],[\"java对象流序列化是java标准库提供的一种序列化方式\",{\"1\":{\"178\":1}}],[\"java对象流序列化\",{\"1\":{\"178\":1}}],[\"java通过java\",{\"1\":{\"301\":1}}],[\"java线程将操作系统中的就绪和运行两种状态笼\",{\"1\":{\"241\":1}}],[\"java内存模型通过定义内存间的交互操作规则\",{\"1\":{\"211\":1}}],[\"java内存模型的抽象图\",{\"1\":{\"211\":1}}],[\"java内存模型\",{\"0\":{\"210\":1},\"1\":{\"211\":1}}],[\"java语言是值传递\",{\"1\":{\"207\":1}}],[\"java语言有哪些特点\",{\"0\":{\"147\":1}}],[\"java是值传递\",{\"0\":{\"207\":1}}],[\"java中提供了多种原子操作类\",{\"1\":{\"406\":1}}],[\"java中的forkjoinpool使用工作窃取队列来实现任务的并行执行\",{\"1\":{\"346\":1}}],[\"java中的delayed接口和delayedworkqueue类用于实现延迟队列\",{\"1\":{\"346\":1}}],[\"java中的priorityblockingqueue是一个线程安全的优先级队列实现\",{\"1\":{\"346\":1}}],[\"java中的线程池实现\",{\"0\":{\"301\":1}}],[\"java中的线程分为两类\",{\"1\":{\"246\":1}}],[\"java中序列化可以通过实现externalizable或者serializable来实现\",{\"1\":{\"209\":1}}],[\"java中实现map接口的有哪些类\",{\"0\":{\"192\":1}}],[\"java中可以使用google提供的protobuf\",{\"1\":{\"178\":1}}],[\"java中可以使用第三方库\",{\"1\":{\"178\":3}}],[\"java中可作为gc\",{\"0\":{\"88\":1}}],[\"java注解本质上是一个标记\",{\"1\":{\"190\":1}}],[\"java泛型是java\",{\"1\":{\"185\":1}}],[\"java库\",{\"1\":{\"178\":1}}],[\"java序列化可以将对象序列化为字节流\",{\"1\":{\"178\":1}}],[\"java序列化只会保存对象的非静态成员变量\",{\"1\":{\"177\":1}}],[\"java可以对字符串进行缓存和共享\",{\"1\":{\"168\":1}}],[\"java5\",{\"1\":{\"163\":1}}],[\"java的spi机制会使用服务加载器加载这些配置文件\",{\"1\":{\"153\":1}}],[\"java的spi\",{\"1\":{\"153\":1}}],[\"java的垃圾回收器不使用引用计数算法\",{\"1\":{\"87\":1}}],[\"java的垃圾回收器使用了\",{\"1\":{\"87\":1}}],[\"javadoc\",{\"1\":{\"148\":1}}],[\"javac\",{\"1\":{\"148\":1}}],[\"java程序运行在java虚拟机上\",{\"1\":{\"148\":1}}],[\"java程序在不同平台上运行时\",{\"1\":{\"135\":1}}],[\"java概述\",{\"0\":{\"146\":1}}],[\"java8有哪些内置函数式接口\",{\"0\":{\"143\":1}}],[\"java堆的内存分区主要是为了优化内存的使用和垃圾回收效率\",{\"1\":{\"91\":1}}],[\"java堆的内存分区了解吗\",{\"0\":{\"91\":1}}],[\"java堆可以根据内存分配的策略划分为不同的区域\",{\"1\":{\"91\":1}}],[\"java堆是java虚拟机管理的最大的一块内存区域\",{\"1\":{\"91\":1}}],[\"java堆是否规整是由选择的垃圾收集器是否具有压缩整理能力决定的\",{\"1\":{\"79\":1}}],[\"java堆内存溢出\",{\"1\":{\"85\":2}}],[\"java堆中可能会划分出一块内存作为句柄池\",{\"1\":{\"83\":1}}],[\"java虚拟机中常见的垃圾收集算法包括以下几种\",{\"1\":{\"92\":1}}],[\"java虚拟机规范中只规定了reference是一个指向对象的引用\",{\"1\":{\"83\":1}}],[\"java虚拟机\",{\"1\":{\"54\":1,\"72\":1,\"78\":1,\"148\":1}}],[\"java\",{\"0\":{\"137\":1,\"151\":1,\"168\":1,\"180\":1,\"209\":1,\"455\":1},\"1\":{\"53\":1,\"55\":1,\"79\":2,\"80\":1,\"85\":2,\"88\":1,\"98\":1,\"127\":1,\"131\":1,\"133\":1,\"139\":1,\"141\":3,\"144\":1,\"145\":1,\"148\":7,\"150\":2,\"151\":2,\"163\":3,\"177\":1,\"187\":3,\"188\":1,\"196\":1,\"204\":1,\"206\":1,\"211\":1,\"240\":1,\"256\":1,\"257\":1,\"279\":4,\"281\":4,\"286\":2,\"288\":4,\"303\":3,\"305\":3,\"320\":5,\"324\":4,\"328\":5,\"332\":2,\"336\":3,\"363\":1,\"364\":1,\"373\":2,\"376\":1,\"416\":2}}],[\"java栈\",{\"1\":{\"53\":2,\"55\":1,\"57\":1,\"68\":1,\"71\":1,\"88\":1,\"133\":1}}],[\"javascript\",{\"2\":{\"26\":1}}],[\"jvm先检查对象markword是否指向当前线程栈帧中的锁记录\",{\"1\":{\"390\":1}}],[\"jvm使用cas操作将对象头markword更新为指向锁记录的指针\",{\"1\":{\"390\":1}}],[\"jvm采用\",{\"1\":{\"380\":2}}],[\"jvm中的即时编译器\",{\"1\":{\"315\":1}}],[\"jvm退出\",{\"1\":{\"246\":1}}],[\"jvm执行start方法\",{\"1\":{\"238\":1}}],[\"jvm负责将字节码转换为对应平台的机器码\",{\"1\":{\"135\":1}}],[\"jvm负责分配和管理程序运行时所需的内存\",{\"1\":{\"132\":1}}],[\"jvm有一套安全管理机制\",{\"1\":{\"132\":1}}],[\"jvm自动管理内存\",{\"1\":{\"132\":1}}],[\"jvm将字节码解释或编译成本地机器码\",{\"1\":{\"132\":1}}],[\"jvm从文件系统中加载java字节码文件\",{\"1\":{\"132\":1}}],[\"jvm的开销\",{\"0\":{\"313\":1}}],[\"jvm的跨平台特性\",{\"0\":{\"135\":1}}],[\"jvm的工作过程\",{\"0\":{\"134\":1}}],[\"jvm的结构大致可以分为以下几个部分\",{\"1\":{\"133\":1}}],[\"jvm的结构\",{\"0\":{\"133\":1}}],[\"jvm的主要功能\",{\"0\":{\"132\":1}}],[\"jvm的内存区域主要包括\",{\"1\":{\"55\":1}}],[\"jvm的内存区域分为方法区\",{\"1\":{\"53\":1}}],[\"jvm的内存区域分为多个部分\",{\"1\":{\"53\":1}}],[\"jvm是java语言实现跨平台特性\",{\"1\":{\"135\":1}}],[\"jvm是java技术的核心部分\",{\"1\":{\"131\":1}}],[\"jvm是怎么设计来保证线程安全的\",{\"0\":{\"81\":1}}],[\"jvm支持逃逸分析的参数包括\",{\"1\":{\"127\":1}}],[\"jvm参数和逃逸分析\",{\"0\":{\"127\":1}}],[\"jvm可能会优化\",{\"1\":{\"126\":1}}],[\"jvm可以进行一系列优化\",{\"1\":{\"129\":1}}],[\"jvm可以进行一些优化\",{\"1\":{\"125\":1}}],[\"jvm可以消除不必要的同步代码\",{\"1\":{\"125\":1}}],[\"jvm会判断是否已经是重量级锁\",{\"1\":{\"390\":1}}],[\"jvm会正常退出\",{\"1\":{\"246\":1}}],[\"jvm会为对象设置对象头信息\",{\"1\":{\"78\":1}}],[\"jvm会将分配的内存空间初始化为零值\",{\"1\":{\"78\":1}}],[\"jvm会先检查字符串常量池中是否已经存在相同的字符串\",{\"1\":{\"64\":1}}],[\"jvm\",{\"0\":{\"81\":1,\"148\":1},\"1\":{\"53\":1,\"54\":1,\"63\":1,\"72\":1,\"78\":1,\"79\":5,\"80\":4,\"81\":4,\"100\":1,\"101\":1,\"131\":1,\"148\":2,\"157\":1,\"173\":1,\"183\":1}}],[\"踩了一些坑\",{\"1\":{\"24\":1}}],[\"踩坑\",{\"0\":{\"24\":1}}],[\"默认的segment长度是16\",{\"1\":{\"444\":1}}],[\"默认的拒绝策略\",{\"1\":{\"345\":1}}],[\"默认10次\",{\"1\":{\"390\":1}}],[\"默认策略\",{\"1\":{\"345\":1}}],[\"默认情况下\",{\"1\":{\"284\":1,\"308\":1}}],[\"默认情况类没有覆盖\",{\"1\":{\"205\":1}}],[\"默认\",{\"0\":{\"198\":1}}],[\"默认范围是\",{\"1\":{\"173\":1}}],[\"默认开启\",{\"1\":{\"127\":1}}],[\"默认值\",{\"1\":{\"23\":1,\"159\":1,\"201\":1,\"273\":1}}],[\"默认为15\",{\"1\":{\"97\":1}}],[\"默认为\",{\"1\":{\"11\":1}}],[\"修饰存储元素的\",{\"1\":{\"413\":1}}],[\"修饰代码块\",{\"1\":{\"378\":1}}],[\"修饰静态方法\",{\"1\":{\"378\":1}}],[\"修饰实例方法\",{\"1\":{\"378\":1}}],[\"修饰的\",{\"1\":{\"392\":1}}],[\"修饰的变量不可变\",{\"1\":{\"204\":1}}],[\"修饰的变量值不会被持久化和恢复\",{\"1\":{\"177\":1}}],[\"修饰的方法不可被重写\",{\"1\":{\"204\":1}}],[\"修饰符修饰的变量\",{\"1\":{\"202\":1}}],[\"修正后的解释和示例代码\",{\"0\":{\"70\":1}}],[\"修复\",{\"0\":{\"23\":1}}],[\"修改同步状态成功即为获得锁\",{\"1\":{\"392\":1}}],[\"修改是无效的\",{\"1\":{\"183\":1}}],[\"修改theme\",{\"1\":{\"23\":1}}],[\"修改\",{\"0\":{\"16\":1,\"17\":1},\"1\":{\"392\":1,\"416\":1}}],[\"gson等\",{\"1\":{\"178\":1}}],[\"get查询\",{\"1\":{\"445\":1}}],[\"get流程\",{\"1\":{\"444\":1}}],[\"gettreenode\",{\"1\":{\"428\":1}}],[\"getnode\",{\"1\":{\"428\":2}}],[\"getname\",{\"1\":{\"251\":3,\"253\":3,\"257\":4,\"303\":1,\"305\":1,\"328\":1,\"373\":1}}],[\"getintvolatile\",{\"1\":{\"407\":1}}],[\"getanddecrement\",{\"1\":{\"407\":1}}],[\"getandset\",{\"1\":{\"406\":1}}],[\"getandaddint\",{\"1\":{\"407\":2}}],[\"getandadd\",{\"1\":{\"228\":1}}],[\"getruntime\",{\"1\":{\"336\":1}}],[\"getstring\",{\"1\":{\"324\":1}}],[\"getsystemclassloader\",{\"1\":{\"232\":1}}],[\"getcause\",{\"1\":{\"359\":1,\"363\":1}}],[\"getconnection\",{\"1\":{\"324\":1}}],[\"getcount\",{\"1\":{\"249\":1}}],[\"getclass\",{\"1\":{\"175\":1}}],[\"get\",{\"1\":{\"144\":1,\"222\":1,\"230\":1,\"231\":1,\"271\":3,\"279\":1,\"281\":3,\"359\":1,\"363\":1,\"411\":3,\"428\":1}}],[\"generational\",{\"1\":{\"92\":1}}],[\"generation\",{\"1\":{\"53\":2,\"55\":1,\"91\":3,\"100\":1,\"102\":2}}],[\"goals\",{\"1\":{\"102\":1,\"109\":1}}],[\"g1适用于大多数现代应用\",{\"1\":{\"117\":1}}],[\"g1适用于多核处理器和大内存的环境\",{\"1\":{\"104\":1}}],[\"g1具有自适应调优能力\",{\"1\":{\"114\":1}}],[\"g1具有自适应调优功能\",{\"1\":{\"109\":1}}],[\"g1通过标记\",{\"1\":{\"114\":1}}],[\"g1通过分区管理和并发回收机制\",{\"1\":{\"114\":1}}],[\"g1通过混合回收\",{\"1\":{\"109\":1}}],[\"g1的设计目标之一就是提供可预测的低停顿时间\",{\"1\":{\"114\":1}}],[\"g1的引入旨在克服cms的局限性\",{\"1\":{\"110\":1}}],[\"g1和zgc是首选\",{\"1\":{\"117\":1}}],[\"g1和zgc\",{\"1\":{\"111\":1}}],[\"g1设计之初即考虑了大内存环境\",{\"1\":{\"109\":1}}],[\"g1除了支持并发标记外\",{\"1\":{\"109\":1}}],[\"g1会动态调整垃圾收集过程\",{\"1\":{\"109\":1}}],[\"g1会根据设置的暂停时间来调整其行为\",{\"1\":{\"102\":1}}],[\"g1引入了目标停顿时间设置\",{\"1\":{\"109\":1}}],[\"g1采用了分区\",{\"1\":{\"109\":1}}],[\"g1heapregionsize=<size>\",{\"1\":{\"105\":1}}],[\"g1可以根据用户设定的停顿时间目标自动调整其行为\",{\"1\":{\"104\":1}}],[\"g1可以通过参数配置目标暂停时间\",{\"1\":{\"102\":1}}],[\"g1在处理大堆内存时能有效控制垃圾收集的停顿时间\",{\"1\":{\"104\":1}}],[\"g1在回收过程中会同时处理年轻代和老年代的垃圾收集\",{\"1\":{\"102\":1}}],[\"g1收集器和cms一样\",{\"1\":{\"102\":1}}],[\"g1收集器专为多处理器和大内存的环境设计\",{\"1\":{\"101\":1}}],[\"g1收集器是一种面向服务端应用的垃圾收集器\",{\"1\":{\"98\":1}}],[\"g1垃圾收集器通过分区管理\",{\"1\":{\"106\":1,\"110\":1}}],[\"g1垃圾收集器的配置参数\",{\"0\":{\"105\":1}}],[\"g1垃圾收集器的优势\",{\"0\":{\"104\":1,\"109\":1}}],[\"g1垃圾收集器的工作阶段\",{\"0\":{\"103\":1}}],[\"g1垃圾收集器的关键特点\",{\"0\":{\"102\":1}}],[\"g1垃圾收集器\",{\"1\":{\"101\":1}}],[\"g1垃圾收集器了解吗\",{\"0\":{\"101\":1}}],[\"g1\",{\"1\":{\"98\":1,\"112\":1,\"120\":1,\"121\":1}}],[\"garbage\",{\"1\":{\"92\":1,\"96\":1,\"98\":2,\"101\":2,\"112\":2,\"120\":2,\"133\":1}}],[\"gc分代年龄\",{\"1\":{\"386\":1}}],[\"gc分代信息\",{\"1\":{\"78\":1}}],[\"gc可以通过调整\",{\"1\":{\"121\":1}}],[\"gc日志\",{\"1\":{\"121\":1}}],[\"gc停顿时间长和调优复杂等问题限制了其进一步的应用和发展\",{\"1\":{\"110\":1}}],[\"gc停顿时间长\",{\"1\":{\"108\":1,\"112\":1}}],[\"gc之前检查老年代\",{\"1\":{\"96\":1}}],[\"gc之后的对象移动操作中增加\",{\"1\":{\"97\":1}}],[\"gc之后\",{\"1\":{\"96\":1,\"97\":1}}],[\"gc之后老年代空间不足\",{\"1\":{\"96\":1}}],[\"gc通常在eden区满或者存活对象晋升到老年代时触发\",{\"1\":{\"95\":1}}],[\"gc通常会在新生代和老年代之间进行对象的晋升和迁移\",{\"1\":{\"94\":1}}],[\"gc实际上是对新生代进行垃圾回收\",{\"1\":{\"95\":1}}],[\"gc什么时候触发\",{\"0\":{\"95\":1}}],[\"gc会对新生代和老年代以及永久代\",{\"1\":{\"94\":1}}],[\"gc是一种完全的垃圾回收操作\",{\"1\":{\"94\":1}}],[\"gc是一种混合型的垃圾回收操作\",{\"1\":{\"94\":1}}],[\"gc的时机有两个主要条件\",{\"1\":{\"95\":1}}],[\"gc的目标是清理老年代中的垃圾对象\",{\"1\":{\"94\":1}}],[\"gc的目标是清理新生代中的垃圾对象\",{\"1\":{\"94\":1}}],[\"gc的频率和停顿时间\",{\"1\":{\"76\":1,\"77\":1}}],[\"gc中\",{\"1\":{\"94\":1}}],[\"gc都是什么意思\",{\"0\":{\"94\":1}}],[\"gc时\",{\"1\":{\"93\":1,\"96\":1}}],[\"gc后可能升入老年代的对象大小可能超过了老年代当前可用内存空间\",{\"1\":{\"96\":1}}],[\"gc后升入老年代的对象总和的平均大小\",{\"1\":{\"96\":1}}],[\"gc后仍然存活时\",{\"1\":{\"93\":1}}],[\"gc后仍然存活的对象\",{\"1\":{\"93\":1}}],[\"gc后仍然存活的对象会被晋升到老年代\",{\"1\":{\"91\":1,\"95\":1}}],[\"gc后\",{\"1\":{\"91\":1}}],[\"gc\",{\"0\":{\"94\":5,\"95\":1,\"96\":1},\"1\":{\"82\":1,\"87\":1,\"93\":1,\"94\":14,\"95\":5,\"96\":9,\"100\":1,\"103\":1,\"108\":3,\"118\":1,\"120\":6,\"124\":1,\"204\":1,\"230\":1}}],[\"gh\",{\"1\":{\"22\":1}}],[\"gitgraph\",{\"0\":{\"38\":1}}],[\"git\",{\"0\":{\"38\":1},\"1\":{\"11\":1}}],[\"gitee\",{\"1\":{\"1\":1}}],[\"github上开源\",{\"0\":{\"20\":1}}],[\"github\",{\"1\":{\"1\":1,\"8\":1,\"11\":1}}],[\"是基于红黑树实现的\",{\"1\":{\"448\":1}}],[\"是线程安全的吗\",{\"0\":{\"441\":1}}],[\"是因为如果这个阈值也设置成8\",{\"1\":{\"435\":1}}],[\"是因为当前版本没支持\",{\"1\":{\"27\":1}}],[\"是则向树中插入节点\",{\"1\":{\"427\":1}}],[\"是黑色的\",{\"1\":{\"423\":1}}],[\"是的话就返回遍历\",{\"1\":{\"416\":1}}],[\"是可重入锁\",{\"1\":{\"385\":1}}],[\"是类成员\",{\"1\":{\"378\":1}}],[\"是java提供的线程安全的哈希表实现\",{\"1\":{\"442\":1}}],[\"是java并发面试的高频题目\",{\"1\":{\"392\":1}}],[\"是java\",{\"1\":{\"261\":1}}],[\"是java虚拟机\",{\"1\":{\"101\":1}}],[\"是为成对线程设计的\",{\"1\":{\"259\":1}}],[\"是为每个线程分配的一块私有的内存区域\",{\"1\":{\"80\":1}}],[\"是当最后一个非守护线程束时\",{\"1\":{\"246\":1}}],[\"是系统进行资源分配和调度的基本单位\",{\"1\":{\"236\":1}}],[\"是阿里巴巴开源的基于\",{\"1\":{\"233\":1}}],[\"是原子性操作\",{\"1\":{\"213\":1}}],[\"是指资源是有线性顺序的\",{\"1\":{\"408\":1}}],[\"是指程序执行的顺序与代码的顺序一致\",{\"1\":{\"212\":1}}],[\"是指在程序执行过程中的特定位置\",{\"1\":{\"99\":1}}],[\"是在\",{\"1\":{\"204\":1}}],[\"是被\",{\"1\":{\"202\":1}}],[\"是程序无法处理的\",{\"1\":{\"180\":1}}],[\"是google开发的一种高效的序列化协议\",{\"1\":{\"178\":1}}],[\"是用来控制同时访问特定资源的线程数量\",{\"1\":{\"253\":1}}],[\"是用到了integer自动装箱的机制\",{\"1\":{\"173\":1}}],[\"是用于加载和实例化服务提供者的api\",{\"1\":{\"153\":1}}],[\"是用于防范\",{\"1\":{\"144\":1}}],[\"是a和b相等\",{\"1\":{\"173\":1}}],[\"是确保java应用程序性能和稳定性的关键\",{\"1\":{\"118\":1}}],[\"是一块连续的内存空间\",{\"1\":{\"411\":1}}],[\"是一种有序的的集合\",{\"1\":{\"448\":1}}],[\"是一种原子操作\",{\"1\":{\"398\":1}}],[\"是一种抽象的模型\",{\"1\":{\"211\":1}}],[\"是一种行为规范\",{\"1\":{\"200\":1}}],[\"是一种模板设计\",{\"1\":{\"200\":1}}],[\"是一种标记语言\",{\"1\":{\"178\":1}}],[\"是一种轻量级的数据交换格式\",{\"1\":{\"178\":1}}],[\"是一种元数据文件\",{\"1\":{\"153\":1}}],[\"是一种数据结构\",{\"1\":{\"99\":1}}],[\"是一个把大任务分割成若干个小任务\",{\"1\":{\"376\":1}}],[\"是一个以threadlocal对象为键\",{\"1\":{\"247\":1}}],[\"是一个接口\",{\"1\":{\"239\":1}}],[\"是一个类\",{\"1\":{\"239\":1}}],[\"是一个终端操作\",{\"1\":{\"145\":1}}],[\"是一个虚拟的计算机\",{\"1\":{\"131\":1}}],[\"是一个局部变量\",{\"1\":{\"69\":1}}],[\"是一个专门用于存储字符串字面值\",{\"1\":{\"64\":1}}],[\"是针对老年代的垃圾回收操作\",{\"1\":{\"94\":1}}],[\"是针对新生代的垃圾回收操作\",{\"1\":{\"94\":1}}],[\"是两种不同的内存管理问题\",{\"1\":{\"84\":1}}],[\"是\",{\"0\":{\"168\":1},\"1\":{\"80\":1,\"256\":1,\"386\":1,\"450\":1}}],[\"是每个类文件中的常量池\",{\"1\":{\"65\":1}}],[\"是源码分支\",{\"1\":{\"22\":1}}],[\"是否为树节点\",{\"1\":{\"427\":1}}],[\"是否支持随机访问\",{\"1\":{\"411\":1}}],[\"是否小于等于1\",{\"1\":{\"376\":1}}],[\"是否能够满足系统的性能和稳定性要求\",{\"1\":{\"372\":1}}],[\"是否能作用在\",{\"0\":{\"163\":1}}],[\"是否都不是以\",{\"1\":{\"145\":1}}],[\"是否有以\",{\"1\":{\"145\":1}}],[\"是否想要现在启动\",{\"1\":{\"11\":1}}],[\"是否初始化\",{\"1\":{\"11\":1}}],[\"是否需要一个自动部署文档到\",{\"1\":{\"11\":1}}],[\"点击jconsole线程面板的\",{\"1\":{\"409\":1}}],[\"点击访问即可\",{\"1\":{\"21\":1}}],[\"点击save\",{\"1\":{\"21\":1}}],[\"配置部署分支为gh\",{\"1\":{\"21\":1}}],[\"配置github\",{\"0\":{\"21\":1}}],[\"选中侧边栏pages\",{\"1\":{\"21\":1}}],[\"选择合适的方法取决于您的具体需求和应用场景\",{\"1\":{\"363\":1}}],[\"选择合适的垃圾收集器是一个平衡应用需求\",{\"1\":{\"122\":1}}],[\"选择合适的垃圾收集器\",{\"1\":{\"118\":1}}],[\"选择合适的垃圾收集器取决于应用程序的需求\",{\"1\":{\"111\":1}}],[\"选择合适的垃圾收集器取决于应用程序的性能需求和特点\",{\"1\":{\"98\":1}}],[\"选择合适的垃圾收集算法可以提高垃圾回收的效率和系统的性能\",{\"1\":{\"92\":1}}],[\"选择器\",{\"1\":{\"139\":4}}],[\"选择能适应未来需求的gc\",{\"1\":{\"121\":1}}],[\"选择垃圾收集器的步骤\",{\"0\":{\"121\":1}}],[\"选择使用指针碰撞还是空闲列表取决于堆内存的布局情况以及\",{\"1\":{\"79\":1}}],[\"选择包管理器\",{\"1\":{\"11\":1}}],[\"选择显示语言\",{\"1\":{\"11\":1}}],[\"打开settings\",{\"1\":{\"20\":1}}],[\"打开仓库my\",{\"1\":{\"20\":1,\"21\":1}}],[\"打开http\",{\"1\":{\"12\":1}}],[\"freenext\",{\"1\":{\"381\":1}}],[\"from\",{\"1\":{\"153\":1,\"324\":1}}],[\"from区和to区之间会进行对象的交换\",{\"1\":{\"91\":1}}],[\"from区和to区\",{\"1\":{\"91\":1,\"92\":1,\"93\":1}}],[\"fetchdatafromservice3\",{\"1\":{\"281\":2}}],[\"fetchdatafromservice2\",{\"1\":{\"281\":2}}],[\"fetchdatafromservice1\",{\"1\":{\"281\":2}}],[\"float\",{\"1\":{\"159\":2,\"207\":1}}],[\"forwardingnode<k\",{\"1\":{\"445\":1}}],[\"forwardingnode\",{\"1\":{\"445\":1}}],[\"forkjointask是fork\",{\"1\":{\"376\":1}}],[\"forkjointask\",{\"1\":{\"376\":1}}],[\"forkjoinpool实现了工作窃取算法\",{\"1\":{\"376\":1}}],[\"forkjoinpool是fork\",{\"1\":{\"376\":1}}],[\"forkjoinpool\",{\"1\":{\"283\":1,\"284\":1,\"294\":1,\"376\":1}}],[\"fork\",{\"0\":{\"376\":1},\"1\":{\"376\":8}}],[\"for\",{\"1\":{\"153\":1,\"230\":2,\"251\":1,\"253\":1,\"303\":1,\"305\":1,\"328\":1,\"373\":3,\"427\":3,\"450\":1}}],[\"foreach\",{\"1\":{\"145\":3,\"279\":1}}],[\"found\",{\"1\":{\"11\":1}}],[\"futureexceptionhandling\",{\"1\":{\"363\":1}}],[\"future<integer>\",{\"1\":{\"363\":1}}],[\"future<\",{\"1\":{\"359\":3}}],[\"future<string>\",{\"1\":{\"339\":1}}],[\"future3\",{\"1\":{\"271\":3,\"279\":3,\"281\":3}}],[\"future2\",{\"1\":{\"270\":2,\"271\":3,\"279\":3,\"281\":3}}],[\"future1\",{\"1\":{\"270\":2,\"271\":3,\"279\":3,\"281\":3}}],[\"future\",{\"0\":{\"363\":1},\"1\":{\"263\":2,\"265\":1,\"269\":1,\"273\":1,\"274\":1,\"276\":1,\"277\":1,\"279\":2,\"284\":1,\"287\":1,\"288\":2,\"339\":1,\"359\":3,\"363\":3}}],[\"functionname\",{\"1\":{\"186\":2}}],[\"function\",{\"1\":{\"143\":1,\"145\":1}}],[\"functionalinterface\",{\"1\":{\"142\":1,\"143\":1}}],[\"full\",{\"0\":{\"94\":1},\"1\":{\"94\":3,\"96\":2,\"108\":1,\"110\":1,\"112\":1}}],[\"f\",{\"1\":{\"139\":1,\"445\":4}}],[\"fast\",{\"0\":{\"416\":1},\"1\":{\"416\":1}}],[\"fail\",{\"0\":{\"416\":2},\"1\":{\"416\":2}}],[\"failure\",{\"1\":{\"96\":1,\"108\":1}}],[\"fair\",{\"1\":{\"397\":2}}],[\"fairsync\",{\"0\":{\"394\":1},\"1\":{\"397\":3}}],[\"fallback\",{\"1\":{\"144\":1}}],[\"false\",{\"1\":{\"17\":1,\"145\":1,\"159\":1,\"373\":2,\"397\":1,\"398\":1}}],[\"fibonacci\",{\"1\":{\"376\":1}}],[\"fibonaccitask\",{\"1\":{\"376\":13}}],[\"fixedthreadpool\",{\"0\":{\"353\":1},\"1\":{\"290\":1,\"302\":2,\"351\":1,\"353\":1}}],[\"fifo\",{\"1\":{\"255\":1}}],[\"field\",{\"1\":{\"155\":1,\"190\":1}}],[\"filter\",{\"1\":{\"145\":4}}],[\"file\",{\"1\":{\"65\":1,\"153\":1}}],[\"first\",{\"1\":{\"98\":1,\"101\":1,\"112\":1,\"120\":1,\"428\":9}}],[\"finalizabledelegatedexecutorservice\",{\"1\":{\"355\":1}}],[\"finalize的区别\",{\"0\":{\"204\":1}}],[\"finalize\",{\"0\":{\"90\":1},\"1\":{\"90\":5,\"175\":1,\"204\":6}}],[\"finalresult\",{\"1\":{\"281\":2}}],[\"final修饰的类不可被继承\",{\"1\":{\"204\":1}}],[\"final关键字有什么作用\",{\"0\":{\"203\":1}}],[\"finally中修改try中return的值\",{\"1\":{\"183\":1}}],[\"finally中return\",{\"1\":{\"183\":1}}],[\"finally中正常执行\",{\"1\":{\"183\":1}}],[\"finally\",{\"0\":{\"204\":1},\"1\":{\"183\":10,\"204\":1,\"391\":1,\"445\":1}}],[\"finally块中的代码也无法执行\",{\"1\":{\"182\":2}}],[\"finally一定会执行吗\",{\"0\":{\"182\":1}}],[\"final\",{\"0\":{\"204\":1},\"1\":{\"169\":1,\"200\":1,\"204\":1,\"228\":1,\"231\":1,\"303\":1,\"305\":1,\"320\":1,\"373\":4,\"376\":1,\"401\":1,\"407\":4,\"428\":1,\"445\":2}}],[\"fin\",{\"1\":{\"51\":1}}],[\"web服务器可以预先创建一组线程来处理请求\",{\"1\":{\"319\":1}}],[\"web服务器需要处理大量的客户端请求\",{\"1\":{\"318\":1}}],[\"web服务器\",{\"0\":{\"317\":1}}],[\"weakcompareandsetint\",{\"1\":{\"407\":2}}],[\"weak\",{\"1\":{\"89\":1}}],[\"when\",{\"1\":{\"232\":1,\"445\":1}}],[\"whether\",{\"1\":{\"190\":1}}],[\"while\",{\"1\":{\"85\":1,\"230\":1,\"251\":1,\"320\":1,\"324\":1,\"373\":1,\"407\":1,\"428\":1,\"445\":2}}],[\"word的锁对象\",{\"1\":{\"390\":1}}],[\"word里存储当前线程指针\",{\"1\":{\"387\":1}}],[\"word存储对象自身的运行数据\",{\"1\":{\"386\":1}}],[\"word\",{\"1\":{\"386\":3,\"390\":1}}],[\"worker\",{\"1\":{\"373\":2}}],[\"workers\",{\"1\":{\"373\":5}}],[\"workerthread\",{\"1\":{\"373\":5}}],[\"work\",{\"1\":{\"346\":1}}],[\"workqueue\",{\"1\":{\"304\":1,\"305\":1,\"338\":1,\"344\":1,\"359\":2}}],[\"wora\",{\"1\":{\"131\":1}}],[\"world\",{\"0\":{\"99\":1},\"1\":{\"99\":1,\"100\":1,\"265\":1,\"269\":1,\"270\":1}}],[\"writeobject\",{\"1\":{\"450\":1}}],[\"writeobject自定义序列化和反序列化策略\",{\"1\":{\"415\":1}}],[\"writer\",{\"1\":{\"137\":1}}],[\"write\",{\"1\":{\"131\":1}}],[\"windows\",{\"1\":{\"148\":1}}],[\"window\",{\"1\":{\"51\":1}}],[\"with\",{\"1\":{\"17\":1,\"90\":1}}],[\"waiters\",{\"1\":{\"381\":1}}],[\"waitsetlock\",{\"1\":{\"381\":1}}],[\"waitset\",{\"1\":{\"381\":4}}],[\"waittofight\",{\"1\":{\"249\":6}}],[\"waitind\",{\"1\":{\"241\":1}}],[\"waiting状态是暂时的\",{\"1\":{\"243\":1}}],[\"waiting状态表示线程在等待其他线程的通知或中断\",{\"1\":{\"243\":1}}],[\"waiting状态表示线程正在等待其他线程的通知\",{\"1\":{\"242\":1}}],[\"waiting和terminated有什么区别\",{\"0\":{\"243\":1}}],[\"waiting\",{\"1\":{\"241\":2}}],[\"wait\",{\"1\":{\"175\":3,\"240\":8,\"247\":1,\"381\":1}}],[\"want\",{\"1\":{\"11\":1}}],[\"was\",{\"1\":{\"11\":1}}],[\"warn\",{\"1\":{\"11\":1}}],[\"的源码⾮常⾮常少\",{\"1\":{\"450\":1}}],[\"的顺序进行排序\",{\"1\":{\"448\":1}}],[\"的自然顺序或者\",{\"1\":{\"448\":1}}],[\"的基础上维护了一个双向链表\",{\"1\":{\"447\":1}}],[\"的基础用法\",{\"1\":{\"183\":1}}],[\"的策略\",{\"1\":{\"439\":1}}],[\"的概念\",{\"1\":{\"439\":1}}],[\"的某些数字\",{\"1\":{\"433\":1}}],[\"的低位的余数部分\",{\"1\":{\"431\":1}}],[\"的同时并不释放自己已经获取的资源\",{\"1\":{\"408\":1}}],[\"的原理\",{\"0\":{\"407\":1}}],[\"的当前值是否等于预期值\",{\"1\":{\"398\":1}}],[\"的操作过程如下\",{\"1\":{\"398\":1}}],[\"的状态值加1后返回\",{\"1\":{\"396\":1}}],[\"的状态值为1\",{\"1\":{\"396\":1}}],[\"的执行过程\",{\"0\":{\"396\":1}}],[\"的锁\",{\"1\":{\"378\":2}}],[\"的调用次数\",{\"1\":{\"375\":1}}],[\"的调度\",{\"1\":{\"240\":1}}],[\"的构造函数或者提供的方法\",{\"1\":{\"371\":1}}],[\"的并发行为\",{\"1\":{\"294\":1}}],[\"的结果进行合并\",{\"1\":{\"270\":1}}],[\"的结果暂存起来\",{\"1\":{\"183\":1}}],[\"的屏障\",{\"1\":{\"250\":1}}],[\"的时间自行返回的\",{\"1\":{\"241\":1}}],[\"的方法和使用特定的数据结构\",{\"1\":{\"233\":1}}],[\"的增强版\",{\"1\":{\"233\":1}}],[\"的大小为老数组的两倍\",{\"1\":{\"230\":1}}],[\"的数组\",{\"1\":{\"413\":1}}],[\"的数量已经达到了列表的扩容阈值\",{\"1\":{\"230\":1}}],[\"的数据反序列化为java对象\",{\"1\":{\"178\":1}}],[\"的弱引用\",{\"1\":{\"225\":1}}],[\"的理解\",{\"0\":{\"211\":1}}],[\"的两个对象⽆论如何都不会相等\",{\"1\":{\"206\":1}}],[\"的默认⾏为是对堆上的对象产⽣独特值\",{\"1\":{\"206\":1}}],[\"的⽅式调用\",{\"1\":{\"202\":1}}],[\"的⽅式\",{\"1\":{\"202\":2}}],[\"的静态存储区\",{\"1\":{\"201\":1}}],[\"的兼容性\",{\"1\":{\"188\":1}}],[\"的拼接操作\",{\"1\":{\"171\":1}}],[\"的区别\",{\"0\":{\"197\":1,\"205\":1}}],[\"的区别及作用\",{\"0\":{\"164\":1}}],[\"的区域\",{\"1\":{\"64\":1}}],[\"的类加载机制和类对象模型\",{\"1\":{\"157\":1}}],[\"的容器\",{\"1\":{\"144\":1}}],[\"的\",{\"1\":{\"139\":1,\"183\":1,\"232\":1,\"364\":1,\"381\":1}}],[\"的一部分\",{\"1\":{\"102\":1}}],[\"的垃圾收集\",{\"1\":{\"100\":1}}],[\"的内存不足时\",{\"1\":{\"94\":1}}],[\"的内存区域有一些重要的变化\",{\"1\":{\"54\":1}}],[\"的初始对象开始\",{\"1\":{\"87\":1}}],[\"的工作原理如下\",{\"1\":{\"80\":1}}],[\"的工作流\",{\"1\":{\"11\":1}}],[\"的具体实现\",{\"1\":{\"79\":1}}],[\"的影响\",{\"1\":{\"74\":1}}],[\"的值更新为新值\",{\"1\":{\"398\":1}}],[\"的值更新为新值b\",{\"1\":{\"398\":1}}],[\"的值已经被其他线程改变\",{\"1\":{\"398\":1}}],[\"的值没有被其他线程改变\",{\"1\":{\"398\":1}}],[\"的值相同时\",{\"1\":{\"398\":1}}],[\"的值传递问题\",{\"1\":{\"233\":1}}],[\"的值\",{\"1\":{\"69\":1}}],[\"的逐步移除\",{\"1\":{\"56\":1}}],[\"的博客演示\",{\"1\":{\"17\":1}}],[\"博客演示\",{\"1\":{\"17\":1}}],[\"empty\",{\"1\":{\"412\":1,\"445\":1}}],[\"epoch\",{\"1\":{\"386\":1}}],[\"err\",{\"1\":{\"361\":1}}],[\"error\",{\"1\":{\"180\":1}}],[\"ee\",{\"1\":{\"359\":2}}],[\"each循环遍历键值对\",{\"1\":{\"193\":1}}],[\"each循环遍历键集合或值集合\",{\"1\":{\"193\":1}}],[\"else\",{\"1\":{\"230\":1,\"232\":1,\"376\":1,\"427\":3,\"445\":2}}],[\"elementdata\",{\"1\":{\"412\":3,\"413\":1}}],[\"elementtype\",{\"1\":{\"190\":6}}],[\"element\",{\"1\":{\"187\":2,\"411\":1}}],[\"elimination\",{\"1\":{\"125\":1}}],[\"equals\",{\"0\":{\"205\":1,\"206\":1},\"1\":{\"175\":1,\"205\":2,\"206\":1,\"427\":2,\"428\":2}}],[\"effective\",{\"1\":{\"141\":1}}],[\"entrylist\",{\"1\":{\"381\":2}}],[\"entry为\",{\"1\":{\"229\":1}}],[\"entry数据\",{\"1\":{\"229\":1}}],[\"entry\",{\"1\":{\"228\":1,\"230\":6,\"421\":2}}],[\"entry是threalocal弱引用作为key\",{\"1\":{\"228\":1}}],[\"enum\",{\"1\":{\"163\":1}}],[\"engine\",{\"1\":{\"133\":1}}],[\"enable\",{\"1\":{\"17\":1}}],[\"escapeanalysisexample\",{\"1\":{\"126\":1}}],[\"escape\",{\"0\":{\"125\":1}}],[\"esbuild\",{\"1\":{\"11\":2}}],[\"evacuation\",{\"1\":{\"103\":1}}],[\"e\",{\"1\":{\"85\":2,\"139\":1,\"183\":1,\"187\":1,\"230\":5,\"249\":2,\"251\":2,\"253\":2,\"257\":4,\"271\":2,\"276\":2,\"277\":2,\"279\":8,\"281\":8,\"288\":3,\"303\":2,\"305\":2,\"324\":2,\"328\":2,\"332\":1,\"336\":1,\"342\":1,\"348\":1,\"358\":2,\"360\":2,\"362\":2,\"363\":4,\"373\":3,\"411\":1,\"427\":7,\"428\":10,\"450\":7}}],[\"existing\",{\"1\":{\"450\":1}}],[\"exit\",{\"1\":{\"182\":2,\"204\":1}}],[\"extends\",{\"1\":{\"359\":1,\"373\":1,\"376\":1}}],[\"extensible\",{\"1\":{\"178\":1}}],[\"execute\",{\"1\":{\"339\":2,\"347\":5}}],[\"executequery\",{\"1\":{\"324\":1}}],[\"executor\",{\"1\":{\"303\":6,\"305\":6,\"328\":6,\"332\":3,\"338\":1,\"339\":2,\"342\":4,\"348\":5,\"358\":2,\"360\":1,\"361\":2,\"363\":3}}],[\"executorservice\",{\"1\":{\"286\":2,\"288\":2,\"290\":1,\"291\":1,\"292\":1,\"294\":2,\"302\":3,\"303\":2,\"320\":2,\"328\":2,\"332\":2,\"338\":1,\"353\":1,\"354\":1,\"355\":1,\"358\":1,\"360\":1,\"361\":1,\"363\":1}}],[\"executors\",{\"1\":{\"286\":3,\"288\":2,\"290\":1,\"291\":1,\"292\":1,\"293\":1,\"294\":2,\"302\":4,\"303\":2,\"320\":2,\"328\":2,\"332\":2,\"336\":2,\"358\":1,\"360\":1,\"363\":1}}],[\"executionexception\",{\"1\":{\"271\":1,\"279\":2,\"281\":2,\"359\":1,\"363\":1}}],[\"execution\",{\"1\":{\"133\":1}}],[\"ex\",{\"1\":{\"273\":1,\"274\":2}}],[\"exclusive表示是获取独占资源时被挂起后放入aqs队列的\",{\"1\":{\"392\":1}}],[\"exchange\",{\"1\":{\"257\":2,\"258\":3,\"259\":2}}],[\"exchanger也可以用于校对工作\",{\"1\":{\"259\":1}}],[\"exchanger可以用于遗传算法\",{\"1\":{\"259\":1}}],[\"exchanger<>\",{\"1\":{\"257\":1}}],[\"exchanger<string>\",{\"1\":{\"257\":5}}],[\"exchangerexample\",{\"1\":{\"257\":1}}],[\"exchanger\",{\"0\":{\"256\":1},\"1\":{\"256\":1,\"257\":15,\"258\":1,\"259\":3}}],[\"exceptionally\",{\"0\":{\"273\":1},\"1\":{\"273\":1,\"362\":1}}],[\"exception\",{\"1\":{\"180\":2,\"183\":1,\"358\":1,\"363\":2,\"416\":3}}],[\"expected\",{\"1\":{\"407\":3}}],[\"expungestaleentries\",{\"1\":{\"230\":1}}],[\"expr还可以是字符串\",{\"1\":{\"163\":1}}],[\"expr\",{\"1\":{\"163\":3}}],[\"export\",{\"1\":{\"17\":1}}],[\"examplemethod\",{\"1\":{\"126\":1}}],[\"example\",{\"1\":{\"65\":1,\"70\":1,\"153\":2,\"332\":1}}],[\"eden区满\",{\"1\":{\"95\":1}}],[\"eden区和survivor区\",{\"1\":{\"93\":1}}],[\"eden区是新创建对象的初始分配区域\",{\"1\":{\"93\":1}}],[\"eden区\",{\"1\":{\"91\":1,\"93\":2}}],[\"eden\",{\"1\":{\"53\":1}}],[\"访问修饰符public\",{\"0\":{\"198\":1}}],[\"访问\",{\"0\":{\"12\":1},\"1\":{\"12\":1}}],[\"nt\",{\"1\":{\"445\":2}}],[\"nthreads\",{\"1\":{\"353\":3}}],[\"nil节点\",{\"1\":{\"423\":1}}],[\"nio工作原理\",{\"1\":{\"139\":1}}],[\"nio\",{\"0\":{\"139\":1},\"1\":{\"139\":2}}],[\"n\",{\"1\":{\"376\":15,\"411\":2,\"424\":2,\"427\":3,\"428\":3,\"439\":2,\"445\":6}}],[\"nanos\",{\"1\":{\"175\":1,\"240\":1,\"247\":1}}],[\"native\",{\"1\":{\"53\":1,\"55\":1,\"75\":1,\"88\":1,\"133\":2,\"401\":1,\"407\":1}}],[\"null的槽位才会停止查找\",{\"1\":{\"229\":1}}],[\"null\",{\"1\":{\"144\":2,\"230\":4,\"232\":2,\"274\":1,\"359\":2,\"362\":1,\"381\":9,\"427\":8,\"428\":9,\"445\":7,\"450\":2}}],[\"nullpointerexception\",{\"1\":{\"144\":1}}],[\"number\",{\"1\":{\"51\":2}}],[\"nexttable\",{\"1\":{\"445\":2}}],[\"nexttab\",{\"1\":{\"445\":5}}],[\"next\",{\"1\":{\"324\":1,\"416\":1,\"427\":2,\"428\":2}}],[\"nextindex\",{\"1\":{\"230\":1}}],[\"nexthashcode\",{\"1\":{\"228\":2}}],[\"net\",{\"1\":{\"320\":2}}],[\"netflix\",{\"1\":{\"116\":1}}],[\"network\",{\"1\":{\"11\":1}}],[\"new一个object作为value\",{\"1\":{\"450\":1}}],[\"newnode\",{\"1\":{\"427\":2}}],[\"newcapacity\",{\"1\":{\"412\":6}}],[\"newcachedthreadpool\",{\"1\":{\"291\":1,\"294\":1,\"302\":1,\"354\":1}}],[\"newthread\",{\"1\":{\"360\":1}}],[\"newtab\",{\"1\":{\"230\":7}}],[\"newscheduledthreadpool\",{\"1\":{\"293\":1,\"302\":1,\"336\":1}}],[\"newsinglethreadexecutor\",{\"1\":{\"292\":1,\"302\":1,\"355\":1}}],[\"newfixedthreadpool\",{\"1\":{\"286\":1,\"288\":1,\"290\":1,\"294\":1,\"302\":1,\"303\":1,\"320\":1,\"328\":1,\"332\":1,\"353\":1,\"358\":1,\"360\":1,\"363\":1}}],[\"newlen\",{\"1\":{\"230\":5}}],[\"new创建新对象\",{\"1\":{\"209\":1}}],[\"new\",{\"0\":{\"81\":1,\"170\":1,\"432\":1},\"1\":{\"81\":1,\"85\":2,\"89\":1,\"126\":1,\"145\":1,\"155\":1,\"170\":3,\"222\":1,\"230\":1,\"231\":2,\"241\":1,\"249\":12,\"251\":4,\"253\":3,\"255\":1,\"257\":5,\"273\":1,\"274\":1,\"276\":1,\"277\":1,\"279\":4,\"281\":3,\"288\":1,\"305\":2,\"320\":2,\"324\":1,\"336\":1,\"338\":2,\"353\":2,\"354\":2,\"355\":3,\"356\":1,\"360\":2,\"361\":3,\"363\":1,\"373\":4,\"376\":3,\"378\":1,\"393\":1,\"397\":5,\"412\":1,\"445\":2}}],[\"npm\",{\"1\":{\"14\":1}}],[\"nonfairsync\",{\"0\":{\"395\":1},\"1\":{\"393\":1,\"397\":4}}],[\"nonematch\",{\"1\":{\"145\":1}}],[\"nonestartswithz\",{\"1\":{\"145\":1}}],[\"not\",{\"1\":{\"232\":1}}],[\"notifyall\",{\"1\":{\"175\":1,\"240\":5,\"391\":1}}],[\"notify\",{\"1\":{\"175\":1,\"240\":6,\"247\":1}}],[\"node<\",{\"1\":{\"445\":1}}],[\"node<k\",{\"1\":{\"427\":1,\"428\":4,\"445\":9}}],[\"node节点中的thread变量用来存放进入aqs队列里的线程\",{\"1\":{\"392\":1}}],[\"node\",{\"1\":{\"11\":2,\"428\":1}}],[\"no\",{\"1\":{\"11\":1,\"232\":1,\"445\":1}}],[\"hugecapacity\",{\"1\":{\"412\":1}}],[\"h\",{\"1\":{\"230\":5,\"427\":2}}],[\"hysteresis\",{\"1\":{\"230\":1}}],[\"handler\",{\"1\":{\"361\":2}}],[\"handlerequest\",{\"1\":{\"320\":2}}],[\"handle\",{\"0\":{\"274\":1},\"1\":{\"274\":1}}],[\"happens\",{\"0\":{\"216\":1},\"1\":{\"216\":11}}],[\"hash一样就覆盖\",{\"1\":{\"445\":1}}],[\"hashentry本身就是一个链表的结构\",{\"1\":{\"444\":1}}],[\"hash值\",{\"1\":{\"431\":3}}],[\"hash计算后应该落入第\",{\"1\":{\"229\":1}}],[\"hash\",{\"1\":{\"228\":4,\"421\":1,\"427\":10,\"428\":8,\"438\":2,\"445\":2}}],[\"hashset的add方法\",{\"1\":{\"450\":1}}],[\"hashset⾃⼰不得不实现之外\",{\"1\":{\"450\":1}}],[\"hashset\",{\"1\":{\"206\":1,\"450\":2}}],[\"hashtable\",{\"1\":{\"192\":1}}],[\"hashmap采用了\",{\"1\":{\"439\":1}}],[\"hashmap采用了尾插法\",{\"1\":{\"439\":1}}],[\"hashmap会使用更加均匀的哈希函数来计算索引位置\",{\"1\":{\"439\":1}}],[\"hashmap会将链表转换为红黑树\",{\"1\":{\"439\":1}}],[\"hashmap会向上寻找\",{\"1\":{\"432\":1}}],[\"hashmap扩容机制了解吗\",{\"0\":{\"438\":1}}],[\"hashmap里进行了优化改造\",{\"1\":{\"433\":1}}],[\"hashmap<>\",{\"0\":{\"432\":1}}],[\"hashmap的putval\",{\"1\":{\"450\":1}}],[\"hashmap的put流程知道吗\",{\"0\":{\"427\":1}}],[\"hashmap的容量必须是2的倍数\",{\"1\":{\"432\":1}}],[\"hashmap的哈希函数是先通过\",{\"1\":{\"429\":1}}],[\"hashmap的哈希\",{\"0\":{\"429\":1}}],[\"hashmap怎么查找元素的呢\",{\"0\":{\"428\":1}}],[\"hashmap使用头插法插入元素\",{\"1\":{\"441\":1}}],[\"hashmap使用链表或红黑树来解决冲突\",{\"1\":{\"421\":1}}],[\"hashmap使用键的哈希码\",{\"1\":{\"421\":1}}],[\"hashmap内部使用一个数组\",{\"1\":{\"421\":1}}],[\"hashmap\",{\"0\":{\"441\":1,\"446\":1},\"1\":{\"192\":1,\"206\":1,\"446\":2,\"447\":1,\"450\":2}}],[\"hashcode方法用于获取对象的哈希码\",{\"1\":{\"206\":1}}],[\"hashcode与\",{\"0\":{\"206\":1}}],[\"hashcode\",{\"1\":{\"175\":1,\"206\":4,\"427\":1,\"429\":1,\"440\":1}}],[\"hotspot会计算并记录下对象内部各个偏移量上存储的数据类型\",{\"1\":{\"99\":1}}],[\"hotspot虚拟机并不要求对象的年龄必须达到阈值才能晋升到老年代\",{\"1\":{\"97\":1}}],[\"hotspot虚拟机主要采用直接指针访问方式来进行对象访问\",{\"1\":{\"83\":1}}],[\"hope\",{\"1\":{\"8\":1,\"10\":1,\"11\":5,\"17\":1}}],[\"helptransfer\",{\"1\":{\"445\":1}}],[\"help\",{\"1\":{\"230\":1}}],[\"helloserviceimpl2\",{\"1\":{\"153\":1}}],[\"helloserviceimpl\",{\"1\":{\"153\":3}}],[\"helloservice\",{\"1\":{\"153\":5}}],[\"hello\",{\"1\":{\"64\":2,\"65\":2,\"70\":2,\"153\":1,\"265\":1,\"266\":1,\"267\":1,\"269\":1,\"270\":1}}],[\"hessian是一种基于http的轻量级二进制序列化协议\",{\"1\":{\"178\":1}}],[\"hessian序列化\",{\"1\":{\"178\":1}}],[\"header\",{\"1\":{\"82\":4,\"381\":1}}],[\"heapoverflowexample\",{\"1\":{\"85\":1}}],[\"heap\",{\"1\":{\"53\":1,\"55\":1,\"64\":1,\"124\":1,\"132\":1,\"133\":1}}],[\"http\",{\"1\":{\"11\":2}}],[\"➜\",{\"1\":{\"11\":2}}],[\">>>\",{\"1\":{\"427\":1,\"445\":1}}],[\">>\",{\"1\":{\"412\":2}}],[\">a\",{\"1\":{\"400\":1}}],[\">b\",{\"1\":{\"400\":1}}],[\">重量级锁\",{\"1\":{\"388\":1}}],[\">偏向锁\",{\"1\":{\"388\":1}}],[\">达到屏障点\",{\"1\":{\"251\":1}}],[\">放行\",{\"1\":{\"251\":2}}],[\">=\",{\"1\":{\"230\":4,\"427\":2}}],[\">对象指向分配的内存空间\",{\"1\":{\"215\":1}}],[\">初始化对象\",{\"1\":{\"215\":1}}],[\">\",{\"1\":{\"11\":2,\"85\":1,\"144\":1,\"145\":8,\"150\":1,\"230\":1,\"232\":1,\"249\":6,\"263\":2,\"265\":2,\"266\":2,\"267\":2,\"269\":3,\"270\":3,\"271\":4,\"273\":3,\"274\":3,\"276\":1,\"277\":1,\"279\":6,\"281\":4,\"284\":1,\"287\":1,\"288\":2,\"294\":3,\"303\":1,\"305\":1,\"320\":1,\"328\":1,\"332\":1,\"336\":2,\"339\":2,\"358\":1,\"359\":3,\"360\":1,\"362\":2,\"363\":1,\"373\":1,\"388\":1,\"427\":1,\"428\":1,\"445\":2}}],[\"请求并持有\",{\"1\":{\"408\":2}}],[\"请在浏览器输入给出的开发服务器地址\",{\"1\":{\"11\":1}}],[\"请耐心等待\",{\"1\":{\"11\":1}}],[\"ynchronized修饰同步方法时\",{\"1\":{\"380\":1}}],[\"yield\",{\"1\":{\"240\":2,\"245\":1,\"445\":1}}],[\"y\",{\"1\":{\"126\":4}}],[\"yml\",{\"0\":{\"16\":1}}],[\"young\",{\"0\":{\"94\":1,\"95\":1},\"1\":{\"53\":1,\"91\":1,\"94\":1,\"96\":2,\"102\":1}}],[\"you\",{\"1\":{\"11\":1}}],[\"yes\",{\"1\":{\"11\":3}}],[\"ie\",{\"1\":{\"359\":1}}],[\"illegalstateexception\",{\"1\":{\"276\":1,\"277\":1,\"279\":4,\"281\":3,\"288\":1}}],[\"ilp\",{\"1\":{\"215\":1}}],[\"ignored\",{\"1\":{\"249\":1}}],[\"i++\",{\"1\":{\"213\":1,\"251\":1,\"253\":1,\"303\":1,\"305\":1,\"373\":2}}],[\"implements\",{\"1\":{\"153\":1,\"251\":1,\"253\":1,\"257\":2}}],[\"import\",{\"1\":{\"85\":2,\"257\":1,\"279\":4,\"281\":4,\"286\":2,\"288\":4,\"303\":3,\"305\":3,\"320\":5,\"324\":5,\"328\":5,\"332\":2,\"336\":3,\"363\":1,\"373\":2,\"376\":1}}],[\"isdone\",{\"1\":{\"359\":1}}],[\"isinterrupted\",{\"1\":{\"240\":2}}],[\"isbooted\",{\"1\":{\"232\":2}}],[\"is\",{\"1\":{\"190\":1,\"373\":2}}],[\"ispresent\",{\"1\":{\"144\":1}}],[\"issame\",{\"1\":{\"64\":1}}],[\"ioexception\",{\"1\":{\"320\":3}}],[\"io\",{\"0\":{\"136\":1,\"137\":1},\"1\":{\"320\":1}}],[\"i\",{\"1\":{\"85\":2,\"183\":7,\"213\":4,\"228\":1,\"230\":1,\"251\":3,\"253\":3,\"303\":3,\"305\":3,\"373\":7,\"427\":3,\"445\":2}}],[\"item\",{\"1\":{\"328\":5}}],[\"it\",{\"1\":{\"11\":2,\"17\":1}}],[\"ifpresent\",{\"1\":{\"144\":1}}],[\"if\",{\"0\":{\"217\":1},\"1\":{\"11\":1,\"216\":1,\"217\":3,\"230\":4,\"232\":5,\"273\":1,\"274\":2,\"288\":1,\"303\":1,\"305\":1,\"328\":1,\"336\":1,\"342\":1,\"348\":1,\"359\":3,\"363\":1,\"376\":1,\"384\":1,\"412\":3,\"427\":9,\"428\":5,\"445\":9,\"450\":2}}],[\"inittable\",{\"1\":{\"445\":2}}],[\"initiatingheapoccupancypercent=<n>\",{\"1\":{\"105\":1}}],[\"initialization\",{\"1\":{\"445\":1}}],[\"initial\",{\"1\":{\"100\":1,\"102\":1,\"103\":1}}],[\"index\",{\"1\":{\"303\":2,\"305\":2,\"411\":2}}],[\"inheriting\",{\"1\":{\"232\":1}}],[\"inherit\",{\"1\":{\"232\":1}}],[\"inheritablethreadlocals\",{\"1\":{\"232\":5}}],[\"inheritablethreadlocal原理是什么呢\",{\"0\":{\"232\":1}}],[\"inheritablethreadlocaltest\",{\"1\":{\"231\":1}}],[\"inheritablethreadlocal\",{\"1\":{\"231\":2,\"233\":1}}],[\"increment\",{\"1\":{\"228\":2}}],[\"incremental\",{\"1\":{\"92\":1}}],[\"instruction\",{\"1\":{\"215\":1}}],[\"instanceof\",{\"1\":{\"359\":1,\"427\":1,\"428\":1,\"445\":1}}],[\"instance=new\",{\"1\":{\"215\":1}}],[\"instance\",{\"1\":{\"82\":3}}],[\"inf\",{\"1\":{\"153\":3}}],[\"inputstream\",{\"1\":{\"137\":1}}],[\"intrinsiccandidate\",{\"1\":{\"401\":1}}],[\"intrinsic\",{\"1\":{\"381\":1}}],[\"integercache是一个静态内部类\",{\"1\":{\"173\":1}}],[\"integer\",{\"0\":{\"173\":4},\"1\":{\"173\":2,\"174\":2,\"328\":2,\"354\":1,\"356\":1,\"363\":1,\"376\":2}}],[\"interruptedexception\",{\"1\":{\"249\":4,\"251\":2,\"253\":1,\"255\":1,\"257\":2,\"259\":1,\"271\":1,\"276\":1,\"277\":1,\"279\":4,\"281\":4,\"288\":2,\"303\":2,\"305\":2,\"328\":2,\"332\":1,\"336\":1,\"342\":1,\"348\":1,\"359\":1,\"363\":1,\"373\":3}}],[\"interrupted\",{\"1\":{\"240\":1}}],[\"interrupt\",{\"1\":{\"240\":2,\"303\":1,\"305\":1,\"328\":1,\"332\":1,\"359\":1,\"363\":1,\"373\":4}}],[\"interpreter\",{\"1\":{\"133\":1}}],[\"interfacename\",{\"1\":{\"186\":1}}],[\"interface\",{\"0\":{\"200\":1},\"1\":{\"88\":1,\"133\":1,\"153\":3,\"159\":1,\"186\":1,\"190\":2}}],[\"intern方法有什么作用\",{\"0\":{\"172\":1}}],[\"intern\",{\"1\":{\"66\":1,\"74\":2}}],[\"int\",{\"0\":{\"69\":1},\"1\":{\"65\":1,\"67\":1,\"69\":2,\"70\":1,\"71\":1,\"85\":1,\"126\":4,\"159\":2,\"163\":1,\"174\":1,\"175\":1,\"183\":4,\"213\":2,\"228\":3,\"230\":4,\"240\":1,\"247\":1,\"251\":1,\"253\":1,\"303\":2,\"305\":2,\"320\":2,\"353\":1,\"356\":1,\"359\":2,\"373\":5,\"376\":5,\"392\":1,\"407\":8,\"411\":2,\"412\":5,\"427\":1,\"428\":2,\"445\":4}}],[\"in\",{\"1\":{\"11\":3,\"133\":1}}],[\"3306\",{\"1\":{\"324\":1}}],[\"3000\",{\"1\":{\"276\":1,\"277\":1,\"279\":1,\"281\":1}}],[\"324\",{\"1\":{\"159\":1}}],[\"32\",{\"1\":{\"51\":1,\"159\":2}}],[\"31\",{\"1\":{\"51\":1,\"183\":1}}],[\"3s\",{\"1\":{\"11\":1}}],[\"3\",{\"0\":{\"30\":1,\"264\":1,\"265\":1,\"266\":1,\"267\":2,\"271\":1,\"288\":1,\"292\":1,\"301\":1,\"302\":1,\"313\":1,\"314\":1,\"315\":1,\"325\":1,\"340\":1,\"355\":1,\"360\":1,\"367\":1},\"1\":{\"11\":2,\"159\":1,\"165\":1,\"183\":6,\"230\":2,\"251\":13,\"253\":1,\"255\":1,\"328\":1,\"373\":1,\"389\":2,\"390\":1}}],[\"6锁优化以前\",{\"1\":{\"391\":1}}],[\"6之前synchronized的实现直接调用objectmonitor的enter和exit\",{\"1\":{\"387\":1}}],[\"6之前\",{\"1\":{\"387\":1}}],[\"60l\",{\"1\":{\"338\":1,\"354\":1}}],[\"60\",{\"1\":{\"303\":1,\"305\":2,\"328\":1,\"336\":1,\"342\":1,\"348\":1}}],[\"606\",{\"1\":{\"11\":1}}],[\"6时就计划放弃永久代\",{\"1\":{\"75\":1}}],[\"6及之前位于永久代\",{\"1\":{\"66\":2}}],[\"6及之前\",{\"1\":{\"64\":1,\"65\":1}}],[\"6和1\",{\"1\":{\"59\":1}}],[\"6中\",{\"1\":{\"55\":1}}],[\"64bit\",{\"1\":{\"386\":1}}],[\"64\",{\"1\":{\"51\":1,\"159\":2,\"386\":1}}],[\"63\",{\"1\":{\"51\":1}}],[\"639\",{\"1\":{\"11\":1}}],[\"6\",{\"0\":{\"33\":1,\"54\":1,\"55\":1,\"275\":1,\"276\":1,\"277\":1,\"305\":1,\"363\":1},\"1\":{\"11\":1,\"54\":1,\"60\":1,\"61\":1,\"62\":1,\"253\":1,\"328\":1}}],[\"61\",{\"1\":{\"11\":1}}],[\"8是基于cas+synchronized\",{\"1\":{\"443\":1}}],[\"8还引入了\",{\"1\":{\"439\":1}}],[\"8对hashmap的扩容操作进行了优化\",{\"1\":{\"439\":1}}],[\"8对hashmap主要做了哪些优化呢\",{\"0\":{\"439\":1}}],[\"8对哈希碰撞的处理进行了优化\",{\"1\":{\"439\":1}}],[\"800\",{\"1\":{\"288\":1}}],[\"8080\",{\"1\":{\"11\":3,\"12\":1,\"320\":1}}],[\"8引入的一个异步编程工具类\",{\"1\":{\"261\":1}}],[\"8引入了新的日期和时间api\",{\"1\":{\"141\":1}}],[\"8的stream\",{\"1\":{\"193\":1}}],[\"8之前\",{\"1\":{\"171\":1}}],[\"8之间内存区域的主要变化\",{\"1\":{\"54\":1}}],[\"8都有哪些新特性\",{\"0\":{\"141\":1}}],[\"8新特性\",{\"0\":{\"140\":1}}],[\"8及以后版本\",{\"1\":{\"94\":1}}],[\"8及之后的版本中\",{\"1\":{\"78\":1}}],[\"8开始\",{\"1\":{\"91\":1,\"200\":1}}],[\"8开始被移除\",{\"1\":{\"53\":1}}],[\"8中都存在\",{\"1\":{\"441\":2}}],[\"8中的hashmap改为使用尾插法插入元素\",{\"1\":{\"441\":1}}],[\"8中引入了元空间来替代永久代\",{\"1\":{\"77\":1}}],[\"8中\",{\"1\":{\"57\":1,\"72\":1,\"75\":1,\"141\":1,\"200\":1,\"439\":2}}],[\"8内存区域的变化\",{\"0\":{\"54\":1}}],[\"84\",{\"1\":{\"11\":1}}],[\"825ms\",{\"1\":{\"11\":1}}],[\"8\",{\"0\":{\"35\":1,\"57\":1,\"280\":1,\"281\":1,\"445\":1},\"1\":{\"11\":2,\"59\":1,\"60\":1,\"61\":1,\"62\":1,\"144\":1,\"159\":3,\"328\":1,\"421\":1}}],[\"83\",{\"1\":{\"11\":2}}],[\"1^2\",{\"1\":{\"434\":1}}],[\"1得任意数\",{\"1\":{\"431\":1}}],[\"1st\",{\"1\":{\"427\":2}}],[\"1500\",{\"1\":{\"249\":1}}],[\"159\",{\"1\":{\"51\":1}}],[\"15\",{\"1\":{\"51\":1}}],[\"15zenuml\",{\"0\":{\"47\":1}}],[\"18\",{\"0\":{\"50\":1}}],[\"17\",{\"0\":{\"49\":1}}],[\"160\",{\"1\":{\"51\":1}}],[\"16\",{\"0\":{\"48\":1},\"1\":{\"51\":1,\"159\":2,\"427\":1}}],[\"144\",{\"1\":{\"51\":1}}],[\"143\",{\"1\":{\"51\":1}}],[\"14\",{\"0\":{\"46\":1}}],[\"13思维导图\",{\"0\":{\"45\":1}}],[\"127这种赋值\",{\"1\":{\"173\":1}}],[\"127\",{\"0\":{\"173\":2},\"1\":{\"51\":1,\"159\":1,\"173\":1}}],[\"12\",{\"0\":{\"39\":1}}],[\"128到127之间\",{\"1\":{\"173\":1}}],[\"128\",{\"0\":{\"173\":1},\"1\":{\"11\":1,\"51\":1,\"159\":1,\"173\":1}}],[\"112\",{\"1\":{\"51\":1}}],[\"111\",{\"1\":{\"51\":1}}],[\"110\",{\"1\":{\"51\":1}}],[\"11\",{\"0\":{\"38\":1}}],[\"10毫秒范围内\",{\"1\":{\"112\":1,\"115\":1,\"120\":1}}],[\"10不应该存放在栈中吗\",{\"0\":{\"67\":1}}],[\"109\",{\"1\":{\"51\":1}}],[\"108\",{\"1\":{\"51\":1}}],[\"107\",{\"1\":{\"51\":1}}],[\"106\",{\"1\":{\"51\":1}}],[\"105\",{\"1\":{\"51\":1}}],[\"10000\",{\"1\":{\"253\":1}}],[\"1000000\",{\"1\":{\"85\":1}}],[\"1000\",{\"1\":{\"249\":1,\"251\":1,\"279\":1,\"281\":1,\"288\":1,\"328\":1,\"373\":1}}],[\"100\",{\"1\":{\"51\":1,\"305\":1,\"324\":1,\"361\":1}}],[\"10\",{\"0\":{\"37\":1,\"69\":1},\"1\":{\"11\":2,\"65\":1,\"67\":2,\"69\":8,\"70\":1,\"71\":2,\"286\":1,\"288\":1,\"290\":1,\"302\":1,\"303\":1,\"305\":2,\"320\":1,\"324\":1,\"328\":1,\"338\":1,\"358\":1,\"360\":1,\"361\":2,\"363\":1,\"376\":2}}],[\"192\",{\"1\":{\"51\":1}}],[\"191\",{\"1\":{\"51\":1}}],[\"19\",{\"0\":{\"51\":1},\"1\":{\"11\":1}}],[\"197\",{\"1\":{\"11\":1}}],[\"1\",{\"0\":{\"28\":1,\"54\":2,\"55\":1,\"56\":1,\"57\":1,\"261\":1,\"263\":1,\"265\":1,\"269\":1,\"273\":1,\"276\":1,\"281\":1,\"284\":1,\"286\":1,\"290\":1,\"299\":1,\"302\":1,\"307\":1,\"308\":2,\"309\":1,\"311\":1,\"314\":1,\"317\":1,\"338\":1,\"353\":1,\"358\":1,\"365\":1},\"1\":{\"11\":1,\"54\":2,\"55\":1,\"56\":1,\"57\":1,\"59\":2,\"60\":2,\"61\":2,\"62\":3,\"64\":2,\"65\":2,\"66\":4,\"72\":1,\"77\":1,\"78\":2,\"85\":1,\"126\":1,\"159\":7,\"183\":2,\"213\":1,\"228\":1,\"230\":1,\"249\":1,\"251\":12,\"253\":1,\"255\":1,\"259\":1,\"324\":2,\"328\":1,\"336\":1,\"355\":2,\"376\":3,\"381\":3,\"385\":1,\"389\":1,\"407\":1,\"411\":1,\"412\":2,\"427\":5,\"428\":1,\"430\":1,\"431\":6,\"439\":5,\"445\":4}}],[\"r\",{\"1\":{\"359\":4,\"360\":2,\"361\":2}}],[\"rs\",{\"1\":{\"324\":3,\"445\":3}}],[\"rst\",{\"1\":{\"51\":1}}],[\"race\",{\"1\":{\"445\":1}}],[\"random\",{\"1\":{\"251\":1,\"253\":1,\"273\":1,\"274\":1}}],[\"radix\",{\"1\":{\"174\":1}}],[\"root\",{\"1\":{\"102\":1,\"103\":1}}],[\"roots的对象有哪几种\",{\"0\":{\"88\":1}}],[\"roots到该对象的引用链\",{\"1\":{\"87\":1}}],[\"roots相连\",{\"1\":{\"87\":1}}],[\"roots\",{\"1\":{\"87\":1,\"88\":1,\"100\":2}}],[\"rollup\",{\"1\":{\"11\":1}}],[\"runasync\",{\"1\":{\"263\":2,\"285\":1,\"362\":1}}],[\"runnable\",{\"1\":{\"143\":1,\"237\":1,\"239\":1,\"241\":1,\"251\":2,\"253\":1,\"257\":2,\"358\":1,\"359\":1,\"360\":1,\"361\":1,\"373\":2}}],[\"running\",{\"0\":{\"365\":1},\"1\":{\"11\":2,\"365\":1,\"373\":5}}],[\"runtime和处理器都必须遵守as\",{\"1\":{\"217\":1}}],[\"runtimeexception\",{\"1\":{\"180\":1,\"273\":1,\"274\":1}}],[\"runtime\",{\"1\":{\"56\":1,\"65\":1,\"133\":1,\"190\":2,\"336\":1}}],[\"run\",{\"1\":{\"14\":1,\"131\":1,\"231\":2,\"251\":2,\"253\":1,\"254\":1,\"257\":2,\"373\":2}}],[\"rc\",{\"1\":{\"11\":3}}],[\"reentrantlock怎么实现公平锁的\",{\"0\":{\"397\":1}}],[\"reentrantlock通过sync类\",{\"1\":{\"393\":1}}],[\"reentrantlock实现原理\",{\"0\":{\"393\":1}}],[\"reentrantlock需要手工声明来加锁和释放锁\",{\"1\":{\"391\":1}}],[\"reentrantlock类借助condition接口与newcondition\",{\"1\":{\"391\":1}}],[\"reentrantlock可以指定是公平锁还是非公平锁\",{\"1\":{\"391\":1}}],[\"reentrantlock提供了一种能够中断等待锁的线程的机制\",{\"1\":{\"391\":1}}],[\"reentrantlock\",{\"1\":{\"391\":1,\"393\":1,\"397\":7}}],[\"reentrantlock是基于jdk的api层面实现的\",{\"1\":{\"391\":1}}],[\"rejected\",{\"1\":{\"361\":1}}],[\"rejectedexecution\",{\"1\":{\"361\":1}}],[\"rejectedexecutionhandler\",{\"0\":{\"361\":1},\"1\":{\"344\":1,\"361\":3}}],[\"recursions\",{\"1\":{\"381\":1}}],[\"recursivetask<integer>\",{\"1\":{\"376\":2}}],[\"recursivetask\",{\"1\":{\"376\":2}}],[\"recursivetask用于表示有返回值的任务\",{\"1\":{\"376\":1}}],[\"recursivemethod\",{\"1\":{\"85\":4}}],[\"recipient\",{\"1\":{\"332\":2}}],[\"received\",{\"1\":{\"257\":2}}],[\"release\",{\"1\":{\"253\":1,\"254\":1}}],[\"rehash\",{\"1\":{\"230\":5}}],[\"required\",{\"1\":{\"190\":2}}],[\"retention\",{\"1\":{\"190\":2}}],[\"retentionpolicy\",{\"1\":{\"190\":5}}],[\"returntype\",{\"1\":{\"186\":2}}],[\"return\",{\"0\":{\"164\":1},\"1\":{\"164\":1,\"183\":9,\"228\":1,\"263\":1,\"273\":1,\"274\":3,\"276\":1,\"277\":1,\"279\":4,\"281\":6,\"284\":1,\"287\":1,\"288\":1,\"294\":2,\"339\":1,\"353\":1,\"354\":1,\"355\":1,\"360\":1,\"362\":1,\"363\":1,\"376\":2,\"401\":1,\"407\":3,\"412\":3,\"428\":5,\"445\":3,\"450\":2}}],[\"reduce\",{\"1\":{\"145\":2}}],[\"reduced\",{\"1\":{\"145\":1}}],[\"reduce归约\",{\"1\":{\"145\":1}}],[\"readobject\",{\"1\":{\"450\":1}}],[\"reader\",{\"1\":{\"137\":1}}],[\"reactor\",{\"1\":{\"139\":1}}],[\"replacement\",{\"1\":{\"125\":1}}],[\"region\",{\"1\":{\"102\":3,\"103\":1,\"109\":1}}],[\"register\",{\"1\":{\"53\":1,\"55\":1,\"133\":1}}],[\"remarking\",{\"1\":{\"102\":1}}],[\"remark\",{\"1\":{\"100\":1,\"103\":1}}],[\"reference\",{\"1\":{\"89\":4}}],[\"reference中存储的直接是对象地址\",{\"1\":{\"83\":1}}],[\"reference中存储的是对象的句柄地址\",{\"1\":{\"83\":1}}],[\"responsible\",{\"1\":{\"381\":1}}],[\"response\",{\"1\":{\"257\":2,\"259\":1}}],[\"resultset\",{\"1\":{\"324\":2}}],[\"results\",{\"1\":{\"279\":2}}],[\"result3\",{\"1\":{\"271\":2,\"281\":2}}],[\"result2\",{\"1\":{\"270\":2,\"271\":2,\"281\":2,\"376\":2}}],[\"result1\",{\"1\":{\"270\":2,\"271\":2,\"281\":2,\"376\":2}}],[\"resultfuture\",{\"1\":{\"270\":1}}],[\"result\",{\"1\":{\"265\":2,\"266\":2,\"269\":2,\"274\":2,\"279\":2,\"288\":2,\"294\":4,\"363\":3,\"376\":2}}],[\"resizers\",{\"1\":{\"445\":1}}],[\"resizestamp\",{\"1\":{\"445\":1}}],[\"resize\",{\"1\":{\"230\":3,\"427\":2,\"445\":1}}],[\"resources语句或显式地调用close\",{\"1\":{\"90\":1}}],[\"resolved\",{\"1\":{\"11\":2}}],[\"reserved\",{\"1\":{\"51\":1}}],[\"reused\",{\"1\":{\"11\":2}}],[\"仓库\",{\"1\":{\"11\":1}}],[\"项目启动命令\",{\"0\":{\"14\":1}}],[\"项目需要用到多语言么\",{\"1\":{\"11\":1}}],[\"项目介绍\",{\"1\":{\"1\":1}}],[\"m\",{\"0\":{\"454\":1}}],[\"memory\",{\"1\":{\"75\":1,\"84\":4,\"124\":2,\"211\":3}}],[\"meta\",{\"1\":{\"153\":1}}],[\"metaspace\",{\"0\":{\"59\":1},\"1\":{\"53\":1,\"57\":2,\"72\":1,\"77\":1,\"91\":2}}],[\"methodhandle\",{\"1\":{\"401\":1}}],[\"method\",{\"1\":{\"53\":2,\"55\":2,\"133\":2,\"155\":1,\"190\":2,\"378\":2}}],[\"mincapacity\",{\"1\":{\"412\":6}}],[\"minor\",{\"0\":{\"94\":1,\"95\":1},\"1\":{\"94\":3,\"95\":2,\"103\":1}}],[\"milliseconds\",{\"1\":{\"288\":1,\"353\":1,\"355\":1,\"356\":1,\"361\":1}}],[\"millis\",{\"1\":{\"240\":1,\"247\":2,\"356\":1}}],[\"mixed\",{\"0\":{\"94\":1},\"1\":{\"94\":3,\"102\":2,\"109\":1}}],[\"mission\",{\"1\":{\"75\":1}}],[\"mit\",{\"1\":{\"11\":1}}],[\"math\",{\"1\":{\"251\":1,\"253\":1,\"273\":1,\"274\":1,\"412\":1}}],[\"match\",{\"1\":{\"145\":1}}],[\"macos\",{\"1\":{\"148\":1}}],[\"machine\",{\"1\":{\"131\":1,\"148\":1}}],[\"mapping\",{\"1\":{\"450\":1}}],[\"map\",{\"0\":{\"420\":1},\"1\":{\"99\":1,\"145\":2,\"279\":1,\"450\":1,\"452\":1}}],[\"max\",{\"1\":{\"354\":2,\"356\":2,\"412\":2,\"445\":1}}],[\"maximumpoolsize\",{\"1\":{\"304\":1,\"305\":1,\"338\":2,\"344\":1,\"359\":2}}],[\"maxgcpausemillis来优化停顿时间\",{\"1\":{\"121\":1}}],[\"maxgcpausemillis指定目标停顿时间\",{\"1\":{\"109\":1}}],[\"maxgcpausemillis=<n>\",{\"1\":{\"105\":1,\"120\":1}}],[\"maxgcpausemillis参数设置\",{\"1\":{\"102\":1}}],[\"maxtenuringthreshold参数来设置这个阈值\",{\"1\":{\"97\":1}}],[\"maxpermsize参数\",{\"1\":{\"76\":1}}],[\"maxpermsize参数调整其大小\",{\"1\":{\"74\":1}}],[\"major\",{\"0\":{\"94\":1},\"1\":{\"94\":3}}],[\"markword中锁标志是否为\",{\"1\":{\"389\":1}}],[\"markup\",{\"1\":{\"178\":1}}],[\"marking\",{\"1\":{\"102\":3,\"103\":1}}],[\"mark\",{\"1\":{\"92\":2,\"98\":1,\"100\":4,\"101\":1,\"103\":1,\"107\":1,\"108\":1,\"109\":1,\"112\":1,\"120\":1,\"386\":4,\"390\":1}}],[\"main函数所在的钱程就是一个用户线程\",{\"1\":{\"246\":1}}],[\"main\",{\"1\":{\"23\":1,\"65\":1,\"70\":1,\"85\":2,\"183\":3,\"211\":1,\"231\":1,\"246\":1,\"249\":2,\"251\":1,\"253\":1,\"257\":1,\"279\":1,\"281\":1,\"288\":1,\"303\":1,\"305\":1,\"320\":1,\"324\":1,\"328\":1,\"332\":1,\"336\":1,\"363\":1,\"373\":1,\"376\":2}}],[\"master的代码都是ts和一些markdown文件\",{\"1\":{\"22\":1}}],[\"master\",{\"1\":{\"16\":1,\"22\":1}}],[\"manually\",{\"1\":{\"11\":1}}],[\"make\",{\"1\":{\"11\":1}}],[\"monitor\",{\"1\":{\"381\":4}}],[\"monitorexit或者acc\",{\"1\":{\"381\":1}}],[\"monitorexit\",{\"1\":{\"380\":2,\"381\":1}}],[\"monitorenter\",{\"1\":{\"380\":2,\"381\":2}}],[\"modcount\",{\"1\":{\"416\":1}}],[\"modcount变量是否为expectedmodcount值\",{\"1\":{\"416\":1}}],[\"modcount的值\",{\"1\":{\"416\":1}}],[\"modification\",{\"1\":{\"416\":3}}],[\"model\",{\"1\":{\"211\":1}}],[\"mode\",{\"1\":{\"108\":1}}],[\"modules\",{\"1\":{\"11\":2}}],[\"move\",{\"1\":{\"11\":1}}],[\"mytable\",{\"1\":{\"324\":1}}],[\"mydatabase\",{\"1\":{\"324\":1}}],[\"mysql\",{\"1\":{\"324\":1}}],[\"mybatis\",{\"1\":{\"156\":1}}],[\"myapplication\",{\"1\":{\"127\":1}}],[\"my\",{\"1\":{\"10\":1,\"11\":2,\"14\":1,\"17\":1}}],[\"o\",{\"1\":{\"407\":6}}],[\"owneristhread\",{\"1\":{\"381\":1}}],[\"owner\",{\"1\":{\"381\":5}}],[\"o密集型的\",{\"1\":{\"349\":1}}],[\"o操作的完成\",{\"1\":{\"349\":1}}],[\"o操作\",{\"1\":{\"245\":1}}],[\"overload\",{\"0\":{\"197\":1}}],[\"override\",{\"0\":{\"197\":1},\"1\":{\"153\":1,\"190\":1,\"231\":1,\"251\":2,\"253\":1,\"257\":2,\"359\":1,\"360\":1,\"361\":1,\"373\":1,\"376\":1}}],[\"overflow\",{\"1\":{\"84\":2,\"412\":2}}],[\"optional<string>\",{\"1\":{\"144\":1,\"145\":1}}],[\"optional了解吗\",{\"0\":{\"144\":1}}],[\"optional类是一个容器类\",{\"1\":{\"141\":1}}],[\"optional\",{\"1\":{\"141\":1,\"144\":9,\"145\":1}}],[\"options\",{\"1\":{\"51\":1}}],[\"org\",{\"1\":{\"324\":1}}],[\"ortimeout\",{\"0\":{\"276\":1},\"1\":{\"276\":1}}],[\"ordering\",{\"1\":{\"212\":1}}],[\"orelse\",{\"1\":{\"144\":1}}],[\"oriented\",{\"1\":{\"99\":1}}],[\"oracle在jdk\",{\"1\":{\"75\":1}}],[\"oracle收购bea后\",{\"1\":{\"75\":1}}],[\"oracle收购bea后的整合\",{\"1\":{\"75\":1}}],[\"oopmap\",{\"0\":{\"99\":1},\"1\":{\"99\":1}}],[\"outputstream\",{\"1\":{\"137\":1}}],[\"out\",{\"1\":{\"85\":2,\"144\":1,\"145\":4,\"153\":1,\"183\":4,\"231\":1,\"249\":3,\"251\":4,\"253\":3,\"257\":4,\"266\":1,\"267\":1,\"271\":1,\"279\":2,\"281\":1,\"288\":2,\"294\":1,\"303\":1,\"305\":1,\"324\":1,\"328\":1,\"332\":3,\"336\":1,\"363\":1,\"373\":2,\"376\":1}}],[\"outofmemoryerror\",{\"1\":{\"74\":1,\"85\":2,\"412\":1}}],[\"oldvalue\",{\"1\":{\"450\":3}}],[\"oldcapacity\",{\"1\":{\"412\":5}}],[\"oldlen\",{\"1\":{\"230\":2}}],[\"oldtab\",{\"1\":{\"230\":4}}],[\"old是parallel\",{\"1\":{\"98\":1}}],[\"old是serial收集器的老年代版本\",{\"1\":{\"98\":1}}],[\"old收集器\",{\"1\":{\"98\":2}}],[\"old\",{\"0\":{\"94\":1},\"1\":{\"53\":1,\"91\":1,\"94\":1,\"102\":1}}],[\"onlyifabsent\",{\"1\":{\"450\":1}}],[\"once\",{\"1\":{\"131\":1}}],[\"on\",{\"1\":{\"16\":1,\"373\":1}}],[\"offset\",{\"1\":{\"51\":1,\"407\":6}}],[\"of\",{\"1\":{\"11\":1,\"144\":1,\"279\":1}}],[\"obj\",{\"1\":{\"89\":1,\"175\":1}}],[\"objectinputstream\",{\"1\":{\"415\":1}}],[\"objectoutputstream\",{\"1\":{\"415\":1}}],[\"objectmonitor\",{\"1\":{\"381\":1}}],[\"objectmonitor有两个队列\",{\"1\":{\"381\":1}}],[\"objectmonitor的工作原理\",{\"1\":{\"381\":1}}],[\"object类方法\",{\"1\":{\"240\":1}}],[\"object类提供的clone\",{\"1\":{\"208\":1}}],[\"object作为value的结构\",{\"1\":{\"228\":1}}],[\"object\",{\"0\":{\"175\":1},\"1\":{\"82\":1,\"89\":2,\"99\":1,\"175\":1,\"204\":1,\"381\":1,\"401\":1,\"407\":3,\"428\":2}}],[\"ob\",{\"1\":{\"11\":4}}],[\"2000\",{\"1\":{\"279\":1,\"281\":1,\"303\":1,\"305\":1,\"332\":1}}],[\"2^63\",{\"1\":{\"159\":2}}],[\"2^15\",{\"1\":{\"159\":2}}],[\"2^31\",{\"1\":{\"159\":2}}],[\"246\",{\"1\":{\"11\":1}}],[\"255\",{\"1\":{\"51\":1}}],[\"25\",{\"1\":{\"11\":1}}],[\"2\",{\"0\":{\"29\":1,\"262\":1,\"263\":1,\"266\":1,\"270\":1,\"274\":1,\"277\":1,\"285\":1,\"286\":1,\"287\":2,\"291\":1,\"300\":1,\"309\":1,\"310\":1,\"311\":1,\"312\":2,\"315\":1,\"321\":1,\"339\":1,\"354\":1,\"359\":1,\"366\":1},\"1\":{\"11\":8,\"126\":1,\"159\":2,\"165\":1,\"183\":5,\"213\":1,\"230\":2,\"251\":11,\"276\":1,\"277\":1,\"328\":1,\"376\":2,\"389\":1,\"445\":1}}],[\"22\",{\"1\":{\"11\":1}}],[\"l\",{\"1\":{\"409\":2}}],[\"latch数量减1\",{\"1\":{\"249\":1}}],[\"lambda\",{\"0\":{\"142\":1},\"1\":{\"141\":5,\"142\":2}}],[\"lang\",{\"1\":{\"17\":1,\"74\":1,\"204\":1}}],[\"language\",{\"1\":{\"11\":1,\"178\":1}}],[\"lost\",{\"1\":{\"445\":1}}],[\"log\",{\"1\":{\"424\":1,\"439\":1}}],[\"lower\",{\"1\":{\"230\":1}}],[\"lockinterruptibly\",{\"1\":{\"391\":1}}],[\"lock\",{\"0\":{\"396\":1},\"1\":{\"381\":2,\"397\":2,\"405\":1,\"445\":1}}],[\"lock接口等\",{\"1\":{\"214\":2}}],[\"lock接口\",{\"1\":{\"214\":1}}],[\"locals\",{\"1\":{\"232\":2}}],[\"localvariable\",{\"1\":{\"222\":3}}],[\"localhost\",{\"1\":{\"11\":2,\"12\":1,\"324\":1}}],[\"local\",{\"0\":{\"80\":1},\"1\":{\"11\":3,\"78\":1,\"80\":1,\"211\":1,\"308\":1}}],[\"lombok\",{\"1\":{\"190\":1}}],[\"loadstore\",{\"1\":{\"220\":1}}],[\"loadload\",{\"1\":{\"220\":1}}],[\"load\",{\"1\":{\"153\":2}}],[\"loader\",{\"1\":{\"133\":1,\"153\":4,\"232\":1}}],[\"long类型\",{\"1\":{\"145\":1}}],[\"long\",{\"0\":{\"163\":1},\"1\":{\"145\":1,\"159\":2,\"163\":1,\"175\":2,\"240\":4,\"247\":2,\"249\":1,\"251\":1,\"253\":1,\"359\":1,\"407\":3}}],[\"len\",{\"1\":{\"230\":1}}],[\"length\",{\"1\":{\"51\":1,\"228\":1,\"230\":1,\"412\":1,\"427\":2,\"428\":1,\"445\":4}}],[\"level\",{\"1\":{\"215\":1}}],[\"leak\",{\"1\":{\"84\":2}}],[\"linkedlist每个节点\",{\"1\":{\"411\":1}}],[\"linkedlist基于链表\",{\"1\":{\"411\":2}}],[\"linkedlist基于链表实现\",{\"1\":{\"411\":1}}],[\"linkedlist基于双向链表实现\",{\"1\":{\"411\":1}}],[\"linkedlist更利于增删\",{\"1\":{\"411\":1}}],[\"linkedblockingqueue<>\",{\"1\":{\"361\":1,\"373\":1}}],[\"linkedblockingqueue<runnable>\",{\"1\":{\"338\":1,\"353\":1,\"355\":1}}],[\"linkedblockingqueue\",{\"1\":{\"296\":1,\"373\":1}}],[\"linkedhashmap在\",{\"1\":{\"447\":1}}],[\"linkedhashmap\",{\"0\":{\"447\":1},\"1\":{\"192\":1,\"446\":1,\"447\":1}}],[\"linux\",{\"1\":{\"148\":1}}],[\"list归约成一个值\",{\"1\":{\"145\":1}}],[\"list<integer>\",{\"1\":{\"328\":1}}],[\"list<string>\",{\"1\":{\"145\":1,\"279\":1}}],[\"list<byte\",{\"1\":{\"85\":1}}],[\"list\",{\"0\":{\"410\":1},\"1\":{\"85\":3,\"145\":3,\"279\":2,\"281\":1,\"328\":1,\"452\":1}}],[\"listed\",{\"1\":{\"11\":1}}],[\"literals\",{\"1\":{\"64\":1}}],[\"afternodeaccess\",{\"1\":{\"450\":1}}],[\"afterexecute\",{\"1\":{\"359\":3}}],[\"aqs是一个一个fifo的双向队列\",{\"1\":{\"392\":1}}],[\"aqs\",{\"1\":{\"392\":3,\"396\":2}}],[\"aqs了解多少\",{\"0\":{\"392\":1}}],[\"apache\",{\"1\":{\"324\":1}}],[\"api遍历\",{\"1\":{\"193\":1}}],[\"api提供了一种更简洁\",{\"1\":{\"141\":1}}],[\"api\",{\"1\":{\"141\":2,\"375\":7}}],[\"acc\",{\"1\":{\"380\":1,\"381\":1}}],[\"accept\",{\"1\":{\"320\":1}}],[\"acquiredwithtimeout\",{\"1\":{\"255\":1}}],[\"acquired\",{\"1\":{\"255\":1}}],[\"acquire\",{\"1\":{\"253\":1,\"254\":1,\"255\":1}}],[\"ack\",{\"1\":{\"51\":1}}],[\"acknowledgment\",{\"1\":{\"51\":1}}],[\"awaittermination\",{\"1\":{\"288\":1,\"303\":1,\"305\":1,\"328\":1,\"336\":1,\"342\":1,\"348\":1}}],[\"await\",{\"1\":{\"249\":6,\"251\":2}}],[\"avoid\",{\"1\":{\"230\":1}}],[\"asynctaskexample\",{\"1\":{\"332\":1}}],[\"aslist\",{\"1\":{\"328\":1}}],[\"as\",{\"0\":{\"217\":1},\"1\":{\"216\":1,\"217\":1}}],[\"aba\",{\"0\":{\"400\":1},\"1\":{\"399\":1}}],[\"abortpolicy\",{\"1\":{\"345\":1}}],[\"abstractqueuedsynchronizer\",{\"1\":{\"392\":1}}],[\"abstract\",{\"0\":{\"200\":1}}],[\"abc\",{\"0\":{\"170\":2},\"1\":{\"170\":6}}],[\"autowired\",{\"1\":{\"190\":1}}],[\"autoboxcachemax=来修改缓存的最大值\",{\"1\":{\"173\":1}}],[\"aop\",{\"1\":{\"190\":1}}],[\"a1==b1的结果是false\",{\"1\":{\"173\":1}}],[\"a=\",{\"0\":{\"173\":1},\"1\":{\"173\":1}}],[\"a+b拼接后的对象位于堆中\",{\"1\":{\"171\":1}}],[\"a和b初始化时位于字符串常量池\",{\"1\":{\"171\":1}}],[\"aaa1\",{\"1\":{\"145\":1}}],[\"aaa2\",{\"1\":{\"145\":1}}],[\"aio\",{\"0\":{\"139\":1},\"1\":{\"139\":1}}],[\"annotated\",{\"1\":{\"190\":1}}],[\"annotation\",{\"1\":{\"190\":1}}],[\"anymatch\",{\"1\":{\"145\":1}}],[\"anystartswitha\",{\"1\":{\"145\":1}}],[\"anywhere\",{\"1\":{\"131\":1}}],[\"analysis\",{\"0\":{\"125\":1}}],[\"and\",{\"1\":{\"51\":1,\"81\":1,\"92\":2,\"398\":1,\"406\":1}}],[\"adding\",{\"1\":{\"445\":1}}],[\"add方法有锁\",{\"1\":{\"419\":1}}],[\"addshutdownhook\",{\"1\":{\"336\":1}}],[\"add\",{\"1\":{\"85\":1,\"145\":8,\"450\":1}}],[\"added\",{\"1\":{\"11\":2}}],[\"always\",{\"1\":{\"428\":1}}],[\"allof\",{\"0\":{\"271\":1},\"1\":{\"271\":3,\"279\":3,\"281\":3}}],[\"allocation\",{\"0\":{\"80\":1},\"1\":{\"78\":1,\"80\":1,\"125\":1}}],[\"allmatch\",{\"1\":{\"145\":1}}],[\"allstartswitha\",{\"1\":{\"145\":2}}],[\"already\",{\"1\":{\"11\":1}}],[\"array\",{\"1\":{\"412\":1}}],[\"arrays\",{\"1\":{\"328\":2}}],[\"arrayblockingqueue<>\",{\"1\":{\"305\":1}}],[\"arrayblockingqueue\",{\"1\":{\"296\":1,\"305\":1}}],[\"arraylist通过两个方法readobject\",{\"1\":{\"415\":1}}],[\"arraylist的序列化不太一样\",{\"1\":{\"413\":1}}],[\"arraylist的扩容机制了解吗\",{\"0\":{\"412\":1}}],[\"arraylist怎么序列化的知道吗\",{\"0\":{\"413\":1}}],[\"arraylist是预先定义好的数组\",{\"1\":{\"411\":1}}],[\"arraylist基于数组\",{\"1\":{\"411\":2}}],[\"arraylist基于数组实现\",{\"1\":{\"411\":2}}],[\"arraylist增删如果是数组末尾的位置\",{\"1\":{\"411\":1}}],[\"arraylist更利于查找\",{\"1\":{\"411\":1}}],[\"arraylist和linkedlist有什么区别\",{\"0\":{\"411\":1}}],[\"arraylist<>\",{\"1\":{\"85\":1,\"145\":1}}],[\"arraylist\",{\"1\":{\"85\":1}}],[\"arg\",{\"1\":{\"186\":1}}],[\"args\",{\"1\":{\"65\":1,\"70\":1,\"85\":2,\"183\":3,\"231\":1,\"249\":2,\"251\":1,\"253\":1,\"257\":1,\"279\":1,\"281\":1,\"288\":1,\"303\":1,\"305\":1,\"320\":1,\"324\":1,\"328\":1,\"332\":1,\"336\":1,\"363\":1,\"373\":1,\"376\":1,\"401\":1}}],[\"area\",{\"1\":{\"53\":1,\"55\":1,\"133\":2}}],[\"attached\",{\"1\":{\"232\":1}}],[\"atomicreference等\",{\"1\":{\"406\":1}}],[\"atomiclong\",{\"1\":{\"406\":1}}],[\"atomicinteger\",{\"0\":{\"407\":1},\"1\":{\"406\":1}}],[\"atomicity\",{\"1\":{\"212\":1}}],[\"atomic类等\",{\"1\":{\"214\":1}}],[\"at\",{\"1\":{\"11\":1}}],[\"a\",{\"0\":{\"67\":1,\"69\":1},\"1\":{\"11\":3,\"65\":1,\"67\":1,\"69\":7,\"70\":1,\"71\":2,\"139\":1,\"145\":7,\"398\":3,\"400\":1}}],[\"sqlexception\",{\"1\":{\"324\":2}}],[\"sql\",{\"1\":{\"324\":4}}],[\"sleep\",{\"1\":{\"240\":1,\"249\":2,\"251\":1,\"253\":1,\"276\":1,\"277\":1,\"279\":3,\"281\":3,\"288\":1,\"303\":1,\"305\":1,\"328\":1,\"332\":1,\"373\":1}}],[\"simplewebserver\",{\"1\":{\"320\":3}}],[\"singlethreadexecutor\",{\"0\":{\"355\":1},\"1\":{\"302\":2,\"351\":1}}],[\"singlethreadpool\",{\"1\":{\"292\":1}}],[\"singleton\",{\"1\":{\"215\":2}}],[\"sizectl\",{\"1\":{\"445\":5}}],[\"size\",{\"1\":{\"230\":3,\"232\":1,\"412\":1}}],[\"sz\",{\"1\":{\"230\":2}}],[\"sayhello\",{\"1\":{\"153\":3}}],[\"safe\",{\"0\":{\"416\":1},\"1\":{\"99\":1,\"416\":1}}],[\"spring里的很多注解\",{\"1\":{\"156\":1}}],[\"spring\",{\"1\":{\"156\":2}}],[\"spin\",{\"1\":{\"445\":1}}],[\"spinclock\",{\"1\":{\"381\":1}}],[\"spinfreq\",{\"1\":{\"381\":1}}],[\"spi机制的应用场景\",{\"1\":{\"153\":1}}],[\"spi机制的优势\",{\"1\":{\"153\":1}}],[\"spi机制的工作原理如下\",{\"1\":{\"153\":1}}],[\"spi中的几个关键元素\",{\"1\":{\"153\":1}}],[\"space错误\",{\"1\":{\"74\":1}}],[\"space\",{\"1\":{\"53\":2}}],[\"sdk\",{\"1\":{\"148\":1}}],[\"s2\",{\"1\":{\"145\":2}}],[\"s1\",{\"1\":{\"145\":2}}],[\"s\",{\"1\":{\"144\":2,\"145\":12,\"170\":1,\"174\":3}}],[\"shift\",{\"1\":{\"445\":1}}],[\"shared表示是获取共享资源时被阻塞挂起后放入aqs队列的\",{\"1\":{\"392\":1}}],[\"shutdownnow\",{\"1\":{\"288\":2,\"303\":2,\"305\":2,\"328\":2,\"336\":2,\"342\":3,\"348\":6,\"367\":1}}],[\"shutdown\",{\"0\":{\"366\":1},\"1\":{\"288\":1,\"303\":1,\"305\":1,\"328\":1,\"332\":1,\"336\":1,\"342\":2,\"348\":4,\"363\":1,\"366\":3,\"368\":1,\"373\":2}}],[\"short\",{\"1\":{\"159\":2,\"163\":1}}],[\"shouldprefetch\",{\"1\":{\"17\":1}}],[\"shenandoah\",{\"1\":{\"120\":1}}],[\"shenandoah是一种低延迟的垃圾收集器\",{\"1\":{\"98\":1}}],[\"shenandoah收集器\",{\"1\":{\"98\":1}}],[\"sc\",{\"1\":{\"445\":13}}],[\"scheduleatfixedrate\",{\"1\":{\"336\":1}}],[\"scheduler\",{\"1\":{\"336\":6}}],[\"scheduledtaskexample\",{\"1\":{\"336\":1}}],[\"scheduledthreadpoolexecutor\",{\"1\":{\"356\":1}}],[\"scheduledthreadpool\",{\"0\":{\"356\":1},\"1\":{\"293\":1,\"302\":2,\"351\":1}}],[\"scheduledexecutorservice\",{\"1\":{\"293\":1,\"302\":1,\"336\":2}}],[\"scalar\",{\"1\":{\"125\":1}}],[\"scanning\",{\"1\":{\"102\":1,\"103\":1}}],[\"scavenge收集器的老年代版本\",{\"1\":{\"98\":1}}],[\"scavenge收集器也是针对新生代的收集器\",{\"1\":{\"98\":1}}],[\"scavenge收集器\",{\"1\":{\"98\":1}}],[\"script\",{\"1\":{\"11\":1}}],[\"switch\",{\"0\":{\"163\":1},\"1\":{\"163\":1}}],[\"sweep\",{\"1\":{\"92\":1,\"98\":1,\"100\":3,\"101\":1,\"107\":1,\"112\":1,\"120\":1}}],[\"swap\",{\"1\":{\"81\":1,\"398\":1,\"406\":1}}],[\"socket\",{\"1\":{\"320\":3}}],[\"sorted\",{\"1\":{\"145\":4}}],[\"soft\",{\"1\":{\"89\":1}}],[\"source\",{\"1\":{\"51\":1,\"190\":2}}],[\"sourcemap\",{\"1\":{\"11\":1}}],[\"system\",{\"1\":{\"85\":2,\"96\":1,\"144\":1,\"145\":4,\"153\":1,\"182\":1,\"183\":4,\"204\":1,\"231\":1,\"232\":1,\"249\":3,\"251\":4,\"253\":3,\"257\":4,\"266\":1,\"267\":1,\"271\":1,\"279\":2,\"281\":1,\"288\":2,\"294\":1,\"303\":1,\"305\":1,\"324\":1,\"328\":1,\"332\":3,\"336\":2,\"361\":1,\"363\":1,\"373\":2,\"376\":1}}],[\"sync\",{\"1\":{\"397\":2}}],[\"synchronous\",{\"1\":{\"346\":1}}],[\"synchronousqueue<runnable>\",{\"1\":{\"354\":1}}],[\"synchronousqueue\",{\"1\":{\"344\":1}}],[\"synchronizedmap\",{\"1\":{\"442\":1}}],[\"synchronizedlist包装arraylist\",{\"1\":{\"417\":1}}],[\"synchronized与wait\",{\"1\":{\"391\":1}}],[\"synchronized的性能比reentrantlock差很多\",{\"1\":{\"391\":1}}],[\"synchronized的实现原理\",{\"0\":{\"379\":1}}],[\"synchronized是java语言的关键字\",{\"1\":{\"391\":1}}],[\"synchronized是怎么加锁的呢\",{\"0\":{\"380\":1}}],[\"synchronized做了哪些优化\",{\"0\":{\"387\":1}}],[\"synchronized优化了解吗\",{\"0\":{\"386\":1}}],[\"synchronized怎么实现可重入的呢\",{\"0\":{\"385\":1}}],[\"synchronized怎么保证有序性\",{\"0\":{\"384\":1}}],[\"synchronized怎么保证可见性\",{\"0\":{\"383\":1}}],[\"synchronized同步的代码块\",{\"1\":{\"384\":1}}],[\"synchronized可见性\",{\"0\":{\"382\":1}}],[\"synchronized锁住的是什么呢\",{\"0\":{\"381\":1}}],[\"synchronized修饰代码块时\",{\"1\":{\"380\":1}}],[\"synchronized\",{\"1\":{\"378\":5,\"380\":1,\"381\":2,\"385\":2,\"391\":1,\"442\":1}}],[\"synchronized用过吗\",{\"0\":{\"378\":1}}],[\"synchronized关键字等\",{\"1\":{\"212\":1}}],[\"synchronization\",{\"1\":{\"125\":1}}],[\"syn\",{\"1\":{\"51\":1}}],[\"succ\",{\"1\":{\"381\":1}}],[\"suppresswarnings\",{\"1\":{\"445\":1}}],[\"supplyasync\",{\"1\":{\"263\":2,\"265\":1,\"266\":1,\"267\":1,\"269\":2,\"270\":2,\"271\":3,\"273\":1,\"274\":1,\"276\":1,\"277\":1,\"279\":3,\"281\":3,\"284\":1,\"285\":1,\"287\":1,\"288\":1,\"294\":1}}],[\"supplier\",{\"1\":{\"143\":1}}],[\"super\",{\"1\":{\"231\":1,\"356\":1,\"359\":2}}],[\"submit\",{\"1\":{\"303\":1,\"305\":1,\"320\":1,\"328\":1,\"332\":1,\"339\":1,\"347\":3,\"358\":1,\"363\":1,\"373\":2}}],[\"subsystem\",{\"1\":{\"133\":1}}],[\"subdependencies\",{\"1\":{\"11\":1}}],[\"survivor区不足\",{\"1\":{\"95\":1}}],[\"survivor区通常有两个\",{\"1\":{\"93\":1}}],[\"survivor区是用于存放经过一次minor\",{\"1\":{\"93\":1}}],[\"survivor区用来保存经过一次gc后仍然存活的对象\",{\"1\":{\"91\":1}}],[\"survivor区\",{\"1\":{\"91\":1,\"93\":2}}],[\"survivor\",{\"1\":{\"53\":1}}],[\"segment如果是空就先初始化\",{\"1\":{\"444\":1}}],[\"segment之间相互不会受到影响\",{\"1\":{\"444\":1}}],[\"segment则包含hashentry的数组\",{\"1\":{\"444\":1}}],[\"segment继承于reentrantlock\",{\"1\":{\"444\":1}}],[\"sendemail\",{\"1\":{\"332\":2}}],[\"seconds\",{\"1\":{\"255\":1,\"259\":1,\"276\":1,\"277\":1,\"303\":1,\"305\":2,\"328\":1,\"336\":2,\"338\":1,\"342\":1,\"348\":1,\"354\":1}}],[\"semaphore可以设置为公平模式\",{\"1\":{\"255\":1}}],[\"semaphoreexample\",{\"1\":{\"253\":1}}],[\"semaphore\",{\"0\":{\"253\":1},\"1\":{\"253\":5,\"254\":1,\"255\":3}}],[\"setqueue\",{\"1\":{\"371\":1}}],[\"setcorepoolsize\",{\"1\":{\"371\":1}}],[\"setmaximumpoolsize\",{\"1\":{\"371\":1}}],[\"setmaxidle\",{\"1\":{\"324\":1}}],[\"setmaxopenpreparedstatements\",{\"1\":{\"324\":1}}],[\"setminidle\",{\"1\":{\"324\":1}}],[\"setpassword\",{\"1\":{\"324\":1}}],[\"setuncaughtexceptionhandler\",{\"1\":{\"360\":1}}],[\"setusername\",{\"1\":{\"324\":1}}],[\"seturl\",{\"1\":{\"324\":1}}],[\"setthreshold\",{\"1\":{\"230\":1}}],[\"set\",{\"0\":{\"449\":1},\"1\":{\"222\":1,\"230\":1,\"231\":1,\"452\":1}}],[\"service3数据\",{\"1\":{\"281\":1}}],[\"service2数据\",{\"1\":{\"281\":1}}],[\"service1数据\",{\"1\":{\"281\":1}}],[\"serviceloader<helloservice>\",{\"1\":{\"153\":2}}],[\"services\",{\"1\":{\"153\":3}}],[\"service\",{\"1\":{\"153\":9}}],[\"serversocket\",{\"1\":{\"320\":5}}],[\"server\",{\"1\":{\"11\":1}}],[\"serial语义的存在\",{\"1\":{\"384\":1}}],[\"serial语义的意思是\",{\"1\":{\"217\":1}}],[\"serial语义\",{\"1\":{\"217\":2}}],[\"serial又是什么\",{\"0\":{\"217\":1}}],[\"serialversionuid的值保持不变\",{\"1\":{\"177\":1}}],[\"serialversionuid\",{\"1\":{\"177\":1}}],[\"serializable接口有什么用\",{\"1\":{\"177\":1}}],[\"serial\",{\"1\":{\"98\":2,\"120\":1,\"216\":1}}],[\"serial收集器\",{\"1\":{\"98\":1}}],[\"sequence\",{\"1\":{\"51\":1}}],[\"select\",{\"1\":{\"11\":1,\"324\":1}}],[\"src\",{\"1\":{\"11\":1}}],[\"stealing\",{\"1\":{\"346\":1}}],[\"stmt\",{\"1\":{\"324\":2}}],[\"stw\",{\"1\":{\"100\":2}}],[\"storage\",{\"1\":{\"308\":1}}],[\"storeload\",{\"1\":{\"220\":1}}],[\"storestore\",{\"1\":{\"220\":1}}],[\"store\",{\"1\":{\"11\":2}}],[\"stopworker\",{\"1\":{\"373\":2}}],[\"stop\",{\"0\":{\"367\":1},\"1\":{\"99\":1,\"100\":1,\"367\":2,\"368\":1}}],[\"stream的常用api\",{\"1\":{\"145\":1}}],[\"stream的常用操作有\",{\"1\":{\"145\":1}}],[\"stream流一般用于集合\",{\"1\":{\"145\":1}}],[\"stream\",{\"0\":{\"145\":1},\"1\":{\"141\":2,\"145\":12,\"279\":2,\"281\":1}}],[\"strong\",{\"1\":{\"89\":1}}],[\"str\",{\"1\":{\"65\":1,\"70\":1}}],[\"str2\",{\"0\":{\"170\":1},\"1\":{\"64\":2}}],[\"str1\",{\"0\":{\"170\":1},\"1\":{\"64\":2,\"170\":1}}],[\"string怎么转成integer的\",{\"0\":{\"174\":1}}],[\"string的确是不可变的\",{\"1\":{\"171\":1}}],[\"string不是不可变类吗\",{\"0\":{\"171\":1}}],[\"string是不可变的\",{\"1\":{\"169\":1}}],[\"string是java基本数据类型吗\",{\"1\":{\"168\":1}}],[\"stringbuilder是stringbuffer的非线程安全版本\",{\"1\":{\"169\":1}}],[\"stringbuilder类\",{\"1\":{\"169\":1}}],[\"stringbuilder\",{\"1\":{\"169\":1}}],[\"stringbuffer的性能相对较低\",{\"1\":{\"169\":1}}],[\"stringbuffer的方法都使用synchronized关键字进行同步\",{\"1\":{\"169\":1}}],[\"stringbuffer是可变的\",{\"1\":{\"169\":1}}],[\"stringbuffer类\",{\"1\":{\"169\":1}}],[\"stringbuffer\",{\"0\":{\"169\":1},\"1\":{\"169\":1}}],[\"string和stringbuilder\",{\"0\":{\"169\":1}}],[\"string类是线程安全的\",{\"1\":{\"169\":1}}],[\"string类\",{\"1\":{\"169\":1}}],[\"string类的不可变性使得它在安全性和可靠性方面更加可靠\",{\"1\":{\"168\":1}}],[\"string类的不可变性使得它可以被安全地用于多线程环境下\",{\"1\":{\"168\":1}}],[\"string类在java中被声明为final类\",{\"1\":{\"168\":1}}],[\"string上\",{\"0\":{\"163\":1}}],[\"stringcollection\",{\"1\":{\"145\":17}}],[\"string\",{\"0\":{\"168\":1,\"170\":2},\"1\":{\"64\":4,\"65\":2,\"70\":2,\"74\":1,\"85\":2,\"145\":3,\"163\":1,\"168\":3,\"169\":1,\"170\":5,\"174\":3,\"183\":3,\"231\":1,\"249\":2,\"251\":1,\"253\":1,\"257\":5,\"259\":1,\"271\":3,\"279\":1,\"281\":5,\"288\":1,\"303\":1,\"305\":1,\"320\":1,\"324\":1,\"328\":1,\"332\":2,\"336\":1,\"363\":1,\"373\":1,\"376\":1}}],[\"stamp\",{\"1\":{\"401\":1,\"445\":1}}],[\"state+1\",{\"1\":{\"392\":1}}],[\"state值时通过\",{\"1\":{\"392\":1}}],[\"state\",{\"1\":{\"392\":1,\"397\":1}}],[\"static修饰的方法\",{\"1\":{\"202\":1}}],[\"static等修饰符所修饰\",{\"1\":{\"201\":1}}],[\"static\",{\"1\":{\"65\":1,\"70\":1,\"85\":3,\"183\":6,\"186\":1,\"200\":1,\"202\":1,\"222\":1,\"228\":2,\"231\":1,\"249\":3,\"251\":2,\"253\":2,\"257\":3,\"279\":1,\"281\":4,\"288\":1,\"303\":1,\"305\":1,\"320\":1,\"324\":1,\"328\":2,\"332\":2,\"336\":1,\"353\":1,\"354\":1,\"355\":1,\"363\":1,\"373\":1,\"376\":1,\"378\":1}}],[\"staic\",{\"1\":{\"378\":1}}],[\"stackoverflowexample\",{\"1\":{\"85\":1}}],[\"stackoverflowerror\",{\"1\":{\"85\":2}}],[\"stack\",{\"1\":{\"53\":2,\"55\":2,\"124\":1,\"125\":1,\"132\":1,\"133\":2}}],[\"start\",{\"1\":{\"216\":3,\"231\":1,\"249\":10,\"251\":1,\"253\":1,\"257\":2,\"373\":1}}],[\"startswithb\",{\"1\":{\"145\":1}}],[\"startswith\",{\"1\":{\"145\":6}}],[\"stars\",{\"1\":{\"4\":1}}],[\"star\",{\"0\":{\"4\":1}}],[\"+除留余数法\",{\"1\":{\"440\":1}}],[\"+1\",{\"1\":{\"381\":1}}],[\"++size\",{\"1\":{\"427\":1}}],[\"++bincount\",{\"1\":{\"427\":1}}],[\"++和\",{\"1\":{\"166\":1}}],[\"++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\",{\"1\":{\"11\":1}}],[\"++++++++\",{\"1\":{\"11\":1}}],[\"+eliminatelocks\",{\"1\":{\"127\":2}}],[\"+eliminateallocations\",{\"1\":{\"127\":2}}],[\"+doescapeanalysis\",{\"1\":{\"127\":2}}],[\"+useshenandoahgc\",{\"1\":{\"120\":1}}],[\"+useserialgc\",{\"1\":{\"120\":1}}],[\"+usezgc\",{\"1\":{\"120\":1}}],[\"+useconcmarksweepgc\",{\"1\":{\"120\":1}}],[\"+useparallelgc\",{\"1\":{\"120\":1}}],[\"+useg1gc\",{\"1\":{\"105\":1,\"120\":1}}],[\"+\",{\"1\":{\"11\":4,\"85\":1,\"145\":2,\"171\":2,\"201\":1,\"213\":1,\"231\":1,\"251\":4,\"253\":4,\"257\":8,\"265\":1,\"269\":1,\"270\":1,\"271\":4,\"279\":1,\"281\":5,\"288\":1,\"294\":2,\"303\":4,\"305\":4,\"324\":1,\"328\":3,\"332\":1,\"336\":1,\"361\":1,\"363\":1,\"373\":5,\"376\":2,\"381\":1,\"407\":1,\"412\":2,\"421\":3,\"445\":3}}],[\"+606\",{\"1\":{\"11\":1}}],[\"+83\",{\"1\":{\"11\":1}}],[\"t线程还在同步代码块中\",{\"1\":{\"389\":1}}],[\"t线程已经退出同步代码块\",{\"1\":{\"389\":1}}],[\"ttl通过重写\",{\"1\":{\"233\":1}}],[\"ttl\",{\"0\":{\"233\":1},\"1\":{\"233\":1}}],[\"tabat\",{\"1\":{\"445\":1}}],[\"tab\",{\"1\":{\"427\":8,\"428\":4,\"445\":17}}],[\"table\",{\"1\":{\"228\":2,\"230\":2,\"427\":1,\"428\":1,\"445\":5}}],[\"take\",{\"1\":{\"356\":1,\"373\":1}}],[\"task2\",{\"1\":{\"376\":2}}],[\"task1\",{\"1\":{\"376\":3}}],[\"taskid\",{\"1\":{\"373\":3}}],[\"taskqueue\",{\"1\":{\"373\":4}}],[\"task\",{\"1\":{\"251\":3,\"361\":1,\"363\":3,\"373\":6,\"376\":2}}],[\"target\",{\"1\":{\"190\":2}}],[\"type\",{\"1\":{\"187\":1,\"190\":1}}],[\"t\",{\"1\":{\"186\":1,\"187\":1,\"231\":2,\"359\":7,\"360\":1,\"389\":1}}],[\"tidying\",{\"0\":{\"368\":1},\"1\":{\"368\":2,\"369\":1}}],[\"timout\",{\"1\":{\"240\":1}}],[\"timeunit\",{\"1\":{\"249\":1,\"255\":1,\"259\":1,\"276\":1,\"277\":1,\"288\":2,\"303\":2,\"305\":3,\"328\":2,\"336\":3,\"338\":1,\"342\":1,\"344\":1,\"348\":1,\"353\":1,\"354\":1,\"355\":1,\"359\":1,\"361\":1}}],[\"timeoutexception\",{\"1\":{\"251\":1}}],[\"timeout\",{\"1\":{\"175\":2,\"240\":2,\"249\":1}}],[\"time包\",{\"1\":{\"141\":1}}],[\"time\",{\"1\":{\"102\":2,\"109\":1,\"133\":1,\"241\":1}}],[\"title\",{\"1\":{\"17\":1,\"51\":1}}],[\"treeifybin\",{\"1\":{\"427\":2}}],[\"treeify\",{\"1\":{\"427\":2}}],[\"treenode<k\",{\"1\":{\"427\":1,\"428\":1}}],[\"treenode\",{\"1\":{\"427\":1,\"428\":1}}],[\"treemap\",{\"0\":{\"448\":1},\"1\":{\"192\":1,\"446\":1,\"448\":2}}],[\"transferindex\",{\"1\":{\"445\":1}}],[\"transfer\",{\"1\":{\"346\":1,\"445\":1}}],[\"transmittablethreadlocal\",{\"1\":{\"233\":1}}],[\"transient\",{\"1\":{\"177\":4,\"413\":2}}],[\"tryacquire\",{\"1\":{\"255\":3,\"392\":1,\"397\":1}}],[\"try\",{\"1\":{\"85\":2,\"181\":1,\"183\":6,\"204\":1,\"249\":2,\"251\":1,\"253\":1,\"257\":2,\"271\":1,\"276\":1,\"277\":1,\"279\":4,\"281\":4,\"288\":2,\"303\":2,\"305\":2,\"324\":1,\"328\":2,\"332\":1,\"336\":1,\"342\":1,\"348\":1,\"358\":1,\"359\":1,\"363\":1,\"373\":3,\"445\":1}}],[\"true\",{\"1\":{\"64\":1,\"85\":1,\"144\":1,\"145\":1,\"190\":2,\"251\":1,\"255\":2,\"320\":1,\"363\":1,\"373\":1,\"397\":2,\"398\":1}}],[\"tlab\",{\"1\":{\"80\":11,\"81\":3}}],[\"this|object\",{\"1\":{\"378\":1}}],[\"this相当于是指向当前对象本身\",{\"1\":{\"199\":1}}],[\"this的用法在java中大体可以分为3种\",{\"1\":{\"199\":1}}],[\"this关键字有什么作用\",{\"0\":{\"199\":1}}],[\"this\",{\"1\":{\"126\":2,\"232\":3,\"251\":1,\"253\":1,\"257\":2,\"373\":1,\"376\":1,\"378\":1,\"401\":1,\"407\":1,\"427\":1,\"445\":2}}],[\"threshold\",{\"1\":{\"230\":7,\"427\":4}}],[\"threadfactory\",{\"1\":{\"344\":1,\"360\":4}}],[\"threadpool\",{\"1\":{\"320\":3,\"373\":3}}],[\"threadpoolexecutor\",{\"1\":{\"305\":3,\"338\":1,\"353\":1,\"354\":1,\"355\":1,\"359\":1,\"361\":2,\"364\":1,\"371\":2}}],[\"threadpoolexample\",{\"1\":{\"303\":1}}],[\"thread类中的静态方法\",{\"1\":{\"240\":2}}],[\"thread类的方法\",{\"1\":{\"240\":1}}],[\"thread类适合直接创建新线程\",{\"1\":{\"239\":1}}],[\"thread类有一个类型为threadlocal\",{\"1\":{\"224\":1}}],[\"thread和runnable有什么区别\",{\"0\":{\"239\":1}}],[\"threadlocalhashcode\",{\"1\":{\"228\":1,\"230\":1}}],[\"threadlocal本身不存储值\",{\"1\":{\"224\":1}}],[\"threadlocalmap\",{\"1\":{\"232\":2}}],[\"threadlocalmap扩容机制了解吗\",{\"0\":{\"230\":1}}],[\"threadlocalmap怎么解决hash冲突的\",{\"0\":{\"229\":1}}],[\"threadlocalmap用的是哈希取余法\",{\"1\":{\"228\":1}}],[\"threadlocalmap的结构了解吗\",{\"0\":{\"228\":1}}],[\"threadlocalmap的key没了\",{\"1\":{\"225\":1}}],[\"threadlocalmap的key\",{\"1\":{\"225\":1}}],[\"threadlocalmap的实例变量threadlocals\",{\"1\":{\"224\":1}}],[\"threadlocalmap中使用的\",{\"1\":{\"225\":1}}],[\"threadlocalmap内部维护着entry数组\",{\"1\":{\"224\":1}}],[\"threadlocal怎么实现的呢\",{\"0\":{\"224\":1}}],[\"threadlocal<\",{\"1\":{\"230\":1}}],[\"threadlocal<>\",{\"1\":{\"222\":1}}],[\"threadlocal<string>\",{\"1\":{\"222\":1}}],[\"threadlocal是什么\",{\"0\":{\"222\":1}}],[\"threadlocal\",{\"0\":{\"221\":1,\"225\":1},\"1\":{\"222\":1,\"225\":1,\"231\":4,\"232\":3,\"233\":1,\"247\":1}}],[\"threadlocal的弱引用导致内存泄漏也是个老生常谈的话题了\",{\"1\":{\"86\":1}}],[\"threadlocal使用不当\",{\"1\":{\"86\":1}}],[\"thread\",{\"0\":{\"80\":1},\"1\":{\"78\":1,\"80\":1,\"231\":2,\"232\":2,\"239\":1,\"249\":22,\"251\":5,\"253\":5,\"257\":6,\"276\":1,\"277\":1,\"279\":3,\"281\":3,\"288\":1,\"303\":3,\"305\":3,\"308\":1,\"328\":3,\"332\":2,\"336\":1,\"359\":1,\"360\":6,\"363\":1,\"364\":1,\"373\":7,\"445\":1}}],[\"throw\",{\"1\":{\"181\":1,\"273\":1,\"274\":1,\"276\":1,\"277\":1,\"279\":4,\"281\":3,\"288\":1,\"363\":1,\"412\":1}}],[\"throwable\",{\"1\":{\"90\":1,\"180\":1,\"359\":1}}],[\"throws\",{\"1\":{\"90\":1,\"181\":1,\"249\":2,\"320\":2}}],[\"thencombine\",{\"0\":{\"270\":1},\"1\":{\"270\":1}}],[\"thencompose\",{\"0\":{\"269\":1},\"1\":{\"269\":1}}],[\"thenrun\",{\"0\":{\"267\":1},\"1\":{\"267\":1}}],[\"thenacceptasync\",{\"1\":{\"294\":1}}],[\"thenaccept\",{\"0\":{\"266\":1},\"1\":{\"266\":1,\"271\":1,\"279\":1,\"281\":1,\"288\":1}}],[\"thenapplyasync\",{\"1\":{\"294\":1}}],[\"thenapply\",{\"0\":{\"265\":1},\"1\":{\"265\":1}}],[\"then\",{\"1\":{\"11\":1}}],[\"the\",{\"0\":{\"99\":1},\"1\":{\"11\":1,\"99\":1,\"100\":1,\"126\":1,\"190\":1,\"230\":1,\"232\":1}}],[\"theme\",{\"1\":{\"8\":1,\"10\":1,\"11\":5,\"17\":2}}],[\"tcp\",{\"1\":{\"51\":1}}],[\"ts\",{\"0\":{\"17\":1},\"1\":{\"23\":1}}],[\"terminated\",{\"0\":{\"369\":1},\"1\":{\"241\":1,\"369\":2}}],[\"terser\",{\"1\":{\"11\":1}}],[\"test\",{\"1\":{\"183\":6}}],[\"tenured\",{\"1\":{\"100\":1}}],[\"template\",{\"1\":{\"11\":2}}],[\"tolist\",{\"1\":{\"279\":1}}],[\"tostring\",{\"1\":{\"175\":1,\"361\":1}}],[\"touppercase\",{\"1\":{\"145\":1}}],[\"to\",{\"1\":{\"11\":2,\"20\":1,\"190\":1,\"230\":1,\"232\":1,\"445\":1}}],[\"tmp\",{\"1\":{\"11\":2}}],[\"v>\",{\"1\":{\"427\":2,\"428\":5,\"445\":10}}],[\"vector的所有方法都是同步的\",{\"1\":{\"417\":1}}],[\"vector是一个线程安全的动态数组类\",{\"1\":{\"417\":1}}],[\"vm\",{\"1\":{\"232\":2}}],[\"volatile修饰原数组array\",{\"1\":{\"418\":1}}],[\"volatile\",{\"1\":{\"373\":1,\"392\":2}}],[\"volatile和synchronized关键字\",{\"1\":{\"247\":1}}],[\"volatile怎么保证有序性的呢\",{\"0\":{\"220\":1}}],[\"volatile怎么保证可见性的呢\",{\"0\":{\"219\":1}}],[\"volatile可以确保对某个变量的更新对其他线程马上可见\",{\"1\":{\"219\":1}}],[\"volatile就是更轻量的选择\",{\"1\":{\"219\":1}}],[\"volatile有两个作用\",{\"1\":{\"218\":1}}],[\"volatile实现原理了解吗\",{\"0\":{\"218\":1}}],[\"volatile变量规则\",{\"1\":{\"216\":1}}],[\"volatile关键字\",{\"1\":{\"212\":1}}],[\"void\",{\"1\":{\"65\":1,\"70\":1,\"85\":3,\"90\":1,\"126\":1,\"153\":2,\"183\":3,\"230\":2,\"231\":2,\"240\":1,\"249\":3,\"251\":3,\"253\":2,\"257\":3,\"279\":1,\"281\":1,\"288\":1,\"303\":1,\"305\":1,\"320\":2,\"324\":1,\"328\":2,\"332\":2,\"336\":1,\"359\":1,\"361\":1,\"363\":1,\"373\":5,\"376\":1,\"378\":2}}],[\"v\",{\"0\":{\"454\":1},\"1\":{\"187\":1,\"271\":1,\"279\":1,\"281\":1,\"398\":7,\"407\":5,\"428\":1,\"450\":1}}],[\"val\",{\"1\":{\"401\":2}}],[\"valatile保证有序性\",{\"1\":{\"220\":1}}],[\"value的能力能指向下一个节点的指针\",{\"1\":{\"444\":1}}],[\"value还在\",{\"1\":{\"225\":1}}],[\"value是threadlocal的泛型值\",{\"1\":{\"224\":1}}],[\"valueof\",{\"1\":{\"173\":1,\"174\":1}}],[\"value\",{\"1\":{\"156\":1,\"169\":2,\"187\":2,\"230\":1,\"354\":2,\"356\":2,\"407\":1,\"427\":3,\"428\":1,\"445\":1,\"450\":3}}],[\"variable\",{\"1\":{\"51\":1}}],[\"virtual\",{\"1\":{\"131\":1,\"148\":1}}],[\"visibility\",{\"1\":{\"20\":1,\"212\":1}}],[\"vite\",{\"1\":{\"11\":1}}],[\"v5\",{\"1\":{\"11\":1}}],[\"vue\",{\"1\":{\"11\":1}}],[\"vuepress\",{\"1\":{\"10\":1,\"11\":8,\"17\":1}}],[\"v3\",{\"1\":{\"11\":2}}],[\"bin\",{\"1\":{\"445\":1}}],[\"bincount\",{\"1\":{\"427\":3}}],[\"bio\",{\"0\":{\"139\":1},\"1\":{\"139\":1}}],[\"bucket\",{\"1\":{\"421\":1,\"446\":1}}],[\"buffers\",{\"1\":{\"178\":1}}],[\"buffer\",{\"0\":{\"80\":1},\"1\":{\"78\":1,\"80\":1}}],[\"b又变回a的情况\",{\"1\":{\"400\":1}}],[\"bounded\",{\"1\":{\"346\":1}}],[\"boot\",{\"1\":{\"156\":1}}],[\"boolean等\",{\"1\":{\"207\":1}}],[\"boolean\",{\"1\":{\"64\":1,\"145\":3,\"159\":2,\"190\":1,\"240\":2,\"249\":1,\"255\":2,\"373\":1,\"397\":1,\"401\":2,\"407\":2,\"450\":1}}],[\"by\",{\"1\":{\"328\":1}}],[\"bytecode\",{\"1\":{\"131\":1}}],[\"byte\",{\"0\":{\"163\":1},\"1\":{\"85\":1,\"159\":2,\"163\":1}}],[\"beforec\",{\"1\":{\"216\":1}}],[\"before于线程a从threadb\",{\"1\":{\"216\":1}}],[\"before于线程b中的任意操作\",{\"1\":{\"216\":1}}],[\"before于任意后续对这个volatile域的读\",{\"1\":{\"216\":1}}],[\"before于随后对这个锁的加锁\",{\"1\":{\"216\":1}}],[\"before于该线程中的任意后续操作\",{\"1\":{\"216\":1}}],[\"before和我们息息相关的有六大规则\",{\"1\":{\"216\":1}}],[\"before关系来执行的结果一致\",{\"1\":{\"216\":1}}],[\"before关系指定的顺序来执行\",{\"1\":{\"216\":1}}],[\"before关系\",{\"1\":{\"216\":1}}],[\"before另一个操作\",{\"1\":{\"216\":1}}],[\"before的定义\",{\"1\":{\"216\":1}}],[\"before\",{\"1\":{\"216\":3}}],[\"before了解吗\",{\"0\":{\"216\":1}}],[\"beta\",{\"1\":{\"51\":1}}],[\"brokenbarrierexception\",{\"1\":{\"251\":3}}],[\"break\",{\"0\":{\"164\":1},\"1\":{\"164\":1,\"427\":2,\"445\":4}}],[\"branches\",{\"1\":{\"16\":1}}],[\"bbb2\",{\"1\":{\"145\":1}}],[\"bbb3\",{\"1\":{\"145\":1}}],[\"bbb1\",{\"1\":{\"145\":1}}],[\"blockingqueue\",{\"1\":{\"373\":1}}],[\"blockingqueue<runnable>\",{\"1\":{\"359\":1,\"373\":1}}],[\"blocked状态表示线程被阻塞\",{\"1\":{\"242\":1}}],[\"blocked和waiting有什么区别\",{\"0\":{\"242\":1}}],[\"blocked\",{\"1\":{\"241\":1}}],[\"bloch\",{\"1\":{\"141\":1}}],[\"blogs\",{\"1\":{\"11\":1}}],[\"blogs>\",{\"1\":{\"11\":1}}],[\"blog\",{\"1\":{\"11\":1}}],[\"b\",{\"0\":{\"173\":1},\"1\":{\"139\":5,\"145\":4,\"216\":1,\"398\":2}}],[\"basicdatasource\",{\"1\":{\"324\":3}}],[\"base\",{\"1\":{\"17\":1}}],[\"barrier\",{\"1\":{\"250\":1,\"251\":8}}],[\"bam\",{\"1\":{\"144\":3}}],[\"baidusyncdisk\",{\"1\":{\"11\":2}}],[\"displaced\",{\"1\":{\"390\":1}}],[\"display\",{\"1\":{\"11\":1}}],[\"discardoldestpolicy\",{\"1\":{\"345\":1}}],[\"discardpolicy\",{\"1\":{\"345\":1}}],[\"dbcp2\",{\"1\":{\"324\":1}}],[\"dbcp为例\",{\"1\":{\"324\":1}}],[\"dubbo等\",{\"1\":{\"178\":1}}],[\"dump等命令也会触发full\",{\"1\":{\"96\":1}}],[\"ddd1\",{\"1\":{\"145\":1}}],[\"ddd2\",{\"1\":{\"145\":1}}],[\"d\",{\"0\":{\"173\":1},\"1\":{\"139\":2}}],[\"daemon\",{\"1\":{\"246\":1}}],[\"datasource\",{\"1\":{\"324\":8}}],[\"databaseconnectionpoolexample\",{\"1\":{\"324\":1}}],[\"data\",{\"1\":{\"51\":2,\"82\":3,\"133\":1,\"257\":6,\"259\":1,\"328\":2}}],[\"daiwencheng\",{\"1\":{\"11\":2}}],[\"delta\",{\"1\":{\"407\":2}}],[\"delayqueue\",{\"1\":{\"356\":1}}],[\"delayedworkqueue\",{\"1\":{\"356\":1}}],[\"delay\",{\"1\":{\"346\":1}}],[\"declares\",{\"1\":{\"190\":1}}],[\"destination\",{\"1\":{\"51\":1}}],[\"description\",{\"1\":{\"17\":1}}],[\"defineuserconfig\",{\"1\":{\"17\":1}}],[\"defaultcapacity\",{\"1\":{\"412\":1}}],[\"default\",{\"1\":{\"17\":1,\"190\":1,\"198\":1,\"232\":1,\"356\":1,\"412\":1,\"445\":1}}],[\"development\",{\"1\":{\"148\":1}}],[\"dev\",{\"1\":{\"11\":3,\"14\":1}}],[\"devdependencies\",{\"1\":{\"11\":2}}],[\"demo\",{\"1\":{\"11\":1}}],[\"deploy\",{\"0\":{\"16\":1}}],[\"dependency\",{\"1\":{\"11\":2,\"190\":1}}],[\"deprecated\",{\"1\":{\"11\":1}}],[\"do\",{\"1\":{\"407\":1,\"428\":1}}],[\"doubling\",{\"1\":{\"230\":1}}],[\"double\",{\"1\":{\"159\":2}}],[\"done\",{\"1\":{\"11\":4}}],[\"downloaded\",{\"1\":{\"11\":2}}],[\"documented\",{\"1\":{\"190\":1}}],[\"documents\",{\"1\":{\"11\":2}}],[\"docsbranch\",{\"1\":{\"23\":1}}],[\"docs的settings项\",{\"1\":{\"21\":1}}],[\"docs\",{\"0\":{\"16\":1},\"1\":{\"10\":1,\"11\":3,\"14\":2,\"17\":1,\"20\":1}}],[\"dlx\",{\"1\":{\"11\":2}}],[\"cmp\",{\"1\":{\"401\":2}}],[\"cms需要对许多参数进行调优\",{\"1\":{\"108\":1}}],[\"cms会触发一次full\",{\"1\":{\"108\":1}}],[\"cms的局限性\",{\"0\":{\"108\":1}}],[\"cms也有其缺点\",{\"1\":{\"100\":1}}],[\"cms开始进行垃圾收集\",{\"1\":{\"100\":1}}],[\"cmsinitiatingoccupancyfraction\",{\"1\":{\"100\":1}}],[\"cms使用标记\",{\"1\":{\"100\":1,\"108\":1}}],[\"cms收集器通过初始标记\",{\"1\":{\"100\":1}}],[\"cms收集器还有一个重要的参数\",{\"1\":{\"100\":1}}],[\"cms收集器提供了并发压缩\",{\"1\":{\"100\":1}}],[\"cms收集器设计的主要目的是降低垃圾收集对应用程序的停顿时间\",{\"1\":{\"100\":1}}],[\"cms收集器有以下几个特点\",{\"1\":{\"100\":1}}],[\"cms收集器主要用于老年代\",{\"1\":{\"100\":1}}],[\"cms收集器是一种以减少停顿时间为目标的收集器\",{\"1\":{\"98\":1}}],[\"cms\",{\"1\":{\"98\":1,\"100\":1,\"112\":1,\"120\":1}}],[\"cxq\",{\"1\":{\"381\":1}}],[\"ce\",{\"1\":{\"359\":2}}],[\"currenttimemillis\",{\"1\":{\"336\":1}}],[\"currentthread\",{\"1\":{\"251\":3,\"253\":3,\"257\":4,\"303\":2,\"305\":2,\"328\":2,\"332\":1,\"359\":1,\"363\":1,\"373\":4}}],[\"customthreadpoolexample\",{\"1\":{\"288\":1,\"305\":1}}],[\"customthreadpool\",{\"1\":{\"286\":1,\"287\":1,\"288\":6,\"359\":2,\"373\":4}}],[\"cyclic\",{\"1\":{\"250\":1}}],[\"cyclicbarrier可以在所有的线程释放后重新使\",{\"1\":{\"252\":1}}],[\"cyclicbarrier面向的是线程数\",{\"1\":{\"252\":1}}],[\"cyclicbarrier是可重用的\",{\"1\":{\"252\":1}}],[\"cyclicbarrier和countdownlatch有什么区别\",{\"0\":{\"252\":1}}],[\"cyclicbarrierexample\",{\"1\":{\"251\":1}}],[\"cyclicbarrier的字面意思是可循环使用\",{\"1\":{\"250\":1}}],[\"cyclicbarrier\",{\"0\":{\"250\":1},\"1\":{\"251\":5,\"252\":1}}],[\"cpu消耗\",{\"0\":{\"310\":1}}],[\"cpu\",{\"1\":{\"240\":2,\"244\":1,\"245\":4,\"394\":1,\"395\":1}}],[\"ccl\",{\"1\":{\"232\":1}}],[\"ccc\",{\"1\":{\"145\":1}}],[\"c和d不相等\",{\"1\":{\"173\":1}}],[\"c=\",{\"0\":{\"173\":1}}],[\"check\",{\"1\":{\"428\":1}}],[\"checkedexception\",{\"1\":{\"180\":1}}],[\"checksum\",{\"1\":{\"51\":1}}],[\"characteristics\",{\"1\":{\"232\":1}}],[\"charat\",{\"1\":{\"144\":1}}],[\"char\",{\"1\":{\"159\":2,\"163\":1,\"169\":2}}],[\"channel代表了服务端与客户端的连接\",{\"1\":{\"139\":1}}],[\"capacity\",{\"1\":{\"412\":1,\"445\":1}}],[\"cancellationexception\",{\"1\":{\"359\":1}}],[\"callerrunspolicy\",{\"1\":{\"345\":1}}],[\"callable<integer>\",{\"1\":{\"363\":1}}],[\"callable\",{\"0\":{\"363\":1},\"1\":{\"143\":1,\"358\":1,\"363\":2}}],[\"car\",{\"1\":{\"253\":3,\"254\":1}}],[\"cachedthreadpool\",{\"0\":{\"354\":1},\"1\":{\"291\":1,\"302\":2,\"351\":1}}],[\"cache\",{\"1\":{\"91\":1}}],[\"catch\",{\"1\":{\"85\":2,\"181\":1,\"183\":2,\"204\":1,\"249\":2,\"251\":1,\"253\":1,\"257\":2,\"271\":1,\"276\":1,\"277\":1,\"279\":4,\"281\":4,\"288\":2,\"303\":2,\"305\":2,\"324\":1,\"328\":2,\"332\":1,\"336\":1,\"342\":1,\"348\":1,\"358\":1,\"359\":3,\"363\":2,\"373\":3}}],[\"castabat\",{\"1\":{\"445\":1}}],[\"cas操作\",{\"1\":{\"445\":1}}],[\"cas操作都不做\",{\"1\":{\"387\":1}}],[\"cas+synchronized\",{\"0\":{\"445\":1}}],[\"caspair\",{\"1\":{\"401\":1}}],[\"cas获取偏向锁失败表示有竞争\",{\"1\":{\"389\":1}}],[\"cas\",{\"0\":{\"399\":1},\"1\":{\"81\":2,\"392\":1,\"397\":3,\"398\":6,\"404\":2}}],[\"cleansomeslots\",{\"1\":{\"230\":1}}],[\"cleanup\",{\"1\":{\"102\":1,\"103\":1}}],[\"clone\",{\"1\":{\"175\":1}}],[\"classloader\",{\"1\":{\"232\":1}}],[\"classname\",{\"1\":{\"186\":1}}],[\"class文件加载到内存中\",{\"1\":{\"134\":1}}],[\"class文件\",{\"1\":{\"132\":1,\"133\":1,\"150\":1}}],[\"class\",{\"0\":{\"200\":1},\"1\":{\"65\":2,\"70\":1,\"85\":2,\"126\":2,\"133\":1,\"150\":2,\"151\":1,\"153\":3,\"155\":1,\"159\":1,\"186\":1,\"190\":4,\"231\":1,\"232\":1,\"251\":2,\"253\":2,\"257\":3,\"279\":1,\"281\":1,\"288\":1,\"303\":1,\"305\":1,\"320\":1,\"324\":1,\"328\":1,\"332\":1,\"336\":1,\"359\":1,\"363\":1,\"373\":2,\"376\":1,\"378\":3}}],[\"clientsocket\",{\"1\":{\"320\":3}}],[\"client\",{\"1\":{\"11\":1}}],[\"c4deployment\",{\"0\":{\"44\":1}}],[\"c4dynamic\",{\"0\":{\"43\":1}}],[\"c4component\",{\"0\":{\"42\":1}}],[\"c4container\",{\"0\":{\"41\":1}}],[\"c4context\",{\"0\":{\"40\":1}}],[\"c4\",{\"0\":{\"39\":1,\"40\":1,\"41\":1,\"42\":1,\"43\":1,\"44\":1}}],[\"cn\",{\"1\":{\"17\":1}}],[\"column\",{\"1\":{\"324\":1}}],[\"collect\",{\"1\":{\"279\":1}}],[\"collectors\",{\"1\":{\"279\":2,\"281\":1}}],[\"collector\",{\"1\":{\"98\":1,\"101\":1,\"112\":1,\"120\":1,\"133\":1}}],[\"collections\",{\"1\":{\"102\":2,\"109\":1,\"442\":1}}],[\"collection\",{\"1\":{\"92\":1,\"96\":1}}],[\"corepoolsize\",{\"1\":{\"304\":1,\"305\":1,\"338\":2,\"344\":1,\"356\":2,\"359\":2}}],[\"commons\",{\"1\":{\"324\":2}}],[\"commonpool\",{\"1\":{\"283\":1,\"284\":1,\"294\":1}}],[\"com\",{\"1\":{\"153\":2,\"332\":1}}],[\"comprator\",{\"1\":{\"448\":1}}],[\"compute\",{\"1\":{\"376\":9}}],[\"completed\",{\"1\":{\"373\":1}}],[\"completeontimeout\",{\"0\":{\"277\":1},\"1\":{\"277\":1}}],[\"completablefuture的线程池设置\",{\"0\":{\"283\":1}}],[\"completablefuturerealworldexample\",{\"1\":{\"281\":1}}],[\"completablefutureparallelexample\",{\"1\":{\"279\":1}}],[\"completablefuture<void>\",{\"1\":{\"263\":1,\"271\":1,\"279\":1,\"281\":1}}],[\"completablefuture<string>\",{\"1\":{\"263\":1,\"265\":1,\"269\":1,\"270\":3,\"271\":3,\"273\":1,\"274\":1,\"276\":1,\"277\":1,\"279\":3,\"281\":6,\"284\":1,\"287\":1,\"288\":1}}],[\"completablefuture\",{\"0\":{\"263\":1,\"268\":1,\"362\":1},\"1\":{\"261\":1,\"263\":3,\"265\":1,\"266\":1,\"267\":1,\"269\":4,\"270\":3,\"271\":5,\"273\":1,\"274\":1,\"276\":1,\"277\":1,\"279\":5,\"281\":5,\"282\":1,\"283\":1,\"284\":2,\"285\":2,\"287\":2,\"288\":2,\"294\":2,\"362\":2}}],[\"component\",{\"1\":{\"156\":1}}],[\"compiler\",{\"1\":{\"133\":1}}],[\"comparator\",{\"1\":{\"143\":1}}],[\"compareandsetint是个native方法\",{\"1\":{\"407\":1}}],[\"compareandsetint\",{\"1\":{\"407\":2,\"445\":2}}],[\"compareandset\",{\"1\":{\"401\":2,\"406\":1}}],[\"compareto\",{\"1\":{\"145\":1}}],[\"compare\",{\"1\":{\"81\":1,\"398\":1,\"406\":1}}],[\"compacting\",{\"1\":{\"100\":1}}],[\"compact\",{\"1\":{\"92\":1,\"108\":1}}],[\"countdown\",{\"1\":{\"249\":9}}],[\"countdownlatch在计数器为0\",{\"1\":{\"252\":1}}],[\"countdownlatch面向的是任务\",{\"1\":{\"252\":1}}],[\"countdownlatch中的各个子线程不可以等待其他线程\",{\"1\":{\"252\":1}}],[\"countdownlatch是一次性的\",{\"1\":{\"252\":2}}],[\"countdownlatch的核心方法\",{\"1\":{\"249\":1}}],[\"countdownlatch\",{\"0\":{\"249\":1},\"1\":{\"249\":22,\"252\":1}}],[\"count++\",{\"1\":{\"230\":1}}],[\"count\",{\"1\":{\"145\":3,\"230\":2,\"381\":3}}],[\"counter\",{\"1\":{\"53\":1,\"55\":1,\"133\":1}}],[\"copyonwrite\",{\"1\":{\"418\":1}}],[\"copyonwritearraylist适合在读多写少的场景中使用\",{\"1\":{\"418\":1}}],[\"copyonwritearraylist通过创建副本的方式实现线程安全\",{\"1\":{\"418\":1}}],[\"copyonwritearraylist就是线程安全版本的arraylist\",{\"1\":{\"418\":1}}],[\"copyonwritearraylist了解多少\",{\"0\":{\"418\":1}}],[\"copyonwritearraylist具有较高的性能\",{\"1\":{\"417\":1}}],[\"copyonwritearraylist是一种线程安全的并发list\",{\"1\":{\"417\":1}}],[\"copy\",{\"1\":{\"109\":1}}],[\"copying\",{\"1\":{\"92\":1}}],[\"code\",{\"1\":{\"91\":1,\"190\":1,\"412\":1,\"421\":1}}],[\"codec\",{\"1\":{\"11\":1}}],[\"conn\",{\"1\":{\"324\":2}}],[\"connection\",{\"1\":{\"324\":2}}],[\"contextclassloader\",{\"1\":{\"232\":3}}],[\"continue\",{\"0\":{\"164\":1},\"1\":{\"164\":1}}],[\"control\",{\"1\":{\"102\":1}}],[\"control管理工具\",{\"1\":{\"75\":1}}],[\"conscious\",{\"1\":{\"412\":1}}],[\"constructor\",{\"1\":{\"155\":1,\"190\":1}}],[\"constant\",{\"1\":{\"56\":1,\"64\":1,\"65\":2}}],[\"consumer\",{\"1\":{\"143\":1,\"257\":3,\"258\":1}}],[\"concurrent包下的容器都是安全失败\",{\"1\":{\"416\":1}}],[\"concurrent包提供了多种线程池实现\",{\"1\":{\"301\":1}}],[\"concurrenthashmap线程安全在jdk1\",{\"1\":{\"443\":1}}],[\"concurrenthashmap\",{\"1\":{\"192\":1,\"442\":2}}],[\"concurrent\",{\"1\":{\"98\":1,\"100\":3,\"101\":1,\"102\":2,\"103\":1,\"107\":1,\"108\":1,\"112\":1,\"120\":1,\"257\":1,\"279\":2,\"281\":2,\"286\":2,\"288\":4,\"303\":3,\"305\":3,\"320\":2,\"328\":3,\"332\":2,\"336\":3,\"363\":1,\"373\":2,\"376\":1}}],[\"configuration\",{\"1\":{\"153\":1}}],[\"config\",{\"0\":{\"17\":1}}],[\"c\",{\"1\":{\"11\":2,\"139\":1,\"216\":1}}],[\"createinheritedmap\",{\"1\":{\"232\":1}}],[\"create\",{\"1\":{\"10\":1,\"11\":1}}],[\"0得0\",{\"1\":{\"431\":1}}],[\"00000006\",{\"1\":{\"435\":1}}],[\"00\",{\"1\":{\"390\":1}}],[\"01\",{\"1\":{\"389\":1}}],[\"0x61c88647\",{\"1\":{\"228\":2}}],[\"0d\",{\"1\":{\"159\":1}}],[\"0f\",{\"1\":{\"159\":1}}],[\"0l\",{\"1\":{\"159\":1,\"353\":1,\"355\":1,\"361\":1}}],[\"0\",{\"1\":{\"11\":16,\"51\":1,\"85\":1,\"144\":1,\"159\":5,\"183\":1,\"204\":1,\"230\":1,\"232\":2,\"273\":1,\"274\":1,\"303\":1,\"305\":1,\"336\":1,\"354\":1,\"373\":2,\"381\":8,\"397\":1,\"412\":3,\"427\":3,\"428\":1,\"445\":7}}],[\"42\",{\"1\":{\"363\":1}}],[\"4028235e38\",{\"1\":{\"159\":1}}],[\"409\",{\"1\":{\"11\":1}}],[\"45\",{\"1\":{\"159\":1}}],[\"4e\",{\"1\":{\"159\":1}}],[\"4之前的选择\",{\"1\":{\"139\":1}}],[\"4\",{\"0\":{\"31\":1,\"268\":1,\"269\":1,\"270\":1,\"271\":1,\"289\":1,\"290\":1,\"291\":1,\"292\":1,\"293\":2,\"303\":1,\"329\":1,\"341\":1,\"356\":1,\"361\":1,\"368\":1},\"1\":{\"11\":2,\"159\":3,\"229\":2,\"230\":3,\"328\":2,\"389\":1,\"390\":1}}],[\"7版本的concurrenthashmap采用分段锁机制\",{\"1\":{\"444\":1}}],[\"7版本是基于\",{\"1\":{\"443\":1}}],[\"7和jdk1\",{\"1\":{\"441\":2}}],[\"7和1\",{\"1\":{\"54\":1,\"60\":1,\"61\":1}}],[\"75作为hashmap的默认加载因子呢\",{\"0\":{\"437\":1}}],[\"75\",{\"0\":{\"436\":1}}],[\"7976931348623157e308\",{\"1\":{\"159\":1}}],[\"7及以前版本\",{\"1\":{\"94\":1}}],[\"7及以前版本的概念\",{\"1\":{\"91\":1}}],[\"7及之前的版本中\",{\"1\":{\"78\":1}}],[\"7开始位于堆中\",{\"1\":{\"66\":2}}],[\"7开始\",{\"1\":{\"64\":1,\"65\":1}}],[\"7中\",{\"1\":{\"56\":1,\"75\":1,\"441\":1}}],[\"7428\",{\"1\":{\"11\":2}}],[\"7\",{\"0\":{\"34\":1,\"54\":1,\"56\":1,\"278\":1,\"444\":1},\"1\":{\"11\":2,\"59\":1,\"62\":1,\"163\":1,\"328\":1,\"421\":1}}],[\"创建定时任务线程池\",{\"1\":{\"356\":1}}],[\"创建单线程线程池\",{\"1\":{\"355\":1}}],[\"创建缓存线程池\",{\"1\":{\"354\":1}}],[\"创建核心线程执行任务\",{\"1\":{\"353\":1}}],[\"创建核心线程和任务队列\",{\"1\":{\"343\":1}}],[\"创建固定大小线程池\",{\"1\":{\"353\":1}}],[\"创建新线程执行任务\",{\"1\":{\"340\":1}}],[\"创建自定义线程池\",{\"0\":{\"286\":1},\"1\":{\"288\":1,\"305\":1}}],[\"创建并启动两个线程\",{\"1\":{\"257\":1}}],[\"创建并启动六个线程模拟汽车\",{\"1\":{\"253\":1}}],[\"创建并启动三个线程\",{\"1\":{\"251\":1}}],[\"创建cyclicbarrier实例\",{\"1\":{\"251\":1}}],[\"创建一个\",{\"1\":{\"376\":1}}],[\"创建一个自定义的线程池\",{\"1\":{\"359\":1}}],[\"创建一个自定义线程池\",{\"1\":{\"286\":1}}],[\"创建一个固定大小的线程池\",{\"1\":{\"286\":1,\"303\":1}}],[\"创建一个包含所有异步任务的completablefuture\",{\"1\":{\"279\":1}}],[\"创建一个exchanger实例\",{\"1\":{\"257\":1}}],[\"创建一个semaphore实例\",{\"1\":{\"253\":1}}],[\"创建一个threadlocal变量\",{\"1\":{\"222\":1}}],[\"创建一个1mb大小的字节数组对象\",{\"1\":{\"85\":1}}],[\"创建\",{\"0\":{\"263\":1},\"1\":{\"222\":1}}],[\"创建了一个threadloca变量localvariable\",{\"1\":{\"222\":1}}],[\"创建了一个threadlocal变量\",{\"1\":{\"222\":1}}],[\"创建了几个对象\",{\"1\":{\"170\":1}}],[\"创建对象有哪几种方式\",{\"0\":{\"209\":1}}],[\"创建对象实例的方式\",{\"1\":{\"155\":1}}],[\"创建类实例\",{\"1\":{\"155\":1}}],[\"创建过程\",{\"0\":{\"11\":1}}],[\"创建项目模板\",{\"0\":{\"10\":1}}],[\"pipedreader和pipedwriter\",{\"1\":{\"247\":1}}],[\"pipedinputstream\",{\"1\":{\"247\":1}}],[\"pipedoutputstream\",{\"1\":{\"247\":1}}],[\"p\",{\"1\":{\"126\":2,\"427\":9}}],[\"phantom\",{\"1\":{\"89\":1}}],[\"priority\",{\"1\":{\"346\":1}}],[\"printstacktrace\",{\"1\":{\"249\":1,\"251\":1,\"253\":1,\"257\":2,\"271\":1,\"281\":1,\"324\":1,\"358\":1,\"359\":1,\"360\":1,\"362\":1,\"363\":2}}],[\"print\",{\"1\":{\"183\":1}}],[\"println\",{\"1\":{\"85\":2,\"144\":1,\"145\":4,\"153\":1,\"183\":3,\"231\":1,\"249\":3,\"251\":4,\"253\":3,\"257\":4,\"266\":1,\"267\":1,\"271\":1,\"279\":2,\"281\":1,\"288\":2,\"294\":1,\"303\":1,\"305\":1,\"324\":1,\"328\":1,\"332\":3,\"336\":1,\"361\":1,\"363\":1,\"373\":2,\"376\":1}}],[\"private\",{\"0\":{\"198\":1},\"1\":{\"169\":1,\"198\":1,\"201\":1,\"228\":3,\"230\":2,\"249\":1,\"251\":1,\"253\":1,\"257\":2,\"281\":3,\"320\":2,\"328\":1,\"332\":1,\"373\":5,\"376\":1,\"401\":1,\"412\":1,\"445\":1}}],[\"present\",{\"1\":{\"450\":1}}],[\"preparestatement\",{\"1\":{\"324\":1}}],[\"preparedstatement\",{\"1\":{\"324\":2}}],[\"predicate\",{\"1\":{\"143\":1}}],[\"pretenuresizethreshold参数来设置大对象的大小阈值\",{\"1\":{\"97\":1}}],[\"processing\",{\"1\":{\"328\":1}}],[\"process\",{\"1\":{\"328\":2}}],[\"protocol\",{\"1\":{\"178\":1}}],[\"protobuf\",{\"1\":{\"178\":1}}],[\"protobuf序列化\",{\"1\":{\"178\":1}}],[\"protected和default修饰符\",{\"1\":{\"200\":1}}],[\"protected\",{\"0\":{\"198\":1},\"1\":{\"90\":1,\"198\":1,\"359\":1,\"376\":1}}],[\"provider\",{\"1\":{\"153\":3}}],[\"promotion\",{\"1\":{\"96\":1}}],[\"programming\",{\"1\":{\"99\":1}}],[\"program\",{\"1\":{\"53\":1,\"55\":1,\"133\":1}}],[\"progress\",{\"1\":{\"11\":2}}],[\"producer\",{\"1\":{\"257\":3,\"258\":1}}],[\"prod\",{\"1\":{\"11\":1}}],[\"project\",{\"1\":{\"11\":1}}],[\"permanent\",{\"1\":{\"55\":1,\"91\":1}}],[\"permgen\",{\"0\":{\"59\":1},\"1\":{\"53\":1,\"55\":1,\"56\":1,\"64\":1,\"72\":1,\"74\":1,\"77\":1}}],[\"put流程\",{\"1\":{\"444\":1,\"445\":1}}],[\"put和get并发时\",{\"1\":{\"441\":1}}],[\"puttreeval\",{\"1\":{\"427\":1}}],[\"put\",{\"1\":{\"373\":1,\"450\":1}}],[\"public\",{\"1\":{\"20\":1,\"65\":2,\"70\":2,\"85\":5,\"126\":2,\"153\":3,\"183\":6,\"186\":4,\"190\":2,\"198\":1,\"200\":1,\"222\":1,\"231\":3,\"249\":2,\"251\":5,\"253\":4,\"257\":6,\"279\":2,\"281\":2,\"288\":2,\"303\":2,\"305\":2,\"320\":3,\"324\":2,\"328\":2,\"332\":2,\"336\":2,\"353\":1,\"354\":1,\"355\":1,\"356\":1,\"359\":2,\"360\":1,\"361\":1,\"363\":2,\"373\":7,\"376\":3,\"397\":2,\"401\":1,\"407\":4,\"428\":1,\"450\":1}}],[\"push\",{\"1\":{\"16\":1}}],[\"pwa\",{\"1\":{\"17\":1}}],[\"posts\",{\"0\":{\"453\":1}}],[\"postinstall\",{\"1\":{\"11\":1}}],[\"polymorphicsignature\",{\"1\":{\"401\":1}}],[\"point对象只在examplemethod方法内部使用\",{\"1\":{\"126\":1}}],[\"point\",{\"1\":{\"99\":1,\"126\":5}}],[\"pointer\",{\"1\":{\"51\":1}}],[\"poolsize\",{\"1\":{\"320\":2,\"373\":6}}],[\"pool2\",{\"1\":{\"294\":3}}],[\"pool1\",{\"1\":{\"294\":3}}],[\"pool\",{\"1\":{\"56\":1,\"64\":1,\"65\":2,\"364\":1}}],[\"port\",{\"1\":{\"51\":2,\"320\":2}}],[\"powershell\",{\"1\":{\"11\":1}}],[\"plugin\",{\"1\":{\"11\":1}}],[\"pair\",{\"1\":{\"401\":1}}],[\"pair<v>\",{\"1\":{\"401\":2}}],[\"password\",{\"1\":{\"324\":1}}],[\"pause\",{\"1\":{\"102\":2,\"109\":1}}],[\"parkinglot\",{\"1\":{\"253\":8,\"255\":3}}],[\"park\",{\"1\":{\"242\":1,\"392\":1}}],[\"parent\",{\"1\":{\"232\":2}}],[\"parentmap\",{\"1\":{\"232\":4}}],[\"parameter\",{\"1\":{\"190\":1}}],[\"paralleldataprocessingexample\",{\"1\":{\"328\":1}}],[\"parallelism\",{\"1\":{\"215\":1}}],[\"parallel\",{\"1\":{\"98\":4,\"120\":1}}],[\"parseint\",{\"1\":{\"174\":1}}],[\"parnew是serial收集器的多线程版本\",{\"1\":{\"98\":1}}],[\"parnew收集器\",{\"1\":{\"98\":1}}],[\"padding\",{\"1\":{\"51\":1,\"82\":3}}],[\"packet\",{\"1\":{\"51\":2}}],[\"packages\",{\"1\":{\"11\":1}}],[\"package\",{\"1\":{\"11\":1}}],[\"pages是发布分支\",{\"1\":{\"22\":1}}],[\"pages分支\",{\"0\":{\"22\":1}}],[\"pages\",{\"0\":{\"19\":1,\"21\":1},\"1\":{\"11\":1,\"21\":1,\"22\":1}}],[\"pages搭建\",{\"1\":{\"8\":1}}],[\"psh\",{\"1\":{\"51\":1}}],[\"ps\",{\"1\":{\"11\":1}}],[\"pnpm\",{\"1\":{\"10\":1,\"11\":5}}],[\"和hashmap的get流程基本相同\",{\"1\":{\"445\":1}}],[\"和统计学有关\",{\"1\":{\"435\":1}}],[\"和安全失败\",{\"0\":{\"416\":1}}],[\"和内存位置\",{\"1\":{\"398\":1}}],[\"和内存泄漏\",{\"1\":{\"84\":1}}],[\"和新值\",{\"1\":{\"398\":1}}],[\"和公平锁一样都会进入到\",{\"1\":{\"397\":1}}],[\"和notify\",{\"1\":{\"391\":1}}],[\"和unlock\",{\"1\":{\"391\":1}}],[\"和第\",{\"1\":{\"376\":1}}],[\"和recursiveaction用于表示没有返回值的任务\",{\"1\":{\"376\":1}}],[\"和submit\",{\"1\":{\"347\":1}}],[\"和string\",{\"0\":{\"170\":1}}],[\"和无界队列\",{\"1\":{\"344\":1}}],[\"和任务队列\",{\"1\":{\"338\":1}}],[\"和join\",{\"1\":{\"247\":1}}],[\"和引用数据类型变量的地址值\",{\"1\":{\"208\":1}}],[\"和引用类型的null\",{\"1\":{\"78\":1}}],[\"和常量\",{\"1\":{\"200\":1}}],[\"和接口\",{\"0\":{\"200\":1}}],[\"和接⼝\",{\"1\":{\"196\":1}}],[\"和重写\",{\"0\":{\"197\":1}}],[\"和⼯具\",{\"1\":{\"148\":1}}],[\"和即时编译器\",{\"1\":{\"133\":1}}],[\"和本地方法栈\",{\"1\":{\"133\":1}}],[\"和栈\",{\"1\":{\"132\":1}}],[\"和标记\",{\"1\":{\"109\":1}}],[\"和清理\",{\"1\":{\"102\":1}}],[\"和类unloading的机制\",{\"1\":{\"100\":1}}],[\"和对齐填充\",{\"1\":{\"82\":1}}],[\"和符号引用\",{\"1\":{\"68\":1}}],[\"和两个幸存者区\",{\"1\":{\"53\":1}}],[\"和老年代\",{\"1\":{\"53\":1}}],[\"和\",{\"0\":{\"148\":1,\"162\":1,\"170\":1,\"363\":1},\"1\":{\"8\":1,\"87\":1,\"137\":3,\"148\":1,\"216\":1,\"246\":1,\"251\":1,\"415\":1,\"426\":1,\"439\":1}}],[\"幻灯片页\",{\"0\":{\"6\":1}}],[\"趋势\",{\"0\":{\"4\":1}}],[\"||\",{\"1\":{\"427\":3,\"428\":2,\"445\":5,\"450\":1}}],[\"|\",{\"1\":{\"1\":1,\"11\":2,\"82\":14,\"251\":1,\"271\":1,\"279\":1,\"281\":1}}],[\"欢迎来到鱼塘\",{\"1\":{\"1\":1}}],[\"鱼塘\",{\"0\":{\"0\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n}})=>{e==="suggest"?self.postMessage(st(t,v[s],n)):e==="search"?self.postMessage(et(t,v[s],n)):self.postMessage({suggestions:st(t,v[s],n),results:et(t,v[s],n)})};
//# sourceMappingURL=index.js.map
