const nt="ENTRIES",V="KEYS",T="VALUES",F="";class D{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===F)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==F).join("")}value(){return E(this._path).node.get(F)}result(){switch(this._type){case T:return this.value();case V:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],ot=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return W(e,t,s,n,i,1,o,""),n},W=(e,t,s,n,o,u,i,r)=>{const h=u*i;t:for(const c of e.keys())if(c===F){const d=o[h-1];d<=s&&n.set(r,[e.get(c),d])}else{let d=u;for(let l=0;l<c.length;++l,++d){const p=c[l],f=i*d,g=f-i;let a=o[f];const m=Math.max(0,d-s-1),y=Math.min(i-1,d+s);for(let _=m;_<y;++_){const b=p!==t[_],z=o[g+_]+ +b,A=o[g+_+1]+1,w=o[f+_]+1,L=o[f+_+1]=Math.min(z,A,w);L<a&&(a=L)}if(a>s)continue t}W(e.get(c),t,s,n,o,d,i,r+c)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=O(n);for(const i of o.keys())if(i!==F&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ut(this._tree,t)}entries(){return new D(this,nt)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return ot(this._tree,t,s)}get(t){const s=I(this._tree,t);return s!==void 0?s.get(F):void 0}has(t){const s=I(this._tree,t);return s!==void 0&&s.has(F)}keys(){return new D(this,V)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,M(this._tree,t).set(F,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=M(this._tree,t);return n.set(F,s(n.get(F))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=M(this._tree,t);let o=n.get(F);return o===void 0&&n.set(F,o=s()),o}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==F&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},I=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==F&&t.startsWith(s))return I(e.get(s),t.slice(s.length))},M=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==F&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const h=e.get(u);if(r===u.length)e=h;else{const c=new Map;c.set(u.slice(r),h),e.set(t.slice(n,n+r),c),e.delete(u),e=c}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ut=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(F),s.size===0)R(n);else if(s.size===1){const[o,u]=s.entries().next().value;$(n,o,u)}}},R=e=>{if(e.length===0)return;const[t,s]=O(e);if(t.delete(s),t.size===0)R(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==F&&$(e.slice(0,-1),n,o)}},$=(e,t,s)=>{if(e.length===0)return;const[n,o]=O(e);n.set(o+t,s),n.delete(o)},O=e=>e[e.length-1],it=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},rt=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,S="or",q="and",ct="and_not",lt=(e,t)=>{e.includes(t)||e.push(t)},P=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},G=({score:e},{score:t})=>t-e,ht=()=>new Map,k=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},N=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,dt={[S]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),P(n.terms,u)}}return e},[q]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);P(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[ct]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},at=(e,t,s,n,o,u)=>{const{k:i,b:r,d:h}=u;return Math.log(1+(s-t+.5)/(t+.5))*(h+e*(i+1)/(e+i*(1-r+r*n/o)))},ft=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},H=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},gt=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const o=e._index.fetch(n,ht),u=o.get(t);u==null||u.get(s)==null?H(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},mt={k:1.2,b:.7,d:.5},pt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(rt),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof(console==null?void 0:console[e])=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:S,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:mt},Ft={combineWith:q,prefix:(e,t,s)=>t===s.length-1},_t={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},yt={..._t,...U},Y=(e,t=S)=>{if(e.length===0)return new Map;const s=t.toLowerCase();return e.reduce(dt[s])||new Map},B=(e,t,s,n,o,u,i,r,h=new Map)=>{if(o==null)return h;for(const c of Object.keys(u)){const d=u[c],l=e._fieldIds[c],p=o.get(l);if(p==null)continue;let f=p.size;const g=e._avgFieldLength[l];for(const a of p.keys()){if(!e._documentIds.has(a)){gt(e,l,a,s),f-=1;continue}const m=i?i(e._documentIds.get(a),s,e._storedFields.get(a)):1;if(!m)continue;const y=p.get(a),_=e._fieldLength.get(a)[l],b=at(y,f,e._documentCount,_,g,r),z=n*d*m*b,A=h.get(a);if(A){A.score+=z,lt(A.terms,t);const w=N(A.match,s);w?w.push(c):A.match[s]=[c]}else h.set(a,{score:z,terms:[t],match:{[s]:[c]}})}}return h},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((a,m)=>({...a,[m]:N(n.boost,m)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:h}=n,{fuzzy:c,prefix:d}={...J.weights,...i},l=e._index.get(t.term),p=B(e,t.term,t.term,1,l,o,u,h);let f,g;if(t.prefix&&(f=e._index.atPrefix(t.term)),t.fuzzy){const a=t.fuzzy===!0?.2:t.fuzzy,m=a<1?Math.min(r,Math.round(t.term.length*a)):a;m&&(g=e._index.fuzzyGet(t.term,m))}if(f)for(const[a,m]of f){const y=a.length-t.term.length;if(!y)continue;g==null||g.delete(a);const _=d*a.length/(a.length+.3*y);B(e,t.term,a,_,m,o,u,h,p)}if(g)for(const a of g.keys()){const[m,y]=g.get(a);if(!y)continue;const _=c*a.length/(a.length+y);B(e,t.term,a,_,m,o,u,h,p)}return p},X=(e,t,s={})=>{if(typeof t!="string"){const d={...s,...t,queries:void 0},l=t.queries.map(p=>X(e,p,d));return Y(l,d.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:h}=i,c=r(t).flatMap(d=>h(d)).filter(d=>!!d).map(ft(i)).map(d=>At(e,d,i));return Y(c,i.combineWith)},K=(e,t,s={})=>{const n=X(e,t,s),o=[];for(const[u,{score:i,terms:r,match:h}]of n){const c=r.length,d={id:e._documentIds.get(u),score:i*c,terms:Object.keys(h),match:h};Object.assign(d,e._storedFields.get(u)),(s.filter==null||s.filter(d))&&o.push(d)}return o.sort(G),o},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of K(e,t,s)){const r=i.join(" "),h=n.get(r);h!=null?(h.score+=u,h.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:h}]of n)o.push({suggestion:u,terms:r,score:i/h});return o.sort(G),o};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if((t==null?void 0:t.fields)==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?yt:t.autoVacuum;this._options={...pt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...Ft,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:h,serializationVersion:c},d)=>{if(c!==1&&c!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const l=new Et(d);l._documentCount=t,l._nextId=s,l._documentIds=k(n),l._idToShortId=new Map,l._fieldIds=o,l._fieldLength=k(u),l._avgFieldLength=i,l._storedFields=k(r),l._dirtCount=h||0,l._index=new C;for(const[p,f]of l._documentIds)l._idToShortId.set(f,p);for(const[p,f]of e){const g=new Map;for(const a of Object.keys(f)){let m=f[a];c===1&&(m=m.ds),g.set(parseInt(a,10),k(m))}l._index.set(p,g)}return l},Q=Object.entries,wt=Object.fromEntries,j=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(c,d=!1)=>{let l="";i===0?l=c.length>20?`… ${c.slice(-20)}`:c:d?l=c.length+i>100?`${c.slice(0,100-i)}… `:c:l=c.length>20?`${c.slice(0,20)} … ${c.slice(-20)}`:c,l&&o.push(l),i+=l.length,d||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let h=s.indexOf(n,u);if(h===-1)return null;for(;h>=0;){const c=h+n.length;if(r(e.slice(u,h)),u=c,i>100)break;h=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},Z=/[\u4e00-\u9fa5]/g,tt=(e={})=>({fuzzy:.2,prefix:!0,processTerm:t=>{const s=t.match(Z)||[],n=t.replace(Z,"").toLowerCase();return n?[n,...s]:[...s]},...e}),xt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),kt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),et=(e,t,s={})=>{const n={};return K(t,e,tt({boost:{h:2,t:1,c:4},...s})).forEach(o=>{const{id:u,terms:i,score:r}=o,h=u.includes("@"),c=u.includes("#"),[d,l]=u.split(/[#@]/),{contents:p}=n[d]??={title:"",contents:[]};if(h)p.push([{type:"customField",key:d,index:l,display:i.map(f=>o.c.map(g=>j(g,f))).flat().filter(f=>f!==null)},r]);else{const f=i.map(g=>j(o.h,g)).filter(g=>g!==null);if(f.length&&p.push([{type:c?"heading":"title",key:d,...c&&{anchor:l},display:f},r]),"t"in o)for(const g of o.t){const a=i.map(m=>j(g,m)).filter(m=>m!==null);a.length&&p.push([{type:"text",key:d,...c&&{anchor:l},display:a},r])}}}),Q(n).sort(([,o],[,u])=>"max"==="total"?xt(o,u):kt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=it(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},st=(e,t,s={})=>Ct(t,e,tt(s)).map(({suggestion:n})=>n),v=wt(Q(JSON.parse("{\"/\":{\"documentCount\":176,\"nextId\":176,\"documentIds\":{\"0\":\"v-8daa1a0e\",\"1\":\"v-8daa1a0e#关于网站\",\"2\":\"v-8daa1a0e#关于作者\",\"3\":\"v-8daa1a0e#占个位\",\"4\":\"v-8daa1a0e#star-趋势\",\"5\":\"v-184f4da6\",\"6\":\"v-2e3eac9e\",\"7\":\"v-4bc4557f\",\"8\":\"v-4bc4557f#三分钟搭建一个博客网站\",\"9\":\"v-4bc4557f#准备运行环境\",\"10\":\"v-4bc4557f#创建项目模板\",\"11\":\"v-4bc4557f#创建过程\",\"12\":\"v-4bc4557f#访问\",\"13\":\"v-4bc4557f#效果\",\"14\":\"v-4bc4557f#项目启动命令\",\"15\":\"v-4bc4557f#发布到github\",\"16\":\"v-4bc4557f#修改deploy-docs-yml\",\"17\":\"v-4bc4557f#修改config-ts\",\"18\":\"v-4bc4557f#共享项目到github\",\"19\":\"v-4bc4557f#从master新建分支gh-pages-推送新分支到github\",\"20\":\"v-4bc4557f#github上开源\",\"21\":\"v-4bc4557f#配置github-pages\",\"22\":\"v-4bc4557f#更新博客只在master分支上改-不要动gh-pages分支\",\"23\":\"v-4bc4557f#修复-编辑此页-功能链接跳转不对问题\",\"24\":\"v-4bc4557f#踩坑\",\"25\":\"v-4bc4557f@0\",\"26\":\"v-4bc4557f@1\",\"27\":\"v-20738152\",\"28\":\"v-20738152#java-中-io-流分为几种\",\"29\":\"v-20738152#既然有了字节流-为什么还要有字符流\",\"30\":\"v-20738152#bio、nio、aio\",\"31\":\"v-fc32ae94\",\"32\":\"v-fc32ae94#jdk1-8都有哪些新特性\",\"33\":\"v-fc32ae94#lambda-表达式了解多少\",\"34\":\"v-fc32ae94#java8有哪些内置函数式接口\",\"35\":\"v-fc32ae94#optional了解吗\",\"36\":\"v-fc32ae94#stream-流用过吗\",\"37\":\"v-1cf004e2\",\"38\":\"v-1cf004e2#java语言有哪些特点\",\"39\":\"v-1cf004e2#jvm、jdk-和-jre-有什么区别\",\"40\":\"v-1cf004e2#说说什么是跨平台性-原理是什么\",\"41\":\"v-1cf004e2#什么是字节码-采用字节码的好处是什么\",\"42\":\"v-1cf004e2#为什么说-java-语言-编译与解释并存\",\"43\":\"v-5982fa10\",\"44\":\"v-5982fa10#说下什么是java的spi机制\",\"45\":\"v-70c64af0\",\"46\":\"v-70c64af0#什么是反射\",\"47\":\"v-70c64af0#反射的应用场景\",\"48\":\"v-70c64af0#反射的实现原理\",\"49\":\"v-1e829856\",\"50\":\"v-1e829856#java有哪些数据类型\",\"51\":\"v-1e829856#什么是自动类型转换、强制类型转换\",\"52\":\"v-1e829856#什么是自动拆箱-封箱\",\"53\":\"v-1e829856#和-有什么区别\",\"54\":\"v-1e829856#switch-是否能作用在-byte-long-string上\",\"55\":\"v-1e829856#break-continue-return-的区别及作用\",\"56\":\"v-1e829856#用最有效率的方法计算2乘以8\",\"57\":\"v-1e829856#说说自增自减运算\",\"58\":\"v-63c28b90\",\"59\":\"v-63c28b90#string-是-java-基本数据类型吗-可以被继承吗\",\"60\":\"v-63c28b90#string和stringbuilder、stringbuffer\",\"61\":\"v-63c28b90#string-str1-new-string-abc-和string-str2-abc-和-区别\",\"62\":\"v-63c28b90#string不是不可变类吗-字符串拼接是如何实现的\",\"63\":\"v-63c28b90#intern方法有什么作用\",\"64\":\"v-63c28b90#integer-a-127-integer-b-127-integer-c-128-integer-d-128-相等吗\",\"65\":\"v-63c28b90#string怎么转成integer的-原理\",\"66\":\"v-63c28b90#object-类的常见方法\",\"67\":\"v-a668a33c\",\"68\":\"v-a668a33c#什么是序列化-什么是反序列化\",\"69\":\"v-a668a33c#说说有哪些常见的序列化方式\",\"70\":\"v-09de2f71\",\"71\":\"v-09de2f71#java-中异常层级结构\",\"72\":\"v-09de2f71#异常的处理机制\",\"73\":\"v-09de2f71#finally一定会执行吗\",\"74\":\"v-09de2f71#三道经典异常处理代码题\",\"75\":\"v-1ed0dc53\",\"76\":\"v-1ed0dc53#什么是泛型\",\"77\":\"v-1ed0dc53#泛型的使用方法\",\"78\":\"v-1ed0dc53#泛型常用的通配符有哪些\",\"79\":\"v-1ed0dc53#什么是泛型擦除\",\"80\":\"v-08ef6fc0\",\"81\":\"v-08ef6fc0#说一下你对注解的理解\",\"82\":\"v-f52152e0\",\"83\":\"v-f52152e0#java中实现map接口的有哪些类\",\"84\":\"v-f52152e0#遍历hashmap的几种方法\",\"85\":\"v-95dc3ca2\",\"86\":\"v-95dc3ca2#面向对象和面向过程的区别\",\"87\":\"v-95dc3ca2#面向对象有哪些特性\",\"88\":\"v-95dc3ca2#重载-overload-和重写-override-的区别\",\"89\":\"v-95dc3ca2#访问修饰符public、private、protected、以及不写-默认-时的-区别\",\"90\":\"v-95dc3ca2#this关键字有什么作用\",\"91\":\"v-95dc3ca2#抽象类-abstract-class-和接口-interface-有什么区别\",\"92\":\"v-95dc3ca2#成员变量与局部变量的区别有哪些\",\"93\":\"v-95dc3ca2#静态变量和实例变量的区别-静态方法、实例方法呢\",\"94\":\"v-95dc3ca2#final关键字有什么作用\",\"95\":\"v-95dc3ca2#final、finally、finalize的区别\",\"96\":\"v-95dc3ca2#和-equals-的区别\",\"97\":\"v-95dc3ca2#hashcode与-equals\",\"98\":\"v-95dc3ca2#java是值传递-还是引用传递\",\"99\":\"v-95dc3ca2#什么是深拷贝和浅拷贝\",\"100\":\"v-95dc3ca2#java-创建对象有哪几种方式\",\"101\":\"v-b1bf17b8\",\"102\":\"v-b1bf17b8#threadlocal是什么\",\"103\":\"v-b1bf17b8#你在工作中用到过threadlocal吗\",\"104\":\"v-b1bf17b8#threadlocal怎么实现的呢\",\"105\":\"v-b1bf17b8#threadlocal-内存泄露是怎么回事\",\"106\":\"v-b1bf17b8#那怎么解决内存泄漏问题呢\",\"107\":\"v-b1bf17b8#为什么key还要设计成弱引用\",\"108\":\"v-b1bf17b8#threadlocalmap的结构了解吗\",\"109\":\"v-b1bf17b8#threadlocalmap怎么解决hash冲突的\",\"110\":\"v-b1bf17b8#threadlocalmap扩容机制了解吗\",\"111\":\"v-b1bf17b8#父子线程怎么共享数据\",\"112\":\"v-b1bf17b8#inheritablethreadlocal原理是什么呢\",\"113\":\"v-b1bf17b8#还有什么其它办法-ttl\",\"114\":\"v-758586f5\",\"115\":\"v-758586f5#并行跟并发有什么区别\",\"116\":\"v-758586f5#说说什么是进程和线程\",\"117\":\"v-758586f5#说说线程有几种创建方式\",\"118\":\"v-758586f5#为什么调用start-方法时会执行run-方法-那怎么不直接调用run-方法\",\"119\":\"v-758586f5#thread和runnable有什么区别\",\"120\":\"v-758586f5#线程有哪些常用的调度方法\",\"121\":\"v-758586f5#线程有几种状态\",\"122\":\"v-758586f5#blocked和waiting有什么区别\",\"123\":\"v-758586f5#waiting和terminated有什么区别\",\"124\":\"v-758586f5#什么是线程上下文切换\",\"125\":\"v-758586f5#线程上下文切换通常发生在以下几种情况下\",\"126\":\"v-758586f5#守护线程了解吗\",\"127\":\"v-758586f5#线程间有哪些通信方式\",\"128\":\"v-2fb9c1b2\",\"129\":\"v-2fb9c1b2#arraylist和linkedlist有什么区别\",\"130\":\"v-2fb9c1b2#arraylist的扩容机制了解吗\",\"131\":\"v-2fb9c1b2#arraylist怎么序列化的知道吗-为什么用transient修饰数组\",\"132\":\"v-2fb9c1b2#为什么最arraylist不直接序列化元素数组呢\",\"133\":\"v-2fb9c1b2#那arraylist怎么序列化呢\",\"134\":\"v-2fb9c1b2#快速失败-fail-fast-和安全失败-fail-safe-了解吗\",\"135\":\"v-2fb9c1b2#实现arraylist线程安全有哪几种方法\",\"136\":\"v-2fb9c1b2#copyonwritearraylist了解多少\",\"137\":\"v-2fb9c1b2#数据拷贝的过程中-有其它线程写入数据怎么办\",\"138\":\"v-ae523934\",\"139\":\"v-ae523934#能说一下hashmap的数据结构吗\",\"140\":\"v-ae523934#你对红黑树了解多少-为什么不用二叉树-平衡树呢\",\"141\":\"v-ae523934#什么是红黑树\",\"142\":\"v-ae523934#为什么不用二叉树\",\"143\":\"v-ae523934#为什么不用平衡二叉树\",\"144\":\"v-ae523934#红黑树怎么保持平衡的知道吗\",\"145\":\"v-ae523934#hashmap的put流程知道吗\",\"146\":\"v-ae523934#hashmap怎么查找元素的呢\",\"147\":\"v-ae523934#hashmap的哈希-扰动函数是怎么设计的\",\"148\":\"v-ae523934#为什么哈希-扰动函数能降hash碰撞\",\"149\":\"v-ae523934#为什么hashmap的容量是2的倍数呢\",\"150\":\"v-ae523934#如果初始化hashmap-传一个17的值-new-hashmap-它会怎么处理\",\"151\":\"v-ae523934#你还知道哪些哈希函数的构造方法呢\",\"152\":\"v-ae523934#解决哈希冲突有哪些方法呢\",\"153\":\"v-ae523934#为什么hashmap链表转红黑树的阈值为8呢\",\"154\":\"v-ae523934#扩容在什么时候呢-为什么扩容因子是0-75\",\"155\":\"v-ae523934#那么为什么选择了0-75作为hashmap的默认加载因子呢\",\"156\":\"v-ae523934#hashmap扩容机制了解吗\",\"157\":\"v-ae523934#jdk1-8对hashmap主要做了哪些优化呢-为什么\",\"158\":\"v-ae523934#你能自己设计实现一个hashmap吗\",\"159\":\"v-ae523934#hashmap-是线程安全的吗-多线程下会有什么问题\",\"160\":\"v-ae523934#有什么办法能解决hashmap线程不安全的问题呢\",\"161\":\"v-ae523934#能说一下concurrenthashmap的具体实现吗\",\"162\":\"v-ae523934#jdk1-7-分段锁\",\"163\":\"v-ae523934#jdk1-8-cas-synchronized\",\"164\":\"v-ae523934#hashmap-内部节点是有序的吗\",\"165\":\"v-ae523934#讲讲-linkedhashmap-怎么实现有序的\",\"166\":\"v-ae523934#讲讲-treemap-怎么实现有序的\",\"167\":\"v-1aeb7fc0\",\"168\":\"v-1aeb7fc0#讲讲hashset的底层实现\",\"169\":\"v-03c57507\",\"170\":\"v-03c57507#说说有哪些常见集合\",\"171\":\"v-e1e3da16\",\"172\":\"v-aefb69fe\",\"173\":\"v-1303aad4\",\"174\":\"v-152c160c\",\"175\":\"v-5911796e\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1],\"1\":[1,6],\"2\":[1,1],\"3\":[1,1],\"4\":[2,1],\"5\":[1],\"6\":[1],\"7\":[1],\"8\":[1,6],\"9\":[1,4],\"10\":[1,8],\"11\":[1,154],\"12\":[1,4],\"13\":[1],\"14\":[1,7],\"15\":[1],\"16\":[4,6],\"17\":[3,23],\"18\":[1],\"19\":[3],\"20\":[1,8],\"21\":[2,12],\"22\":[3,8],\"23\":[3,7],\"24\":[1,2],\"25\":[null,null,1],\"26\":[null,null,1],\"27\":[1],\"28\":[5,22],\"29\":[3,22],\"30\":[4,55],\"31\":[2],\"32\":[3,45],\"33\":[3,7],\"34\":[2,10],\"35\":[2,38],\"36\":[3,105],\"37\":[1],\"38\":[2,7],\"39\":[6,44],\"40\":[3,5],\"41\":[3,15],\"42\":[5,12],\"43\":[1],\"44\":[2,85],\"45\":[1],\"46\":[2,15],\"47\":[2,8],\"48\":[1,11],\"49\":[1],\"50\":[2,53],\"51\":[3,5],\"52\":[3,4],\"53\":[3,3],\"54\":[6,24],\"55\":[5,15],\"56\":[2,6],\"57\":[2,12],\"58\":[1],\"59\":[6,30],\"60\":[3,56],\"61\":[10,20],\"62\":[3,13],\"63\":[2,8],\"64\":[11,33],\"65\":[3,10],\"66\":[3,21],\"67\":[1],\"68\":[3,53],\"69\":[2,43],\"70\":[1],\"71\":[3,14],\"72\":[2,7],\"73\":[2,15],\"74\":[1,65],\"75\":[1],\"76\":[2,7],\"77\":[2,15],\"78\":[2,19],\"79\":[2,12],\"80\":[1],\"81\":[2,56],\"82\":[1],\"83\":[2,16],\"84\":[2,7],\"85\":[1],\"86\":[2,13],\"87\":[2,21],\"88\":[6,23],\"89\":[8,19],\"90\":[2,7],\"91\":[7,42],\"92\":[2,41],\"93\":[4,29],\"94\":[2,6],\"95\":[4,42],\"96\":[4,10],\"97\":[3,32],\"98\":[3,14],\"99\":[2,24],\"100\":[3,6],\"101\":[1],\"102\":[2,29],\"103\":[2,2],\"104\":[2,14],\"105\":[3,20],\"106\":[2,3],\"107\":[2,9],\"108\":[2,43],\"109\":[2,26],\"110\":[2,82],\"111\":[2,33],\"112\":[2,48],\"113\":[3,12],\"114\":[1],\"115\":[2,10],\"116\":[2,10],\"117\":[2,12],\"118\":[5,10],\"119\":[2,25],\"120\":[2,97],\"121\":[2,31],\"122\":[2,11],\"123\":[2,7],\"124\":[2,16],\"125\":[1,15],\"126\":[2,22],\"127\":[2,56],\"128\":[1],\"129\":[2,51],\"130\":[2,41],\"131\":[3,7],\"132\":[2,6],\"133\":[2,7],\"134\":[7,68],\"135\":[2,25],\"136\":[2,37],\"137\":[3,3],\"138\":[1],\"139\":[2,32],\"140\":[4],\"141\":[2,17],\"142\":[2,11],\"143\":[2,8],\"144\":[2,6],\"145\":[2,71],\"146\":[2,51],\"147\":[3,12],\"148\":[3,8],\"149\":[2,26],\"150\":[6,7],\"151\":[2,20],\"152\":[2,23],\"153\":[2,21],\"154\":[4,6],\"155\":[3,17],\"156\":[2,9],\"157\":[4,43],\"158\":[2,7],\"159\":[4,26],\"160\":[2,19],\"161\":[2,6],\"162\":[3,30],\"163\":[3,109],\"164\":[3,13],\"165\":[4,8],\"166\":[4,13],\"167\":[1],\"168\":[2,47],\"169\":[1],\"170\":[2,3],\"171\":[1],\"172\":[1],\"173\":[1],\"174\":[1],\"175\":[1]},\"averageFieldLength\":[2.420681818181819,22.061574470206995,0.07407407407407407],\"storedFields\":{\"0\":{\"h\":\"鱼塘\"},\"1\":{\"h\":\"关于网站\",\"t\":[\"欢迎来到鱼塘\",\"传送门：GitHub | Gitee。\",\"项目介绍\"]},\"2\":{\"h\":\"关于作者\",\"t\":[\"关于作者\"]},\"3\":{\"h\":\"占个位\",\"t\":[\"占个位\"]},\"4\":{\"h\":\"Star 趋势\",\"t\":[\"Stars\"]},\"5\":{\"h\":\"主页\"},\"6\":{\"h\":\"幻灯片页\"},\"7\":{\"h\":\"三分钟搭建一个博客网站\"},\"8\":{\"h\":\"三分钟搭建一个博客网站\",\"t\":[\"基于vuepress-theme-hope 和 github pages搭建\"]},\"9\":{\"h\":\"准备运行环境\",\"t\":[\"安装nodejs 下载地址\",\"安装pnpm 参考资料\"]},\"10\":{\"h\":\"创建项目模板\",\"t\":[\"pnpm create vuepress-theme-hope my-docs \"]},\"11\":{\"h\":\"创建过程\",\"t\":[\"PowerShell 7.4.0 PS C:\\\\Users\\\\daiwencheng\\\\Documents\\\\BaiduSyncdisk\\\\ob\\\\ob\\\\blogs> pnpm create vuepress-theme-hope my-docs .../Local/pnpm/store/v3/tmp/dlx-7428 | +83 ++++++++ .../Local/pnpm/store/v3/tmp/dlx-7428 | Progress: resolved 83, reused 61, downloaded 22, added 83, done ? Select a language to display / 选择显示语言 简体中文 ? 选择包管理器 pnpm 生成 package.json... ? 设置应用名称 vuepress-theme-hope-template ? 设置应用版本号 2.0.0 ? 设置应用描述 A project of vuepress-theme-hope ? 设置协议 MIT ? 项目需要用到多语言么? No ? 是否需要一个自动部署文档到 GitHub Pages 的工作流？ Yes ? 你想要创建什么类型的项目？ blog 生成模板... ? 是否初始化 Git 仓库? Yes 安装依赖... 这可能需要数分钟，请耐心等待. 我们无法正确输出子进程的进度条，所以进程可能会看似未响应 WARN 2 deprecated subdependencies found: rollup-plugin-terser@7.0.2, sourcemap-codec@1.4.8 Packages: +606 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ Progress: resolved 639, reused 409, downloaded 197, added 606, done node_modules/.pnpm/esbuild@0.19.8/node_modules/esbuild: Running postinstall script, done in 825ms devDependencies: + @vuepress/client 2.0.0-rc.0 + vue 3.3.10 + vuepress 2.0.0-rc.0 + vuepress-theme-hope 2.0.0-rc.2 The dependency was already listed in devDependencies. If you want to make it a prod dependency, then move it manually. Done in 25.3s 模板已成功生成! ? 是否想要现在启动 Demo 查看? Yes 启动开发服务器... 启动成功后，请在浏览器输入给出的开发服务器地址(默认为 'localhost:8080') > vuepress-theme-hope-template@2.0.0 docs:dev C:\\\\Users\\\\daiwencheng\\\\Documents\\\\BaiduSyncdisk\\\\ob\\\\ob\\\\blogs\\\\my-docs > vuepress dev src vite v5.0.6 dev server running at: ➜ Local: http://localhost:8080/ ➜ Network: http://10.246.84.128:8080/ \"]},\"12\":{\"h\":\"访问\",\"t\":[\"打开http://localhost:8080/ 访问\"]},\"13\":{\"h\":\"效果\"},\"14\":{\"h\":\"项目启动命令\",\"t\":[\"需要先进入项目目录 my-docs\",\"npm run docs:dev \"]},\"15\":{\"h\":\"发布到github\"},\"16\":{\"h\":\"修改 deploy-docs.yml\",\"t\":[\"on: push: branches: # 确保这是你正在使用的分支名称 - master \"]},\"17\":{\"h\":\"修改 config.ts\",\"t\":[\"export default defineUserConfig({ base: \\\"/my-docs/\\\", lang: \\\"zh-CN\\\", title: \\\"博客演示\\\", description: \\\"vuepress-theme-hope 的博客演示\\\", theme, // Enable it with pwa // shouldPrefetch: false, }); \"]},\"18\":{\"h\":\"共享项目到GitHub\"},\"19\":{\"h\":\"从master新建分支gh-pages,推送新分支到github\"},\"20\":{\"h\":\"GitHub上开源\",\"t\":[\"打开仓库my-docs\",\"打开Settings\",\"底部设置Change visibility 为change to public\"]},\"21\":{\"h\":\"配置Github Pages\",\"t\":[\"打开仓库my-docs的Settings项,选中侧边栏pages,配置部署分支为gh-pages,点击save.\",\"在actions菜单栏中应该会触发自动发布,没有的话随便修改下master分支代码,就会触发自动发布\",\"发布完成后,此时pages页会显示访问域名,点击访问即可\"]},\"22\":{\"h\":\"更新博客只在master分支上改,不要动gh-pages分支\",\"t\":[\"master 是源码分支 gh-pages是发布分支 master的代码都是ts和一些markdown文件,需要build成html文件和js才行,即gh-pages\"]},\"23\":{\"h\":\"修复\\\"编辑此页\\\"功能链接跳转不对问题\",\"t\":[\"修改theme.ts\",\"docsBranch: 文档所在分支,默认值: \\\"main\\\"\"]},\"24\":{\"h\":\"踩坑\",\"t\":[\"踩了一些坑,可以看提交记录\"]},\"25\":{\"c\":[\"前端\"]},\"26\":{\"c\":[\"JavaScript\"]},\"27\":{\"h\":\"IO\"},\"28\":{\"h\":\"Java 中 IO 流分为几种?\",\"t\":[\"按照流的流向分，可以分为 输入流 和 输出流 \",\"InputStream / Reader : 所有的输入流的基类，前者是字节输入流，后者是字符输入流\",\"OutputStream / Writer : 所有输出流的基类，前者是字节输出流，后者是字符输出流\",\"按照操作单元划分，可以划分为 字节流 和 字符流\",\"按照流的角色划分为 节点流 和 处理流\"]},\"29\":{\"h\":\"既然有了字节流,为什么还要有字符流？\",\"t\":[\"字节流\",\"字节流则更适合处理二进制数据\",\"字节流以字节为单位进行输入输出，适用于处理二进制数据（例如图像、音频、视频等）或与底层设备进行通信时。字节流通常用于处理文件和网络连接中的数据传输。它们是处理数据的底层工具，提供了最基本的输入输出操作。\",\"字符流\",\"字符流更适合读取和写入文本文件\",\"字符流以字符为单位进行输入输出，适用于处理文本数据。字符流会自动处理字符编码和解码，而字节流则需要手动处理。这使得字符流在处理文本数据时更方便和高效，尤其是当涉及到国际化和本地化时、\",\"尽管字节流可以处理所有类型的数据，但为了更方便地处理文本数据，Java提供了字符流\"]},\"30\":{\"h\":\"BIO、NIO、AIO？\",\"t\":[\"BIO\",\"同步阻塞IO\",\"客户端有连接请求时服务器端就需要启动一个线程进行处理（可以使用连接池优化）\",\"JDK1.4之前的选择\",\"NIO\",\"同步非阻塞IO\",\"服务器端用一个线程处理多个连接，客户端发送的连接请求会注册到多路复用器上，多路复用器轮询到连接有IO请求就进行处理\",\"NIO工作原理\",\"应用程序（A）通过选择器（B）发起连接请求\",\"选择器（B）将通道（channel代表了服务端与客户端的连接）注册，使其成为监视对象，以便选择器可以监听多个通道的事件。\",\"当有新的连接请求到达时，选择器（B）会处理这个事件，并将新的通道（C）加入到已注册的通道列表（D）中，以备后续操作。\",\"选择器（B）不断监听通道列表（D）中通道的读写事件。\",\"当某个通道（E）有读或写事件时，选择器（B）会将该通道标记为就绪状态，并执行相应的读取或写入操作。\",\"读取或写入操作使用缓冲区（F）来处理数据，应用程序可以在缓冲区中读取或写入数据。\",\"AIO\",\"异步非阻塞IO\",\"Java 的 NIO 就是 Reactor\",\"当有事件触发时，服务器端得到通知，进行相应的处理，完成后才通知(回调)服务端程序启动线程去处理\",\"一般适用于连接数较多且连接时间较长的应用\"]},\"31\":{\"h\":\"JDK1.8新特性\"},\"32\":{\"h\":\"JDK1.8都有哪些新特性？\",\"t\":[\"接口的默认方法和静态方法 \",\"在Java 8中，接口可以包含默认方法和静态方法\",\"Lambda 表达式和函数式接口 \",\"Lambda 表达式本质上是一段匿名内部类，可以传递一段代码\",\"Lambda 允许把函数作为一个方法的参数（函数作为参数传递到方法中），使用 Lambda 表达式使代码更加简洁\",\"但是也不要滥用，否则会有可读性等问题\",\"《Effective Java》作者 Josh Bloch 建议使用 Lambda 表达式最好不要超过3行\",\"Stream API \",\"Stream API提供了一种更简洁、更易于并行处理数据集合的方式\",\"通过Stream API，我们可以对集合进行过滤、映射、排序、聚合等操作，提高了代码的可读性和简洁性\",\"新的日期和时间API \",\"Java 8引入了新的日期和时间API（java.time包），提供了更好的日期和时间处理方式\",\"新的API解决了旧的Date和Calendar类在处理日期和时间时的一些问题，并提供了更多的功能和灵活性\",\"Optional 类 \",\"Optional类是一个容器类，用于表示一个值可能存在或不存在\",\"通过Optional类，我们可以避免空指针异常，并更好地处理可能为空的值\"]},\"33\":{\"h\":\"Lambda 表达式了解多少？\",\"t\":[\"Lambda 表达式本质上是一段匿名内部类，也可以是一段可以传递的代码\",\"只有函数式接口（FunctionalInterface）才能缩写成 Lambda 表示式\"]},\"34\":{\"h\":\"Java8有哪些内置函数式接口？\",\"t\":[\"添加了 @FunctionalInterface 注解的接口 \",\"Comparator\",\"Runnable\",\"Callable\",\"Predicate\",\"Function\",\"Supplier\",\"Consumer\"]},\"35\":{\"h\":\"Optional了解吗？\",\"t\":[\"Optional 是用于防范 NullPointerException\",\"可以将 Optional 看做是包装对象（可能是 null , 也有可能非 null ）的容器\",\"当我们定义了 一个方法，这个方法返回的对象可能是空，也有可能非空的时候，我们就可以考虑用 Optional 来包装它，这也是在 Java 8 被推荐使用的做法\",\"Optional<String> optional = Optional.of(\\\"bam\\\"); optional.isPresent(); // true optional.get(); // \\\"bam\\\" optional.orElse(\\\"fallback\\\"); // \\\"bam\\\" optional.ifPresent((s) -> System.out.println(s.charAt(0))); \"]},\"36\":{\"h\":\"Stream 流用过吗？\",\"t\":[\"Stream 流，简单来说，使用 java.util.Stream 对一个包含一个或多个元素的集合做各种操作\",\"这些操作可能是 中间操作 亦或是 终端操作\",\"终端操作会返回一个结果，而中间操作会返回一个 Stream 流\",\"Stream流一般用于集合，Stream的常用操作有\",\" List<String> stringCollection = new ArrayList<>(); stringCollection.add(\\\"ddd2\\\"); stringCollection.add(\\\"aaa2\\\"); stringCollection.add(\\\"bbb1\\\"); stringCollection.add(\\\"aaa1\\\"); stringCollection.add(\\\"bbb3\\\"); stringCollection.add(\\\"ccc\\\"); stringCollection.add(\\\"bbb2\\\"); stringCollection.add(\\\"ddd1\\\"); \",\"Filter 过滤\",\"stringCollection .stream() .filter((s) -> s.startsWith(\\\"a\\\")) .forEach(System.out::println); \",\"Sorted 排序\",\" stringCollection .stream() .sorted() .filter((s) -> s.startsWith(\\\"a\\\")) .forEach(System.out::println); \",\"Map 转换\",\" stringCollection .stream() .map(String::toUpperCase) .sorted((a, b) -> b.compareTo(a)) .forEach(System.out::println); \",\"Match 匹配\",\"// 验证 list 中 string 是否有以 a 开头的, 匹配到第一个，即返回 true boolean anyStartsWithA = stringCollection .stream() .anyMatch((s) -> s.startsWith(\\\"a\\\")) boolean allStartsWithA = stringCollection .stream() .allMatch((s) -> s.startsWith(\\\"a\\\")); System.out.println(allStartsWithA); // false // 验证 list 中 string 是否都不是以 z 开头的, boolean noneStartsWithZ = stringCollection .stream() .noneMatch((s) -> s.startsWith(\\\"z\\\")) \",\"Count 计数\",\"// 先对 list 中字符串开头为 b 进行过滤，让后统计数量 long startsWithB = stringCollection .stream() .filter((s) -> s.startsWith(\\\"b\\\")) .count(); \",\"count 是一个终端操作，它能够统计 stream 流中的元素总数，返回值是 long类型\",\"Reduce归约\",\"Optional<String> reduced = stringCollection .stream() .sorted() .reduce((s1, s2) -> s1 + \\\"#\\\" + s2); \",\"Reduce 中文翻译为：减少、缩小。通过入参的 Function ，我们能够将 list归约成一个值。它的返回类型是 Optional 类型\",\"Stream的常用API\"]},\"37\":{\"h\":\"Java概述\"},\"38\":{\"h\":\"Java语言有哪些特点？\",\"t\":[\"面向对象 \",\"封装\",\"继承\",\"多态\",\"平台无关性\",\"支持多线程\",\"编译与解释并存\"]},\"39\":{\"h\":\"JVM、JDK 和 JRE 有什么区别？\",\"t\":[\"JVM\",\"Java Virtual Machine，Java虚拟机，Java程序运行在Java虚拟机上。针对不同 系统的实现（Windows，Linux，macOS）不同的JVM，因此Java语言可以实现跨平 台。\",\"JRE\",\"Java 运⾏时环境。它是运⾏已编译 Java 程序所需的所有内容的集合，包括Java 虚拟机（JVM），Java 类库，Java 命令和其他的⼀些基础构件。但是，它不能⽤于创建新程序。\",\"JDK\",\"Java Development Kit，它是功能⻬全的 Java SDK。它拥有 JRE 所拥有的⼀ 切，还有编译器（javac）和⼯具（如 javadoc 和 jdb）。它能够创建和编译程序。 简单来说，JDK包含JRE，JRE包含JVM。\"]},\"40\":{\"h\":\"说说什么是跨平台性？原理是什么?\",\"t\":[\"跨平台：一次编译，多操作系统运行\",\"实现原理：不同系统安装不同Java虚拟机\"]},\"41\":{\"h\":\"什么是字节码？采用字节码的好处是什么?\",\"t\":[\".class文件\",\"字节码能够被虚拟机识别，从而实现Java程序的跨平台性\",\"Java 程序从源代码到运行主要有三步 \",\"编译：.java ->.class\",\"解释：虚拟机执行Java字节码，.class -机器码\",\"执行 ：对应的操作系统执行二进制机器码\"]},\"42\":{\"h\":\"为什么说 Java 语言“编译与解释并存”？\",\"t\":[\"因为 Java 程序要经过先编译，后解释两个步骤 \",\"由 Java 编写的程序需要先经过编译步骤，生成字节码（ *.class 文件）\",\"这种字节码必须再经过JVM，解释成操作系统能识别的机器码，再由操作系统执行\"]},\"43\":{\"h\":\"其它\"},\"44\":{\"h\":\"说下什么是Java的SPI机制？\",\"t\":[\"Java的SPI（Service Provider Interface）机制是Java标准库提供的一种服务发现机制\",\"它允许第三方组件在不修改源代码的情况下，通过在Classpath中提供配置文件，向应用程序注入实现了特定接口的服务提供者\",\"SPI中的几个关键元素\",\"服务接口（Service Interface）： 定义了服务的契约，描述了服务提供者需要实现的接口或抽象类\",\"服务提供者（Service Provider）： 实现了服务接口的具体类，并通过配置文件等方式注册到SPI框架中\",\"服务提供者配置文件（Service Provider Configuration File）： 是一种元数据文件，通常位于META-INF/services/目录下，文件名为服务接口的全限定名。该文件包含了服务接口的实现类的全限定名，每个实现类占据一行\",\"服务加载器（Service Loader）： 是用于加载和实例化服务提供者的API。它在运行时查找并加载META-INF/services/目录下的配置文件，并根据配置文件中指定的实现类实例化相应的对象\",\"SPI机制的工作原理如下\",\"定义服务接口\",\"首先，应用程序定义一个接口，这个接口是服务的契约，规定了需要提供的功能或扩展点\",\"public interface HelloService { void sayHello(); } \",\"编写服务提供者\",\"接着，编写服务提供者，实现服务接口，并提供了具体的功能实现\",\"public class HelloServiceImpl implements HelloService { @Override public void sayHello() { System.out.println(\\\"Hello from HelloServiceImpl!\\\"); } } \",\"编写服务提供者配置文件\",\"每个服务提供者将自己的实现类配置到一个特定的配置文件中，该文件位于 META-INF/services/ 目录下，以接口的全限定名命名\",\"com.example.service.HelloServiceImpl com.example.service.HelloServiceImpl2 \",\"服务加载\",\"在应用程序运行时，Java的SPI机制会使用服务加载器加载这些配置文件，并根据文件中指定的实现类，实例化对应的服务提供者对象\",\"ServiceLoader<HelloService> loader =ServiceLoader.load(HelloService.class) \",\"服务使用\",\"ServiceLoader<HelloService> loader =ServiceLoader.load(HelloService.class) for (HelloService service : loader) { service.sayHello(); } \",\"SPI机制的优势\",\"解耦了服务的实现和调用方\",\"应用程序可以在不修改源代码的情况下，动态地替换、扩展或定制某个功能或组件的实现\",\"SPI机制的应用场景\",\"数据库驱动、日志框架、插件系统等\"]},\"45\":{\"h\":\"反射\"},\"46\":{\"h\":\"什么是反射？\",\"t\":[\"new 对象 \",\"创建对象实例的方式\",\"在编译时候就确定了类型信息\",\"反射 \",\"在运行时动态地获取类信息、创建类实例、调用类方法这时候就要用到反射\",\"通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性\",\"反射相关类 \",\"Class\",\"Method\",\"Field\",\"Constructor\"]},\"47\":{\"h\":\"反射的应用场景？\",\"t\":[\"Spring/Spring Boot、MyBatis 等等框架中都大量使用了反射机制\",\"Spring里的很多注解 ，它真正的功能实现就是利用反射 \",\"@Component\",\"@Value\"]},\"48\":{\"h\":\"反射的实现原理\",\"t\":[\"基于Java虚拟机（JVM）的类加载机制和类对象模型\",\"在Java中，每个类都有一个对应的Class对象，该对象包含了类的名称、字段、方法等信息\",\"通过反射，我们可以获取到Class对象信息，并在运行时动态地操作类和对象\"]},\"49\":{\"h\":\"基础语法\"},\"50\":{\"h\":\"Java有哪些数据类型？\",\"t\":[\"基本数据类型\",\"数值型 \",\"整数类型（byte、short、int、long）\",\"浮点类型（float、double）\",\"字符型（char）\",\"布尔型（boolean）\",\"基本类型\",\"位数\",\"字节\",\"默认值\",\"最小值\",\"最大值\",\"int\",\"32\",\"4\",\"0\",\"-2^31\",\"2^31-1\",\"short\",\"16\",\"2\",\"0\",\"-2^15\",\"2^15-1\",\"long\",\"64\",\"8\",\"0L\",\"-2^63\",\"2^63-1\",\"byte\",\"8\",\"1\",\"0\",\"-128\",\"127\",\"char\",\"16\",\"2\",\"'\\\\u0000'\",\"'\\\\u0000'\",\"'\\\\uffff'\",\"float\",\"32\",\"4\",\"0.0f\",\"1.4E-45\",\"3.4028235E38\",\"double\",\"64\",\"8\",\"0.0d\",\"4.9E-324\",\"1.7976931348623157E308\",\"boolean\",\"1\",\"false\",\"引用数据类型\",\"类（class）\",\"接口（interface）\",\"数组([])\"]},\"51\":{\"h\":\"什么是自动类型转换、强制类型转换？\",\"t\":[\"自动类型转换：把一个表数范围小的数值或变量直接赋给另一个数范围大的变量时\",\"强制类型转换：反之，需要强制转换\"]},\"52\":{\"h\":\"什么是自动拆箱/封箱？\",\"t\":[\"装箱 ：将基本类型用它们对应的引用类型包装起来\",\"拆箱 ：将包装类型转换为基本数据类型\"]},\"53\":{\"h\":\"&和&&有什么区别？\",\"t\":[\"&：短路与\",\"&&：逻辑与\"]},\"54\":{\"h\":\"switch 是否能作用在 byte/long/String上？\",\"t\":[\"Java5 以前 switch(expr)中，expr 只能是 byte、short、char、int\",\"从 Java 5 开始，Java 中引入了枚举类型， expr 也可以是 enum 类型\",\"从 Java 7 开始，expr还可以是字符串(String)，但是长整型(long)在目前所有的版本中都是不可以的\"]},\"55\":{\"h\":\"break ,continue ,return 的区别及作用？\",\"t\":[\"break 跳出整个循环，不再执行循环( 结束当前的循环体 )\",\"continue 跳出本次循环，继续执行下次循环( 结束正在执行的循环 进入下一个循环条件 )\",\"return 程序返回，不再执行下面的代码( 结束当前的方法 直接返回 )\"]},\"56\":{\"h\":\"用最有效率的方法计算2乘以8？\",\"t\":[\"2 << 3。位运算，数字的二进制位左移三位相当于乘以2的三次方。\"]},\"57\":{\"h\":\"说说自增自减运算？\",\"t\":[\"++和--运算符可以放在变量之前，也可以放在变量之后\",\"运算符放在变量之前时(前缀)，先自增/减，再赋值\",\"当运算符放在变量之后时(后缀)，先赋值，再自增/减\"]},\"58\":{\"h\":\"常用类\"},\"59\":{\"h\":\"String 是 Java 基本数据类型吗？可以被继承吗？\",\"t\":[\"String是Java基本数据类型吗？\",\"不是，引用数据类型\",\"String 类可以继承吗?\",\"不行。String类在Java中被声明为final类，这意味着它不能被继承\",\"这样设计的原因\",\"字符串的不可变性\",\"String类的不可变性使得它可以被安全地用于多线程环境下，不会出现线程安全问题\",\"任何对 String 对象的操作（如拼接、替换等）都会返回一个新的 String 对象，而不会修改原始对象的值\",\"字符串常量池的优化\",\"由于字符串是不可变的，Java可以对字符串进行缓存和共享，以提高性能和节省内存\",\"这就是通过字符串常量池来实现的，它存储了所有字符串字面量的唯一实例\",\"安全性和可靠性\",\"String类的不可变性使得它在安全性和可靠性方面更加可靠。例如，它可以被用作Map的键，因为它的哈希值是固定的\"]},\"60\":{\"h\":\"String和StringBuilder、StringBuffer？\",\"t\":[\"类名\",\"可变性\",\"线程安全性\",\"性能\",\"String\",\"不可变\",\"线程安全\",\"低\",\"StringBuffer\",\"可变\",\"线程安全\",\"低\",\"StringBuilder\",\"可变\",\"非线程安全\",\"高\",\"String类 \",\"String是不可变的，使用 private final char value[] 来存储字符串，一旦创建就不能修改其值 \",\"jdk11使用byte[]存储字符串\",\"任何对String的修改都会创建一个新的String对象\",\"String类是线程安全的，因为它的不可变性保证了多个线程可以安全地共享String对象\",\"由于不可变性的特性，对于频繁的字符串拼接操作，会产生大量的临时对象，影响性能\",\"StringBuffer类 \",\"StringBuffer是可变的，使用 char value[] 存储字符串，它的值可以被修改\",\"为了保证线程安全性，StringBuffer的方法都使用synchronized关键字进行同步，在多线程环境下，使用StringBuffer可以保证线程安全\",\"由于同步的开销，StringBuffer的性能相对较低\",\"StringBuilder类 \",\"StringBuilder是StringBuffer的非线程安全版本，它的方法没有使用synchronized关键字进行同步\",\"在单线程环境下，使用StringBuilder可以获得更好的性能\",\"在多线程环境下使用StringBuilder，需要自行保证线程安全\",\"使用建议 \",\"操作的数据量较小，可以使用String类\",\"多线程环境下操作大量的数据，需要保证线程安全，可以使用StringBuffer类\",\"单线程环境下操作大量的数据，可以使用StringBuilder类以，性能更好\"]},\"61\":{\"h\":\"String str1 = new String(\\\"abc\\\")和String str2 = \\\"abc\\\" 和 区别？\",\"t\":[\"对象创建过程 \",\"两个语句都会去字符串常量池中检查是否已经存在 “abc”，如果有则直接使用，如果没有则会在常量池中创建 “abc” 对象\",\"String str1 = new String(\\\"abc\\\") 还会通过 new String() 在堆里创建一个\\\"abc\\\" 字符串对象实例\",\"String s = new String(\\\"abc\\\")创建了几个对象？ \",\"一个或两个 \",\"如果字符串常量池已经有“abc”，则是一个；否则，两个\"]},\"62\":{\"h\":\"String不是不可变类吗？字符串拼接是如何实现的？\",\"t\":[\"String的确是不可变的，“+”的拼接操作，其实是会生成新的对象\",\"在jdk1.8之前，那么会生成多个中间对象 \",\"a和b初始化时位于字符串常量池，a+b拼接后的对象位于堆中。经过拼接新生成了String对象。如果拼接多次，那么会生成多个中间对象\",\"在Java8时JDK对“+”号拼接会编译成StringBuilder的append方法\"]},\"63\":{\"h\":\"intern方法有什么作用？\",\"t\":[\"如果当前字符串内容存在于字符串常量池（即equals()方法为true，也就是内容一样），直接返回字符串常量池中的字符串\",\"否则，将此String对象添加到池中，并返回String对象的引用\"]},\"64\":{\"h\":\"Integer a= 127，Integer b = 127；Integer c= 128，Integer d =128；相等吗?\",\"t\":[\"是a和b相等，c和d不相等 \",\"Integer a= 127这种赋值，是用到了Integer自动装箱的机制。自动装箱的时候会去缓存池里取Integer对象，没有取到才会创建新的对象\",\"如果整型字面量的值在-128到127之间，那么自动装箱时不会new新的Integer对象，而是直接引用缓存池中的Integer对象，超过范围 a1==b1的结果是false\",\"什么是Integer缓存？ \",\"因为根据实践发现大部分的数据操作都集中在值比较小的范围，因此 Integer 搞了个缓存池，默认范围是 -128 到 127，可以根据通过设置 JVM-XX:AutoBoxCacheMax=来修改缓存的最大值，最小值改不了\",\"实现的原理是int 在自动装箱的时候会调用Integer.valueOf，进而用到了IntegerCache\",\"IntegerCache是一个静态内部类， 在静态块中会初始化好缓存值\"]},\"65\":{\"h\":\"String怎么转成Integer的？原理？\",\"t\":[\"方法\",\"Integer.parseInt(String s)\",\"Integer.valueOf(String s)\",\"原理\",\"最终都调用parseInt(String s, int radix) 方法\"]},\"66\":{\"h\":\"Object 类的常见方法?\",\"t\":[\"对象比较 \",\"hashCode()\",\"equals(Object obj)\",\"对象拷贝 \",\"clone()\",\"对象转字符串 \",\"toString()\",\"多线程调度 \",\"wait()\",\"wait(long timeout)\",\"wait(long timeout,int nanos)\",\"notify()\",\"notifyAll()\",\"反射 \",\"getClass()\",\"垃圾回收 \",\"finalize\"]},\"67\":{\"h\":\"序列化\"},\"68\":{\"h\":\"什么是序列化？什么是反序列化？\",\"t\":[\"序列化 \",\"把Java对象转为二进制流，方便存储和传输\",\"反序列化 \",\"把二进制流恢复成对象\",\"Serializable接口有什么用？ \",\"用于标识类可以被序列化\",\"实现Serializable接口的类可以将对象转换为字节流进行传输和存储，实现数据的持久化和 跨平台的数据交换\",\"serialVersionUID 又有什么用 \",\"版本控制 \",\"当一个类被序列化后，如果后续对该类进行了修改，例如添加、删除或修改了类的属性、方法等，那么序列化和反序列化时可能会出现版本不一致的问题。为了避免这种问题，可以在类中显式地定义serialVersionUID字段，并确保在类的修改后，serialVersionUID的值保持不变。当反序列化时，会比较序列化类的版本号和当前类的版本号是否一致，如果不一致，则会抛出InvalidClassException异常\",\"兼容性 \",\"当一个类的实例被序列化后，如果在后续的版本中对该类进行了修改，但是仍然希望能够反序列化之前的序列化数据，那么可以通过显式地指定serialVersionUID来保持兼容性。如果新版本的类和旧版本的类具有相同的serialVersionUID，那么即使类的结构发生了变化，仍然可以成功反序列化之前的序列化数据\",\"Java 序列化不包含静态变量 \",\"Java序列化只会保存对象的非静态成员变量，不包含静态变量\",\"静态变量属于类的状态信息，在序列化时不需要保存\",\"如果有些变量不想序列化，怎么办？ \",\"使用 transient 关键字修饰\",\"transient 关键字的作用 \",\"阻止实例中那些用此关键字修饰的的变量序列化\",\"当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复\",\"transient 只能修饰变量，不能修饰类和方法\"]},\"69\":{\"h\":\"说说有哪些常见的序列化方式？\",\"t\":[\"Java对象流序列化 \",\"Java对象流序列化是Java标准库提供的一种序列化方式\",\"通过实现Serializable接口和Externalizable接口来实现对象的序列化和反序列化\",\"Java序列化可以将对象序列化为字节流，也可以将对象序列化为JSON、XML等格式\",\"JSON序列化 \",\"是一种轻量级的数据交换格式，常用于Web应用中\",\"Java中可以使用第三方库，如Jackson、Gson等，将对象序列化为JSON格式，也可以将JSON格式的数据反序列化为Java对象\",\"XML序列化 \",\"XML（Extensible Markup Language）是一种标记语言，常用于Web应用中\",\"Java中可以使用第三方库，如JAXB、XStream等，将对象序列化为XML格式，也可以将XML格式的数据反序列化为Java对象\",\"Protobuf序列化 \",\"Protobuf（Protocol Buffers）是Google开发的一种高效的序列化协议\",\"可以将结构化的数据序列化为紧凑的二进制格式\",\"Java中可以使用Google提供的protobuf-java库，将对象序列化为Protobuf格式，也可以将Protobuf格式的数据反序列化为Java对象\",\"Hessian序列化 \",\"Hessian是一种基于HTTP的轻量级二进制序列化协议\",\"可以将Java对象序列化为二进制格式，并通过HTTP协议进行传输\",\"Java中可以使用第三方库，如Hessian、Dubbo等，将对象序列化为Hessian格式，也可以将Hessian格式\\n的数据反序列化为Java对象\"]},\"70\":{\"h\":\"异常处理\"},\"71\":{\"h\":\"Java 中异常层级结构?\",\"t\":[\"Throwable \",\"Error \",\"内部错误，是程序无法处理的，比如虚拟机异常\",\"Exception \",\"CheckedException \",\"受检异常：编译器会强制检查并要求处理的异常\",\"RuntimeException \",\"运行时异常：程序运行中出现异常，比如我们熟悉的空指针、数组下标越界等等\",\"Exception\"]},\"72\":{\"h\":\"异常的处理机制？\",\"t\":[\"抛出异常 \",\"throw\",\"throws\",\"系统自动抛异常\",\"捕获异常 \",\"try catch\"]},\"73\":{\"h\":\"finally一定会执行吗？\",\"t\":[\"可能不会执行的情况\",\"程序还没有进入try语句块就因为异常导致程序终止\",\"在try块中调用了System.exit()方法：System.exit()方法会终止Java虚拟机的运行，导致程序直接退出，此时finally块中的代码不会执行\",\"在try块中发生了死循环或无限递归：如果try块中的代码导致了无限循环或无限递归，程序将无法继续执行，finally块中的代码也无法执行\",\"在try块中发生了线程死锁：如果try块中的代码导致了线程死锁，程序将无法继续执行，finally块中的代码也无法执行\"]},\"74\":{\"h\":\"三道经典异常处理代码题\",\"t\":[\"题目1：finally中正常执行（执行顺序：先finally，再catch中return）\",\"public static void main(String[] args) { System.out.println(test()); } public static int test() { try { return 1; } catch (Exception e) { return 2; } finally { System.out.print(\\\"3\\\"); } } \",\"执行结果：31\",\"解析：try、catch。finally 的基础用法，在 return 前会先执行 finally 语句块，所以是先输出 finally 里的 3，再输出 return 的 1\",\"题目2：finally中return（按finally中return的为准）\",\"public static void main(String[] args) { System.out.println(test()); } public static int test() { try { return 2; } finally { return 3; } } \",\"执行结果：3\",\"解析：try 返回前先执行 finally，结果 finally 里不按套路出牌，直接 return 了，自然也就走不到 try 里面的 return 了\",\"题目3：finally中修改try中return的值（修改是无效的）\",\"public static void main(String[] args) { System.out.println(test()); } public static int test() { int i = 0; try { i = 2; return i; } finally { i = 3; } } \",\"执行结果：2\",\"在执行 finally 之前，JVM 会先将 i 的结果暂存起来，然后 finally 执行完毕后，会返回之前暂存的结果，而不是返回 i，所以即使 i 已经被修改为 3，最终返回的还是之前暂存起来的结果 2\"]},\"75\":{\"h\":\"泛型\"},\"76\":{\"h\":\"什么是泛型？\",\"t\":[\"用于在编译时期提供类型安全的参数化类型 \",\"Java泛型是Java 5引入的一个特性\",\"通过使用泛型，可以在编写代码时指定类、接口或方法的参数和返回值的类型，从而增加代码的可读性和安全性\"]},\"77\":{\"h\":\"泛型的使用方法？\",\"t\":[\"泛型类\",\"public class ClassName <T> \",\"泛型接口\",\"public interface InterfaceName <T> \",\"泛型方法\",\"public static <T> ReturnType functionName \",\"public <T> ReturnType functionName(T arg) \"]},\"78\":{\"h\":\"泛型常用的通配符有哪些？\",\"t\":[\"?表示不确定的 java 类型\",\"T(type)表示具体的一个 java 类型\",\"K V (key value) 分别代表 java 键值中的 Key Value\",\"E (element) 代表 Element\"]},\"79\":{\"h\":\"什么是泛型擦除？\",\"t\":[\"泛型主要是为了提供编译时类型检查，而在运行时，泛型信息会被擦除，这就是泛型擦除\",\"优点：提高了代码的运行效率和与旧版本 Java 的兼容性（JDK5之前是没有泛型 ）\",\"缺点：在运行时获取泛型类型信息，以及无法使用基本类型作为泛型参数等\"]},\"80\":{\"h\":\"注解\"},\"81\":{\"h\":\"说一下你对注解的理解？\",\"t\":[\"Java注解本质上是一个标记\",\"注解可以标记在类上、方法上、属性上等，标记自身也可以设置一些值\",\"有了标记之后，我们就可以在编译或者运行阶段去识别这些标记，然后搞一些事情，这就是注解的用处\",\"AOP，使用注解作为切点就是运行期注解的应用\",\"lombok，就是注解在编译期的运行\",\"注解生命周期\",\"RetentionPolicy.SOURCE\",\"给编译器用的，不会写入 class 文件\",\"@Target(ElementType.METHOD) @Retention(RetentionPolicy.SOURCE) public @interface Override { } \",\"RetentionPolicy.CLASS\",\"会写入 class 文件，在类加载阶段丢弃，也就是运行的时候就没这个信息了\",\"没找到 \",\"RetentionPolicy.RUNTIME\",\"会写入 class 文件，永久保存，可以通过反射获取注解信息\",\"@Target({ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.PARAMETER, ElementType.FIELD, ElementType.ANNOTATION_TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface Autowired { /** * Declares whether the annotated dependency is required. * <p>Defaults to {@code true}. */ boolean required() default true; } \"]},\"82\":{\"h\":\"集合基础\"},\"83\":{\"h\":\"Java中实现Map接口的有哪些类？\",\"t\":[\"HashMap：基于哈希表实现的Map，无序，允许键和值为null。\",\"LinkedHashMap：基于哈希表和双向链表实现的Map，保持插入顺序或访问顺序。\",\"TreeMap：基于红黑树实现的有序Map，按照键的自然顺序或自定义顺序进行排序。\",\"Hashtable：基于哈希表实现的Map，线程安全，不允许键和值为null。\",\"ConcurrentHashMap：基于哈希表实现的线程安全的Map，支持高并发操作\"]},\"84\":{\"h\":\"遍历HashMap的几种方法？\",\"t\":[\"使用迭代器遍历\",\"使用for-each循环遍历键集合或值集合\",\"使用for-each循环遍历键值对\",\"使用Java 8的Stream API遍历\"]},\"85\":{\"h\":\"面向对象\"},\"86\":{\"h\":\"⾯向对象和⾯向过程的区别?\",\"t\":[\"⾯向过程\",\"面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候再一个一个的一次调用就可以。\",\"⾯向对象\",\"面向对象，把构成问题的事务分解成各个对象，而建立对象的目的也不是为了完成一个个步骤，而是为了描述某个事件在解决整个问题的过程所发生的行为。 目的是为了写出通用的代码，加强代码的重用，屏蔽差异性。\"]},\"87\":{\"h\":\"面向对象有哪些特性?\",\"t\":[\"封装 \",\"封装把⼀个对象的属性私有化，同时提供⼀些可以被外界访问的属性的⽅法\",\"继承 \",\"继承是使⽤已存在的类的定义作为基础创建新的类，新类的定义可以增加新的属性或新的方法，也可以继承父类的属性和方法。通过继承可以很方便地进行代码复用\",\"多态 \",\"所谓多态就是指程序中定义的引⽤变量所指向的具体类型和通过该引⽤变量发出的⽅法调⽤在编程时并不确定，⽽是在程序运⾏期间才确定\",\"即⼀个引⽤变量到底会指向哪个类的实例对象，该引⽤变量发出的⽅法调⽤到底是哪个类中实现的⽅法，必须在由程序运⾏期间才能决定\",\"在 Java 中有两种形式可以实现多态：继承（多个⼦类对同⼀⽅法的重写）和接⼝（实现接⼝并覆盖接⼝中同⼀⽅法）\"]},\"88\":{\"h\":\"重载（overload）和重写（override）的区别？\",\"t\":[\"方法重载和方法重写都是实现多态性的方式\",\"区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性\",\"方法重载\",\"方法名相同，形参不同（参数个数、参数类型、参数顺序满足任一）则视为重载；\",\"与返回值和修饰符无关\",\"调用方法不同，与异常类型更没关系\",\"发生在同一个类中\",\"方法重写\",\"方法名相同，形参相同\",\"基本数据类型相同，若为引用数据类型则返回值为被重写方法的返回值或是其子类\",\"重写方法不能抛出范围更大的受控异常（父类不希望子类出现更多的异常）\",\"重写方法的访问权限可以更广（子类可以扩大方法的访问范围）\",\"发生在具有继承关系的父子类中\"]},\"89\":{\"h\":\"访问修饰符public、private、protected、以及不写（默认）时的 区别?\",\"t\":[\"default (即默认，什么也不写） \",\"在同一包内可见，不使用任何修饰符。可以修饰在类、接口、变量、方法。\",\"private \",\"在同一类内可见。可以修饰变量、方法。\",\"注意：不能修饰外部类\",\"public \",\"对所有类可见。可以修饰类、接口、变量、方法\",\"protected \",\"对同一包内的类和所有子类可见。可以修饰变量、方法。\",\"注意：不能修饰外部类\"]},\"90\":{\"h\":\"this关键字有什么作用？\",\"t\":[\"指向对象本身的一个指针\",\"this的用法在Java中大体可以分为3种 \",\"普通的直接引用，this相当于是指向当前对象本身\",\"形参与成员变量名字重名，用this来区分\",\"引用本类的构造函数\"]},\"91\":{\"h\":\"抽象类(abstract class)和接口(interface)有什么区别？\",\"t\":[\"方法实现 \",\"接口中的方法默认是公开的(public)，只能定义，不能实现。从JDK 8开始，接口中的方法可以有默认实现，而抽象类可以包含非抽象的方法 \",\"如果同时实现两个接口，并且接口中定义了相同的默认方法，则必须重写方法，否则会报错\",\"在JDK 8中，接口也可以定义静态方法，并且可以直接使用接口名调用 \",\"实现类和实例不能调用静态方法\",\"JDK 9允许在接口中定义私有方法\",\"变量 \",\"接口中只能包含静态(static)和常量(final)变量，不能有其他类型的变量。而抽象类中可以包含任意类型的变量\",\"实现 \",\"一个类可以实现多个接口，但只能继承一个抽象类。接口自身可以通过extends关键字扩展多个接口\",\"方法修饰符 \",\"接口中的方法默认修饰符是public，抽象方法可以有public、protected和default修饰符。抽象方法是为了被重写，所以不能使用private修饰符\",\"设计层面 \",\"抽象类是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为规范\"]},\"92\":{\"h\":\"成员变量与局部变量的区别有哪些？\",\"t\":[\"成员变量 = 实例变量 + 静态变量（类变量）\",\"语法形式 \",\"成员变量是在类中声明的变量，可以被public、private、static等修饰符所修饰\",\"成员变量包括实例变量和静态变量（类变量） \",\"实例变量是每个对象独有的，而静态变量是类共享的\",\"局部变量是在方法中或代码块中声明的变量，不能被访问控制修饰符及static所修饰\",\"存储方式 \",\"实例变量存储在堆内存中\",\"静态变量存储在方法区（元空间）的静态存储区，所有对象共享同一份静态变量的拷贝\",\"局部变量存在栈内存中，随着方法或代码块的执行而创建和销毁\",\"生存周期 \",\"静态变量在类被加载至数据区后，只有当程序结束时才会被销毁，它的生命周期与程序的生命周期相同。\",\"实例变量即对象变量，随对象的创建而生，随对象的销毁而销毁\",\"局部变量只在方法或代码块内有效，一旦超出这个范围就不再有效\",\"默认值 \",\"非final修饰的成员变量具有默认值，而局部变量没有默认值\",\"成员变量的默认值根据其类型而定，例如整型默认为0，布尔型默认为false，引用类型默认为null\",\"局部变量在使用前必须显式地进行初始化\"]},\"93\":{\"h\":\"静态变量和实例变量的区别？静态方法、实例方法呢？\",\"t\":[\"静态变量 \",\"是被 static 修饰符修饰的变量，也称为类变量，它属于类，不属于类的任何一个对象，一个类不管创建多少个对象，静态变量在内存中有且仅有一个副本\",\"实例变量 \",\"必须依存于某一实例，需要先创建对象然后通过对象才能访问到它。静态变量可以实现让多个对象共享内存\",\"静态方法 \",\"static修饰的方法，也被称为类方法\",\"在外部调⽤静态⽅法时，可以使⽤\\\"类名.⽅法名\\\"的⽅式，也可以使⽤\\\"对象名.⽅法名\\\"的⽅式\",\"静态方法里不能访问类的非静态成员变量和方法\",\"实例⽅法 \",\"依存于类的实例\",\"需要使用\\\"对象名.⽅法名\\\"的⽅式调用\",\"可以访问类的所有成员变量和方法\"]},\"94\":{\"h\":\"final关键字有什么作用？\",\"t\":[\"被final修饰的类不可以被继承\",\"被final修饰的方法不可以被重写\",\"被final修饰的变量不可变，被final修饰的变量必须被显式第指定初始值 \",\"这里的不可变指的是变量的引用不可变，不是引用指向的内容的不可变\"]},\"95\":{\"h\":\"final、finally、finalize的区别？\",\"t\":[\"final 用于修饰变量、方法和类 \",\"final修饰的类不可被继承\",\"修饰的方法不可被重写\",\"修饰的变量不可变\",\"在 try/catch 语句中，最终一定被执行 \",\"经常被用在需要释放资源的情况下\",\"System.exit (0) 可以阻断 finally 执行\",\"finalize 是在 java.lang.Object 里定义的方法 \",\"这个方法在 gc 启动，该对象被回收的时候被调用\",\"一个对象的 finalize 方法只会被调用一次，finalize 被调用不一定会立即回收该对象 \",\"不推荐使用 \",\"有可能调用 finalize 后，该对象又不需要被回收了，然后到了真正要被回收的时候，因为前面调用过一次，所以不会再次调用 finalize 了，进而产生问题，因此不推荐使用 finalize 方法\"]},\"96\":{\"h\":\"==和 equals 的区别？\",\"t\":[\"== \",\"判断两个对象是不是同⼀个对象 \",\"基本数据类型==比较的是值\",\"引⽤数据类型==比较的是内存地址\",\"equals() \",\"判断两个对象是否相等\",\"默认情况类没有覆盖 equals() ⽅法，等价于通过“ == ”比较这两个对象\"]},\"97\":{\"h\":\"hashCode与 equals?\",\"t\":[\"什么是HashCode？ \",\"hashCode方法用于获取对象的哈希码，哈希码是一个整数，用来表示对象的唯一标识\",\"哈希码常用于哈希表等数据结构的实现中，可以快速定位对象\",\"为什么重写 quals 时必须重写 hashCode ⽅法？ \",\"这是Java的规定，主要目的是确保 Java 中的集合类（例如 HashMap、HashSet 等）能够正确地工作并保持一致性 \",\"对象相等性原则 \",\"如果两个对象根据 equals() 方法判断相等，则它们的 hashCode() 方法的返回值必须相等\",\"hashCode() 的默认⾏为是对堆上的对象产⽣独特值。如果没有重写 hashCode() ，则该class 的两个对象⽆论如何都不会相等（即使这两个对象指向相同的数据）\"]},\"98\":{\"h\":\"Java是值传递，还是引用传递？\",\"t\":[\"Java语言是值传递 \",\"当传递基本数据类型（如int、float、boolean等）时 \",\"传递的是该值的副本，对形参的修改不会影响实参\",\"当传递对象引用时 \",\"传递的是该引用的副本，而不是对象本身。因此，对形参引用的修改不会影响实参引用的指向，但可以通过引用修改对象的状态\"]},\"99\":{\"h\":\"什么是深拷贝和浅拷贝?\",\"t\":[\"浅拷贝 \",\"仅拷贝被拷贝对象的成员变量的值，也就是基本数据类型变量的值，和引用数据类型变量的地址值，而对于引用类型变量指向的堆中的对象不会拷贝。\",\"深拷贝 \",\"完全拷贝一个对象，拷贝被拷贝对象的成员变量的值，堆中的对象也会拷贝一份\",\"深拷贝是安全的 \",\"浅拷贝的话如果有引用类型，那么拷贝后对象，引用类型变量修改，会影响原对象\",\"浅拷贝如何实现呢？ \",\"Object类提供的clone()方法可以非常简单地实现对象的浅拷贝\",\"深拷贝如何实现呢？ \",\"重写克隆方法 \",\"重写克隆方法，引用类型变量单独克隆，这里可能会涉及多层递归\",\"序列化 \",\"可以先讲原对象序列化，再反序列化成拷贝对象\"]},\"100\":{\"h\":\"Java 创建对象有哪几种方式？\",\"t\":[\"new创建新对象\",\"通过反射机制\",\"采用clone机制\",\"通过序列化机制 \",\"Java中序列化可以通过实现Externalizable或者Serializable来实现\",\"或者使用json序列化\"]},\"101\":{\"h\":\"ThreadLocal\"},\"102\":{\"h\":\"ThreadLocal是什么？\",\"t\":[\"ThreadLocal，也就是线程本地变量\",\"创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的一个本地拷贝\",\"多个线程操作这个变量的时候，实际是操作自己本地内存里面的变量，从而起到线程隔离的作用，避免了线程 安全问题\",\"创建\",\"创建了一个ThreadLoca变量localVariable，任何一个线程都能并发访问localVariable。\",\"//创建一个ThreadLocal变量 public static ThreadLocal<String> localVariable = new ThreadLocal<>(); \",\"写入\",\"线程可以在任何地方使用localVariable，写入变量\",\"localVariable.set(\\\"鄙人张三”); \",\"读取\",\"线程在任何地方读取的都是它写入的变量。\",\" localVariable.get(); \"]},\"103\":{\"h\":\"你在工作中用到过ThreadLocal吗？\",\"t\":[\"用来做用户信息上下文的存储 \",\"存放token\"]},\"104\":{\"h\":\"ThreadLocal怎么实现的呢？\",\"t\":[\"Thread类有一个类型为ThreadLocal.ThreadLocalMap的实例变量threadLocals，每个线程都有一个属于自己的ThreadLocalMap\",\"ThreadLocalMap内部维护着Entry数组，每个Entry代表一个完整的对象，key是ThreadLocal的弱引用，value是ThreadLocal的泛型值\",\"每个线程在往ThreadLocal里设置值的时候，都是往自己的ThreadLocalMap里存，读也是以某个ThreadLocal作为引用，在自己的map里找对应的key，从而实现了线程隔离\",\"ThreadLocal本身不存储值，它只是作为一个key来让线程往ThreadLocalMap里存取值\"]},\"105\":{\"h\":\"ThreadLocal 内存泄露是怎么回事？\",\"t\":[\"ThreadLocalMap中使用的 key 为 ThreadLocal 的弱引用 \",\"弱引用：只要垃圾回收机制一运行，不管JVM的内存空间是否充足，都会回收该对象占用的内存。\",\"弱引用很容易被回收，如果ThreadLocal（ThreadLocalMap的Key）被垃圾回收器回收了，但是ThreadLocalMap生命周期和Thread是一样的，它这时候如果不被回收，就会出现这种情况：ThreadLocalMap的key没了，value还在，这 就会造成了内存泄漏问题\"]},\"106\":{\"h\":\"那怎么解决内存泄漏问题呢？\",\"t\":[\"使用完ThreadLocal后，及时调用remove()方法释放内存空间\"]},\"107\":{\"h\":\"为什么key还要设计成弱引用？\",\"t\":[\"key设计成弱引用同样是为了防止内存泄漏问题 \",\"在ThreadLocal中，每个ThreadLocal实例都对应着一个ThreadLocalMap对象，而ThreadLocalMap使用ThreadLocal实例作为键，用于存储线程局部变量的值。\",\"如果将ThreadLocal实例作为强引用存储在ThreadLocalMap中，那么即使线程不再使用某个ThreadLocal实例，该实例也无法被垃圾回收，从而可能导致内存泄漏\"]},\"108\":{\"h\":\"ThreadLocalMap的结构了解吗？\",\"t\":[\"元素数组\",\"一个table数组，存储Entry类型的元素，Entry是ThreaLocal弱引用作为key，Object作为value的结构\",\"private Entry[] table \",\"散列方法\",\"散列方法就是怎么把对应的key映射到table数组的相应下标，ThreadLocalMap用的是哈希取余法，取出key的threadLocalHashCode，然后和table数组长度减一&运算（相当于取余）\",\"int i = key.threadLocalHashCode & (table.length - 1); \",\"这里的threadLocalHashCode计算有点东西，每创建一个ThreadLocal对象，它就会新增 0x61c88647\",\"这个值很特殊，它是斐波那契数 也叫 黄金分割数\",\"hash 增量为 这个数字，带来的好处就是 hash 分布非常均匀\",\"private static final int HASH_INCREMENT = 0x61c88647; private static int nextHashCode() { return nextHashCode.getAndAdd(HASH_INCREMENT); } \"]},\"109\":{\"h\":\"ThreadLocalMap怎么解决Hash冲突的？\",\"t\":[\"开放定址法\",\"简单来说，就是这个坑被人占了，那就接着去找空着的坑，往后找一圈没找到就会从头开始找\",\"如上图所示，如果我们插入一个value=27的数据，通过 hash计算后应该落入第 4 个槽位中，而槽位 4 已经有了 Entry数据，而且Entry数据的key和当前不相等。此时就会线性向后查找，一直找到 Entry为 null的槽位才会停止查找，把元素放到空的槽中\",\"在get的时候，也会根据ThreadLocal对象的hash值，定位到table中的位置，然后判断该槽位Entry对象中的key是否和get的key一致，如果不一致，就判断下一个位置\"]},\"110\":{\"h\":\"ThreadLocalMap扩容机制了解吗？\",\"t\":[\"rehash()时机\",\"在ThreadLocalMap.set()方法的最后，如果执行完启发式清理工作后，未清理到任何数据，且当前散列数组中 Entry 的数量已经达到了列表的扩容阈值 (len*2/3) ，就开始执行 rehash() 逻辑\",\"if (!cleanSomeSlots(i, sz) && sz >= threshold) rehash(); \",\"rehash\",\"会先去清理过期的Entry\",\"然后还要根据条件判断size >= threshold - threshold / 4 也就是 size >= threshold* 3/4 来决定是否需要扩容\",\"private void rehash() { //清理过期Entry expungeStaleEntries(); // Use lower threshold for doubling to avoid hysteresis if (size >= threshold - threshold / 4) resize(); } \",\"resize\",\"扩容后的 newTab 的大小为老数组的两倍\",\"然后遍历老的table数组，散列方法重新计算位置\",\"开放地址解决冲突，然后放到新的newTab ，遍历完成之后， oldTab 中所有的 entry 数据都已经放入到 newTab 中了，然后table引用指向 newTab\",\" private void resize() { Entry[] oldTab = table; int oldLen = oldTab.length; int newLen = oldLen * 2; Entry[] newTab = new Entry[newLen]; int count = 0; for (Entry e : oldTab) { if (e != null) { ThreadLocal<?> k = e.get(); if (k == null) { e.value = null; // Help the GC } else { int h = k.threadLocalHashCode & (newLen - 1); while (newTab[h] != null) h = nextIndex(h, newLen); newTab[h] = e; count++; } } } setThreshold(newLen); size = count; table = newTab; } \"]},\"111\":{\"h\":\"父子线程怎么共享数据？\",\"t\":[\"InheritableThreadLocal\",\"在主线程的InheritableThreadLocal实例设置值，在子线程中就可以拿到了\",\"public class InheritableThreadLocalTest { public static void main(String[] args) { final ThreadLocal threadLocal = new InheritableThreadLocal(); // 主线程 threadLocal.set(\\\"不擅技术\\\"); //子线程 Thread t = new Thread() { @Override public void run() { super.run(); System.out.println(\\\"鄙人三某 ，\\\" + threadLocal.get()); } }; t.start(); } } \"]},\"112\":{\"h\":\"InheritableThreadLocal原理是什么呢？\",\"t\":[\"原理很简单，在Thread类里还有另外一个变量\",\"ThreadLocal.ThreadLocalMap inheritableThreadLocals = null; \",\"在Thread的构造函数中，如果父线程的 inheritableThreadLocals 不为空，就把它赋给当前线程（子线程）的 inheritableThreadLocals\",\" // thread locals if (!attached) { if ((characteristics & NO_INHERIT_THREAD_LOCALS) == 0) { ThreadLocal.ThreadLocalMap parentMap = parent.inheritableThreadLocals; if (parentMap != null && parentMap.size() > 0) { //从父线程中取出inheritableThreadLocals this.inheritableThreadLocals = ThreadLocal.createInheritedMap(parentMap); } if (VM.isBooted()) { this.contextClassLoader = contextClassLoader(parent); } } else if (VM.isBooted()) { // default CCL to the system class loader when not inheriting this.contextClassLoader = ClassLoader.getSystemClassLoader(); } } \"]},\"113\":{\"h\":\"还有什么其它办法？TTL？\",\"t\":[\"TransmittableThreadLocal（TTL） \",\"是阿里巴巴开源的基于 InheritableThreadLocal 的增强版\",\"解决了线程池等场景下InheritableThreadLocal 的值传递问题\",\"TTL通过重写 ThreadLocal 的方法和使用特定的数据结构，确保子线程能够正确获取父线程最新的值\",\"它还提供了自定义初始化方法和支持传递不可序列化对象的功能\"]},\"114\":{\"h\":\"基础\"},\"115\":{\"h\":\"并行跟并发有什么区别？\",\"t\":[\"并行就是同一时刻，两个线程都在执行。这就要求有两个CPU去分别执行两个线程\",\"并发就是同一时刻，只有一个执行，但是一个时间段内，两个线程都执行了 \",\"并发的实现依赖于CPU切换线程，因为切换的时间特别短，所以基本对于用户是无感知的\"]},\"116\":{\"h\":\"说说什么是进程和线程？\",\"t\":[\"进程 \",\"进程是代码在数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位\",\"一个进程中有多个线程，多个线程共用进程的堆和方法区资源\",\"线程 \",\"线程是进程的一个执行路径，一个进程中至少有一个线程，进程中的多个线程共享进程的资源\",\"每个线程有自己的程序计数器和栈\"]},\"117\":{\"h\":\"说说线程有几种创建方式？\",\"t\":[\"继承Thread类 \",\"继承Thread类，重写run()方法，调用start()方法启动线程\",\"实现Runnable接口 \",\"实现 Runnable 接口，重写run()方法\",\"实现Callable接口 \",\"实现Callable接口，重写call()方法，这种方式可以通过FutureTask获取任务执行的返回值\"]},\"118\":{\"h\":\"为什么调用start()方法时会执行run()方法，那怎么不直接调用run()方法？\",\"t\":[\"JVM执行start方法，会先创建一条线程，由创建出来的新线程去执行thread的run方法，这才起到多线程的效果\",\"为什么我们不能直接调用run()方法？ \",\"如果直接调用Thread的run()方法，那么run方法还是运行在主线程中，相当于顺序执行，就起不到多线程的效果\"]},\"119\":{\"h\":\"Thread和Runnable有什么区别？\",\"t\":[\"特点\",\"Thread\",\"Runnable\",\"继承关 系\",\"是一个类\",\"是一个接口\",\"代码复 用\",\"不方便，每个线程需要创建新实 例\",\"方便，多个线程可以共享同一实 例\",\"灵活性\",\"相对较低，只能继承Thread类\",\"相对较高，可以与其他接口组合\",\"可控性\",\"相对较低，需要手动管理线程\",\"相对较高，可以通过线程池管理\",\"Thread类适合直接创建新线程\",\"而Runnable接口适合定义线程要执行的任务，并可以与其他接口组合使用\"]},\"120\":{\"h\":\"线程有哪些常用的调度方法？\",\"t\":[\"线程等待与通知 \",\"Object类方法 \",\"wait() \",\"当一个线程A调用一个共享变量的 wait()方法时， 线程A会被阻塞挂起，发生下面几种情况才会返回\",\"其他线程调用了线程A共享对象 notify()或者 notifyAll()方法\",\"其他线程调用了线程A的 interrupt() 方法，线程A抛出InterruptedException异常返回\",\"wait(long timeout) \",\"这个方法相比 wait() 方法多了一个超时参数\",\"在等待时间内没有其他线程调用相同对象的 notify() 或 notifyAll() 方法唤醒它，或者等待时间到期，线程会被自动唤醒，并且重新尝试获取对象的锁\",\"如果等待时间到期而线程没有获取到锁，则线程会被唤醒，但是它不会重新尝试获取锁。相反，它会在等待队列中等待，直到其他线程通过 notify() 或 notifyAll() 方法唤醒它，并且在获取锁之前，线程是不会继续执行的\",\"wait(long timeout, int nanos)\",\"其内部调用的是 wait(long timout）函数\",\"notify() \",\"一个线程A调用共享对象的 notify() 方法后，会唤醒一个在这个共享变量上调用 wait 系列方法后被挂起的线程。 一个共享变量上可能会有多个线程在等待，具体唤醒哪个等待的线程是随机的\",\"notifyAll() \",\"不同于在共享变量上调用 notify() 函数会唤醒被阻塞到该共享变量上的一个线程，notifyAll()方法则会唤醒所有在该共享变量上由于调用 wait 系列方法而被挂起的线程\",\"Thread类的方法 \",\"join() \",\"如果一个线程A执行了thread.join()语句，其含义是：当前线程A等待thread线程终止之后从thread.join()返回\",\"线程休眠 \",\"sleep(long millis) \",\"Thread类中的静态方法\",\"当一个执行中的线程A调用了Thread的sleep方法后，线程A会暂时让出指定时间的执行权\",\"但是线程A所拥有的监视器资源，比如锁还是持有不让出的\",\"指定的睡眠时间到了后该函数会正常返回，接着参与 CPU 的调度，获取到 CPU 资源后就可以继续运行\",\"让出优先权 \",\"yield() \",\"Thread类中的静态方法\",\"当一个线程调用 yield 方法时，实际就是在暗示线程调度器当前线程请求让出自己的CPU ，但是线程调度器可以无条件忽略这个暗示\",\"线程中断 \",\"定义 \",\"Java 中的线程中断是一种线程间的协作模式\",\"通过设置线程的中断标志并不能直接终止该线程的执行，而是被中断的线程根据中断状态自行处理\",\"方法 \",\"void interrupt() \",\"中断线程\",\"例如，当线程A运行时，线程B可以调用线程interrupt() 方法来设置线程的中断标志为true 并立即返回\",\"线程A实际并没有被中断， 会继续往下执行\",\"boolean isInterrupted() \",\"检测当前线程是否被中断\",\"boolean interrupted() \",\"检测当前线程是否被中断，与 isInterrupted 不同的是，该方法如果发现当前线程被中断，则会清除中断标志\"]},\"121\":{\"h\":\"线程有几种状态？\",\"t\":[\"线程共有六种状态\",\"状态\",\"说明\",\"NEW\",\"初始状态：线程被创建，但还没有调用start()方法\",\"RUNNABLE\",\"运行状态：Java线程将操作系统中的就绪和运行两种状态笼 统的称作“运行”\",\"BLOCKED\",\"阻塞状态：表示线程阻塞于锁\",\"WAITING\",\"等待状态：表示线程进入等待状态，进入该状态表示当前线 程需要等待其他线程做出一些特定动作（通知或中断）\",\"TIME_WAITING\",\"超时等待状态：该状态不同于 WAITIND，它是可以在指定 的时间自行返回的\",\"TERMINATED\",\"终止状态：表示当前线程已经执行完毕\"]},\"122\":{\"h\":\"BLOCKED和WAITING有什么区别？\",\"t\":[\"BLOCKED状态表示线程被阻塞，无法继续执行，通常是因为等待获取锁\",\"WAITING状态表示线程正在等待其他线程的通知，通常是因为调用了wait()方法、join()方法或LockSupport.park()方法\",\"这两种状态的区别在于阻塞状态是等待获取锁，而等待状态是等待其他线程的通知或中断\"]},\"123\":{\"h\":\"WAITING和TERMINATED有什么区别？\",\"t\":[\"WAITING状态表示线程在等待其他线程的通知或中断\",\"而TERMINATED状态表示线程已经执行完毕，不再执行任何代码\",\"WAITING状态是暂时的，可以再次进入RUNNABLE状态，而TERMINATED状态是永久的，线程不会再进入任何状态\"]},\"124\":{\"h\":\"什么是线程上下文切换？\",\"t\":[\"线程上下文切换是指在多线程环境下，CPU 从一个线程转而执行另一个线程的过程。\",\"在这个过程中，操作系统会保存当前线程的上下文（包括寄存器状态、程序计数器、堆栈指针等信息），然后恢复下一个线程的上下文，以便该线程可以继续执行。\",\"线程上下文切换是一种非常耗时的操作，因为操作系统需要保存和恢复线程的上下文信息。因此，在编写多线程应用程序时，应尽量减少线程上下文切换的次数，以提高系统的性能和效率\"]},\"125\":{\"h\":\"线程上下文切换通常发生在以下几种情况下\",\"t\":[\"当一个线程的时间片用完时，操作系统会强制进行线程上下文切换，将 CPU 时间片分配给另一个处于就绪状态的线程。\",\"当一个线程因为等待某些事件（如I/O操作、锁的释放等）而被阻塞时，操作系统会将 CPU 时间片分配给另一个处于就绪状态的线程\",\"当一个线程调用了 yield() 方法主动放弃 CPU 时间片时，操作系统会将 CPU 时间片分配给另一个处于就绪状态的线程\"]},\"126\":{\"h\":\"守护线程了解吗？\",\"t\":[\"Java中的线程分为两类，分别为 daemon 线程（守护线程）和 user 线程（用户线程）\",\"在JVM 启动时会调用 main 函数，main函数所在的钱程就是一个用户线程\",\"其实在JVM 内部同时还启动了很多守护线程， 比如垃圾回收线程\",\"那么守护线程和用户线程有什么区别呢 ？ \",\"是当最后一个非守护线程束时，JVM会正常退出，而不管当前是否存在守护线程，也就是说守护线程是否结束并不影响 JVM退出\"]},\"127\":{\"h\":\"线程间有哪些通信方式？\",\"t\":[\"volatile和synchronized关键字 \",\"关键字volatile可以用来修饰字段（成员变量），就是告知程序任何对该变量的访问均需要从共享内存中获取，而对它的改变必须同步刷新回共享内存，它能保证所有线程对变量访问的可见性\",\"关键字synchronized可以修饰方法或者以同步块的形式来进行使用，它主要确保多个线程在同一个时刻，只能有一个线程处于方法或者同步块中，它保证了线程对变量访问的可见性和排他性\",\"等待/通知机制 \",\"可以通过Java内置的等待/通知机制（wait()/notify()）实现一个线程修改一个对象的值，而另一个线程感知到了变化，然后进行相应的操作\",\"管道输入/输出流 \",\"管道输入/输出流和普通的文件输入/输出流或者网络输入/输出流不同之处在于，它主要用于线程之间的数据传输，而传输的媒介为内存\",\"管道输入/输出流主要包括了如下4种具体实现 \",\"PipedOutputStream、PipedInputStream、 PipedReader和PipedWriter，前两种面向字节，而后两种面向字 符\",\"使用Thread.join() \",\"如果一个线程A执行了thread.join()语句，其含义是：当前线程A等待thread线程终止之后才从thread.join()返回\",\"线程Thread除了提供join()方法之外，还提供了join(long millis)和join(long millis,int nanos)两个具备超时特性的方法\",\"使用ThreadLocal（线程内 ） \",\"ThreadLocal，即线程变量，是一个以ThreadLocal对象为键、任意对象为值的存储结构\",\"这个结构被附带在线程上，也就是说一个线程可以根据一个ThreadLocal对象查询到绑定在这个线程上的一个值\"]},\"128\":{\"h\":\"List\"},\"129\":{\"h\":\"ArrayList和LinkedList有什么区别？\",\"t\":[\"数据结构不同 \",\"ArrayList基于数组实现\",\"LinkedList基于双向链表实现\",\"多数情况下，ArrayList更利于查找，LinkedList更利于增删 \",\"查找速率 \",\"ArrayList基于数组实现，get(int index)可以直接通过数组下标获取，时间复杂度是O(1)\",\"LinkedList基于链表实现，get(int index)需要遍历链表，时间复杂度是O(n)\",\"get(E element)这种查找，两种集合都需要遍历，时间复杂度都是O(n)\",\"增删速率 \",\"ArrayList增删如果是数组末尾的位置，直接插入或者删除就可以了，但是如果插入中间的位置，就需要把插入位置后的元素都向前或者向后移动，甚至还有可能触发扩容\",\"双向链表的插入和删除只需要改变前驱节点、后继节点和插入节点的指向就行了，不需要移动元素\",\"是否支持随机访问 \",\"ArrayList基于数组，所以它可以根据下标查找，支持随机访问 \",\"它也实现了RandmoAccess 接口，这个接口只是用来标识是否支持随机访问\",\"LinkedList基于链表，所以它没法根据序号直接获取元素，它没有实现RandmoAccess 接口，标记不支持随机访问\",\"内存占用 \",\"ArrayList基于数组，是一块连续的内存空间 \",\"ArrayList是预先定义好的数组，可能会有空的内存空间，存在一定空间浪费\",\"LinkedList基于链表，内存空间不连续，它们在空间占用上都有一些额外的消耗 \",\"LinkedList每个节点，需要存储前驱和后继，所以每个节点会占用更多的空间\"]},\"130\":{\"h\":\"ArrayList的扩容机制了解吗？\",\"t\":[\"数组满了，再插入时，触发扩容\",\"计算新数组容量，容量大小为原数组1.5倍\",\" private int newCapacity(int minCapacity) { // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity >> 1); if (newCapacity - minCapacity <= 0) { if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) return Math.max(DEFAULT_CAPACITY, minCapacity); if (minCapacity < 0) // overflow throw new OutOfMemoryError(); return minCapacity; } return (newCapacity - MAX_ARRAY_SIZE <= 0) ? newCapacity : hugeCapacity(minCapacity); } \",\"int newCapacity = oldCapacity + (oldCapacity >> 1);\",\"复制原数组元素到新数组\"]},\"131\":{\"h\":\"ArrayList怎么序列化的知道吗？ 为什么用transient修饰数组？\",\"t\":[\"ArrayList的序列化不太一样，它使用 transient 修饰存储元素的 elementData 的数组\",\"transient 关键字的作用是让被修饰的成员属性不被序列化\"]},\"132\":{\"h\":\"为什么最ArrayList不直接序列化元素数组呢？\",\"t\":[\"出于效率的考虑 \",\"数组可能长度100，但实际只用了50，剩下的50不用其实不用序列化，这样可以提高序列化和反序列化的效率，还可以节省内存空间\"]},\"133\":{\"h\":\"那ArrayList怎么序列化呢 ？\",\"t\":[\"ArrayList通过两个方法readObject、writeObject自定义序列化和反序列化策略，实际直接使用两个流 ObjectOutputStream 和 ObjectInputStream 来进行序列化和反序列化\"]},\"134\":{\"h\":\"快速失败(fail-fast)和安全失败(fail-safe)了解吗？\",\"t\":[\"快速失败（fail—fast）：快速失败是Java集合的一种错误检测机制 \",\"触发 \",\"在用迭代器遍历一个集合对象时，如果线程A遍历过程中，线程B对集合对象的内容进行了修改（增加、删除、修改），则会抛出Concurrent Modification Exception\",\"原理 \",\"迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个modCount 变量。集合在被遍历期间如果内容发生变化，就会改变 modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测 modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。\",\"注意 \",\"这里异常的抛出条件是检测到 modCount！=expectedmodCount 这个条件。如果集合发生变化时修改modCount值刚好又设置为了expectedmodCount值，则异常不会抛出。因此，不能依赖于这个异常是否抛出而进行并发操作的编程，这个异常只建议用于检测并发修改的bug\",\"场景 \",\"java.util包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改），比如ArrayList 类。\",\"安全失败（fail—safe） \",\"策略 \",\"采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历\",\"原理 \",\"由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception\",\"缺点 \",\"基于拷贝内容的优点是避免了Concurrent Modification Exception，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的\",\"场景 \",\"java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改，比如CopyOnWriteArrayList类\"]},\"135\":{\"h\":\"实现ArrayList线程安全有哪几种方法？\",\"t\":[\"用Vector代替ArrayList \",\"Vector是一个线程安全的动态数组类，可以直接使用它来替代ArrayList\",\"Vector的所有方法都是同步的，因此在并发环境下可以安全地进行读写操作。\",\"但它的性能很低，不推荐使用。\",\"使用Collections.synchronizedList包装ArrayList \",\"可以使用Collections工具类的synchronizedList方法将ArrayList转换为线程安全的List\",\"该方法返回一个包装后的线程安全List，对该List的所有操作都会进行同步处理，确保线程安全\",\"使用CopyOnWriteArrayList代替ArrayList \",\"CopyOnWriteArrayList是一种线程安全的并发List\",\"它通过在修改时创建副本来实现并发访问\",\"由于读操作不需要加锁，因此在读多写少的场景中，CopyOnWriteArrayList具有较高的性能\",\"使用同步机制控制ArrayList的读写 \",\"在使用ArrayList时，可以通过同步机制（如使用synchronized关键字或Lock）来控制对ArrayList的读写操作，以确保线程安全\"]},\"136\":{\"h\":\"CopyOnWriteArrayList了解多少？\",\"t\":[\"CopyOnWriteArrayList就是线程安全版本的ArrayList，它的名字叫 CopyOnWrite，写时复制，已经明示了它的原理\",\"特点 \",\"线程安全性 \",\"CopyOnWriteArrayList通过创建副本的方式实现线程安全，因此可以在多线程环境下安全地进行读操作，而不需要额外的同步措施\",\"读写分离 \",\"CopyOnWriteArrayList适合在读多写少的场景中使用，因为每次写操作都会创建一个新的副本，会带来一定的内存开销。但在读操作频繁、写操作较少的情况下，可以获得较高的读取性能\",\"迭代器的弱一致性 \",\"由于CopyOnWriteArrayList在写操作时会创建副本，因此在遍历集合时使用的迭代器可能不反映最新的修改。迭代器提供的是一个一致性视图，即迭代器创建时的集合状态\",\"工作流程 \",\"将原数组拷贝一份\",\"写操作在副本上，加锁\",\"读操作在原数组上，无锁\",\"写完将元素数组指向副本\",\"缺点 \",\"由于CopyOnWriteArrayList在每次写操作时都会创建副本，因此适用于写操作较少、读操作频繁且对实时性要求不高的场景。如果写操作频繁或对实时性要求较高，可能会带来较高的内存开销和延迟。\",\"volatile修饰原数组array，保证了可见性\"]},\"137\":{\"h\":\"数据拷贝的过程中，有其它线程写入数据怎么办？\",\"t\":[\"阻塞呗，数据拷贝在add方法中进行，add方法有锁\"]},\"138\":{\"h\":\"Map\"},\"139\":{\"h\":\"能说一下HashMap的数据结构吗？\",\"t\":[\"数组 + 链表（JDK1.7）\",\"数组 + 链表 + 红黑树 （JDK1.8）\",\"数据结构示意图\",\"存储结构 \",\"HashMap内部使用一个数组（Entry[]）来存储数据\",\"数组中的每个元素称为一个桶（Bucket），每个桶存储一个键值对（Entry）\",\"哈希函数 \",\"HashMap使用键的哈希码（hash code）来计算存储位置\",\"每个键值对根据哈希函数计算得到一个桶的索引，然后将键值对存储在该桶中\",\"冲突处理 \",\"由于哈希函数的计算结果可能会出现冲突，即不同的键计算得到相同的桶索引\",\"HashMap使用链表或红黑树来解决冲突\",\"当桶中的元素较少时，使用链表存储键值对\",\"当桶中的元素较多时，将链表转换为红黑树，以提高查找、插入和删除的效率\"]},\"140\":{\"h\":\"你对红黑树了解多少？为什么不用二叉树/平衡树呢？\"},\"141\":{\"h\":\"什么是红黑树？\",\"t\":[\"红黑树是一种自平衡的二叉搜索树\",\"二叉搜索树性质\",\"左子节点的值小于等于当前节点的值，右子节点的值大于等于当前节点的值\",\"节点颜色\",\"每个节点要么是红色，要么是黑色\",\"根节点和叶子节点\",\"根节点是黑色的，叶子节点（NIL节点）是黑色的\",\"红色节点限制\",\"红色节点的子节点必须是黑色的\",\"黑色节点计数\",\"从任一节点到其每个叶子节点的路径上，黑色节点的数量是相同的\"]},\"142\":{\"h\":\"为什么不用二叉树？\",\"t\":[\"红黑树相对于普通的二叉搜索树的优势在于它能够保持良好的平衡，性能更加优秀和稳定\",\"普通的二叉搜索树在最坏情况下可能会退化成链表 ,导致插入、删除和查找操作的时间复杂度变为O(n)\",\"而红黑树通过自平衡的特性，避免了这种退化情况，保证了操作的最坏时间复杂度为O(log n)，其中n是树中节点的数量\"]},\"143\":{\"h\":\"为什么不用平衡二叉树？\",\"t\":[\"相比于平衡二叉树，红黑树在保持平衡的过程中旋转的次数较少，提高了插入和删除操作的效率\",\"红黑树通过引入节点颜色和特定性质，保证了树的相对平衡\",\"而平衡二叉树要求更严格的平衡条件，需要更多的旋转操作来保持平衡，导致插入和删除操作的效率较低\"]},\"144\":{\"h\":\"红黑树怎么保持平衡的知道吗？\",\"t\":[\"红黑树有两种方式保持平衡： 旋转 和 染色\",\"旋转 \",\"旋转分为两种，左旋和右旋\",\"染色\"]},\"145\":{\"h\":\"HashMap的put流程知道吗？\",\"t\":[\"首先进行哈希值的扰动，获取一个新的哈希值\",\"(key == null) ? 0 : (h =key.hashCode()) ^ (h >>> 16) \",\"判断tab是否位空或者长度为0，如果是则进行扩容操作\",\"if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; \",\"根据哈希值计算下标，如果对应下标正好没有存放数据，则直接插入即可，否则需要覆盖\",\"if ((p = tab[i = (n - 1) & hash]) == null) tab[i] = newNode(hash, key, value, null); else { //覆盖 } \",\"判断tab[i]是否为树节点，否则向链表中插入数据，是则向树中插入节点\",\"// 覆盖逻辑 Node<K,V> e; K k; if (p.hash == hash && ((k = p.key) == key || (key != null && key.equals(k)))) e = p; else if (p instanceof TreeNode) e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value); else { for (int binCount = 0; ; ++binCount) { if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; } if (e.hash == hash && ((k = e.key) == key || (key != null && key.equals(k)))) break; p = e; } } \",\"如果链表中插入节点的时候，链表长度大于等于8，则需要把链表转换为红黑树\",\" if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); \",\"最后所有元素处理完成后，判断是否超过阈值； threshold ，超过则扩容\",\" if (++size > threshold) resize(); \"]},\"146\":{\"h\":\"HashMap怎么查找元素的呢？\",\"t\":[\" public V get(Object key) { Node<K,V> e; return (e = getNode(hash(key), key)) == null ? null : e.value; } \",\" final Node<K,V> getNode(int hash, Object key) { Node<K,V>[] tab; Node<K,V> first, e; int n; K k; if ((tab = table) != null && (n = tab.length) > 0 && (first = tab[(n - 1) & hash]) != null) { if (first.hash == hash && // always check first node ((k = first.key) == key || (key != null && key.equals(k)))) return first; if ((e = first.next) != null) { if (first instanceof TreeNode) return ((TreeNode<K,V>)first).getTreeNode(hash, key); do { if (e.hash == hash && ((k = e.key) == key || (key != null && key.equals(k)))) return e; } while ((e = e.next) != null); } } return null; } \",\"使用扰动函数，获取新的哈希值\",\"计算数组下标，获取节点\",\"当前节点和key匹配，直接返回\",\"否则，当前节点是否为树节点，查找红黑树\",\"否则，遍历链表查找\"]},\"147\":{\"h\":\"HashMap的哈希/扰动函数是怎么设计的?\",\"t\":[\"HashMap的哈希函数是先通过 hashCode() 获取到key的哈希值\",\"哈希值是一个32位的int类型的数值，然后再将哈希值右移16位（高位），然后与哈希值本身异或，达到高位与低位混合的效果\",\"这样的设计增加了哈希值的随机性，降低了哈希冲突的概率 。\",\"异或操作使得低位的特征影响到高位，减少了相同低位的哈希值导致相同索引位置的情况\"]},\"148\":{\"h\":\"为什么哈希/扰动函数能降hash碰撞？\",\"t\":[\"因为哈希值&(数组长度 - 1)保留的是hash值的地位特征，所以对扰动函数通过对哈希值进行变换，新hash值保留了高低位的特征，这样使得哈希值的分布更加均匀，从而降低哈希碰撞的概率\"]},\"149\":{\"h\":\"为什么HashMap的容量是2的倍数呢？\",\"t\":[\"方便哈希取余 \",\"取余是去除整数倍，保留整数倍以下的数据\",\"hash值&(数组大小-1) ，也达到了取余的效果 \",\"数组大小为2的倍数，(数组大小-1) 则为一个全是1的二进制数\",\"hash值&(数组大小-1) 结果为直接保留hash值对(数组大小-1) 的低位的余数部分 \",\"因为任意数&1得任意数\",\"任意数&0得0\",\"hash值&(数组大小-1) ，将(数组大小-1)高位补0，补全到和hash值一样多的位数，那么hash值高位是与0做&运算，低位是与1做位运算，即保留了低位hash值，也是取余的效果\",\"在扩容时，利用扩容后的大小也是2的倍数，将已经产生hash碰撞的元素完美的转移到新的table中去\"]},\"150\":{\"h\":\"如果初始化HashMap，传一个17的值 new HashMap<> ，它会怎么处理？\",\"t\":[\"初始化时，传的不是2的倍数时，HashMap会向上寻找 离得最近的2的倍数 ，所以传入17，但HashMap的实际容量是32\",\"HashMap的容量必须是2的倍数\"]},\"151\":{\"h\":\"你还知道哪些哈希函数的构造方法呢？\",\"t\":[\"除留取余法 \",\"HashMap里进行了优化改造，效率更高，散列也更均衡\",\"直接定址法 \",\"直接根据 key 来映射到对应的数组位置，例如1232放到下标1232的位置\",\"数字分析法 \",\"取 key 的某些数字（例如十位和百位）作为映射的位置\",\"平方取中法 \",\"取 key 平方的中间几位作为映射的位置\",\"折叠法 \",\"将 key 分割成位数相同的几段，然后把它们的叠加和作为映射的位置\"]},\"152\":{\"h\":\"解决哈希冲突有哪些方法呢？\",\"t\":[\"链地址法 \",\"在冲突的位置拉一个链表，把冲突的元素放进去\",\"开放定址法 \",\"开放定址法就是从冲突的位置再接着往下找，给冲突元素找个空位\",\"找到空闲位置的方法也有很多 \",\"线行探查法 \",\"从冲突的位置开始，依次判断下一个位置是否空闲，直至找到空闲位置\",\"平方探查法 \",\"从冲突的位置x开始，第一次增加 1^2 个位置，第二次增加2^2 …，直至找到空闲的位置\",\"再哈希法 \",\"换种哈希函数，重新计算冲突元素的地址\",\"建立公共溢出区 \",\"再建一个数组，把冲突的元素放进去\"]},\"153\":{\"h\":\"为什么HashMap链表转红黑树的阈值为8呢？\",\"t\":[\"红黑树节点的大小大概是普通节点大小的两倍，所以转红黑树，牺牲了空间换时间，更多的是一种兜底的策略，保证极端情况下的查找效率\",\"链表转红黑树的阈值为什么要选8呢？ \",\"和统计学有关。理想情况下，使用随机哈希码，链表里的节点符合泊松分布，出现节点个数的概率是递减的，节点个数为8的情况，发生概率仅为0.00000006\",\"红黑树转回链表的阈值为什么是6，而不是8？ \",\"是因为如果这个阈值也设置成8，假如发生碰撞，节点增减刚好在8附近，会发生链表和红黑树的不断转换，导致资源浪费\"]},\"154\":{\"h\":\"扩容在什么时候呢？为什么扩容因子是0.75？\",\"t\":[\"为了减少哈希冲突发生的概率,当前HashMap的元素个数达到一个临界值的时候，就会触发扩容\",\"这个 临界值threshold 就是由加载因子和当前容器的容量大小来确定的\"]},\"155\":{\"h\":\"那么为什么选择了0.75作为HashMap的默认加载因子呢？\",\"t\":[\"这是对 空间 成本和 时间 成本平衡的考虑 \",\"假如我们设的比较大，元素比较多，空位比较少的时候才扩容，那么发生哈希冲突的概率就增加了，查找的时间成本就增加了\",\"我们设的比较小的话，元素比较少，空位比较多的时候就扩容了，发生哈希碰撞的概率就降低了，查找时间成本降低，但是就需要更多的空间去存储元素，空间成本就增加了\"]},\"156\":{\"h\":\"HashMap扩容机制了解吗？\",\"t\":[\"为了减少哈希冲突发生的概率,当前HashMap的元素个数达到一个临界值的时候，就会触发扩容\",\"链表结构扩容后 \",\"hash&老容量==0 \",\"现在位置=原先位置\",\"hash&老容量==1 \",\"现在位置=原先位置+oldCap\"]},\"157\":{\"h\":\"JDK1.8对HashMap主要做了哪些优化呢？为什么？\",\"t\":[\"数据结构 \",\"在JDK 1.8中，当哈希冲突较多时，HashMap会将链表转换为红黑树，以提高查找、插入和删除操作的效率\",\"种优化是为了解决在极端情况下链表过长导致的性能问题。\",\"红黑树的平均时间复杂度为O(log n)，相比于链表的O(n)更高效\",\"哈希碰撞优化 \",\"JDK 1.8对哈希碰撞的处理进行了优化\",\"当发生哈希碰撞时，HashMap会使用更加均匀的哈希函数来计算索引位置，减少碰撞的概率\",\"JDK 1.8还引入了\\\"树化阈值\\\"和\\\"链表转树阈值\\\"的概念，动态调整链表和红黑树的阈值，以平衡性能和空间的消耗\",\"链表插入方式 \",\"在JDK 1.8中，当插入新的键值对时，HashMap采用了尾插法（将新键值对插入链表或红黑树末尾），而不是头插法\",\"这样做可以减少链表或红黑树的重新排序次数，提高插入操作的效率\",\"扩容优化 \",\"JDK 1.8对HashMap的扩容操作进行了优化\",\"在扩容时，HashMap采用了\\\"渐进式扩容\\\"的策略，将扩容操作分散到多次进行，避免了一次性重新计算所有键的哈希值和索引位置，减少了扩容操作的时间和资源消耗\"]},\"158\":{\"h\":\"你能自己设计实现一个HashMap吗？\",\"t\":[\"散列函数 \",\"hashCode()+除留余数法\",\"冲突解决 \",\"链地址法\",\"扩容 \",\"节点重新hash获取位置\"]},\"159\":{\"h\":\"HashMap 是线程安全的吗？多线程下会有什么问题？\",\"t\":[\"不是线程安全的\",\"多线程下扩容死循环 \",\"在JDK1.7中，HashMap使用头插法插入元素，当多个线程同时进行扩容操作时，可能会导致环形链表的出现，从而形成死循环\",\"JDK1.8中的HashMap改为使用尾插法插入元素，在扩容时保持链表元素原本的顺序，避免了环形链表的问题\",\"多线程的put可能导致元素的丢失 \",\"当多个线程同时执行put操作时，如果计算出来的索引位置相同，就会导致后一个key覆盖前一个key，从而导致元素的丢失\",\"这个问题在JDK1.7和JDK1.8中都存在\",\"put和get并发时，可能导致get为null \",\"当一个线程执行put操作导致扩容时，另一个线程同时执行get操作\",\"由于扩容过程中元素迁移的不可见性，可能导致get操作返回null\",\"这个问题在JDK1.7和JDK1.8中都存在\"]},\"160\":{\"h\":\"有什么办法能解决HashMap线程不安全的问题呢？\",\"t\":[\"使用线程安全的包装类 \",\"使用 Collections.synchronizedMap() 方法将HashMap包装成线程安全的Map\",\"这个方法返回一个线程安全的Map对象，对该对象的操作会自动进行同步，从而保证线程安全\",\"使用同步机制 \",\"可以使用 synchronized 关键字或其他同步机制（如ReentrantLock ）对HashMap进行加锁\",\"使用线程安全的并发容器 \",\"可以使用 ConcurrentHashMap 代替HashMap\",\"ConcurrentHashMap 是Java提供的线程安全的哈希表实现，通过使用锁分段技术和CAS操作来实现高效的并发性能\"]},\"161\":{\"h\":\"能说一下ConcurrentHashmap的具体实现吗？\",\"t\":[\"ConcurrentHashmap线程安全在jdk1.7版本是基于 分段锁 实现\",\"在jdk1.8是基于CAS+synchronized 实现\"]},\"162\":{\"h\":\"JDK1.7：分段锁\",\"t\":[\"JDK1.7版本的ConcurrentHashMap采用分段锁机制 \",\"里面包含一个Segment数组，Segment继承于ReentrantLock，Segment则包含HashEntry的数组\",\"HashEntry本身就是一个链表的结构，具有保存key、value的能力能指向下一个节点的指针\",\"实际上就是相当于每个Segment都是一个HashMap\",\"默认的Segment长度是16，也就是支持16个线程的并发写，Segment之间相互不会受到影响\",\"put流程 \",\"计算hash，定位到segment，segment如果是空就先初始化\",\"使用ReentrantLock加锁，如果获取锁失败则尝试自旋，自旋超过次数就阻塞获取，保证一定获取锁成功\",\"遍历HashEntry，就是和HashMap一样，数组中key和hash一样就直接替换，不存在就再插入链表，链表同样操作\",\"get流程 \",\"key通过hash定位到segment，再遍历链表定位到具体的元素上\",\"需要注意的是value是volatile的，所以get是不需要加锁的\"]},\"163\":{\"h\":\"JDK1.8：CAS+synchronized\",\"t\":[\"数据结构\",\"数据结构和HashMap是一样的，数组+链表+红黑树\",\"它实现线程安全的关键点在于put流程\",\"put流程\",\"首先计算hash，遍历node数组，如果数组是空的话，就通过CAS+自旋的方式初始化数组\",\" if (tab == null || (n = tab.length) == 0) tab = initTable(); \",\"初始化数组\",\"private final Node<K,V>[] initTable() { Node<K,V>[] tab; int sc; while ((tab = table) == null || tab.length == 0) { //如果正在初始化或者扩容 if ((sc = sizeCtl) < 0) //等待(让出线程) Thread.yield(); // lost initialization race; just spin else if (U.compareAndSetInt(this, SIZECTL, sc, -1)) {//CAS操作 try { if ((tab = table) == null || tab.length == 0) { int n = (sc > 0) ? sc : DEFAULT_CAPACITY; @SuppressWarnings(\\\"unchecked\\\") Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n]; table = tab = nt; sc = n - (n >>> 2); } } finally { sizeCtl = sc; } break; } } return tab; } \",\"如果当前数组位置是空则直接通过CAS自旋写入数据\",\"else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) { if (casTabAt(tab, i, null, new Node<K,V>(hash, key, value))) break; // no lock when adding to empty bin } \",\"如果hash==MOVED，说明需要扩容，执行扩容\",\" final Node<K,V>[] helpTransfer(Node<K,V>[] tab, Node<K,V> f) { Node<K,V>[] nextTab; int sc; if (tab != null && (f instanceof ForwardingNode) && (nextTab = ((ForwardingNode<K,V>)f).nextTable) != null) { int rs = resizeStamp(tab.length) << RESIZE_STAMP_SHIFT; while (nextTab == nextTable && table == tab && (sc = sizeCtl) < 0) { if (sc == rs + MAX_RESIZERS || sc == rs + 1 || transferIndex <= 0) break; if (U.compareAndSetInt(this, SIZECTL, sc, sc + 1)) { transfer(tab, nextTab); break; } } return nextTab; } return table; } \",\"如果都不满足，就使用synchronized写入数据\",\"写入数据同样判断链表、红黑树，链表写入和HashMap的方式一样，key hash一样就覆盖，反之就尾插法，链表长度超过8就转换成红黑树\",\"get查询\",\"无锁化读取，和HashMap的get流程基本相同 \",\"头节点通过Unsafe获取\"]},\"164\":{\"h\":\"HashMap 内部节点是有序的吗？\",\"t\":[\"HashMap 内部节点的顺序是无序的\",\"因为 HashMap 使用的是哈希表的数据结构，它通过哈希函数将键映射到桶（bucket）中，而不是按照插入顺序进行存储\",\"如果需要有序的存储和遍历元素，可以考虑使用 LinkedHashMap 或者 TreeMap\"]},\"165\":{\"h\":\"讲讲 LinkedHashMap 怎么实现有序的？\",\"t\":[\"LinkedHashMap在 HashMap 的基础上维护了一个双向链表，用于记录元素的插入顺序或访问顺序\",\"通过这个链表， LinkedHashMap 可以按照插入顺序或访问顺序进行遍历。\"]},\"166\":{\"h\":\"讲讲 TreeMap 怎么实现有序的？\",\"t\":[\"TreeMap 是基于红黑树实现的，是一种有序的的集合\",\"在 TreeMap 中，元素是按照是按照 Key 的自然顺序或者 Comprator 的顺序进行排序，因此可以通过键值来遍历 集合中的元素 \",\"不是通过插入顺序遍历\"]},\"167\":{\"h\":\"Set\"},\"168\":{\"h\":\"讲讲HashSet的底层实现？\",\"t\":[\"HashSet 底层就是基于 HashMap 实现的\",\"HashSet 的源码⾮常⾮常少，因为除了clone() 、 writeObject() 、 readObject() 是 HashSet⾃⼰不得不实现之外，其他⽅法都是直接调⽤ HashMap 中的⽅法。\",\"HashSet的add方法\",\" public boolean add(E e) { return map.put(e, PRESENT)==null; } \",\"直接调用HashMap的put方法，将添加的元素作为key，new一个Object作为value\",\"会根据返回值是否为空来判断是否插入元素成功\",\"HashMap的putVal\",\"进行了一系列判断，最后的结果是，只有在key在table数组中不存在的时候，才会返回插入的值\",\"if (e != null) { // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; } \"]},\"169\":{\"h\":\"引言\"},\"170\":{\"h\":\"说说有哪些常见集合？\",\"t\":[\"List\",\"Map\",\"Set\"]},\"171\":{\"h\":\"Posts\"},\"172\":{\"h\":\"Java基础\"},\"173\":{\"h\":\"Java\"},\"174\":{\"h\":\"Java并发\"},\"175\":{\"h\":\"Java集合\"}},\"dirtCount\":0,\"index\":[[\"才会返回插入的值\",{\"1\":{\"168\":1}}],[\"才能缩写成\",{\"1\":{\"33\":1}}],[\"底层就是基于\",{\"1\":{\"168\":1}}],[\"底部设置change\",{\"1\":{\"20\":1}}],[\"怎么实现有序的\",{\"0\":{\"165\":1,\"166\":1}}],[\"怎么办\",{\"1\":{\"68\":1}}],[\"讲讲hashset的底层实现\",{\"0\":{\"168\":1}}],[\"讲讲\",{\"0\":{\"165\":1,\"166\":1}}],[\"头节点通过unsafe获取\",{\"1\":{\"163\":1}}],[\"具有保存key\",{\"1\":{\"162\":1}}],[\"具体唤醒哪个等待的线程是随机的\",{\"1\":{\"120\":1}}],[\"另一个线程同时执行get操作\",{\"1\":{\"159\":1}}],[\"冲突解决\",{\"1\":{\"158\":1}}],[\"冲突处理\",{\"1\":{\"139\":1}}],[\"渐进式扩容\",{\"1\":{\"157\":1}}],[\"动态调整链表和红黑树的阈值\",{\"1\":{\"157\":1}}],[\"动态地替换\",{\"1\":{\"44\":1}}],[\"树化阈值\",{\"1\":{\"157\":1}}],[\"种优化是为了解决在极端情况下链表过长导致的性能问题\",{\"1\":{\"157\":1}}],[\"老容量==1\",{\"1\":{\"156\":1}}],[\"老容量==0\",{\"1\":{\"156\":1}}],[\"现在位置=原先位置+oldcap\",{\"1\":{\"156\":1}}],[\"现在位置=原先位置\",{\"1\":{\"156\":1}}],[\"空位比较多的时候就扩容了\",{\"1\":{\"155\":1}}],[\"空位比较少的时候才扩容\",{\"1\":{\"155\":1}}],[\"空间成本就增加了\",{\"1\":{\"155\":1}}],[\"空间\",{\"1\":{\"155\":1}}],[\"假如我们设的比较大\",{\"1\":{\"155\":1}}],[\"假如发生碰撞\",{\"1\":{\"153\":1}}],[\"成本平衡的考虑\",{\"1\":{\"155\":1}}],[\"成本和\",{\"1\":{\"155\":1}}],[\"成员变量的默认值根据其类型而定\",{\"1\":{\"92\":1}}],[\"成员变量包括实例变量和静态变量\",{\"1\":{\"92\":1}}],[\"成员变量是在类中声明的变量\",{\"1\":{\"92\":1}}],[\"成员变量\",{\"1\":{\"92\":1,\"127\":1}}],[\"成员变量与局部变量的区别有哪些\",{\"0\":{\"92\":1}}],[\"临界值threshold\",{\"1\":{\"154\":1}}],[\"出现节点个数的概率是递减的\",{\"1\":{\"153\":1}}],[\"出于效率的考虑\",{\"1\":{\"132\":1}}],[\"理想情况下\",{\"1\":{\"153\":1}}],[\"牺牲了空间换时间\",{\"1\":{\"153\":1}}],[\"建立公共溢出区\",{\"1\":{\"152\":1}}],[\"建议使用\",{\"1\":{\"32\":1}}],[\"换种哈希函数\",{\"1\":{\"152\":1}}],[\"第二次增加2^2\",{\"1\":{\"152\":1}}],[\"第一次增加\",{\"1\":{\"152\":1}}],[\"个位置\",{\"1\":{\"152\":1}}],[\"个槽位中\",{\"1\":{\"109\":1}}],[\"依次判断下一个位置是否空闲\",{\"1\":{\"152\":1}}],[\"依存于类的实例\",{\"1\":{\"93\":1}}],[\"线行探查法\",{\"1\":{\"152\":1}}],[\"线程b对集合对象的内容进行了修改\",{\"1\":{\"134\":1}}],[\"线程b可以调用线程interrupt\",{\"1\":{\"120\":1}}],[\"线程内\",{\"1\":{\"127\":1}}],[\"线程thread除了提供join\",{\"1\":{\"127\":1}}],[\"线程间有哪些通信方式\",{\"0\":{\"127\":1}}],[\"线程上下文切换通常发生在以下几种情况下\",{\"0\":{\"125\":1}}],[\"线程上下文切换是一种非常耗时的操作\",{\"1\":{\"124\":1}}],[\"线程上下文切换是指在多线程环境下\",{\"1\":{\"124\":1}}],[\"线程不会再进入任何状态\",{\"1\":{\"123\":1}}],[\"线程被创建\",{\"1\":{\"121\":1}}],[\"线程共有六种状态\",{\"1\":{\"121\":1}}],[\"线程有几种状态\",{\"0\":{\"121\":1}}],[\"线程有哪些常用的调度方法\",{\"0\":{\"120\":1}}],[\"线程中断\",{\"1\":{\"120\":1}}],[\"线程休眠\",{\"1\":{\"120\":1}}],[\"线程是不会继续执行的\",{\"1\":{\"120\":1}}],[\"线程是进程的一个执行路径\",{\"1\":{\"116\":1}}],[\"线程会被自动唤醒\",{\"1\":{\"120\":1}}],[\"线程a实际并没有被中断\",{\"1\":{\"120\":1}}],[\"线程a会暂时让出指定时间的执行权\",{\"1\":{\"120\":1}}],[\"线程a会被阻塞挂起\",{\"1\":{\"120\":1}}],[\"线程a抛出interruptedexception异常返回\",{\"1\":{\"120\":1}}],[\"线程等待与通知\",{\"1\":{\"120\":1}}],[\"线程\",{\"1\":{\"116\":1,\"126\":2}}],[\"线程在任何地方读取的都是它写入的变量\",{\"1\":{\"102\":1}}],[\"线程可以在任何地方使用localvariable\",{\"1\":{\"102\":1}}],[\"线程安全\",{\"1\":{\"60\":2,\"83\":1}}],[\"线程安全性\",{\"1\":{\"60\":1,\"136\":1}}],[\"找到空闲位置的方法也有很多\",{\"1\":{\"152\":1}}],[\"给冲突元素找个空位\",{\"1\":{\"152\":1}}],[\"给编译器用的\",{\"1\":{\"81\":1}}],[\"链地址法\",{\"1\":{\"152\":1,\"158\":1}}],[\"链表长度超过8就转换成红黑树\",{\"1\":{\"163\":1}}],[\"链表长度大于等于8\",{\"1\":{\"145\":1}}],[\"链表写入和hashmap的方式一样\",{\"1\":{\"163\":1}}],[\"链表同样操作\",{\"1\":{\"162\":1}}],[\"链表插入方式\",{\"1\":{\"157\":1}}],[\"链表转树阈值\",{\"1\":{\"157\":1}}],[\"链表转红黑树的阈值为什么要选8呢\",{\"1\":{\"153\":1}}],[\"链表结构扩容后\",{\"1\":{\"156\":1}}],[\"链表里的节点符合泊松分布\",{\"1\":{\"153\":1}}],[\"链表\",{\"1\":{\"139\":2}}],[\"折叠法\",{\"1\":{\"151\":1}}],[\"作为映射的位置\",{\"1\":{\"151\":1}}],[\"作者\",{\"1\":{\"32\":1}}],[\"散列函数\",{\"1\":{\"158\":1}}],[\"散列也更均衡\",{\"1\":{\"151\":1}}],[\"散列方法重新计算位置\",{\"1\":{\"110\":1}}],[\"散列方法就是怎么把对应的key映射到table数组的相应下标\",{\"1\":{\"108\":1}}],[\"散列方法\",{\"1\":{\"108\":1}}],[\"效率更高\",{\"1\":{\"151\":1}}],[\"效果\",{\"0\":{\"13\":1}}],[\"除留取余法\",{\"1\":{\"151\":1}}],[\"离得最近的2的倍数\",{\"1\":{\"150\":1}}],[\"初始化数组\",{\"1\":{\"163\":1}}],[\"初始化时\",{\"1\":{\"150\":1}}],[\"初始状态\",{\"1\":{\"121\":1}}],[\"利用扩容后的大小也是2的倍数\",{\"1\":{\"149\":1}}],[\"补全到和hash值一样多的位数\",{\"1\":{\"149\":1}}],[\"取\",{\"1\":{\"151\":2}}],[\"取余是去除整数倍\",{\"1\":{\"149\":1}}],[\"取出key的threadlocalhashcode\",{\"1\":{\"108\":1}}],[\"扰动函数能降hash碰撞\",{\"0\":{\"148\":1}}],[\"扰动函数是怎么设计的\",{\"0\":{\"147\":1}}],[\"降低了哈希冲突的概率\",{\"1\":{\"147\":1}}],[\"达到高位与低位混合的效果\",{\"1\":{\"147\":1}}],[\"覆盖逻辑\",{\"1\":{\"145\":1}}],[\"覆盖\",{\"1\":{\"145\":1}}],[\"根据哈希值计算下标\",{\"1\":{\"145\":1}}],[\"根节点是黑色的\",{\"1\":{\"141\":1}}],[\"根节点和叶子节点\",{\"1\":{\"141\":1}}],[\"判断是否超过阈值\",{\"1\":{\"145\":1}}],[\"判断tab\",{\"1\":{\"145\":1}}],[\"判断tab是否位空或者长度为0\",{\"1\":{\"145\":1}}],[\"判断两个对象是否相等\",{\"1\":{\"96\":1}}],[\"判断两个对象是不是同⼀个对象\",{\"1\":{\"96\":1}}],[\"^\",{\"1\":{\"145\":1}}],[\"获取节点\",{\"1\":{\"146\":1}}],[\"获取新的哈希值\",{\"1\":{\"146\":1}}],[\"获取一个新的哈希值\",{\"1\":{\"145\":1}}],[\"获取到key的哈希值\",{\"1\":{\"147\":1}}],[\"获取到\",{\"1\":{\"120\":1}}],[\"左旋和右旋\",{\"1\":{\"144\":1}}],[\"左子节点的值小于等于当前节点的值\",{\"1\":{\"141\":1}}],[\"染色\",{\"1\":{\"144\":2}}],[\"旋转分为两种\",{\"1\":{\"144\":1}}],[\"旋转\",{\"1\":{\"144\":2}}],[\"避免了环形链表的问题\",{\"1\":{\"159\":1}}],[\"避免了一次性重新计算所有键的哈希值和索引位置\",{\"1\":{\"157\":1}}],[\"避免了这种退化情况\",{\"1\":{\"142\":1}}],[\"避免了线程\",{\"1\":{\"102\":1}}],[\"导致资源浪费\",{\"1\":{\"153\":1}}],[\"导致插入和删除操作的效率较低\",{\"1\":{\"143\":1}}],[\"导致插入\",{\"1\":{\"142\":1}}],[\"导致程序直接退出\",{\"1\":{\"73\":1}}],[\"普通的二叉搜索树在最坏情况下可能会退化成链表\",{\"1\":{\"142\":1}}],[\"普通的直接引用\",{\"1\":{\"90\":1}}],[\"黑色节点的数量是相同的\",{\"1\":{\"141\":1}}],[\"黑色节点计数\",{\"1\":{\"141\":1}}],[\"红色节点的子节点必须是黑色的\",{\"1\":{\"141\":1}}],[\"红色节点限制\",{\"1\":{\"141\":1}}],[\"红黑树的平均时间复杂度为o\",{\"1\":{\"157\":1}}],[\"红黑树转回链表的阈值为什么是6\",{\"1\":{\"153\":1}}],[\"红黑树节点的大小大概是普通节点大小的两倍\",{\"1\":{\"153\":1}}],[\"红黑树有两种方式保持平衡\",{\"1\":{\"144\":1}}],[\"红黑树怎么保持平衡的知道吗\",{\"0\":{\"144\":1}}],[\"红黑树通过引入节点颜色和特定性质\",{\"1\":{\"143\":1}}],[\"红黑树在保持平衡的过程中旋转的次数较少\",{\"1\":{\"143\":1}}],[\"红黑树相对于普通的二叉搜索树的优势在于它能够保持良好的平衡\",{\"1\":{\"142\":1}}],[\"红黑树是一种自平衡的二叉搜索树\",{\"1\":{\"141\":1}}],[\"红黑树\",{\"1\":{\"139\":1,\"163\":1}}],[\"叶子节点\",{\"1\":{\"141\":1}}],[\"要么是黑色\",{\"1\":{\"141\":1}}],[\"节点重新hash获取位置\",{\"1\":{\"158\":1}}],[\"节点增减刚好在8附近\",{\"1\":{\"153\":1}}],[\"节点个数为8的情况\",{\"1\":{\"153\":1}}],[\"节点颜色\",{\"1\":{\"141\":1}}],[\"节点流\",{\"1\":{\"28\":1}}],[\"右子节点的值大于等于当前节点的值\",{\"1\":{\"141\":1}}],[\"二叉搜索树性质\",{\"1\":{\"141\":1}}],[\"平方探查法\",{\"1\":{\"152\":1}}],[\"平方的中间几位作为映射的位置\",{\"1\":{\"151\":1}}],[\"平方取中法\",{\"1\":{\"151\":1}}],[\"平衡树呢\",{\"0\":{\"140\":1}}],[\"平台无关性\",{\"1\":{\"38\":1}}],[\"插入和删除操作的效率\",{\"1\":{\"157\":1}}],[\"插入和删除的效率\",{\"1\":{\"139\":1}}],[\"插件系统等\",{\"1\":{\"44\":1}}],[\"哈希碰撞优化\",{\"1\":{\"157\":1}}],[\"哈希值是一个32位的int类型的数值\",{\"1\":{\"147\":1}}],[\"哈希函数\",{\"1\":{\"139\":1}}],[\"哈希码常用于哈希表等数据结构的实现中\",{\"1\":{\"97\":1}}],[\"哈希码是一个整数\",{\"1\":{\"97\":1}}],[\"能说一下concurrenthashmap的具体实现吗\",{\"0\":{\"161\":1}}],[\"能说一下hashmap的数据结构吗\",{\"0\":{\"139\":1}}],[\"能够正确地工作并保持一致性\",{\"1\":{\"97\":1}}],[\"保证一定获取锁成功\",{\"1\":{\"162\":1}}],[\"保证极端情况下的查找效率\",{\"1\":{\"153\":1}}],[\"保证了树的相对平衡\",{\"1\":{\"143\":1}}],[\"保证了操作的最坏时间复杂度为o\",{\"1\":{\"142\":1}}],[\"保证了可见性\",{\"1\":{\"136\":1}}],[\"保留整数倍以下的数据\",{\"1\":{\"149\":1}}],[\"保留的是hash值的地位特征\",{\"1\":{\"148\":1}}],[\"保持插入顺序或访问顺序\",{\"1\":{\"83\":1}}],[\"工作流程\",{\"1\":{\"136\":1}}],[\"写完将元素数组指向副本\",{\"1\":{\"136\":1}}],[\"写操作在副本上\",{\"1\":{\"136\":1}}],[\"写操作较少的情况下\",{\"1\":{\"136\":1}}],[\"写时复制\",{\"1\":{\"136\":1}}],[\"写入数据同样判断链表\",{\"1\":{\"163\":1}}],[\"写入变量\",{\"1\":{\"102\":1}}],[\"写入\",{\"1\":{\"102\":1}}],[\"策略\",{\"1\":{\"134\":1}}],[\"迭代器提供的是一个一致性视图\",{\"1\":{\"136\":1}}],[\"迭代器的弱一致性\",{\"1\":{\"136\":1}}],[\"迭代器遍历的是开始遍历那一刻拿到的集合拷贝\",{\"1\":{\"134\":1}}],[\"迭代器并不能访问到修改后的内容\",{\"1\":{\"134\":1}}],[\"迭代器在遍历时直接访问集合中的内容\",{\"1\":{\"134\":1}}],[\"迭代过程中被修改\",{\"1\":{\"134\":1}}],[\"场景\",{\"1\":{\"134\":2}}],[\"集合中的元素\",{\"1\":{\"166\":1}}],[\"集合在被遍历期间如果内容发生变化\",{\"1\":{\"134\":1}}],[\"集合基础\",{\"0\":{\"82\":1}}],[\"删除和查找操作的时间复杂度变为o\",{\"1\":{\"142\":1}}],[\"删除\",{\"1\":{\"134\":1}}],[\"删除或修改了类的属性\",{\"1\":{\"68\":1}}],[\"触发\",{\"1\":{\"134\":1}}],[\"触发扩容\",{\"1\":{\"130\":1}}],[\"快速失败是java集合的一种错误检测机制\",{\"1\":{\"134\":1}}],[\"快速失败\",{\"0\":{\"134\":1},\"1\":{\"134\":1}}],[\"剩下的50不用其实不用序列化\",{\"1\":{\"132\":1}}],[\"复制原数组元素到新数组\",{\"1\":{\"130\":1}}],[\"容量大小为原数组1\",{\"1\":{\"130\":1}}],[\"计算hash\",{\"1\":{\"162\":1}}],[\"计算数组下标\",{\"1\":{\"146\":1}}],[\"计算新数组容量\",{\"1\":{\"130\":1}}],[\"计数\",{\"1\":{\"36\":1}}],[\"标记不支持随机访问\",{\"1\":{\"129\":1}}],[\"标记自身也可以设置一些值\",{\"1\":{\"81\":1}}],[\"双向链表的插入和删除只需要改变前驱节点\",{\"1\":{\"129\":1}}],[\"甚至还有可能触发扩容\",{\"1\":{\"129\":1}}],[\"增加\",{\"1\":{\"134\":1}}],[\"增删速率\",{\"1\":{\"129\":1}}],[\"增量为\",{\"1\":{\"108\":1}}],[\"两种集合都需要遍历\",{\"1\":{\"129\":1}}],[\"两个具备超时特性的方法\",{\"1\":{\"127\":1}}],[\"两个线程都执行了\",{\"1\":{\"115\":1}}],[\"两个线程都在执行\",{\"1\":{\"115\":1}}],[\"两个\",{\"1\":{\"61\":1}}],[\"两个语句都会去字符串常量池中检查是否已经存在\",{\"1\":{\"61\":1}}],[\"查找时间成本降低\",{\"1\":{\"155\":1}}],[\"查找的时间成本就增加了\",{\"1\":{\"155\":1}}],[\"查找红黑树\",{\"1\":{\"146\":1}}],[\"查找速率\",{\"1\":{\"129\":1}}],[\"查看\",{\"1\":{\"11\":1}}],[\"任意数\",{\"1\":{\"149\":1}}],[\"任意对象为值的存储结构\",{\"1\":{\"127\":1}}],[\"任何一个线程都能并发访问localvariable\",{\"1\":{\"102\":1}}],[\"任何对string的修改都会创建一个新的string对象\",{\"1\":{\"60\":1}}],[\"任何对\",{\"1\":{\"59\":1}}],[\"符\",{\"1\":{\"127\":1}}],[\"管道输入\",{\"1\":{\"127\":3}}],[\"守护线程\",{\"1\":{\"126\":1}}],[\"守护线程了解吗\",{\"0\":{\"126\":1}}],[\"锁的释放等\",{\"1\":{\"125\":1}}],[\"应尽量减少线程上下文切换的次数\",{\"1\":{\"124\":1}}],[\"应用程序可以在不修改源代码的情况下\",{\"1\":{\"44\":1}}],[\"应用程序可以在缓冲区中读取或写入数据\",{\"1\":{\"30\":1}}],[\"应用程序定义一个接口\",{\"1\":{\"44\":1}}],[\"应用程序\",{\"1\":{\"30\":1}}],[\"堆栈指针等信息\",{\"1\":{\"124\":1}}],[\"堆中的对象也会拷贝一份\",{\"1\":{\"99\":1}}],[\"包括寄存器状态\",{\"1\":{\"124\":1}}],[\"包括java\",{\"1\":{\"39\":1}}],[\"操作系统会将\",{\"1\":{\"125\":2}}],[\"操作系统会强制进行线程上下文切换\",{\"1\":{\"125\":1}}],[\"操作系统会保存当前线程的上下文\",{\"1\":{\"124\":1}}],[\"操作的数据量较小\",{\"1\":{\"60\":1}}],[\"无锁化读取\",{\"1\":{\"163\":1}}],[\"无锁\",{\"1\":{\"136\":1}}],[\"无法继续执行\",{\"1\":{\"122\":1}}],[\"无序\",{\"1\":{\"83\":1}}],[\"终止遍历\",{\"1\":{\"134\":1}}],[\"终止状态\",{\"1\":{\"121\":1}}],[\"终端操作会返回一个结果\",{\"1\":{\"36\":1}}],[\"终端操作\",{\"1\":{\"36\":1}}],[\"超过则扩容\",{\"1\":{\"145\":1}}],[\"超过范围\",{\"1\":{\"64\":1}}],[\"超时等待状态\",{\"1\":{\"121\":1}}],[\"程需要等待其他线程做出一些特定动作\",{\"1\":{\"121\":1}}],[\"程序计数器\",{\"1\":{\"124\":1}}],[\"程序将无法继续执行\",{\"1\":{\"73\":2}}],[\"程序还没有进入try语句块就因为异常导致程序终止\",{\"1\":{\"73\":1}}],[\"程序运行中出现异常\",{\"1\":{\"71\":1}}],[\"程序返回\",{\"1\":{\"55\":1}}],[\"程序要经过先编译\",{\"1\":{\"42\":1}}],[\"程序从源代码到运行主要有三步\",{\"1\":{\"41\":1}}],[\"程序所需的所有内容的集合\",{\"1\":{\"39\":1}}],[\"阻塞呗\",{\"1\":{\"137\":1}}],[\"阻塞状态\",{\"1\":{\"121\":1}}],[\"阻止实例中那些用此关键字修饰的的变量序列化\",{\"1\":{\"68\":1}}],[\"统的称作\",{\"1\":{\"121\":1}}],[\"状态\",{\"1\":{\"121\":1}}],[\"检测当前线程是否被中断\",{\"1\":{\"120\":2}}],[\"让出线程\",{\"1\":{\"163\":1}}],[\"让出优先权\",{\"1\":{\"120\":1}}],[\"让后统计数量\",{\"1\":{\"36\":1}}],[\"资源后就可以继续运行\",{\"1\":{\"120\":1}}],[\"指定的睡眠时间到了后该函数会正常返回\",{\"1\":{\"120\":1}}],[\"指向对象本身的一个指针\",{\"1\":{\"90\":1}}],[\"函数会唤醒被阻塞到该共享变量上的一个线程\",{\"1\":{\"120\":1}}],[\"函数\",{\"1\":{\"120\":1,\"126\":1}}],[\"函数作为参数传递到方法中\",{\"1\":{\"32\":1}}],[\"直至找到空闲的位置\",{\"1\":{\"152\":1}}],[\"直至找到空闲位置\",{\"1\":{\"152\":1}}],[\"直到其他线程通过\",{\"1\":{\"120\":1}}],[\"直接调用hashmap的put方法\",{\"1\":{\"168\":1}}],[\"直接根据\",{\"1\":{\"151\":1}}],[\"直接定址法\",{\"1\":{\"151\":1}}],[\"直接插入或者删除就可以了\",{\"1\":{\"129\":1}}],[\"直接\",{\"1\":{\"74\":1}}],[\"直接返回字符串常量池中的字符串\",{\"1\":{\"63\":1}}],[\"直接返回\",{\"1\":{\"55\":1,\"146\":1}}],[\"灵活性\",{\"1\":{\"119\":1}}],[\"例\",{\"1\":{\"119\":2}}],[\"例如十位和百位\",{\"1\":{\"151\":1}}],[\"例如1232放到下标1232的位置\",{\"1\":{\"151\":1}}],[\"例如整型默认为0\",{\"1\":{\"92\":1}}],[\"例如添加\",{\"1\":{\"68\":1}}],[\"例如\",{\"1\":{\"59\":1,\"97\":1,\"120\":1}}],[\"例如图像\",{\"1\":{\"29\":1}}],[\"代替hashmap\",{\"1\":{\"160\":1}}],[\"代码复\",{\"1\":{\"119\":1}}],[\"代表\",{\"1\":{\"78\":1}}],[\"系列方法而被挂起的线程\",{\"1\":{\"120\":1}}],[\"系列方法后被挂起的线程\",{\"1\":{\"120\":1}}],[\"系\",{\"1\":{\"119\":1}}],[\"系统自动抛异常\",{\"1\":{\"72\":1}}],[\"系统的实现\",{\"1\":{\"39\":1}}],[\"特点\",{\"1\":{\"119\":1,\"136\":1}}],[\"确保线程安全\",{\"1\":{\"135\":1}}],[\"确保子线程能够正确获取父线程最新的值\",{\"1\":{\"113\":1}}],[\"确保这是你正在使用的分支名称\",{\"1\":{\"16\":1}}],[\"鄙人三某\",{\"1\":{\"111\":1}}],[\"鄙人张三\",{\"1\":{\"102\":1}}],[\"子线程\",{\"1\":{\"111\":1,\"112\":1}}],[\"子类可以扩大方法的访问范围\",{\"1\":{\"88\":1}}],[\"父子线程怎么共享数据\",{\"0\":{\"111\":1}}],[\"父类不希望子类出现更多的异常\",{\"1\":{\"88\":1}}],[\"遍历node数组\",{\"1\":{\"163\":1}}],[\"遍历hashentry\",{\"1\":{\"162\":1}}],[\"遍历hashmap的几种方法\",{\"0\":{\"84\":1}}],[\"遍历链表查找\",{\"1\":{\"146\":1}}],[\"遍历下一个元素之前\",{\"1\":{\"134\":1}}],[\"遍历完成之后\",{\"1\":{\"110\":1}}],[\"扩容\",{\"1\":{\"158\":1}}],[\"扩容优化\",{\"1\":{\"157\":1}}],[\"扩容在什么时候呢\",{\"0\":{\"154\":1}}],[\"扩容后的\",{\"1\":{\"110\":1}}],[\"扩展或定制某个功能或组件的实现\",{\"1\":{\"44\":1}}],[\"清理过期entry\",{\"1\":{\"110\":1}}],[\"逻辑\",{\"1\":{\"110\":1}}],[\"逻辑与\",{\"1\":{\"53\":1}}],[\"且当前散列数组中\",{\"1\":{\"110\":1}}],[\"未清理到任何数据\",{\"1\":{\"110\":1}}],[\"定位到segment\",{\"1\":{\"162\":1}}],[\"定位到table中的位置\",{\"1\":{\"109\":1}}],[\"定义\",{\"1\":{\"120\":1}}],[\"定义服务接口\",{\"1\":{\"44\":1}}],[\"定义了服务的契约\",{\"1\":{\"44\":1}}],[\"已经明示了它的原理\",{\"1\":{\"136\":1}}],[\"已经有了\",{\"1\":{\"109\":1}}],[\"已经被修改为\",{\"1\":{\"74\":1}}],[\"往后找一圈没找到就会从头开始找\",{\"1\":{\"109\":1}}],[\"分段锁\",{\"0\":{\"162\":1},\"1\":{\"161\":1}}],[\"分割成位数相同的几段\",{\"1\":{\"151\":1}}],[\"分别为\",{\"1\":{\"126\":1}}],[\"分别代表\",{\"1\":{\"78\":1}}],[\"分布非常均匀\",{\"1\":{\"108\":1}}],[\"带来的好处就是\",{\"1\":{\"108\":1}}],[\"黄金分割数\",{\"1\":{\"108\":1}}],[\"每当迭代器使用hashnext\",{\"1\":{\"134\":1}}],[\"每创建一个threadlocal对象\",{\"1\":{\"108\":1}}],[\"每个节点要么是红色\",{\"1\":{\"141\":1}}],[\"每个键值对根据哈希函数计算得到一个桶的索引\",{\"1\":{\"139\":1}}],[\"每个桶存储一个键值对\",{\"1\":{\"139\":1}}],[\"每个threadlocal实例都对应着一个threadlocalmap对象\",{\"1\":{\"107\":1}}],[\"每个线程需要创建新实\",{\"1\":{\"119\":1}}],[\"每个线程有自己的程序计数器和栈\",{\"1\":{\"116\":1}}],[\"每个线程在往threadlocal里设置值的时候\",{\"1\":{\"104\":1}}],[\"每个线程都有一个属于自己的threadlocalmap\",{\"1\":{\"104\":1}}],[\"每个entry代表一个完整的对象\",{\"1\":{\"104\":1}}],[\"每个类都有一个对应的class对象\",{\"1\":{\"48\":1}}],[\"每个服务提供者将自己的实现类配置到一个特定的配置文件中\",{\"1\":{\"44\":1}}],[\"每个实现类占据一行\",{\"1\":{\"44\":1}}],[\"相比于链表的o\",{\"1\":{\"157\":1}}],[\"相比于平衡二叉树\",{\"1\":{\"143\":1}}],[\"相反\",{\"1\":{\"120\":1}}],[\"相对较高\",{\"1\":{\"119\":2}}],[\"相对较低\",{\"1\":{\"119\":2}}],[\"相当于顺序执行\",{\"1\":{\"118\":1}}],[\"相当于取余\",{\"1\":{\"108\":1}}],[\"相等吗\",{\"0\":{\"64\":1}}],[\"元素是按照是按照\",{\"1\":{\"166\":1}}],[\"元素比较少\",{\"1\":{\"155\":1}}],[\"元素比较多\",{\"1\":{\"155\":1}}],[\"元素数组\",{\"1\":{\"108\":1}}],[\"元空间\",{\"1\":{\"92\":1}}],[\"及时调用remove\",{\"1\":{\"106\":1}}],[\"那arraylist怎么序列化呢\",{\"0\":{\"133\":1}}],[\"那怎么不直接调用run\",{\"0\":{\"118\":1}}],[\"那怎么解决内存泄漏问题呢\",{\"0\":{\"106\":1}}],[\"那就接着去找空着的坑\",{\"1\":{\"109\":1}}],[\"那么发生哈希冲突的概率就增加了\",{\"1\":{\"155\":1}}],[\"那么为什么选择了0\",{\"0\":{\"155\":1}}],[\"那么hash值高位是与0做\",{\"1\":{\"149\":1}}],[\"那么守护线程和用户线程有什么区别呢\",{\"1\":{\"126\":1}}],[\"那么run方法还是运行在主线程中\",{\"1\":{\"118\":1}}],[\"那么即使线程不再使用某个threadlocal实例\",{\"1\":{\"107\":1}}],[\"那么即使类的结构发生了变化\",{\"1\":{\"68\":1}}],[\"那么访问这个变量的每个线程都会有这个变量的一个本地拷贝\",{\"1\":{\"102\":1}}],[\"那么拷贝后对象\",{\"1\":{\"99\":1}}],[\"那么可以通过显式地指定serialversionuid来保持兼容性\",{\"1\":{\"68\":1}}],[\"那么序列化和反序列化时可能会出现版本不一致的问题\",{\"1\":{\"68\":1}}],[\"那么自动装箱时不会new新的integer对象\",{\"1\":{\"64\":1}}],[\"那么会生成多个中间对象\",{\"1\":{\"62\":2}}],[\"弱引用很容易被回收\",{\"1\":{\"105\":1}}],[\"弱引用\",{\"1\":{\"105\":1}}],[\"内存空间不连续\",{\"1\":{\"129\":1}}],[\"内存占用\",{\"1\":{\"129\":1}}],[\"内存泄露是怎么回事\",{\"0\":{\"105\":1}}],[\"内部节点的顺序是无序的\",{\"1\":{\"164\":1}}],[\"内部节点是有序的吗\",{\"0\":{\"164\":1}}],[\"内部同时还启动了很多守护线程\",{\"1\":{\"126\":1}}],[\"内部错误\",{\"1\":{\"71\":1}}],[\"读操作频繁且对实时性要求不高的场景\",{\"1\":{\"136\":1}}],[\"读操作在原数组上\",{\"1\":{\"136\":1}}],[\"读写分离\",{\"1\":{\"136\":1}}],[\"读也是以某个threadlocal作为引用\",{\"1\":{\"104\":1}}],[\"读取\",{\"1\":{\"102\":1}}],[\"读取或写入操作使用缓冲区\",{\"1\":{\"30\":1}}],[\"都会检测\",{\"1\":{\"134\":1}}],[\"都会回收该对象占用的内存\",{\"1\":{\"105\":1}}],[\"都会返回一个新的\",{\"1\":{\"59\":1}}],[\"都是往自己的threadlocalmap里存\",{\"1\":{\"104\":1}}],[\"存在一定空间浪费\",{\"1\":{\"129\":1}}],[\"存放token\",{\"1\":{\"103\":1}}],[\"存储结构\",{\"1\":{\"139\":1}}],[\"存储entry类型的元素\",{\"1\":{\"108\":1}}],[\"存储方式\",{\"1\":{\"92\":1}}],[\"存储字符串\",{\"1\":{\"60\":2}}],[\"或\",{\"1\":{\"120\":2}}],[\"或者等待时间到期\",{\"1\":{\"120\":1}}],[\"或者\",{\"1\":{\"120\":1,\"164\":1}}],[\"或者使用json序列化\",{\"1\":{\"100\":1}}],[\"或与底层设备进行通信时\",{\"1\":{\"29\":1}}],[\"采用安全失败机制的集合容器\",{\"1\":{\"134\":1}}],[\"采用clone机制\",{\"1\":{\"100\":1}}],[\"采用字节码的好处是什么\",{\"0\":{\"41\":1}}],[\"拷贝被拷贝对象的成员变量的值\",{\"1\":{\"99\":1}}],[\"完全拷贝一个对象\",{\"1\":{\"99\":1}}],[\"完成后才通知\",{\"1\":{\"30\":1}}],[\"深拷贝如何实现呢\",{\"1\":{\"99\":1}}],[\"深拷贝是安全的\",{\"1\":{\"99\":1}}],[\"深拷贝\",{\"1\":{\"99\":1}}],[\"仅拷贝被拷贝对象的成员变量的值\",{\"1\":{\"99\":1}}],[\"浅拷贝如何实现呢\",{\"1\":{\"99\":1}}],[\"浅拷贝的话如果有引用类型\",{\"1\":{\"99\":1}}],[\"浅拷贝\",{\"1\":{\"99\":1}}],[\"传的不是2的倍数时\",{\"1\":{\"150\":1}}],[\"传一个17的值\",{\"0\":{\"150\":1}}],[\"传递的是该引用的副本\",{\"1\":{\"98\":1}}],[\"传递的是该值的副本\",{\"1\":{\"98\":1}}],[\"传送门\",{\"1\":{\"1\":1}}],[\"主线程\",{\"1\":{\"111\":1}}],[\"主要目的是确保\",{\"1\":{\"97\":1}}],[\"主页\",{\"0\":{\"5\":1}}],[\"时间\",{\"1\":{\"155\":1}}],[\"时间复杂度都是o\",{\"1\":{\"129\":1}}],[\"时间复杂度是o\",{\"1\":{\"129\":2}}],[\"时间片时\",{\"1\":{\"125\":1}}],[\"时间片分配给另一个处于就绪状态的线程\",{\"1\":{\"125\":3}}],[\"时机\",{\"1\":{\"110\":1}}],[\"时\",{\"1\":{\"98\":1}}],[\"时必须重写\",{\"1\":{\"97\":1}}],[\"时的\",{\"0\":{\"89\":1}}],[\"quals\",{\"1\":{\"97\":1}}],[\"比较这两个对象\",{\"1\":{\"96\":1}}],[\"比如copyonwritearraylist类\",{\"1\":{\"134\":1}}],[\"比如arraylist\",{\"1\":{\"134\":1}}],[\"比如垃圾回收线程\",{\"1\":{\"126\":1}}],[\"比如锁还是持有不让出的\",{\"1\":{\"120\":1}}],[\"比如我们熟悉的空指针\",{\"1\":{\"71\":1}}],[\"比如虚拟机异常\",{\"1\":{\"71\":1}}],[\"等待\",{\"1\":{\"127\":1,\"163\":1}}],[\"等待状态\",{\"1\":{\"121\":1}}],[\"等\",{\"1\":{\"97\":1}}],[\"等价于通过\",{\"1\":{\"96\":1}}],[\"等等框架中都大量使用了反射机制\",{\"1\":{\"47\":1}}],[\"⽅法\",{\"1\":{\"96\":1,\"97\":1}}],[\"⽅法名\",{\"1\":{\"93\":3}}],[\"引言\",{\"0\":{\"169\":1}}],[\"引⽤数据类型==比较的是内存地址\",{\"1\":{\"96\":1}}],[\"引用类型变量单独克隆\",{\"1\":{\"99\":1}}],[\"引用类型变量修改\",{\"1\":{\"99\":1}}],[\"引用类型默认为null\",{\"1\":{\"92\":1}}],[\"引用本类的构造函数\",{\"1\":{\"90\":1}}],[\"引用数据类型\",{\"1\":{\"50\":1,\"59\":1}}],[\"经常被用在需要释放资源的情况下\",{\"1\":{\"95\":1}}],[\"经过拼接新生成了string对象\",{\"1\":{\"62\":1}}],[\"必须依存于某一实例\",{\"1\":{\"93\":1}}],[\"必须在由程序运⾏期间才能决定\",{\"1\":{\"87\":1}}],[\"静态方法里不能访问类的非静态成员变量和方法\",{\"1\":{\"93\":1}}],[\"静态方法\",{\"0\":{\"93\":1},\"1\":{\"93\":1}}],[\"静态变量可以实现让多个对象共享内存\",{\"1\":{\"93\":1}}],[\"静态变量在内存中有且仅有一个副本\",{\"1\":{\"93\":1}}],[\"静态变量在类被加载至数据区后\",{\"1\":{\"92\":1}}],[\"静态变量和实例变量的区别\",{\"0\":{\"93\":1}}],[\"静态变量存储在方法区\",{\"1\":{\"92\":1}}],[\"静态变量\",{\"1\":{\"92\":1,\"93\":1}}],[\"静态变量属于类的状态信息\",{\"1\":{\"68\":1}}],[\"非final修饰的成员变量具有默认值\",{\"1\":{\"92\":1}}],[\"非线程安全\",{\"1\":{\"60\":1}}],[\"随对象的销毁而销毁\",{\"1\":{\"92\":1}}],[\"随对象的创建而生\",{\"1\":{\"92\":1}}],[\"随着方法或代码块的执行而创建和销毁\",{\"1\":{\"92\":1}}],[\"生存周期\",{\"1\":{\"92\":1}}],[\"生成字节码\",{\"1\":{\"42\":1}}],[\"生成模板\",{\"1\":{\"11\":1}}],[\"生成\",{\"1\":{\"11\":1}}],[\"局部变量在使用前必须显式地进行初始化\",{\"1\":{\"92\":1}}],[\"局部变量只在方法或代码块内有效\",{\"1\":{\"92\":1}}],[\"局部变量存在栈内存中\",{\"1\":{\"92\":1}}],[\"局部变量是在方法中或代码块中声明的变量\",{\"1\":{\"92\":1}}],[\"设计层面\",{\"1\":{\"91\":1}}],[\"设置协议\",{\"1\":{\"11\":1}}],[\"设置应用描述\",{\"1\":{\"11\":1}}],[\"设置应用版本号\",{\"1\":{\"11\":1}}],[\"设置应用名称\",{\"1\":{\"11\":1}}],[\"抽象方法是为了被重写\",{\"1\":{\"91\":1}}],[\"抽象方法可以有public\",{\"1\":{\"91\":1}}],[\"抽象类是对类的抽象\",{\"1\":{\"91\":1}}],[\"抽象类\",{\"0\":{\"91\":1}}],[\"9允许在接口中定义私有方法\",{\"1\":{\"91\":1}}],[\"9e\",{\"1\":{\"50\":1}}],[\"变量\",{\"1\":{\"89\":2,\"91\":2,\"134\":1}}],[\"什么也不写\",{\"1\":{\"89\":1}}],[\"什么是红黑树\",{\"0\":{\"141\":1}}],[\"什么是线程上下文切换\",{\"0\":{\"124\":1}}],[\"什么是深拷贝和浅拷贝\",{\"0\":{\"99\":1}}],[\"什么是hashcode\",{\"1\":{\"97\":1}}],[\"什么是泛型擦除\",{\"0\":{\"79\":1}}],[\"什么是泛型\",{\"0\":{\"76\":1}}],[\"什么是反序列化\",{\"0\":{\"68\":1}}],[\"什么是反射\",{\"0\":{\"46\":1}}],[\"什么是序列化\",{\"0\":{\"68\":1}}],[\"什么是integer缓存\",{\"1\":{\"64\":1}}],[\"什么是自动拆箱\",{\"0\":{\"52\":1}}],[\"什么是自动类型转换\",{\"0\":{\"51\":1}}],[\"什么是字节码\",{\"0\":{\"41\":1}}],[\"重新计算冲突元素的地址\",{\"1\":{\"152\":1}}],[\"重写call\",{\"1\":{\"117\":1}}],[\"重写run\",{\"1\":{\"117\":2}}],[\"重写克隆方法\",{\"1\":{\"99\":2}}],[\"重写方法的访问权限可以更广\",{\"1\":{\"88\":1}}],[\"重写方法不能抛出范围更大的受控异常\",{\"1\":{\"88\":1}}],[\"重载\",{\"0\":{\"88\":1}}],[\"若为引用数据类型则返回值为被重写方法的返回值或是其子类\",{\"1\":{\"88\":1}}],[\"形参与成员变量名字重名\",{\"1\":{\"90\":1}}],[\"形参相同\",{\"1\":{\"88\":1}}],[\"形参不同\",{\"1\":{\"88\":1}}],[\"与\",{\"1\":{\"120\":1}}],[\"与异常类型更没关系\",{\"1\":{\"88\":1}}],[\"与返回值和修饰符无关\",{\"1\":{\"88\":1}}],[\"调用start\",{\"1\":{\"117\":1}}],[\"调用方法不同\",{\"1\":{\"88\":1}}],[\"调用类方法这时候就要用到反射\",{\"1\":{\"46\":1}}],[\"参数顺序满足任一\",{\"1\":{\"88\":1}}],[\"参数类型\",{\"1\":{\"88\":1}}],[\"参数个数\",{\"1\":{\"88\":1}}],[\"参考资料\",{\"1\":{\"9\":1}}],[\"⽽是在程序运⾏期间才确定\",{\"1\":{\"87\":1}}],[\"新hash值保留了高低位的特征\",{\"1\":{\"148\":1}}],[\"新类的定义可以增加新的属性或新的方法\",{\"1\":{\"87\":1}}],[\"新的api解决了旧的date和calendar类在处理日期和时间时的一些问题\",{\"1\":{\"32\":1}}],[\"新的日期和时间api\",{\"1\":{\"32\":1}}],[\"同时提供⼀些可以被外界访问的属性的⽅法\",{\"1\":{\"87\":1}}],[\"同步非阻塞io\",{\"1\":{\"30\":1}}],[\"同步阻塞io\",{\"1\":{\"30\":1}}],[\"屏蔽差异性\",{\"1\":{\"86\":1}}],[\"加锁\",{\"1\":{\"136\":1}}],[\"加强代码的重用\",{\"1\":{\"86\":1}}],[\"加入到已注册的通道列表\",{\"1\":{\"30\":1}}],[\"目的是为了写出通用的代码\",{\"1\":{\"86\":1}}],[\"目录下的配置文件\",{\"1\":{\"44\":1}}],[\"目录下\",{\"1\":{\"44\":2}}],[\"面向过程就是分析出解决问题所需要的步骤\",{\"1\":{\"86\":1}}],[\"面向对象有哪些特性\",{\"0\":{\"87\":1}}],[\"面向对象\",{\"0\":{\"85\":1},\"1\":{\"38\":1,\"86\":1}}],[\"⾯向对象\",{\"1\":{\"86\":1}}],[\"⾯向对象和⾯向过程的区别\",{\"0\":{\"86\":1}}],[\"⾯向过程\",{\"1\":{\"86\":1}}],[\"支持随机访问\",{\"1\":{\"129\":1}}],[\"支持高并发操作\",{\"1\":{\"83\":1}}],[\"支持多线程\",{\"1\":{\"38\":1}}],[\"允许键和值为null\",{\"1\":{\"83\":1}}],[\"允许把函数作为一个方法的参数\",{\"1\":{\"32\":1}}],[\"永久保存\",{\"1\":{\"81\":1}}],[\"没找到\",{\"1\":{\"81\":1}}],[\"没有取到才会创建新的对象\",{\"1\":{\"64\":1}}],[\"没有的话随便修改下master分支代码\",{\"1\":{\"21\":1}}],[\"属性上等\",{\"1\":{\"81\":1}}],[\"缺点\",{\"1\":{\"79\":1,\"134\":1,\"136\":1}}],[\"优点\",{\"1\":{\"79\":1}}],[\"键值中的\",{\"1\":{\"78\":1}}],[\"key通过hash定位到segment\",{\"1\":{\"162\":1}}],[\"key设计成弱引用同样是为了防止内存泄漏问题\",{\"1\":{\"107\":1}}],[\"key是threadlocal的弱引用\",{\"1\":{\"104\":1}}],[\"key\",{\"1\":{\"78\":2,\"105\":1,\"108\":1,\"145\":12,\"146\":13,\"151\":4,\"163\":2,\"166\":1,\"168\":1}}],[\"k\",{\"1\":{\"78\":1,\"110\":3,\"145\":6,\"146\":6}}],[\"kit\",{\"1\":{\"39\":1}}],[\"<\",{\"1\":{\"130\":1,\"163\":2}}],[\"<=\",{\"1\":{\"130\":2,\"163\":1}}],[\"<p>defaults\",{\"1\":{\"81\":1}}],[\"<t>\",{\"1\":{\"77\":4}}],[\"<<\",{\"1\":{\"56\":1,\"163\":1}}],[\"泛型信息会被擦除\",{\"1\":{\"79\":1}}],[\"泛型主要是为了提供编译时类型检查\",{\"1\":{\"79\":1}}],[\"泛型常用的通配符有哪些\",{\"0\":{\"78\":1}}],[\"泛型方法\",{\"1\":{\"77\":1}}],[\"泛型接口\",{\"1\":{\"77\":1}}],[\"泛型类\",{\"1\":{\"77\":1}}],[\"泛型的使用方法\",{\"0\":{\"77\":1}}],[\"泛型\",{\"0\":{\"75\":1}}],[\"然后把它们的叠加和作为映射的位置\",{\"1\":{\"151\":1}}],[\"然后与哈希值本身异或\",{\"1\":{\"147\":1}}],[\"然后再将哈希值右移16位\",{\"1\":{\"147\":1}}],[\"然后将键值对存储在该桶中\",{\"1\":{\"139\":1}}],[\"然后进行相应的操作\",{\"1\":{\"127\":1}}],[\"然后恢复下一个线程的上下文\",{\"1\":{\"124\":1}}],[\"然后table引用指向\",{\"1\":{\"110\":1}}],[\"然后放到新的newtab\",{\"1\":{\"110\":1}}],[\"然后遍历老的table数组\",{\"1\":{\"110\":1}}],[\"然后还要根据条件判断size\",{\"1\":{\"110\":1}}],[\"然后判断该槽位entry对象中的key是否和get的key一致\",{\"1\":{\"109\":1}}],[\"然后和table数组长度减一\",{\"1\":{\"108\":1}}],[\"然后到了真正要被回收的时候\",{\"1\":{\"95\":1}}],[\"然后用函数把这些步骤一步一步实现\",{\"1\":{\"86\":1}}],[\"然后搞一些事情\",{\"1\":{\"81\":1}}],[\"然后\",{\"1\":{\"74\":1}}],[\"之前\",{\"1\":{\"74\":1}}],[\"自旋超过次数就阻塞获取\",{\"1\":{\"162\":1}}],[\"自然也就走不到\",{\"1\":{\"74\":1}}],[\"自动装箱的时候会去缓存池里取integer对象\",{\"1\":{\"64\":1}}],[\"自动类型转换\",{\"1\":{\"51\":1}}],[\"了解吗\",{\"0\":{\"134\":1}}],[\"了\",{\"1\":{\"74\":2,\"95\":1}}],[\"里面包含一个segment数组\",{\"1\":{\"162\":1}}],[\"里面的\",{\"1\":{\"74\":1}}],[\"里定义的方法\",{\"1\":{\"95\":1}}],[\"里不按套路出牌\",{\"1\":{\"74\":1}}],[\"里的\",{\"1\":{\"74\":1}}],[\"结果为直接保留hash值对\",{\"1\":{\"149\":1}}],[\"结果\",{\"1\":{\"74\":1}}],[\"结束当前的方法\",{\"1\":{\"55\":1}}],[\"结束当前的循环体\",{\"1\":{\"55\":1}}],[\"结束正在执行的循环\",{\"1\":{\"55\":1}}],[\"返回\",{\"1\":{\"120\":1,\"127\":1}}],[\"返回前先执行\",{\"1\":{\"74\":1}}],[\"返回值是\",{\"1\":{\"36\":1}}],[\"按finally中return的为准\",{\"1\":{\"74\":1}}],[\"按照键的自然顺序或自定义顺序进行排序\",{\"1\":{\"83\":1}}],[\"按照流的角色划分为\",{\"1\":{\"28\":1}}],[\"按照流的流向分\",{\"1\":{\"28\":1}}],[\"按照操作单元划分\",{\"1\":{\"28\":1}}],[\"题目3\",{\"1\":{\"74\":1}}],[\"题目2\",{\"1\":{\"74\":1}}],[\"题目1\",{\"1\":{\"74\":1}}],[\"语句\",{\"1\":{\"120\":1,\"127\":1}}],[\"语句中\",{\"1\":{\"95\":1}}],[\"语句块\",{\"1\":{\"74\":1}}],[\"语法形式\",{\"1\":{\"92\":1}}],[\"语言\",{\"0\":{\"42\":1}}],[\"三道经典异常处理代码题\",{\"0\":{\"74\":1}}],[\"三分钟搭建一个博客网站\",{\"0\":{\"7\":1,\"8\":1}}],[\"此时就会线性向后查找\",{\"1\":{\"109\":1}}],[\"此时finally块中的代码不会执行\",{\"1\":{\"73\":1}}],[\"此时pages页会显示访问域名\",{\"1\":{\"21\":1}}],[\"捕获异常\",{\"1\":{\"72\":1}}],[\"抛出异常\",{\"1\":{\"72\":1}}],[\"受检异常\",{\"1\":{\"71\":1}}],[\"异或操作使得低位的特征影响到高位\",{\"1\":{\"147\":1}}],[\"异常的处理机制\",{\"0\":{\"72\":1}}],[\"异常处理\",{\"0\":{\"70\":1}}],[\"异步非阻塞io\",{\"1\":{\"30\":1}}],[\"常用于web应用中\",{\"1\":{\"69\":2}}],[\"常用类\",{\"0\":{\"58\":1}}],[\"xstream等\",{\"1\":{\"69\":1}}],[\"xml\",{\"1\":{\"69\":1}}],[\"xml序列化\",{\"1\":{\"69\":1}}],[\"xml等格式\",{\"1\":{\"69\":1}}],[\"xx\",{\"1\":{\"64\":1}}],[\"被垃圾回收器回收了\",{\"1\":{\"105\":1}}],[\"被调用不一定会立即回收该对象\",{\"1\":{\"95\":1}}],[\"被final修饰的变量必须被显式第指定初始值\",{\"1\":{\"94\":1}}],[\"被final修饰的变量不可变\",{\"1\":{\"94\":1}}],[\"被final修饰的方法不可以被重写\",{\"1\":{\"94\":1}}],[\"被final修饰的类不可以被继承\",{\"1\":{\"94\":1}}],[\"被\",{\"1\":{\"68\":1}}],[\"被推荐使用的做法\",{\"1\":{\"35\":1}}],[\"关键字或其他同步机制\",{\"1\":{\"160\":1}}],[\"关键字synchronized可以修饰方法或者以同步块的形式来进行使用\",{\"1\":{\"127\":1}}],[\"关键字volatile可以用来修饰字段\",{\"1\":{\"127\":1}}],[\"关键字的作用是让被修饰的成员属性不被序列化\",{\"1\":{\"131\":1}}],[\"关键字的作用\",{\"1\":{\"68\":1}}],[\"关键字修饰\",{\"1\":{\"68\":1}}],[\"关于作者\",{\"0\":{\"2\":1},\"1\":{\"2\":1}}],[\"关于网站\",{\"0\":{\"1\":1}}],[\"仍然可以成功反序列化之前的序列化数据\",{\"1\":{\"68\":1}}],[\"兼容性\",{\"1\":{\"68\":1}}],[\"则为一个全是1的二进制数\",{\"1\":{\"149\":1}}],[\"则需要把链表转换为红黑树\",{\"1\":{\"145\":1}}],[\"则直接插入即可\",{\"1\":{\"145\":1}}],[\"则异常不会抛出\",{\"1\":{\"134\":1}}],[\"则会抛出concurrent\",{\"1\":{\"134\":1}}],[\"则会抛出invalidclassexception异常\",{\"1\":{\"68\":1}}],[\"则会清除中断标志\",{\"1\":{\"120\":1}}],[\"则线程会被唤醒\",{\"1\":{\"120\":1}}],[\"则该class\",{\"1\":{\"97\":1}}],[\"则它们的\",{\"1\":{\"97\":1}}],[\"则必须重写方法\",{\"1\":{\"91\":1}}],[\"则视为重载\",{\"1\":{\"88\":1}}],[\"则是一个\",{\"1\":{\"61\":1}}],[\"版本控制\",{\"1\":{\"68\":1}}],[\"又有什么用\",{\"1\":{\"68\":1}}],[\"方便哈希取余\",{\"1\":{\"149\":1}}],[\"方便\",{\"1\":{\"119\":1}}],[\"方便存储和传输\",{\"1\":{\"68\":1}}],[\"方法将hashmap包装成线程安全的map\",{\"1\":{\"160\":1}}],[\"方法之外\",{\"1\":{\"127\":1}}],[\"方法主动放弃\",{\"1\":{\"125\":1}}],[\"方法或locksupport\",{\"1\":{\"122\":1}}],[\"方法来设置线程的中断标志为true\",{\"1\":{\"120\":1}}],[\"方法则会唤醒所有在该共享变量上由于调用\",{\"1\":{\"120\":1}}],[\"方法后\",{\"1\":{\"120\":1}}],[\"方法唤醒它\",{\"1\":{\"120\":2}}],[\"方法多了一个超时参数\",{\"1\":{\"120\":1}}],[\"方法时\",{\"1\":{\"120\":2}}],[\"方法时会执行run\",{\"0\":{\"118\":1}}],[\"方法启动线程\",{\"1\":{\"117\":1}}],[\"方法的最后\",{\"1\":{\"110\":1}}],[\"方法的返回值必须相等\",{\"1\":{\"97\":1}}],[\"方法释放内存空间\",{\"1\":{\"106\":1}}],[\"方法可以非常简单地实现对象的浅拷贝\",{\"1\":{\"99\":1}}],[\"方法判断相等\",{\"1\":{\"97\":1}}],[\"方法只会被调用一次\",{\"1\":{\"95\":1}}],[\"方法和类\",{\"1\":{\"95\":1}}],[\"方法修饰符\",{\"1\":{\"91\":1}}],[\"方法实现\",{\"1\":{\"91\":1}}],[\"方法重写\",{\"1\":{\"88\":1}}],[\"方法重载\",{\"1\":{\"88\":1}}],[\"方法重载和方法重写都是实现多态性的方式\",{\"1\":{\"88\":1}}],[\"方法名相同\",{\"1\":{\"88\":2}}],[\"方法上\",{\"1\":{\"81\":1}}],[\"方法会终止java虚拟机的运行\",{\"1\":{\"73\":1}}],[\"方法等\",{\"1\":{\"68\":1}}],[\"方法等信息\",{\"1\":{\"48\":1}}],[\"方法\",{\"0\":{\"118\":2},\"1\":{\"65\":2,\"73\":1,\"89\":4,\"95\":1,\"117\":3,\"118\":2,\"120\":3,\"121\":1,\"122\":2}}],[\"方法为true\",{\"1\":{\"63\":1}}],[\"把冲突的元素放进去\",{\"1\":{\"152\":2}}],[\"把元素放到空的槽中\",{\"1\":{\"109\":1}}],[\"把构成问题的事务分解成各个对象\",{\"1\":{\"86\":1}}],[\"把二进制流恢复成对象\",{\"1\":{\"68\":1}}],[\"把java对象转为二进制流\",{\"1\":{\"68\":1}}],[\"把一个表数范围小的数值或变量直接赋给另一个数范围大的变量时\",{\"1\":{\"51\":1}}],[\"序列化不包含静态变量\",{\"1\":{\"68\":1}}],[\"序列化\",{\"0\":{\"67\":1},\"1\":{\"68\":1,\"99\":1}}],[\"垃圾回收\",{\"1\":{\"66\":1}}],[\"原理很简单\",{\"1\":{\"112\":1}}],[\"原理\",{\"0\":{\"65\":1},\"1\":{\"65\":1,\"134\":2}}],[\"原理是什么\",{\"0\":{\"40\":1}}],[\"到\",{\"1\":{\"64\":1}}],[\"搞了个缓存池\",{\"1\":{\"64\":1}}],[\"号拼接会编译成stringbuilder的append方法\",{\"1\":{\"62\":1}}],[\"其他⽅法都是直接调⽤\",{\"1\":{\"168\":1}}],[\"其他线程调用了线程a的\",{\"1\":{\"120\":1}}],[\"其他线程调用了线程a共享对象\",{\"1\":{\"120\":1}}],[\"其中n是树中节点的数量\",{\"1\":{\"142\":1}}],[\"其实在jvm\",{\"1\":{\"126\":1}}],[\"其实是会生成新的对象\",{\"1\":{\"62\":1}}],[\"其含义是\",{\"1\":{\"120\":1,\"127\":1}}],[\"其内部调用的是\",{\"1\":{\"120\":1}}],[\"其它\",{\"0\":{\"43\":1}}],[\"否则向链表中插入数据\",{\"1\":{\"145\":1}}],[\"否则需要覆盖\",{\"1\":{\"145\":1}}],[\"否则抛出异常\",{\"1\":{\"134\":1}}],[\"否则会报错\",{\"1\":{\"91\":1}}],[\"否则会有可读性等问题\",{\"1\":{\"32\":1}}],[\"否则\",{\"1\":{\"61\":1,\"63\":1,\"146\":2}}],[\"还可以节省内存空间\",{\"1\":{\"132\":1}}],[\"还提供了join\",{\"1\":{\"127\":1}}],[\"还有什么其它办法\",{\"0\":{\"113\":1}}],[\"还有编译器\",{\"1\":{\"39\":1}}],[\"还是引用传递\",{\"0\":{\"98\":1}}],[\"还会通过\",{\"1\":{\"61\":1}}],[\"区别在于前者实现的是编译时的多态性\",{\"1\":{\"88\":1}}],[\"区别\",{\"0\":{\"61\":1,\"89\":1}}],[\"单线程环境下操作大量的数据\",{\"1\":{\"60\":1}}],[\"影响性能\",{\"1\":{\"60\":1}}],[\"高位补0\",{\"1\":{\"149\":1}}],[\"高位\",{\"1\":{\"147\":1}}],[\"高\",{\"1\":{\"60\":1}}],[\"低位是与1做位运算\",{\"1\":{\"149\":1}}],[\"低\",{\"1\":{\"60\":2}}],[\"性能更加优秀和稳定\",{\"1\":{\"142\":1}}],[\"性能更好\",{\"1\":{\"60\":1}}],[\"性能\",{\"1\":{\"60\":1}}],[\"安全失败\",{\"1\":{\"134\":1}}],[\"安全问题\",{\"1\":{\"102\":1}}],[\"安全性和可靠性\",{\"1\":{\"59\":1}}],[\"安装依赖\",{\"1\":{\"11\":1}}],[\"安装pnpm\",{\"1\":{\"9\":1}}],[\"安装nodejs\",{\"1\":{\"9\":1}}],[\"替换等\",{\"1\":{\"59\":1}}],[\"再遍历链表定位到具体的元素上\",{\"1\":{\"162\":1}}],[\"再建一个数组\",{\"1\":{\"152\":1}}],[\"再哈希法\",{\"1\":{\"152\":1}}],[\"再插入时\",{\"1\":{\"130\":1}}],[\"再反序列化成拷贝对象\",{\"1\":{\"99\":1}}],[\"再输出\",{\"1\":{\"74\":1}}],[\"再catch中return\",{\"1\":{\"74\":1}}],[\"再自增\",{\"1\":{\"57\":1}}],[\"再赋值\",{\"1\":{\"57\":1}}],[\"再由操作系统执行\",{\"1\":{\"42\":1}}],[\"减\",{\"1\":{\"57\":2}}],[\"减少了扩容操作的时间和资源消耗\",{\"1\":{\"157\":1}}],[\"减少了相同低位的哈希值导致相同索引位置的情况\",{\"1\":{\"147\":1}}],[\"减少碰撞的概率\",{\"1\":{\"157\":1}}],[\"减少\",{\"1\":{\"36\":1}}],[\"先finally\",{\"1\":{\"74\":1}}],[\"先赋值\",{\"1\":{\"57\":1}}],[\"先自增\",{\"1\":{\"57\":1}}],[\"先对\",{\"1\":{\"36\":1}}],[\"运行\",{\"1\":{\"121\":1}}],[\"运行状态\",{\"1\":{\"121\":1}}],[\"运行时异常\",{\"1\":{\"71\":1}}],[\"运算\",{\"1\":{\"108\":1,\"149\":1}}],[\"运算符放在变量之前时\",{\"1\":{\"57\":1}}],[\"运算符可以放在变量之前\",{\"1\":{\"57\":1}}],[\"运⾏时环境\",{\"1\":{\"39\":1}}],[\"位运算\",{\"1\":{\"56\":1}}],[\"位数\",{\"1\":{\"50\":1}}],[\"用vector代替arraylist\",{\"1\":{\"135\":1}}],[\"用户线程\",{\"1\":{\"126\":1}}],[\"用\",{\"1\":{\"119\":1}}],[\"用来做用户信息上下文的存储\",{\"1\":{\"103\":1}}],[\"用来表示对象的唯一标识\",{\"1\":{\"97\":1}}],[\"用this来区分\",{\"1\":{\"90\":1}}],[\"用于记录元素的插入顺序或访问顺序\",{\"1\":{\"165\":1}}],[\"用于存储线程局部变量的值\",{\"1\":{\"107\":1}}],[\"用于修饰变量\",{\"1\":{\"95\":1}}],[\"用于在编译时期提供类型安全的参数化类型\",{\"1\":{\"76\":1}}],[\"用于标识类可以被序列化\",{\"1\":{\"68\":1}}],[\"用于表示一个值可能存在或不存在\",{\"1\":{\"32\":1}}],[\"用最有效率的方法计算2乘以8\",{\"0\":{\"56\":1}}],[\"进入该状态表示当前线\",{\"1\":{\"121\":1}}],[\"进入下一个循环条件\",{\"1\":{\"55\":1}}],[\"进程中的多个线程共享进程的资源\",{\"1\":{\"116\":1}}],[\"进程是代码在数据集合上的一次运行活动\",{\"1\":{\"116\":1}}],[\"进程\",{\"1\":{\"116\":1}}],[\"进而产生问题\",{\"1\":{\"95\":1}}],[\"进而用到了integercache\",{\"1\":{\"64\":1}}],[\"进行了一系列判断\",{\"1\":{\"168\":1}}],[\"进行过滤\",{\"1\":{\"36\":1}}],[\"进行相应的处理\",{\"1\":{\"30\":1}}],[\"继续执行下次循环\",{\"1\":{\"55\":1}}],[\"继承关\",{\"1\":{\"119\":1}}],[\"继承thread类\",{\"1\":{\"117\":2}}],[\"继承是使⽤已存在的类的定义作为基础创建新的类\",{\"1\":{\"87\":1}}],[\"继承\",{\"1\":{\"38\":1,\"87\":2}}],[\"跳出本次循环\",{\"1\":{\"55\":1}}],[\"跳出整个循环\",{\"1\":{\"55\":1}}],[\"开放地址解决冲突\",{\"1\":{\"110\":1}}],[\"开放定址法就是从冲突的位置再接着往下找\",{\"1\":{\"152\":1}}],[\"开放定址法\",{\"1\":{\"109\":1,\"152\":1}}],[\"开始\",{\"1\":{\"54\":2}}],[\"开头的\",{\"1\":{\"36\":2}}],[\"5倍\",{\"1\":{\"130\":1}}],[\"5引入的一个特性\",{\"1\":{\"76\":1}}],[\"5\",{\"1\":{\"54\":1}}],[\"只要垃圾回收机制一运行\",{\"1\":{\"105\":1}}],[\"只有在key在table数组中不存在的时候\",{\"1\":{\"168\":1}}],[\"只有一个执行\",{\"1\":{\"115\":1}}],[\"只有当程序结束时才会被销毁\",{\"1\":{\"92\":1}}],[\"只有函数式接口\",{\"1\":{\"33\":1}}],[\"只能有一个线程处于方法或者同步块中\",{\"1\":{\"127\":1}}],[\"只能继承thread类\",{\"1\":{\"119\":1}}],[\"只能定义\",{\"1\":{\"91\":1}}],[\"只能修饰变量\",{\"1\":{\"68\":1}}],[\"只能是\",{\"1\":{\"54\":1}}],[\"短路与\",{\"1\":{\"53\":1}}],[\"拆箱\",{\"1\":{\"52\":1}}],[\"将添加的元素作为key\",{\"1\":{\"168\":1}}],[\"将扩容操作分散到多次进行\",{\"1\":{\"157\":1}}],[\"将新键值对插入链表或红黑树末尾\",{\"1\":{\"157\":1}}],[\"将已经产生hash碰撞的元素完美的转移到新的table中去\",{\"1\":{\"149\":1}}],[\"将链表转换为红黑树\",{\"1\":{\"139\":1}}],[\"将原数组拷贝一份\",{\"1\":{\"136\":1}}],[\"将\",{\"1\":{\"125\":1,\"149\":1,\"151\":1}}],[\"将对象序列化为hessian格式\",{\"1\":{\"69\":1}}],[\"将对象序列化为protobuf格式\",{\"1\":{\"69\":1}}],[\"将对象序列化为xml格式\",{\"1\":{\"69\":1}}],[\"将对象序列化为json格式\",{\"1\":{\"69\":1}}],[\"将此string对象添加到池中\",{\"1\":{\"63\":1}}],[\"将包装类型转换为基本数据类型\",{\"1\":{\"52\":1}}],[\"将基本类型用它们对应的引用类型包装起来\",{\"1\":{\"52\":1}}],[\"将通道\",{\"1\":{\"30\":1}}],[\"装箱\",{\"1\":{\"52\":1}}],[\"封箱\",{\"0\":{\"52\":1}}],[\"封装把⼀个对象的属性私有化\",{\"1\":{\"87\":1}}],[\"封装\",{\"1\":{\"38\":1,\"87\":1}}],[\"反序列化\",{\"1\":{\"68\":1}}],[\"反之就尾插法\",{\"1\":{\"163\":1}}],[\"反之\",{\"1\":{\"51\":1}}],[\"反射的实现原理\",{\"0\":{\"48\":1}}],[\"反射的应用场景\",{\"0\":{\"47\":1}}],[\"反射相关类\",{\"1\":{\"46\":1}}],[\"反射\",{\"0\":{\"45\":1},\"1\":{\"46\":1,\"66\":1}}],[\"强制类型转换\",{\"0\":{\"51\":1},\"1\":{\"51\":1}}],[\"最后的结果是\",{\"1\":{\"168\":1}}],[\"最后所有元素处理完成后\",{\"1\":{\"145\":1}}],[\"最终一定被执行\",{\"1\":{\"95\":1}}],[\"最终返回的还是之前暂存起来的结果\",{\"1\":{\"74\":1}}],[\"最终都调用parseint\",{\"1\":{\"65\":1}}],[\"最大值\",{\"1\":{\"50\":1}}],[\"最小值改不了\",{\"1\":{\"64\":1}}],[\"最小值\",{\"1\":{\"50\":1}}],[\"布尔型默认为false\",{\"1\":{\"92\":1}}],[\"布尔型\",{\"1\":{\"50\":1}}],[\"浮点类型\",{\"1\":{\"50\":1}}],[\"整数类型\",{\"1\":{\"50\":1}}],[\"数字分析法\",{\"1\":{\"151\":1}}],[\"数字的二进制位左移三位相当于乘以2的三次方\",{\"1\":{\"56\":1}}],[\"数据结构和hashmap是一样的\",{\"1\":{\"163\":1}}],[\"数据结构\",{\"1\":{\"157\":1,\"163\":1}}],[\"数据结构示意图\",{\"1\":{\"139\":1}}],[\"数据结构不同\",{\"1\":{\"129\":1}}],[\"数据拷贝在add方法中进行\",{\"1\":{\"137\":1}}],[\"数据拷贝的过程中\",{\"0\":{\"137\":1}}],[\"数据都已经放入到\",{\"1\":{\"110\":1}}],[\"数据库驱动\",{\"1\":{\"44\":1}}],[\"数组+链表+红黑树\",{\"1\":{\"163\":1}}],[\"数组中key和hash一样就直接替换\",{\"1\":{\"162\":1}}],[\"数组中的每个元素称为一个桶\",{\"1\":{\"139\":1}}],[\"数组大小为2的倍数\",{\"1\":{\"149\":1}}],[\"数组大小\",{\"1\":{\"149\":6}}],[\"数组长度\",{\"1\":{\"148\":1}}],[\"数组可能长度100\",{\"1\":{\"132\":1}}],[\"数组满了\",{\"1\":{\"130\":1}}],[\"数组下标越界等等\",{\"1\":{\"71\":1}}],[\"数组\",{\"1\":{\"50\":1,\"139\":2}}],[\"数值型\",{\"1\":{\"50\":1}}],[\"基础\",{\"0\":{\"114\":1}}],[\"基础语法\",{\"0\":{\"49\":1}}],[\"基本类型\",{\"1\":{\"50\":1}}],[\"基本数据类型==比较的是值\",{\"1\":{\"96\":1}}],[\"基本数据类型相同\",{\"1\":{\"88\":1}}],[\"基本数据类型吗\",{\"0\":{\"59\":1}}],[\"基本数据类型\",{\"1\":{\"50\":1}}],[\"基于拷贝内容的优点是避免了concurrent\",{\"1\":{\"134\":1}}],[\"基于红黑树实现的有序map\",{\"1\":{\"83\":1}}],[\"基于哈希表实现的线程安全的map\",{\"1\":{\"83\":1}}],[\"基于哈希表实现的map\",{\"1\":{\"83\":2}}],[\"基于哈希表和双向链表实现的map\",{\"1\":{\"83\":1}}],[\"基于java虚拟机\",{\"1\":{\"48\":1}}],[\"基于vuepress\",{\"1\":{\"8\":1}}],[\"该方法返回一个包装后的线程安全list\",{\"1\":{\"135\":1}}],[\"该方法如果发现当前线程被中断\",{\"1\":{\"120\":1}}],[\"该状态不同于\",{\"1\":{\"121\":1}}],[\"该实例也无法被垃圾回收\",{\"1\":{\"107\":1}}],[\"该对象又不需要被回收了\",{\"1\":{\"95\":1}}],[\"该对象被回收的时候被调用\",{\"1\":{\"95\":1}}],[\"该对象包含了类的名称\",{\"1\":{\"48\":1}}],[\"该引⽤变量发出的⽅法调⽤到底是哪个类中实现的⽅法\",{\"1\":{\"87\":1}}],[\"该文件位于\",{\"1\":{\"44\":1}}],[\"该文件包含了服务接口的实现类的全限定名\",{\"1\":{\"44\":1}}],[\"你能自己设计实现一个hashmap吗\",{\"0\":{\"158\":1}}],[\"你还知道哪些哈希函数的构造方法呢\",{\"0\":{\"151\":1}}],[\"你还可以调用这些方法和属性\",{\"1\":{\"46\":1}}],[\"你对红黑树了解多少\",{\"0\":{\"140\":1}}],[\"你在工作中用到过threadlocal吗\",{\"0\":{\"103\":1}}],[\"你想要创建什么类型的项目\",{\"1\":{\"11\":1}}],[\"日志框架\",{\"1\":{\"44\":1}}],[\"解决哈希冲突有哪些方法呢\",{\"0\":{\"152\":1}}],[\"解决了线程池等场景下inheritablethreadlocal\",{\"1\":{\"113\":1}}],[\"解析\",{\"1\":{\"74\":2}}],[\"解耦了服务的实现和调用方\",{\"1\":{\"44\":1}}],[\"解释成操作系统能识别的机器码\",{\"1\":{\"42\":1}}],[\"解释\",{\"1\":{\"41\":1}}],[\"实际上就是相当于每个segment都是一个hashmap\",{\"1\":{\"162\":1}}],[\"实际直接使用两个流\",{\"1\":{\"133\":1}}],[\"实际就是在暗示线程调度器当前线程请求让出自己的cpu\",{\"1\":{\"120\":1}}],[\"实际是操作自己本地内存里面的变量\",{\"1\":{\"102\":1}}],[\"实例⽅法\",{\"1\":{\"93\":1}}],[\"实例方法呢\",{\"0\":{\"93\":1}}],[\"实例变量即对象变量\",{\"1\":{\"92\":1}}],[\"实例变量存储在堆内存中\",{\"1\":{\"92\":1}}],[\"实例变量是每个对象独有的\",{\"1\":{\"92\":1}}],[\"实例变量\",{\"1\":{\"92\":1,\"93\":1}}],[\"实例化对应的服务提供者对象\",{\"1\":{\"44\":1}}],[\"实现的\",{\"1\":{\"168\":1}}],[\"实现的原理是int\",{\"1\":{\"64\":1}}],[\"实现arraylist线程安全有哪几种方法\",{\"0\":{\"135\":1}}],[\"实现一个线程修改一个对象的值\",{\"1\":{\"127\":1}}],[\"实现callable接口\",{\"1\":{\"117\":2}}],[\"实现runnable接口\",{\"1\":{\"117\":1}}],[\"实现\",{\"1\":{\"91\":1,\"117\":1,\"161\":2}}],[\"实现类和实例不能调用静态方法\",{\"1\":{\"91\":1}}],[\"实现接⼝并覆盖接⼝中同⼀⽅法\",{\"1\":{\"87\":1}}],[\"实现数据的持久化和\",{\"1\":{\"68\":1}}],[\"实现serializable接口的类可以将对象转换为字节流进行传输和存储\",{\"1\":{\"68\":1}}],[\"实现服务接口\",{\"1\":{\"44\":1}}],[\"实现了服务接口的具体类\",{\"1\":{\"44\":1}}],[\"实现原理\",{\"1\":{\"40\":1}}],[\"接着参与\",{\"1\":{\"120\":1}}],[\"接着\",{\"1\":{\"44\":1}}],[\"接口自身可以通过extends关键字扩展多个接口\",{\"1\":{\"91\":1}}],[\"接口中只能包含静态\",{\"1\":{\"91\":1}}],[\"接口中的方法默认修饰符是public\",{\"1\":{\"91\":1}}],[\"接口中的方法默认是公开的\",{\"1\":{\"91\":1}}],[\"接口中的方法可以有默认实现\",{\"1\":{\"91\":1}}],[\"接口也可以定义静态方法\",{\"1\":{\"91\":1}}],[\"接口或方法的参数和返回值的类型\",{\"1\":{\"76\":1}}],[\"接口\",{\"1\":{\"50\":1,\"89\":2,\"117\":1,\"129\":2}}],[\"接口可以包含默认方法和静态方法\",{\"1\":{\"32\":1}}],[\"接口的默认方法和静态方法\",{\"1\":{\"32\":1}}],[\"规定了需要提供的功能或扩展点\",{\"1\":{\"44\":1}}],[\"首先计算hash\",{\"1\":{\"163\":1}}],[\"首先进行哈希值的扰动\",{\"1\":{\"145\":1}}],[\"首先\",{\"1\":{\"44\":1}}],[\"通知机制\",{\"1\":{\"127\":2}}],[\"通知或中断\",{\"1\":{\"121\":1}}],[\"通常是因为调用了wait\",{\"1\":{\"122\":1}}],[\"通常是因为等待获取锁\",{\"1\":{\"122\":1}}],[\"通常位于meta\",{\"1\":{\"44\":1}}],[\"通过这个链表\",{\"1\":{\"165\":1}}],[\"通过使用锁分段技术和cas操作来实现高效的并发性能\",{\"1\":{\"160\":1}}],[\"通过使用泛型\",{\"1\":{\"76\":1}}],[\"通过设置线程的中断标志并不能直接终止该线程的执行\",{\"1\":{\"120\":1}}],[\"通过\",{\"1\":{\"109\":1}}],[\"通过序列化机制\",{\"1\":{\"100\":1}}],[\"通过继承可以很方便地进行代码复用\",{\"1\":{\"87\":1}}],[\"通过实现serializable接口和externalizable接口来实现对象的序列化和反序列化\",{\"1\":{\"69\":1}}],[\"通过反射机制\",{\"1\":{\"100\":1}}],[\"通过反射\",{\"1\":{\"48\":1}}],[\"通过反射你可以获取任意一个类的所有属性和方法\",{\"1\":{\"46\":1}}],[\"通过在classpath中提供配置文件\",{\"1\":{\"44\":1}}],[\"通过入参的\",{\"1\":{\"36\":1}}],[\"通过optional类\",{\"1\":{\"32\":1}}],[\"通过stream\",{\"1\":{\"32\":1}}],[\"通过选择器\",{\"1\":{\"30\":1}}],[\"描述了服务提供者需要实现的接口或抽象类\",{\"1\":{\"44\":1}}],[\"向应用程序注入实现了特定接口的服务提供者\",{\"1\":{\"44\":1}}],[\"机制是java标准库提供的一种服务发现机制\",{\"1\":{\"44\":1}}],[\"机器码\",{\"1\":{\"41\":1}}],[\"说明需要扩容\",{\"1\":{\"163\":1}}],[\"说明\",{\"1\":{\"121\":1}}],[\"说一下你对注解的理解\",{\"0\":{\"81\":1}}],[\"说说有哪些常见集合\",{\"0\":{\"170\":1}}],[\"说说有哪些常见的序列化方式\",{\"0\":{\"69\":1}}],[\"说说线程有几种创建方式\",{\"0\":{\"117\":1}}],[\"说说什么是进程和线程\",{\"0\":{\"116\":1}}],[\"说说什么是跨平台性\",{\"0\":{\"40\":1}}],[\"说说自增自减运算\",{\"0\":{\"57\":1}}],[\"说下什么是java的spi机制\",{\"0\":{\"44\":1}}],[\"文件名为服务接口的全限定名\",{\"1\":{\"44\":1}}],[\"文件\",{\"1\":{\"42\":1,\"81\":3}}],[\"文档所在分支\",{\"1\":{\"23\":1}}],[\"由创建出来的新线程去执行thread的run方法\",{\"1\":{\"118\":1}}],[\"由于扩容过程中元素迁移的不可见性\",{\"1\":{\"159\":1}}],[\"由于哈希函数的计算结果可能会出现冲突\",{\"1\":{\"139\":1}}],[\"由于copyonwritearraylist在每次写操作时都会创建副本\",{\"1\":{\"136\":1}}],[\"由于copyonwritearraylist在写操作时会创建副本\",{\"1\":{\"136\":1}}],[\"由于读操作不需要加锁\",{\"1\":{\"135\":1}}],[\"由于迭代时是对原集合的拷贝进行遍历\",{\"1\":{\"134\":1}}],[\"由于同步的开销\",{\"1\":{\"60\":1}}],[\"由于不可变性的特性\",{\"1\":{\"60\":1}}],[\"由于字符串是不可变的\",{\"1\":{\"59\":1}}],[\"由\",{\"1\":{\"42\":1}}],[\"后继节点和插入节点的指向就行了\",{\"1\":{\"129\":1}}],[\"后\",{\"1\":{\"95\":1}}],[\"后缀\",{\"1\":{\"57\":1}}],[\"后解释两个步骤\",{\"1\":{\"42\":1}}],[\"后者是字符输出流\",{\"1\":{\"28\":1}}],[\"后者是字符输入流\",{\"1\":{\"28\":1}}],[\"因此可以通过键值来遍历\",{\"1\":{\"166\":1}}],[\"因此可以在多线程环境下安全地进行读操作\",{\"1\":{\"136\":1}}],[\"因此适用于写操作较少\",{\"1\":{\"136\":1}}],[\"因此在遍历集合时使用的迭代器可能不反映最新的修改\",{\"1\":{\"136\":1}}],[\"因此在读多写少的场景中\",{\"1\":{\"135\":1}}],[\"因此在并发环境下可以安全地进行读写操作\",{\"1\":{\"135\":1}}],[\"因此不推荐使用\",{\"1\":{\"95\":1}}],[\"因此\",{\"1\":{\"64\":1,\"98\":1,\"124\":1,\"134\":1}}],[\"因此java语言可以实现跨平\",{\"1\":{\"39\":1}}],[\"因为除了clone\",{\"1\":{\"168\":1}}],[\"因为任意数\",{\"1\":{\"149\":1}}],[\"因为哈希值\",{\"1\":{\"148\":1}}],[\"因为每次写操作都会创建一个新的副本\",{\"1\":{\"136\":1}}],[\"因为操作系统需要保存和恢复线程的上下文信息\",{\"1\":{\"124\":1}}],[\"因为切换的时间特别短\",{\"1\":{\"115\":1}}],[\"因为前面调用过一次\",{\"1\":{\"95\":1}}],[\"因为根据实践发现大部分的数据操作都集中在值比较小的范围\",{\"1\":{\"64\":1}}],[\"因为它的不可变性保证了多个线程可以安全地共享string对象\",{\"1\":{\"60\":1}}],[\"因为它的哈希值是固定的\",{\"1\":{\"59\":1}}],[\"因为\",{\"1\":{\"42\":1,\"164\":1}}],[\"对hashmap进行加锁\",{\"1\":{\"160\":1}}],[\"对该对象的操作会自动进行同步\",{\"1\":{\"160\":1}}],[\"对该list的所有操作都会进行同步处理\",{\"1\":{\"135\":1}}],[\"对形参引用的修改不会影响实参引用的指向\",{\"1\":{\"98\":1}}],[\"对形参的修改不会影响实参\",{\"1\":{\"98\":1}}],[\"对同一包内的类和所有子类可见\",{\"1\":{\"89\":1}}],[\"对所有类可见\",{\"1\":{\"89\":1}}],[\"对于频繁的字符串拼接操作\",{\"1\":{\"60\":1}}],[\"对象相等性原则\",{\"1\":{\"97\":1}}],[\"对象名\",{\"1\":{\"93\":2}}],[\"对象转字符串\",{\"1\":{\"66\":1}}],[\"对象拷贝\",{\"1\":{\"66\":1}}],[\"对象比较\",{\"1\":{\"66\":1}}],[\"对象创建过程\",{\"1\":{\"61\":1}}],[\"对象的操作\",{\"1\":{\"59\":1}}],[\"对象\",{\"1\":{\"46\":1,\"59\":1,\"61\":1}}],[\"对应的操作系统执行二进制机器码\",{\"1\":{\"41\":1}}],[\"对一个包含一个或多个元素的集合做各种操作\",{\"1\":{\"36\":1}}],[\"执行扩容\",{\"1\":{\"163\":1}}],[\"执行完毕后\",{\"1\":{\"74\":1}}],[\"执行结果\",{\"1\":{\"74\":3}}],[\"执行顺序\",{\"1\":{\"74\":1}}],[\"执行\",{\"1\":{\"41\":1,\"95\":1}}],[\"从冲突的位置x开始\",{\"1\":{\"152\":1}}],[\"从冲突的位置开始\",{\"1\":{\"152\":1}}],[\"从任一节点到其每个叶子节点的路径上\",{\"1\":{\"141\":1}}],[\"从一个线程转而执行另一个线程的过程\",{\"1\":{\"124\":1}}],[\"从父线程中取出inheritablethreadlocals\",{\"1\":{\"112\":1}}],[\"从jdk\",{\"1\":{\"91\":1}}],[\"从而保证线程安全\",{\"1\":{\"160\":1}}],[\"从而导致元素的丢失\",{\"1\":{\"159\":1}}],[\"从而形成死循环\",{\"1\":{\"159\":1}}],[\"从而降低哈希碰撞的概率\",{\"1\":{\"148\":1}}],[\"从而可能导致内存泄漏\",{\"1\":{\"107\":1}}],[\"从而实现了线程隔离\",{\"1\":{\"104\":1}}],[\"从而实现java程序的跨平台性\",{\"1\":{\"41\":1}}],[\"从而起到线程隔离的作用\",{\"1\":{\"102\":1}}],[\"从而增加代码的可读性和安全性\",{\"1\":{\"76\":1}}],[\"从\",{\"1\":{\"54\":2}}],[\"从master新建分支gh\",{\"0\":{\"19\":1}}],[\"跨平台的数据交换\",{\"1\":{\"68\":1}}],[\"跨平台\",{\"1\":{\"40\":1}}],[\"如reentrantlock\",{\"1\":{\"160\":1}}],[\"如使用synchronized关键字或lock\",{\"1\":{\"135\":1}}],[\"如i\",{\"1\":{\"125\":1}}],[\"如int\",{\"1\":{\"98\":1}}],[\"如上图所示\",{\"1\":{\"109\":1}}],[\"如hessian\",{\"1\":{\"69\":1}}],[\"如jaxb\",{\"1\":{\"69\":1}}],[\"如jackson\",{\"1\":{\"69\":1}}],[\"如果需要有序的存储和遍历元素\",{\"1\":{\"164\":1}}],[\"如果都不满足\",{\"1\":{\"163\":1}}],[\"如果hash==moved\",{\"1\":{\"163\":1}}],[\"如果当前数组位置是空则直接通过cas自旋写入数据\",{\"1\":{\"163\":1}}],[\"如果当前字符串内容存在于字符串常量池\",{\"1\":{\"63\":1}}],[\"如果正在初始化或者扩容\",{\"1\":{\"163\":1}}],[\"如果数组是空的话\",{\"1\":{\"163\":1}}],[\"如果获取锁失败则尝试自旋\",{\"1\":{\"162\":1}}],[\"如果计算出来的索引位置相同\",{\"1\":{\"159\":1}}],[\"如果初始化hashmap\",{\"0\":{\"150\":1}}],[\"如果链表中插入节点的时候\",{\"1\":{\"145\":1}}],[\"如果对应下标正好没有存放数据\",{\"1\":{\"145\":1}}],[\"如果是则进行扩容操作\",{\"1\":{\"145\":1}}],[\"如果写操作频繁或对实时性要求较高\",{\"1\":{\"136\":1}}],[\"如果集合发生变化时修改modcount值刚好又设置为了expectedmodcount值\",{\"1\":{\"134\":1}}],[\"如果线程a遍历过程中\",{\"1\":{\"134\":1}}],[\"如果一个线程a执行了thread\",{\"1\":{\"120\":1,\"127\":1}}],[\"如果等待时间到期而线程没有获取到锁\",{\"1\":{\"120\":1}}],[\"如果直接调用thread的run\",{\"1\":{\"118\":1}}],[\"如果父线程的\",{\"1\":{\"112\":1}}],[\"如果执行完启发式清理工作后\",{\"1\":{\"110\":1}}],[\"如果我们插入一个value=27的数据\",{\"1\":{\"109\":1}}],[\"如果将threadlocal实例作为强引用存储在threadlocalmap中\",{\"1\":{\"107\":1}}],[\"如果threadlocal\",{\"1\":{\"105\":1}}],[\"如果try块中的代码导致了线程死锁\",{\"1\":{\"73\":1}}],[\"如果try块中的代码导致了无限循环或无限递归\",{\"1\":{\"73\":1}}],[\"如果没有重写\",{\"1\":{\"97\":1}}],[\"如果没有则会在常量池中创建\",{\"1\":{\"61\":1}}],[\"如果两个对象根据\",{\"1\":{\"97\":1}}],[\"如果同时实现两个接口\",{\"1\":{\"91\":1}}],[\"如果有些变量不想序列化\",{\"1\":{\"68\":1}}],[\"如果有则直接使用\",{\"1\":{\"61\":1}}],[\"如果新版本的类和旧版本的类具有相同的serialversionuid\",{\"1\":{\"68\":1}}],[\"如果在后续的版本中对该类进行了修改\",{\"1\":{\"68\":1}}],[\"如果不一致\",{\"1\":{\"68\":1,\"109\":1}}],[\"如果后续对该类进行了修改\",{\"1\":{\"68\":1}}],[\"如果整型字面量的值在\",{\"1\":{\"64\":1}}],[\"如果拼接多次\",{\"1\":{\"62\":1}}],[\"如果字符串常量池已经有\",{\"1\":{\"61\":1}}],[\"如拼接\",{\"1\":{\"59\":1}}],[\"如\",{\"1\":{\"39\":1}}],[\"切\",{\"1\":{\"39\":1}}],[\"命令和其他的⼀些基础构件\",{\"1\":{\"39\":1}}],[\"虚拟机执行java字节码\",{\"1\":{\"41\":1}}],[\"虚拟机\",{\"1\":{\"39\":1}}],[\"台\",{\"1\":{\"39\":1}}],[\"针对不同\",{\"1\":{\"39\":1}}],[\"有什么办法能解决hashmap线程不安全的问题呢\",{\"0\":{\"160\":1}}],[\"有什么区别\",{\"0\":{\"39\":1,\"53\":1,\"91\":1}}],[\"有其它线程写入数据怎么办\",{\"0\":{\"137\":1}}],[\"有可能调用\",{\"1\":{\"95\":1}}],[\"有了标记之后\",{\"1\":{\"81\":1}}],[\"有读或写事件时\",{\"1\":{\"30\":1}}],[\"编写服务提供者配置文件\",{\"1\":{\"44\":1}}],[\"编写服务提供者\",{\"1\":{\"44\":2}}],[\"编写的程序需要先经过编译步骤\",{\"1\":{\"42\":1}}],[\"编译器会强制检查并要求处理的异常\",{\"1\":{\"71\":1}}],[\"编译\",{\"1\":{\"41\":1}}],[\"编译与解释并存\",{\"0\":{\"42\":1},\"1\":{\"38\":1}}],[\"编辑此页\",{\"0\":{\"23\":1}}],[\"多数情况下\",{\"1\":{\"129\":1}}],[\"多个线程可以共享同一实\",{\"1\":{\"119\":1}}],[\"多个线程共用进程的堆和方法区资源\",{\"1\":{\"116\":1}}],[\"多个线程操作这个变量的时候\",{\"1\":{\"102\":1}}],[\"多个⼦类对同⼀⽅法的重写\",{\"1\":{\"87\":1}}],[\"多线程的put可能导致元素的丢失\",{\"1\":{\"159\":1}}],[\"多线程下扩容死循环\",{\"1\":{\"159\":1}}],[\"多线程下会有什么问题\",{\"0\":{\"159\":1}}],[\"多线程调度\",{\"1\":{\"66\":1}}],[\"多线程环境下操作大量的数据\",{\"1\":{\"60\":1}}],[\"多操作系统运行\",{\"1\":{\"40\":1}}],[\"多态\",{\"1\":{\"38\":1,\"87\":1}}],[\"多路复用器轮询到连接有io请求就进行处理\",{\"1\":{\"30\":1}}],[\"缩小\",{\"1\":{\"36\":1}}],[\"它通过哈希函数将键映射到桶\",{\"1\":{\"164\":1}}],[\"它通过在修改时创建副本来实现并发访问\",{\"1\":{\"135\":1}}],[\"它实现线程安全的关键点在于put流程\",{\"1\":{\"163\":1}}],[\"它会怎么处理\",{\"0\":{\"150\":1}}],[\"它会在等待队列中等待\",{\"1\":{\"120\":1}}],[\"它使用\",{\"1\":{\"131\":1}}],[\"它们在空间占用上都有一些额外的消耗\",{\"1\":{\"129\":1}}],[\"它们是处理数据的底层工具\",{\"1\":{\"29\":1}}],[\"它没有实现randmoaccess\",{\"1\":{\"129\":1}}],[\"它也实现了randmoaccess\",{\"1\":{\"129\":1}}],[\"它主要用于线程之间的数据传输\",{\"1\":{\"127\":1}}],[\"它主要确保多个线程在同一个时刻\",{\"1\":{\"127\":1}}],[\"它保证了线程对变量访问的可见性和排他性\",{\"1\":{\"127\":1}}],[\"它能保证所有线程对变量访问的可见性\",{\"1\":{\"127\":1}}],[\"它能够创建和编译程序\",{\"1\":{\"39\":1}}],[\"它能够统计\",{\"1\":{\"36\":1}}],[\"它还提供了自定义初始化方法和支持传递不可序列化对象的功能\",{\"1\":{\"113\":1}}],[\"它就会新增\",{\"1\":{\"108\":1}}],[\"它这时候如果不被回收\",{\"1\":{\"105\":1}}],[\"它只是作为一个key来让线程往threadlocalmap里存取值\",{\"1\":{\"104\":1}}],[\"它属于类\",{\"1\":{\"93\":1}}],[\"它的名字叫\",{\"1\":{\"136\":1}}],[\"它的生命周期与程序的生命周期相同\",{\"1\":{\"92\":1}}],[\"它的方法没有使用synchronized关键字进行同步\",{\"1\":{\"60\":1}}],[\"它的值可以被修改\",{\"1\":{\"60\":1}}],[\"它的返回类型是\",{\"1\":{\"36\":1}}],[\"它可以被用作map的键\",{\"1\":{\"59\":1}}],[\"它存储了所有字符串字面量的唯一实例\",{\"1\":{\"59\":1}}],[\"它真正的功能实现就是利用反射\",{\"1\":{\"47\":1}}],[\"它在运行时查找并加载meta\",{\"1\":{\"44\":1}}],[\"它允许第三方组件在不修改源代码的情况下\",{\"1\":{\"44\":1}}],[\"它拥有\",{\"1\":{\"39\":1}}],[\"它是可以在指定\",{\"1\":{\"121\":1}}],[\"它是斐波那契数\",{\"1\":{\"108\":1}}],[\"它是功能⻬全的\",{\"1\":{\"39\":1}}],[\"它是运⾏已编译\",{\"1\":{\"39\":1}}],[\"它不能⽤于创建新程序\",{\"1\":{\"39\":1}}],[\"z\",{\"1\":{\"36\":2}}],[\"zh\",{\"1\":{\"17\":1}}],[\"即保留了低位hash值\",{\"1\":{\"149\":1}}],[\"即不同的键计算得到相同的桶索引\",{\"1\":{\"139\":1}}],[\"即迭代器创建时的集合状态\",{\"1\":{\"136\":1}}],[\"即\",{\"1\":{\"134\":1}}],[\"即线程变量\",{\"1\":{\"127\":1}}],[\"即使这两个对象指向相同的数据\",{\"1\":{\"97\":1}}],[\"即默认\",{\"1\":{\"89\":1}}],[\"即⼀个引⽤变量到底会指向哪个类的实例对象\",{\"1\":{\"87\":1}}],[\"即equals\",{\"1\":{\"63\":1}}],[\"即返回\",{\"1\":{\"36\":1}}],[\"即gh\",{\"1\":{\"22\":1}}],[\"验证\",{\"1\":{\"36\":2}}],[\"匹配到第一个\",{\"1\":{\"36\":1}}],[\"匹配\",{\"1\":{\"36\":1}}],[\"转换\",{\"1\":{\"36\":1}}],[\"过滤\",{\"1\":{\"36\":1}}],[\"而平衡二叉树要求更严格的平衡条件\",{\"1\":{\"143\":1}}],[\"而红黑树通过自平衡的特性\",{\"1\":{\"142\":1}}],[\"而后两种面向字\",{\"1\":{\"127\":1}}],[\"而后者实现的是运行时的多态性\",{\"1\":{\"88\":1}}],[\"而传输的媒介为内存\",{\"1\":{\"127\":1}}],[\"而另一个线程感知到了变化\",{\"1\":{\"127\":1}}],[\"而对它的改变必须同步刷新回共享内存\",{\"1\":{\"127\":1}}],[\"而对于引用类型变量指向的堆中的对象不会拷贝\",{\"1\":{\"99\":1}}],[\"而被阻塞时\",{\"1\":{\"125\":1}}],[\"而terminated状态是永久的\",{\"1\":{\"123\":1}}],[\"而terminated状态表示线程已经执行完毕\",{\"1\":{\"123\":1}}],[\"而threadlocalmap使用threadlocal实例作为键\",{\"1\":{\"107\":1}}],[\"而等待状态是等待其他线程的通知或中断\",{\"1\":{\"122\":1}}],[\"而runnable接口适合定义线程要执行的任务\",{\"1\":{\"119\":1}}],[\"而且entry数据的key和当前不相等\",{\"1\":{\"109\":1}}],[\"而槽位\",{\"1\":{\"109\":1}}],[\"而局部变量没有默认值\",{\"1\":{\"92\":1}}],[\"而静态变量是类共享的\",{\"1\":{\"92\":1}}],[\"而接口是对行为的抽象\",{\"1\":{\"91\":1}}],[\"而抽象类中可以包含任意类型的变量\",{\"1\":{\"91\":1}}],[\"而抽象类可以包含非抽象的方法\",{\"1\":{\"91\":1}}],[\"而是先复制原有集合内容\",{\"1\":{\"134\":1}}],[\"而是被中断的线程根据中断状态自行处理\",{\"1\":{\"120\":1}}],[\"而是为了描述某个事件在解决整个问题的过程所发生的行为\",{\"1\":{\"86\":1}}],[\"而是直接引用缓存池中的integer对象\",{\"1\":{\"64\":1}}],[\"而建立对象的目的也不是为了完成一个个步骤\",{\"1\":{\"86\":1}}],[\"而在运行时\",{\"1\":{\"79\":1}}],[\"而不需要额外的同步措施\",{\"1\":{\"136\":1}}],[\"而不管当前是否存在守护线程\",{\"1\":{\"126\":1}}],[\"而不是按照插入顺序进行存储\",{\"1\":{\"164\":1}}],[\"而不是头插法\",{\"1\":{\"157\":1}}],[\"而不是8\",{\"1\":{\"153\":1}}],[\"而不是对象本身\",{\"1\":{\"98\":1}}],[\"而不是返回\",{\"1\":{\"74\":1}}],[\"而不会修改原始对象的值\",{\"1\":{\"59\":1}}],[\"而中间操作会返回一个\",{\"1\":{\"36\":1}}],[\"而字节流则需要手动处理\",{\"1\":{\"29\":1}}],[\"亦或是\",{\"1\":{\"36\":1}}],[\"unchecked\",{\"1\":{\"163\":1}}],[\"u\",{\"1\":{\"163\":2}}],[\"user\",{\"1\":{\"126\":1}}],[\"users\",{\"1\":{\"11\":2}}],[\"use\",{\"1\":{\"110\":1}}],[\"uffff\",{\"1\":{\"50\":1}}],[\"u0000\",{\"1\":{\"50\":2}}],[\"util包下的集合类都是快速失败的\",{\"1\":{\"134\":1}}],[\"util\",{\"1\":{\"36\":1,\"134\":1}}],[\"简单来说\",{\"1\":{\"36\":1,\"39\":1,\"109\":1}}],[\"简体中文\",{\"1\":{\"11\":1}}],[\"流中的元素总数\",{\"1\":{\"36\":1}}],[\"流\",{\"1\":{\"36\":2}}],[\"流用过吗\",{\"0\":{\"36\":1}}],[\"流分为几种\",{\"0\":{\"28\":1}}],[\"=key\",{\"1\":{\"145\":1}}],[\"=expectedmodcount\",{\"1\":{\"134\":1}}],[\"==null\",{\"1\":{\"168\":1}}],[\"==\",{\"1\":{\"96\":2,\"110\":1,\"112\":1,\"130\":1,\"145\":9,\"146\":5,\"163\":11,\"168\":1}}],[\"==和\",{\"0\":{\"96\":1}}],[\"=128\",{\"0\":{\"64\":1}}],[\"=serviceloader\",{\"1\":{\"44\":2}}],[\"=\",{\"0\":{\"61\":2,\"64\":1},\"1\":{\"35\":1,\"36\":6,\"61\":2,\"74\":3,\"92\":1,\"102\":1,\"108\":2,\"110\":14,\"111\":2,\"112\":6,\"130\":3,\"145\":17,\"146\":14,\"163\":18,\"168\":3}}],[\"来映射到对应的数组位置\",{\"1\":{\"151\":1}}],[\"来计算存储位置\",{\"1\":{\"139\":1}}],[\"来存储数据\",{\"1\":{\"139\":1}}],[\"来存储字符串\",{\"1\":{\"60\":1}}],[\"来控制对arraylist的读写操作\",{\"1\":{\"135\":1}}],[\"来进行序列化和反序列化\",{\"1\":{\"133\":1}}],[\"来决定是否需要扩容\",{\"1\":{\"110\":1}}],[\"来包装它\",{\"1\":{\"35\":1}}],[\"来处理数据\",{\"1\":{\"30\":1}}],[\"一直找到\",{\"1\":{\"109\":1}}],[\"一旦超出这个范围就不再有效\",{\"1\":{\"92\":1}}],[\"一旦创建就不能修改其值\",{\"1\":{\"60\":1}}],[\"一个共享变量上可能会有多个线程在等待\",{\"1\":{\"120\":1}}],[\"一个线程a调用共享对象的\",{\"1\":{\"120\":1}}],[\"一个进程中至少有一个线程\",{\"1\":{\"116\":1}}],[\"一个进程中有多个线程\",{\"1\":{\"116\":1}}],[\"一个table数组\",{\"1\":{\"108\":1}}],[\"一个对象的\",{\"1\":{\"95\":1}}],[\"一个类不管创建多少个对象\",{\"1\":{\"93\":1}}],[\"一个类可以实现多个接口\",{\"1\":{\"91\":1}}],[\"一个或两个\",{\"1\":{\"61\":1}}],[\"一个方法\",{\"1\":{\"35\":1}}],[\"一次编译\",{\"1\":{\"40\":1}}],[\"一般适用于连接数较多且连接时间较长的应用\",{\"1\":{\"30\":1}}],[\"也是取余的效果\",{\"1\":{\"149\":1}}],[\"也达到了取余的效果\",{\"1\":{\"149\":1}}],[\"也会根据threadlocal对象的hash值\",{\"1\":{\"109\":1}}],[\"也叫\",{\"1\":{\"108\":1}}],[\"也被称为类方法\",{\"1\":{\"93\":1}}],[\"也称为类变量\",{\"1\":{\"93\":1}}],[\"也就是支持16个线程的并发写\",{\"1\":{\"162\":1}}],[\"也就是说一个线程可以根据一个threadlocal对象查询到绑定在这个线程上的一个值\",{\"1\":{\"127\":1}}],[\"也就是说守护线程是否结束并不影响\",{\"1\":{\"126\":1}}],[\"也就是\",{\"1\":{\"110\":1}}],[\"也就是线程本地变量\",{\"1\":{\"102\":1}}],[\"也就是基本数据类型变量的值\",{\"1\":{\"99\":1}}],[\"也就是运行的时候就没这个信息了\",{\"1\":{\"81\":1}}],[\"也就是内容一样\",{\"1\":{\"63\":1}}],[\"也可以使⽤\",{\"1\":{\"93\":1}}],[\"也可以继承父类的属性和方法\",{\"1\":{\"87\":1}}],[\"也可以将hessian格式\",{\"1\":{\"69\":1}}],[\"也可以将protobuf格式的数据反序列化为java对象\",{\"1\":{\"69\":1}}],[\"也可以将xml格式的数据反序列化为java对象\",{\"1\":{\"69\":1}}],[\"也可以将json格式的数据反序列化为java对象\",{\"1\":{\"69\":1}}],[\"也可以将对象序列化为json\",{\"1\":{\"69\":1}}],[\"也可以放在变量之后\",{\"1\":{\"57\":1}}],[\"也可以是\",{\"1\":{\"54\":1}}],[\"也可以是一段可以传递的代码\",{\"1\":{\"33\":1}}],[\"也有可能非空的时候\",{\"1\":{\"35\":1}}],[\"也有可能非\",{\"1\":{\"35\":1}}],[\"可控性\",{\"1\":{\"119\":1}}],[\"可能导致get操作返回null\",{\"1\":{\"159\":1}}],[\"可能导致get为null\",{\"1\":{\"159\":1}}],[\"可能会导致环形链表的出现\",{\"1\":{\"159\":1}}],[\"可能会带来较高的内存开销和延迟\",{\"1\":{\"136\":1}}],[\"可能会有空的内存空间\",{\"1\":{\"129\":1}}],[\"可能不会执行的情况\",{\"1\":{\"73\":1}}],[\"可能是\",{\"1\":{\"35\":1}}],[\"可变\",{\"1\":{\"60\":2}}],[\"可变性\",{\"1\":{\"60\":1}}],[\"可以按照插入顺序或访问顺序进行遍历\",{\"1\":{\"165\":1}}],[\"可以考虑使用\",{\"1\":{\"164\":1}}],[\"可以获得较高的读取性能\",{\"1\":{\"136\":1}}],[\"可以直接使用它来替代arraylist\",{\"1\":{\"135\":1}}],[\"可以直接通过数组下标获取\",{\"1\":{\"129\":1}}],[\"可以再次进入runnable状态\",{\"1\":{\"123\":1}}],[\"可以通过同步机制\",{\"1\":{\"135\":1}}],[\"可以通过java内置的等待\",{\"1\":{\"127\":1}}],[\"可以通过线程池管理\",{\"1\":{\"119\":1}}],[\"可以通过反射获取注解信息\",{\"1\":{\"81\":1}}],[\"可以与其他接口组合\",{\"1\":{\"119\":1}}],[\"可以先讲原对象序列化\",{\"1\":{\"99\":1}}],[\"可以快速定位对象\",{\"1\":{\"97\":1}}],[\"可以阻断\",{\"1\":{\"95\":1}}],[\"可以访问类的所有成员变量和方法\",{\"1\":{\"93\":1}}],[\"可以使⽤\",{\"1\":{\"93\":1}}],[\"可以使用\",{\"1\":{\"160\":2}}],[\"可以使用collections工具类的synchronizedlist方法将arraylist转换为线程安全的list\",{\"1\":{\"135\":1}}],[\"可以使用stringbuilder类以\",{\"1\":{\"60\":1}}],[\"可以使用stringbuffer类\",{\"1\":{\"60\":1}}],[\"可以使用string类\",{\"1\":{\"60\":1}}],[\"可以使用连接池优化\",{\"1\":{\"30\":1}}],[\"可以被public\",{\"1\":{\"92\":1}}],[\"可以被继承吗\",{\"0\":{\"59\":1}}],[\"可以修饰类\",{\"1\":{\"89\":1}}],[\"可以修饰变量\",{\"1\":{\"89\":2}}],[\"可以修饰在类\",{\"1\":{\"89\":1}}],[\"可以在多线程下并发使用\",{\"1\":{\"134\":1}}],[\"可以在编写代码时指定类\",{\"1\":{\"76\":1}}],[\"可以在类中显式地定义serialversionuid字段\",{\"1\":{\"68\":1}}],[\"可以根据通过设置\",{\"1\":{\"64\":1}}],[\"可以将java对象序列化为二进制格式\",{\"1\":{\"69\":1}}],[\"可以将结构化的数据序列化为紧凑的二进制格式\",{\"1\":{\"69\":1}}],[\"可以将\",{\"1\":{\"35\":1}}],[\"可以传递一段代码\",{\"1\":{\"32\":1}}],[\"可以划分为\",{\"1\":{\"28\":1}}],[\"可以分为\",{\"1\":{\"28\":1}}],[\"可以看提交记录\",{\"1\":{\"24\":1}}],[\"看做是包装对象\",{\"1\":{\"35\":1}}],[\"注意\",{\"1\":{\"89\":2,\"134\":1}}],[\"注解生命周期\",{\"1\":{\"81\":1}}],[\"注解可以标记在类上\",{\"1\":{\"81\":1}}],[\"注解\",{\"0\":{\"80\":1}}],[\"注解的接口\",{\"1\":{\"34\":1}}],[\"注册\",{\"1\":{\"30\":1}}],[\"添加了\",{\"1\":{\"34\":1}}],[\"表示当前线程已经执行完毕\",{\"1\":{\"121\":1}}],[\"表示线程进入等待状态\",{\"1\":{\"121\":1}}],[\"表示线程阻塞于锁\",{\"1\":{\"121\":1}}],[\"表示具体的一个\",{\"1\":{\"78\":1}}],[\"表示不确定的\",{\"1\":{\"78\":1}}],[\"表示式\",{\"1\":{\"33\":1}}],[\"表达式了解多少\",{\"0\":{\"33\":1}}],[\"表达式最好不要超过3行\",{\"1\":{\"32\":1}}],[\"表达式使代码更加简洁\",{\"1\":{\"32\":1}}],[\"表达式本质上是一段匿名内部类\",{\"1\":{\"32\":1,\"33\":1}}],[\"表达式和函数式接口\",{\"1\":{\"32\":1}}],[\"类变量\",{\"1\":{\"92\":2}}],[\"类的常见方法\",{\"0\":{\"66\":1}}],[\"类名\",{\"1\":{\"60\":1,\"93\":1}}],[\"类可以继承吗\",{\"1\":{\"59\":1}}],[\"类库\",{\"1\":{\"39\":1}}],[\"类型\",{\"1\":{\"36\":1,\"54\":1,\"78\":2}}],[\"类\",{\"1\":{\"32\":1,\"50\":1,\"134\":1}}],[\"提高插入操作的效率\",{\"1\":{\"157\":1}}],[\"提高了插入和删除操作的效率\",{\"1\":{\"143\":1}}],[\"提高了代码的运行效率和与旧版本\",{\"1\":{\"79\":1}}],[\"提高了代码的可读性和简洁性\",{\"1\":{\"32\":1}}],[\"提供了更好的日期和时间处理方式\",{\"1\":{\"32\":1}}],[\"提供了最基本的输入输出操作\",{\"1\":{\"29\":1}}],[\"聚合等操作\",{\"1\":{\"32\":1}}],[\"排序\",{\"1\":{\"32\":1,\"36\":1}}],[\"映射\",{\"1\":{\"32\":1}}],[\"我们设的比较小的话\",{\"1\":{\"155\":1}}],[\"我们就可以在编译或者运行阶段去识别这些标记\",{\"1\":{\"81\":1}}],[\"我们就可以考虑用\",{\"1\":{\"35\":1}}],[\"我们能够将\",{\"1\":{\"36\":1}}],[\"我们可以获取到class对象信息\",{\"1\":{\"48\":1}}],[\"我们可以避免空指针异常\",{\"1\":{\"32\":1}}],[\"我们可以对集合进行过滤\",{\"1\":{\"32\":1}}],[\"我们无法正确输出子进程的进度条\",{\"1\":{\"11\":1}}],[\"更高效\",{\"1\":{\"157\":1}}],[\"更多的是一种兜底的策略\",{\"1\":{\"153\":1}}],[\"更易于并行处理数据集合的方式\",{\"1\":{\"32\":1}}],[\"更新博客只在master分支上改\",{\"0\":{\"22\":1}}],[\"但hashmap的实际容量是32\",{\"1\":{\"150\":1}}],[\"但在读操作频繁\",{\"1\":{\"136\":1}}],[\"但它的性能很低\",{\"1\":{\"135\":1}}],[\"但同样地\",{\"1\":{\"134\":1}}],[\"但实际只用了50\",{\"1\":{\"132\":1}}],[\"但还没有调用start\",{\"1\":{\"121\":1}}],[\"但可以通过引用修改对象的状态\",{\"1\":{\"98\":1}}],[\"但只能继承一个抽象类\",{\"1\":{\"91\":1}}],[\"但是就需要更多的空间去存储元素\",{\"1\":{\"155\":1}}],[\"但是如果插入中间的位置\",{\"1\":{\"129\":1}}],[\"但是线程调度器可以无条件忽略这个暗示\",{\"1\":{\"120\":1}}],[\"但是线程a所拥有的监视器资源\",{\"1\":{\"120\":1}}],[\"但是它不会重新尝试获取锁\",{\"1\":{\"120\":1}}],[\"但是一个时间段内\",{\"1\":{\"115\":1}}],[\"但是threadlocalmap生命周期和thread是一样的\",{\"1\":{\"105\":1}}],[\"但是仍然希望能够反序列化之前的序列化数据\",{\"1\":{\"68\":1}}],[\"但是长整型\",{\"1\":{\"54\":1}}],[\"但是\",{\"1\":{\"39\":1}}],[\"但是也不要滥用\",{\"1\":{\"32\":1}}],[\"但为了更方便地处理文本数据\",{\"1\":{\"29\":1}}],[\"使用的是哈希表的数据结构\",{\"1\":{\"164\":1}}],[\"使用的时候再一个一个的一次调用就可以\",{\"1\":{\"86\":1}}],[\"使用reentrantlock加锁\",{\"1\":{\"162\":1}}],[\"使用线程安全的并发容器\",{\"1\":{\"160\":1}}],[\"使用线程安全的包装类\",{\"1\":{\"160\":1}}],[\"使用同步机制\",{\"1\":{\"160\":1}}],[\"使用同步机制控制arraylist的读写\",{\"1\":{\"135\":1}}],[\"使用随机哈希码\",{\"1\":{\"153\":1}}],[\"使用扰动函数\",{\"1\":{\"146\":1}}],[\"使用链表存储键值对\",{\"1\":{\"139\":1}}],[\"使用copyonwritearraylist代替arraylist\",{\"1\":{\"135\":1}}],[\"使用collections\",{\"1\":{\"135\":1}}],[\"使用threadlocal\",{\"1\":{\"127\":1}}],[\"使用thread\",{\"1\":{\"127\":1}}],[\"使用完threadlocal后\",{\"1\":{\"106\":1}}],[\"使用java\",{\"1\":{\"84\":1}}],[\"使用for\",{\"1\":{\"84\":2}}],[\"使用迭代器遍历\",{\"1\":{\"84\":1}}],[\"使用注解作为切点就是运行期注解的应用\",{\"1\":{\"81\":1}}],[\"使用建议\",{\"1\":{\"60\":1}}],[\"使用stringbuilder可以获得更好的性能\",{\"1\":{\"60\":1}}],[\"使用stringbuffer可以保证线程安全\",{\"1\":{\"60\":1}}],[\"使用\",{\"1\":{\"32\":1,\"36\":1,\"60\":2,\"68\":1,\"160\":1}}],[\"使其成为监视对象\",{\"1\":{\"30\":1}}],[\"在冲突的位置拉一个链表\",{\"1\":{\"152\":1}}],[\"在扩容时保持链表元素原本的顺序\",{\"1\":{\"159\":1}}],[\"在扩容时\",{\"1\":{\"149\":1,\"157\":1}}],[\"在使用arraylist时\",{\"1\":{\"135\":1}}],[\"在遍历期间原集合发生的修改迭代器是不知道的\",{\"1\":{\"134\":1}}],[\"在遍历时不是直接在集合内容上访问的\",{\"1\":{\"134\":1}}],[\"在拷贝的集合上进行遍历\",{\"1\":{\"134\":1}}],[\"在用迭代器遍历一个集合对象时\",{\"1\":{\"134\":1}}],[\"在编写多线程应用程序时\",{\"1\":{\"124\":1}}],[\"在编译时候就确定了类型信息\",{\"1\":{\"46\":1}}],[\"在这个过程中\",{\"1\":{\"124\":1}}],[\"在等待时间内没有其他线程调用相同对象的\",{\"1\":{\"120\":1}}],[\"在子线程中就可以拿到了\",{\"1\":{\"111\":1}}],[\"在主线程的inheritablethreadlocal实例设置值\",{\"1\":{\"111\":1}}],[\"在get的时候\",{\"1\":{\"109\":1}}],[\"在thread的构造函数中\",{\"1\":{\"112\":1}}],[\"在thread类里还有另外一个变量\",{\"1\":{\"112\":1}}],[\"在threadlocalmap\",{\"1\":{\"110\":1}}],[\"在threadlocal中\",{\"1\":{\"107\":1}}],[\"在try块中发生了线程死锁\",{\"1\":{\"73\":1}}],[\"在try块中发生了死循环或无限递归\",{\"1\":{\"73\":1}}],[\"在try块中调用了system\",{\"1\":{\"73\":1}}],[\"在自己的map里找对应的key\",{\"1\":{\"104\":1}}],[\"在自动装箱的时候会调用integer\",{\"1\":{\"64\":1}}],[\"在外部调⽤静态⽅法时\",{\"1\":{\"93\":1}}],[\"在同一类内可见\",{\"1\":{\"89\":1}}],[\"在同一包内可见\",{\"1\":{\"89\":1}}],[\"在类加载阶段丢弃\",{\"1\":{\"81\":1}}],[\"在运行时获取泛型类型信息\",{\"1\":{\"79\":1}}],[\"在运行时动态地获取类信息\",{\"1\":{\"46\":1}}],[\"在执行\",{\"1\":{\"74\":1}}],[\"在\",{\"1\":{\"74\":1,\"87\":1,\"95\":1,\"166\":1}}],[\"在序列化时不需要保存\",{\"1\":{\"68\":1}}],[\"在静态块中会初始化好缓存值\",{\"1\":{\"64\":1}}],[\"在jvm\",{\"1\":{\"126\":1}}],[\"在jdk\",{\"1\":{\"91\":1,\"157\":2}}],[\"在jdk1\",{\"1\":{\"62\":1,\"159\":1,\"161\":1}}],[\"在java8时jdk对\",{\"1\":{\"62\":1}}],[\"在java中\",{\"1\":{\"48\":1}}],[\"在java\",{\"1\":{\"32\":1}}],[\"在堆里创建一个\",{\"1\":{\"61\":1}}],[\"在单线程环境下\",{\"1\":{\"60\":1}}],[\"在多线程环境下使用stringbuilder\",{\"1\":{\"60\":1}}],[\"在多线程环境下\",{\"1\":{\"60\":1}}],[\"在目前所有的版本中都是不可以的\",{\"1\":{\"54\":1}}],[\"在应用程序运行时\",{\"1\":{\"44\":1}}],[\"在actions菜单栏中应该会触发自动发布\",{\"1\":{\"21\":1}}],[\"服务使用\",{\"1\":{\"44\":1}}],[\"服务加载\",{\"1\":{\"44\":1}}],[\"服务加载器\",{\"1\":{\"44\":1}}],[\"服务提供者配置文件\",{\"1\":{\"44\":1}}],[\"服务提供者\",{\"1\":{\"44\":1}}],[\"服务接口\",{\"1\":{\"44\":1}}],[\"服务端程序启动线程去处理\",{\"1\":{\"30\":1}}],[\"服务器端得到通知\",{\"1\":{\"30\":1}}],[\"服务器端用一个线程处理多个连接\",{\"1\":{\"30\":1}}],[\"回调\",{\"1\":{\"30\":1}}],[\"就使用synchronized写入数据\",{\"1\":{\"163\":1}}],[\"就通过cas+自旋的方式初始化数组\",{\"1\":{\"163\":1}}],[\"就需要把插入位置后的元素都向前或者向后移动\",{\"1\":{\"129\":1}}],[\"就起不到多线程的效果\",{\"1\":{\"118\":1}}],[\"就把它赋给当前线程\",{\"1\":{\"112\":1}}],[\"就开始执行\",{\"1\":{\"110\":1}}],[\"就判断下一个位置\",{\"1\":{\"109\":1}}],[\"就会导致后一个key覆盖前一个key\",{\"1\":{\"159\":1}}],[\"就会触发扩容\",{\"1\":{\"154\":1,\"156\":1}}],[\"就会触发自动发布\",{\"1\":{\"21\":1}}],[\"就会改变\",{\"1\":{\"134\":1}}],[\"就会造成了内存泄漏问题\",{\"1\":{\"105\":1}}],[\"就会出现这种情况\",{\"1\":{\"105\":1}}],[\"就是和hashmap一样\",{\"1\":{\"162\":1}}],[\"就是由加载因子和当前容器的容量大小来确定的\",{\"1\":{\"154\":1}}],[\"就是告知程序任何对该变量的访问均需要从共享内存中获取\",{\"1\":{\"127\":1}}],[\"就是这个坑被人占了\",{\"1\":{\"109\":1}}],[\"就是注解在编译期的运行\",{\"1\":{\"81\":1}}],[\"就是\",{\"1\":{\"30\":1}}],[\"并立即返回\",{\"1\":{\"120\":1}}],[\"并可以与其他接口组合使用\",{\"1\":{\"119\":1}}],[\"并发修改\",{\"1\":{\"134\":1}}],[\"并发的实现依赖于cpu切换线程\",{\"1\":{\"115\":1}}],[\"并发就是同一时刻\",{\"1\":{\"115\":1}}],[\"并行就是同一时刻\",{\"1\":{\"115\":1}}],[\"并行跟并发有什么区别\",{\"0\":{\"115\":1}}],[\"并且在遍历过程中使用一个modcount\",{\"1\":{\"134\":1}}],[\"并且在获取锁之前\",{\"1\":{\"120\":1}}],[\"并且重新尝试获取对象的锁\",{\"1\":{\"120\":1}}],[\"并且可以直接使用接口名调用\",{\"1\":{\"91\":1}}],[\"并且接口中定义了相同的默认方法\",{\"1\":{\"91\":1}}],[\"并通过http协议进行传输\",{\"1\":{\"69\":1}}],[\"并通过配置文件等方式注册到spi框架中\",{\"1\":{\"44\":1}}],[\"并确保在类的修改后\",{\"1\":{\"68\":1}}],[\"并返回string对象的引用\",{\"1\":{\"63\":1}}],[\"并在运行时动态地操作类和对象\",{\"1\":{\"48\":1}}],[\"并根据文件中指定的实现类\",{\"1\":{\"44\":1}}],[\"并根据配置文件中指定的实现类实例化相应的对象\",{\"1\":{\"44\":1}}],[\"并提供了具体的功能实现\",{\"1\":{\"44\":1}}],[\"并提供了更多的功能和灵活性\",{\"1\":{\"32\":1}}],[\"并更好地处理可能为空的值\",{\"1\":{\"32\":1}}],[\"并执行相应的读取或写入操作\",{\"1\":{\"30\":1}}],[\"并将新的通道\",{\"1\":{\"30\":1}}],[\"会根据返回值是否为空来判断是否插入元素成功\",{\"1\":{\"168\":1}}],[\"会发生链表和红黑树的不断转换\",{\"1\":{\"153\":1}}],[\"会带来一定的内存开销\",{\"1\":{\"136\":1}}],[\"会继续往下执行\",{\"1\":{\"120\":1}}],[\"会唤醒一个在这个共享变量上调用\",{\"1\":{\"120\":1}}],[\"会先创建一条线程\",{\"1\":{\"118\":1}}],[\"会先去清理过期的entry\",{\"1\":{\"110\":1}}],[\"会先将\",{\"1\":{\"74\":1}}],[\"会影响原对象\",{\"1\":{\"99\":1}}],[\"会写入\",{\"1\":{\"81\":2}}],[\"会返回之前暂存的结果\",{\"1\":{\"74\":1}}],[\"会比较序列化类的版本号和当前类的版本号是否一致\",{\"1\":{\"68\":1}}],[\"会产生大量的临时对象\",{\"1\":{\"60\":1}}],[\"会将该通道标记为就绪状态\",{\"1\":{\"30\":1}}],[\"会处理这个事件\",{\"1\":{\"30\":1}}],[\"当多个线程同时执行put操作时\",{\"1\":{\"159\":1}}],[\"当多个线程同时进行扩容操作时\",{\"1\":{\"159\":1}}],[\"当插入新的键值对时\",{\"1\":{\"157\":1}}],[\"当发生哈希碰撞时\",{\"1\":{\"157\":1}}],[\"当哈希冲突较多时\",{\"1\":{\"157\":1}}],[\"当前hashmap的元素个数达到一个临界值的时候\",{\"1\":{\"154\":1,\"156\":1}}],[\"当前节点是否为树节点\",{\"1\":{\"146\":1}}],[\"当前节点和key匹配\",{\"1\":{\"146\":1}}],[\"当前线程a等待thread线程终止之后才从thread\",{\"1\":{\"127\":1}}],[\"当前线程a等待thread线程终止之后从thread\",{\"1\":{\"120\":1}}],[\"当桶中的元素较多时\",{\"1\":{\"139\":1}}],[\"当桶中的元素较少时\",{\"1\":{\"139\":1}}],[\"当线程a运行时\",{\"1\":{\"120\":1}}],[\"当一个线程执行put操作导致扩容时\",{\"1\":{\"159\":1}}],[\"当一个线程因为等待某些事件\",{\"1\":{\"125\":1}}],[\"当一个线程的时间片用完时\",{\"1\":{\"125\":1}}],[\"当一个线程调用了\",{\"1\":{\"125\":1}}],[\"当一个线程调用\",{\"1\":{\"120\":1}}],[\"当一个线程a调用一个共享变量的\",{\"1\":{\"120\":1}}],[\"当一个执行中的线程a调用了thread的sleep方法后\",{\"1\":{\"120\":1}}],[\"当一个类的实例被序列化后\",{\"1\":{\"68\":1}}],[\"当一个类被序列化后\",{\"1\":{\"68\":1}}],[\"当传递对象引用时\",{\"1\":{\"98\":1}}],[\"当传递基本数据类型\",{\"1\":{\"98\":1}}],[\"当对象被反序列化时\",{\"1\":{\"68\":1}}],[\"当反序列化时\",{\"1\":{\"68\":1}}],[\"当运算符放在变量之后时\",{\"1\":{\"57\":1}}],[\"当我们定义了\",{\"1\":{\"35\":1}}],[\"当有事件触发时\",{\"1\":{\"30\":1}}],[\"当有新的连接请求到达时\",{\"1\":{\"30\":1}}],[\"当某个通道\",{\"1\":{\"30\":1}}],[\"不存在就再插入链表\",{\"1\":{\"162\":1}}],[\"不需要移动元素\",{\"1\":{\"129\":1}}],[\"不方便\",{\"1\":{\"119\":1}}],[\"不为空\",{\"1\":{\"112\":1}}],[\"不擅技术\",{\"1\":{\"111\":1}}],[\"不管jvm的内存空间是否充足\",{\"1\":{\"105\":1}}],[\"不推荐使用\",{\"1\":{\"95\":1,\"135\":1}}],[\"不属于类的任何一个对象\",{\"1\":{\"93\":1}}],[\"不能在多线程下发生并发修改\",{\"1\":{\"134\":1}}],[\"不能依赖于这个异常是否抛出而进行并发操作的编程\",{\"1\":{\"134\":1}}],[\"不能被访问控制修饰符及static所修饰\",{\"1\":{\"92\":1}}],[\"不能有其他类型的变量\",{\"1\":{\"91\":1}}],[\"不能实现\",{\"1\":{\"91\":1}}],[\"不能修饰外部类\",{\"1\":{\"89\":2}}],[\"不能修饰类和方法\",{\"1\":{\"68\":1}}],[\"不使用任何修饰符\",{\"1\":{\"89\":1}}],[\"不允许键和值为null\",{\"1\":{\"83\":1}}],[\"不会写入\",{\"1\":{\"81\":1}}],[\"不会出现线程安全问题\",{\"1\":{\"59\":1}}],[\"不包含静态变量\",{\"1\":{\"68\":1}}],[\"不可变\",{\"1\":{\"60\":1}}],[\"不行\",{\"1\":{\"59\":1}}],[\"不是通过插入顺序遍历\",{\"1\":{\"166\":1}}],[\"不是线程安全的\",{\"1\":{\"159\":1}}],[\"不是引用指向的内容的不可变\",{\"1\":{\"94\":1}}],[\"不是\",{\"1\":{\"59\":1}}],[\"不再执行任何代码\",{\"1\":{\"123\":1}}],[\"不再执行下面的代码\",{\"1\":{\"55\":1}}],[\"不再执行循环\",{\"1\":{\"55\":1}}],[\"不同的是\",{\"1\":{\"120\":1}}],[\"不同的jvm\",{\"1\":{\"39\":1}}],[\"不同于在共享变量上调用\",{\"1\":{\"120\":1}}],[\"不同系统安装不同java虚拟机\",{\"1\":{\"40\":1}}],[\"不断监听通道列表\",{\"1\":{\"30\":1}}],[\"不要动gh\",{\"0\":{\"22\":1}}],[\"以平衡性能和空间的消耗\",{\"1\":{\"157\":1}}],[\"以确保线程安全\",{\"1\":{\"135\":1}}],[\"以提高查找\",{\"1\":{\"139\":1,\"157\":1}}],[\"以提高系统的性能和效率\",{\"1\":{\"124\":1}}],[\"以提高性能和节省内存\",{\"1\":{\"59\":1}}],[\"以便该线程可以继续执行\",{\"1\":{\"124\":1}}],[\"以便选择器可以监听多个通道的事件\",{\"1\":{\"30\":1}}],[\"以及不写\",{\"0\":{\"89\":1}}],[\"以及无法使用基本类型作为泛型参数等\",{\"1\":{\"79\":1}}],[\"以前\",{\"1\":{\"54\":1}}],[\"以接口的全限定名命名\",{\"1\":{\"44\":1}}],[\"以备后续操作\",{\"1\":{\"30\":1}}],[\"发生哈希碰撞的概率就降低了\",{\"1\":{\"155\":1}}],[\"发生概率仅为0\",{\"1\":{\"153\":1}}],[\"发生下面几种情况才会返回\",{\"1\":{\"120\":1}}],[\"发生在具有继承关系的父子类中\",{\"1\":{\"88\":1}}],[\"发生在同一个类中\",{\"1\":{\"88\":1}}],[\"发起连接请求\",{\"1\":{\"30\":1}}],[\"发布完成后\",{\"1\":{\"21\":1}}],[\"发布到github\",{\"0\":{\"15\":1}}],[\"客户端发送的连接请求会注册到多路复用器上\",{\"1\":{\"30\":1}}],[\"客户端有连接请求时服务器端就需要启动一个线程进行处理\",{\"1\":{\"30\":1}}],[\"尽管字节流可以处理所有类型的数据\",{\"1\":{\"29\":1}}],[\"尤其是当涉及到国际化和本地化时\",{\"1\":{\"29\":1}}],[\"这是对\",{\"1\":{\"155\":1}}],[\"这是java的规定\",{\"1\":{\"97\":1}}],[\"这样做可以减少链表或红黑树的重新排序次数\",{\"1\":{\"157\":1}}],[\"这样使得哈希值的分布更加均匀\",{\"1\":{\"148\":1}}],[\"这样的设计增加了哈希值的随机性\",{\"1\":{\"147\":1}}],[\"这样可以提高序列化和反序列化的效率\",{\"1\":{\"132\":1}}],[\"这样设计的原因\",{\"1\":{\"59\":1}}],[\"这两种状态的区别在于阻塞状态是等待获取锁\",{\"1\":{\"122\":1}}],[\"这才起到多线程的效果\",{\"1\":{\"118\":1}}],[\"这种查找\",{\"1\":{\"129\":1}}],[\"这种方式可以通过futuretask获取任务执行的返回值\",{\"1\":{\"117\":1}}],[\"这种字节码必须再经过jvm\",{\"1\":{\"42\":1}}],[\"这就要求有两个cpu去分别执行两个线程\",{\"1\":{\"115\":1}}],[\"这就是注解的用处\",{\"1\":{\"81\":1}}],[\"这就是泛型擦除\",{\"1\":{\"79\":1}}],[\"这就是通过字符串常量池来实现的\",{\"1\":{\"59\":1}}],[\"这\",{\"1\":{\"105\":1}}],[\"这里异常的抛出条件是检测到\",{\"1\":{\"134\":1}}],[\"这里的threadlocalhashcode计算有点东西\",{\"1\":{\"108\":1}}],[\"这里的不可变指的是变量的引用不可变\",{\"1\":{\"94\":1}}],[\"这里可能会涉及多层递归\",{\"1\":{\"99\":1}}],[\"这意味着它不能被继承\",{\"1\":{\"59\":1}}],[\"这个问题在jdk1\",{\"1\":{\"159\":2}}],[\"这个\",{\"1\":{\"154\":1}}],[\"这个异常只建议用于检测并发修改的bug\",{\"1\":{\"134\":1}}],[\"这个条件\",{\"1\":{\"134\":1}}],[\"这个接口只是用来标识是否支持随机访问\",{\"1\":{\"129\":1}}],[\"这个接口是服务的契约\",{\"1\":{\"44\":1}}],[\"这个结构被附带在线程上\",{\"1\":{\"127\":1}}],[\"这个数字\",{\"1\":{\"108\":1}}],[\"这个值很特殊\",{\"1\":{\"108\":1}}],[\"这个方法返回一个线程安全的map对象\",{\"1\":{\"160\":1}}],[\"这个方法返回的对象可能是空\",{\"1\":{\"35\":1}}],[\"这个方法相比\",{\"1\":{\"120\":1}}],[\"这个方法在\",{\"1\":{\"95\":1}}],[\"这些操作可能是\",{\"1\":{\"36\":1}}],[\"这也是在\",{\"1\":{\"35\":1}}],[\"这使得字符流在处理文本数据时更方便和高效\",{\"1\":{\"29\":1}}],[\"这可能需要数分钟\",{\"1\":{\"11\":1}}],[\"适用于处理文本数据\",{\"1\":{\"29\":1}}],[\"适用于处理二进制数据\",{\"1\":{\"29\":1}}],[\"视频等\",{\"1\":{\"29\":1}}],[\"音频\",{\"1\":{\"29\":1}}],[\"为\",{\"1\":{\"105\":1}}],[\"为了减少哈希冲突发生的概率\",{\"1\":{\"154\":1,\"156\":1}}],[\"为了避免这种问题\",{\"1\":{\"68\":1}}],[\"为了保证线程安全性\",{\"1\":{\"60\":1}}],[\"为什么\",{\"0\":{\"157\":1}}],[\"为什么扩容因子是0\",{\"0\":{\"154\":1}}],[\"为什么hashmap链表转红黑树的阈值为8呢\",{\"0\":{\"153\":1}}],[\"为什么hashmap的容量是2的倍数呢\",{\"0\":{\"149\":1}}],[\"为什么哈希\",{\"0\":{\"148\":1}}],[\"为什么不用平衡二叉树\",{\"0\":{\"143\":1}}],[\"为什么不用二叉树\",{\"0\":{\"140\":1,\"142\":1}}],[\"为什么最arraylist不直接序列化元素数组呢\",{\"0\":{\"132\":1}}],[\"为什么用transient修饰数组\",{\"0\":{\"131\":1}}],[\"为什么我们不能直接调用run\",{\"1\":{\"118\":1}}],[\"为什么调用start\",{\"0\":{\"118\":1}}],[\"为什么key还要设计成弱引用\",{\"0\":{\"107\":1}}],[\"为什么重写\",{\"1\":{\"97\":1}}],[\"为什么说\",{\"0\":{\"42\":1}}],[\"为什么还要有字符流\",{\"0\":{\"29\":1}}],[\"为change\",{\"1\":{\"20\":1}}],[\"既然有了字节流\",{\"0\":{\"29\":1}}],[\"处理流\",{\"1\":{\"28\":1}}],[\"字符串拼接是如何实现的\",{\"0\":{\"62\":1}}],[\"字符串对象实例\",{\"1\":{\"61\":1}}],[\"字符串常量池的优化\",{\"1\":{\"59\":1}}],[\"字符串的不可变性\",{\"1\":{\"59\":1}}],[\"字符型\",{\"1\":{\"50\":1}}],[\"字符流会自动处理字符编码和解码\",{\"1\":{\"29\":1}}],[\"字符流以字符为单位进行输入输出\",{\"1\":{\"29\":1}}],[\"字符流更适合读取和写入文本文件\",{\"1\":{\"29\":1}}],[\"字符流\",{\"1\":{\"28\":1,\"29\":1}}],[\"字段\",{\"1\":{\"48\":1}}],[\"字节\",{\"1\":{\"50\":1}}],[\"字节码能够被虚拟机识别\",{\"1\":{\"41\":1}}],[\"字节流通常用于处理文件和网络连接中的数据传输\",{\"1\":{\"29\":1}}],[\"字节流以字节为单位进行输入输出\",{\"1\":{\"29\":1}}],[\"字节流则更适合处理二进制数据\",{\"1\":{\"29\":1}}],[\"字节流\",{\"1\":{\"28\":1,\"29\":1}}],[\"前两种面向字节\",{\"1\":{\"127\":1}}],[\"前会先执行\",{\"1\":{\"74\":1}}],[\"前缀\",{\"1\":{\"57\":1}}],[\"前者是字节输出流\",{\"1\":{\"28\":1}}],[\"前者是字节输入流\",{\"1\":{\"28\":1}}],[\"前端\",{\"2\":{\"25\":1}}],[\"所谓多态就是指程序中定义的引⽤变量所指向的具体类型和通过该引⽤变量发出的⽅法调⽤在编程时并不确定\",{\"1\":{\"87\":1}}],[\"所以get是不需要加锁的\",{\"1\":{\"162\":1}}],[\"所以转红黑树\",{\"1\":{\"153\":1}}],[\"所以传入17\",{\"1\":{\"150\":1}}],[\"所以对扰动函数通过对哈希值进行变换\",{\"1\":{\"148\":1}}],[\"所以在遍历过程中对原集合所作的修改并不能被迭代器检测到\",{\"1\":{\"134\":1}}],[\"所以每个节点会占用更多的空间\",{\"1\":{\"129\":1}}],[\"所以它没法根据序号直接获取元素\",{\"1\":{\"129\":1}}],[\"所以它可以根据下标查找\",{\"1\":{\"129\":1}}],[\"所以基本对于用户是无感知的\",{\"1\":{\"115\":1}}],[\"所以不会触发concurrent\",{\"1\":{\"134\":1}}],[\"所以不会再次调用\",{\"1\":{\"95\":1}}],[\"所以不能使用private修饰符\",{\"1\":{\"91\":1}}],[\"所以即使\",{\"1\":{\"74\":1}}],[\"所以是先输出\",{\"1\":{\"74\":1}}],[\"所以进程可能会看似未响应\",{\"1\":{\"11\":1}}],[\"所拥有的⼀\",{\"1\":{\"39\":1}}],[\"所有对象共享同一份静态变量的拷贝\",{\"1\":{\"92\":1}}],[\"所有输出流的基类\",{\"1\":{\"28\":1}}],[\"所有的输入流的基类\",{\"1\":{\"28\":1}}],[\"输出流主要包括了如下4种具体实现\",{\"1\":{\"127\":1}}],[\"输出流不同之处在于\",{\"1\":{\"127\":1}}],[\"输出流或者网络输入\",{\"1\":{\"127\":1}}],[\"输出流和普通的文件输入\",{\"1\":{\"127\":1}}],[\"输出流\",{\"1\":{\"28\":1,\"127\":1}}],[\"输入流\",{\"1\":{\"28\":1}}],[\"中断线程\",{\"1\":{\"120\":1}}],[\"中的⽅法\",{\"1\":{\"168\":1}}],[\"中的线程中断是一种线程间的协作模式\",{\"1\":{\"120\":1}}],[\"中的集合类\",{\"1\":{\"97\":1}}],[\"中了\",{\"1\":{\"110\":1}}],[\"中所有的\",{\"1\":{\"110\":1}}],[\"中有两种形式可以实现多态\",{\"1\":{\"87\":1}}],[\"中异常层级结构\",{\"0\":{\"71\":1}}],[\"中引入了枚举类型\",{\"1\":{\"54\":1}}],[\"中文翻译为\",{\"1\":{\"36\":1}}],[\"中字符串开头为\",{\"1\":{\"36\":1}}],[\"中间操作\",{\"1\":{\"36\":1}}],[\"中通道的读写事件\",{\"1\":{\"30\":1}}],[\"中\",{\"0\":{\"28\":1},\"1\":{\"30\":1,\"36\":2,\"54\":1,\"164\":1,\"166\":1}}],[\"just\",{\"1\":{\"163\":1}}],[\"join\",{\"1\":{\"120\":3,\"122\":1,\"127\":3}}],[\"josh\",{\"1\":{\"32\":1}}],[\"jdb\",{\"1\":{\"39\":1}}],[\"jdk5之前是没有泛型\",{\"1\":{\"79\":1}}],[\"jdk包含jre\",{\"1\":{\"39\":1}}],[\"jdk\",{\"0\":{\"39\":1},\"1\":{\"39\":1,\"91\":1,\"157\":3}}],[\"jdk11使用byte\",{\"1\":{\"60\":1}}],[\"jdk1\",{\"0\":{\"31\":1,\"32\":1,\"157\":1,\"162\":1,\"163\":1},\"1\":{\"30\":1,\"139\":2,\"159\":1,\"162\":1}}],[\"jre包含jvm\",{\"1\":{\"39\":1}}],[\"jre\",{\"0\":{\"39\":1},\"1\":{\"39\":2}}],[\"jvm退出\",{\"1\":{\"126\":1}}],[\"jvm会正常退出\",{\"1\":{\"126\":1}}],[\"jvm执行start方法\",{\"1\":{\"118\":1}}],[\"jvm\",{\"0\":{\"39\":1},\"1\":{\"39\":2,\"48\":1,\"64\":1,\"74\":1}}],[\"java集合\",{\"0\":{\"175\":1}}],[\"java并发\",{\"0\":{\"174\":1}}],[\"java基础\",{\"0\":{\"172\":1}}],[\"java线程将操作系统中的就绪和运行两种状态笼\",{\"1\":{\"121\":1}}],[\"java语言是值传递\",{\"1\":{\"98\":1}}],[\"java语言有哪些特点\",{\"0\":{\"38\":1}}],[\"java是值传递\",{\"0\":{\"98\":1}}],[\"java中的线程分为两类\",{\"1\":{\"126\":1}}],[\"java中序列化可以通过实现externalizable或者serializable来实现\",{\"1\":{\"100\":1}}],[\"java中实现map接口的有哪些类\",{\"0\":{\"83\":1}}],[\"java中可以使用google提供的protobuf\",{\"1\":{\"69\":1}}],[\"java中可以使用第三方库\",{\"1\":{\"69\":3}}],[\"java注解本质上是一个标记\",{\"1\":{\"81\":1}}],[\"java泛型是java\",{\"1\":{\"76\":1}}],[\"java库\",{\"1\":{\"69\":1}}],[\"java序列化可以将对象序列化为字节流\",{\"1\":{\"69\":1}}],[\"java序列化只会保存对象的非静态成员变量\",{\"1\":{\"68\":1}}],[\"java对象流序列化是java标准库提供的一种序列化方式\",{\"1\":{\"69\":1}}],[\"java对象流序列化\",{\"1\":{\"69\":1}}],[\"java可以对字符串进行缓存和共享\",{\"1\":{\"59\":1}}],[\"java5\",{\"1\":{\"54\":1}}],[\"java有哪些数据类型\",{\"0\":{\"50\":1}}],[\"java的spi机制会使用服务加载器加载这些配置文件\",{\"1\":{\"44\":1}}],[\"java的spi\",{\"1\":{\"44\":1}}],[\"javadoc\",{\"1\":{\"39\":1}}],[\"javac\",{\"1\":{\"39\":1}}],[\"java程序运行在java虚拟机上\",{\"1\":{\"39\":1}}],[\"java虚拟机\",{\"1\":{\"39\":1}}],[\"java概述\",{\"0\":{\"37\":1}}],[\"java8有哪些内置函数式接口\",{\"0\":{\"34\":1}}],[\"java提供了字符流\",{\"1\":{\"29\":1}}],[\"java\",{\"0\":{\"28\":1,\"42\":1,\"59\":1,\"71\":1,\"100\":1,\"173\":1},\"1\":{\"30\":1,\"32\":3,\"35\":1,\"36\":1,\"39\":7,\"41\":2,\"42\":2,\"54\":3,\"68\":1,\"78\":3,\"79\":1,\"87\":1,\"95\":1,\"97\":1,\"120\":1,\"134\":2}}],[\"javascript\",{\"2\":{\"26\":1}}],[\"json序列化\",{\"1\":{\"69\":1}}],[\"json\",{\"1\":{\"11\":1}}],[\"踩了一些坑\",{\"1\":{\"24\":1}}],[\"踩坑\",{\"0\":{\"24\":1}}],[\"默认的segment长度是16\",{\"1\":{\"162\":1}}],[\"默认情况类没有覆盖\",{\"1\":{\"96\":1}}],[\"默认\",{\"0\":{\"89\":1}}],[\"默认范围是\",{\"1\":{\"64\":1}}],[\"默认值\",{\"1\":{\"23\":1,\"50\":1,\"92\":1}}],[\"默认为\",{\"1\":{\"11\":1}}],[\"功能链接跳转不对问题\",{\"0\":{\"23\":1}}],[\"修饰存储元素的\",{\"1\":{\"131\":1}}],[\"修饰的变量不可变\",{\"1\":{\"95\":1}}],[\"修饰的变量值不会被持久化和恢复\",{\"1\":{\"68\":1}}],[\"修饰的方法不可被重写\",{\"1\":{\"95\":1}}],[\"修饰符修饰的变量\",{\"1\":{\"93\":1}}],[\"修复\",{\"0\":{\"23\":1}}],[\"修改是无效的\",{\"1\":{\"74\":1}}],[\"修改theme\",{\"1\":{\"23\":1}}],[\"修改\",{\"0\":{\"16\":1,\"17\":1},\"1\":{\"134\":1}}],[\"需要注意的是value是volatile的\",{\"1\":{\"162\":1}}],[\"需要更多的旋转操作来保持平衡\",{\"1\":{\"143\":1}}],[\"需要存储前驱和后继\",{\"1\":{\"129\":1}}],[\"需要遍历链表\",{\"1\":{\"129\":1}}],[\"需要手动管理线程\",{\"1\":{\"119\":1}}],[\"需要使用\",{\"1\":{\"93\":1}}],[\"需要先创建对象然后通过对象才能访问到它\",{\"1\":{\"93\":1}}],[\"需要先进入项目目录\",{\"1\":{\"14\":1}}],[\"需要保证线程安全\",{\"1\":{\"60\":1}}],[\"需要自行保证线程安全\",{\"1\":{\"60\":1}}],[\"需要强制转换\",{\"1\":{\"51\":1}}],[\"需要build成html文件和js才行\",{\"1\":{\"22\":1}}],[\"gc\",{\"1\":{\"95\":1,\"110\":1}}],[\"gson等\",{\"1\":{\"69\":1}}],[\"get查询\",{\"1\":{\"163\":1}}],[\"get流程\",{\"1\":{\"162\":1}}],[\"gettreenode\",{\"1\":{\"146\":1}}],[\"getnode\",{\"1\":{\"146\":2}}],[\"getsystemclassloader\",{\"1\":{\"112\":1}}],[\"getandadd\",{\"1\":{\"108\":1}}],[\"getclass\",{\"1\":{\"66\":1}}],[\"get\",{\"1\":{\"35\":1,\"102\":1,\"110\":1,\"111\":1,\"129\":3,\"146\":1}}],[\"gh\",{\"1\":{\"22\":1}}],[\"git\",{\"1\":{\"11\":1}}],[\"gitee\",{\"1\":{\"1\":1}}],[\"github上开源\",{\"0\":{\"20\":1}}],[\"github\",{\"1\":{\"1\":1,\"8\":1,\"11\":1}}],[\"是基于红黑树实现的\",{\"1\":{\"166\":1}}],[\"是java提供的线程安全的哈希表实现\",{\"1\":{\"160\":1}}],[\"是线程安全的吗\",{\"0\":{\"159\":1}}],[\"是因为如果这个阈值也设置成8\",{\"1\":{\"153\":1}}],[\"是则向树中插入节点\",{\"1\":{\"145\":1}}],[\"是黑色的\",{\"1\":{\"141\":1}}],[\"是的话就返回遍历\",{\"1\":{\"134\":1}}],[\"是当最后一个非守护线程束时\",{\"1\":{\"126\":1}}],[\"是系统进行资源分配和调度的基本单位\",{\"1\":{\"116\":1}}],[\"是阿里巴巴开源的基于\",{\"1\":{\"113\":1}}],[\"是在\",{\"1\":{\"95\":1}}],[\"是被\",{\"1\":{\"93\":1}}],[\"是程序无法处理的\",{\"1\":{\"71\":1}}],[\"是google开发的一种高效的序列化协议\",{\"1\":{\"69\":1}}],[\"是用到了integer自动装箱的机制\",{\"1\":{\"64\":1}}],[\"是用于加载和实例化服务提供者的api\",{\"1\":{\"44\":1}}],[\"是用于防范\",{\"1\":{\"35\":1}}],[\"是a和b相等\",{\"1\":{\"64\":1}}],[\"是\",{\"0\":{\"59\":1},\"1\":{\"168\":1}}],[\"是一块连续的内存空间\",{\"1\":{\"129\":1}}],[\"是一个以threadlocal对象为键\",{\"1\":{\"127\":1}}],[\"是一个接口\",{\"1\":{\"119\":1}}],[\"是一个类\",{\"1\":{\"119\":1}}],[\"是一个终端操作\",{\"1\":{\"36\":1}}],[\"是一种有序的的集合\",{\"1\":{\"166\":1}}],[\"是一种行为规范\",{\"1\":{\"91\":1}}],[\"是一种模板设计\",{\"1\":{\"91\":1}}],[\"是一种标记语言\",{\"1\":{\"69\":1}}],[\"是一种轻量级的数据交换格式\",{\"1\":{\"69\":1}}],[\"是一种元数据文件\",{\"1\":{\"44\":1}}],[\"是源码分支\",{\"1\":{\"22\":1}}],[\"是否为树节点\",{\"1\":{\"145\":1}}],[\"是否支持随机访问\",{\"1\":{\"129\":1}}],[\"是否能作用在\",{\"0\":{\"54\":1}}],[\"是否都不是以\",{\"1\":{\"36\":1}}],[\"是否有以\",{\"1\":{\"36\":1}}],[\"是否想要现在启动\",{\"1\":{\"11\":1}}],[\"是否初始化\",{\"1\":{\"11\":1}}],[\"是否需要一个自动部署文档到\",{\"1\":{\"11\":1}}],[\"点击访问即可\",{\"1\":{\"21\":1}}],[\"点击save\",{\"1\":{\"21\":1}}],[\"配置部署分支为gh\",{\"1\":{\"21\":1}}],[\"配置github\",{\"0\":{\"21\":1}}],[\"选中侧边栏pages\",{\"1\":{\"21\":1}}],[\"选择器\",{\"1\":{\"30\":4}}],[\"选择包管理器\",{\"1\":{\"11\":1}}],[\"选择显示语言\",{\"1\":{\"11\":1}}],[\"打开settings\",{\"1\":{\"20\":1}}],[\"打开仓库my\",{\"1\":{\"20\":1,\"21\":1}}],[\"打开http\",{\"1\":{\"12\":1}}],[\"推送新分支到github\",{\"0\":{\"19\":1}}],[\"共享项目到github\",{\"0\":{\"18\":1}}],[\"fast\",{\"0\":{\"134\":1},\"1\":{\"134\":1}}],[\"fail\",{\"0\":{\"134\":2},\"1\":{\"134\":2}}],[\"fallback\",{\"1\":{\"35\":1}}],[\"false\",{\"1\":{\"17\":1,\"36\":1,\"50\":1}}],[\"float\",{\"1\":{\"50\":2,\"98\":1}}],[\"first\",{\"1\":{\"146\":9}}],[\"final修饰的类不可被继承\",{\"1\":{\"95\":1}}],[\"final关键字有什么作用\",{\"0\":{\"94\":1}}],[\"finally中修改try中return的值\",{\"1\":{\"74\":1}}],[\"finally中return\",{\"1\":{\"74\":1}}],[\"finally中正常执行\",{\"1\":{\"74\":1}}],[\"finally\",{\"0\":{\"95\":1},\"1\":{\"74\":10,\"95\":1,\"163\":1}}],[\"finally块中的代码也无法执行\",{\"1\":{\"73\":2}}],[\"finally一定会执行吗\",{\"0\":{\"73\":1}}],[\"finalize的区别\",{\"0\":{\"95\":1}}],[\"finalize\",{\"1\":{\"66\":1,\"95\":6}}],[\"final\",{\"0\":{\"95\":1},\"1\":{\"60\":1,\"91\":1,\"95\":1,\"108\":1,\"111\":1,\"146\":1,\"163\":2}}],[\"field\",{\"1\":{\"46\":1,\"81\":1}}],[\"file\",{\"1\":{\"44\":1}}],[\"filter\",{\"1\":{\"36\":4}}],[\"from\",{\"1\":{\"44\":1}}],[\"forwardingnode<k\",{\"1\":{\"163\":1}}],[\"forwardingnode\",{\"1\":{\"163\":1}}],[\"for\",{\"1\":{\"44\":1,\"110\":2,\"145\":3,\"168\":1}}],[\"foreach\",{\"1\":{\"36\":3}}],[\"found\",{\"1\":{\"11\":1}}],[\"functionname\",{\"1\":{\"77\":2}}],[\"function\",{\"1\":{\"34\":1,\"36\":1}}],[\"functionalinterface\",{\"1\":{\"33\":1,\"34\":1}}],[\"f\",{\"1\":{\"30\":1,\"163\":4}}],[\"writeobject\",{\"1\":{\"168\":1}}],[\"writeobject自定义序列化和反序列化策略\",{\"1\":{\"133\":1}}],[\"writer\",{\"1\":{\"28\":1}}],[\"when\",{\"1\":{\"112\":1,\"163\":1}}],[\"whether\",{\"1\":{\"81\":1}}],[\"while\",{\"1\":{\"110\":1,\"146\":1,\"163\":2}}],[\"windows\",{\"1\":{\"39\":1}}],[\"with\",{\"1\":{\"17\":1}}],[\"waitind\",{\"1\":{\"121\":1}}],[\"waiting状态是暂时的\",{\"1\":{\"123\":1}}],[\"waiting状态表示线程在等待其他线程的通知或中断\",{\"1\":{\"123\":1}}],[\"waiting状态表示线程正在等待其他线程的通知\",{\"1\":{\"122\":1}}],[\"waiting和terminated有什么区别\",{\"0\":{\"123\":1}}],[\"waiting\",{\"1\":{\"121\":2}}],[\"wait\",{\"1\":{\"66\":3,\"120\":8,\"127\":1}}],[\"want\",{\"1\":{\"11\":1}}],[\"was\",{\"1\":{\"11\":1}}],[\"warn\",{\"1\":{\"11\":1}}],[\"的源码⾮常⾮常少\",{\"1\":{\"168\":1}}],[\"的顺序进行排序\",{\"1\":{\"166\":1}}],[\"的自然顺序或者\",{\"1\":{\"166\":1}}],[\"的基础上维护了一个双向链表\",{\"1\":{\"165\":1}}],[\"的基础用法\",{\"1\":{\"74\":1}}],[\"的策略\",{\"1\":{\"157\":1}}],[\"的概念\",{\"1\":{\"157\":1}}],[\"的某些数字\",{\"1\":{\"151\":1}}],[\"的低位的余数部分\",{\"1\":{\"149\":1}}],[\"的时间自行返回的\",{\"1\":{\"121\":1}}],[\"的调度\",{\"1\":{\"120\":1}}],[\"的方法和使用特定的数据结构\",{\"1\":{\"113\":1}}],[\"的值传递问题\",{\"1\":{\"113\":1}}],[\"的增强版\",{\"1\":{\"113\":1}}],[\"的大小为老数组的两倍\",{\"1\":{\"110\":1}}],[\"的数组\",{\"1\":{\"131\":1}}],[\"的数量已经达到了列表的扩容阈值\",{\"1\":{\"110\":1}}],[\"的数据反序列化为java对象\",{\"1\":{\"69\":1}}],[\"的弱引用\",{\"1\":{\"105\":1}}],[\"的两个对象⽆论如何都不会相等\",{\"1\":{\"97\":1}}],[\"的默认⾏为是对堆上的对象产⽣独特值\",{\"1\":{\"97\":1}}],[\"的⽅式调用\",{\"1\":{\"93\":1}}],[\"的⽅式\",{\"1\":{\"93\":2}}],[\"的静态存储区\",{\"1\":{\"92\":1}}],[\"的区别\",{\"0\":{\"88\":1,\"96\":1}}],[\"的区别及作用\",{\"0\":{\"55\":1}}],[\"的兼容性\",{\"1\":{\"79\":1}}],[\"的结果暂存起来\",{\"1\":{\"74\":1}}],[\"的拼接操作\",{\"1\":{\"62\":1}}],[\"的类加载机制和类对象模型\",{\"1\":{\"48\":1}}],[\"的容器\",{\"1\":{\"35\":1}}],[\"的\",{\"1\":{\"30\":1,\"74\":1,\"112\":1}}],[\"的博客演示\",{\"1\":{\"17\":1}}],[\"的工作流\",{\"1\":{\"11\":1}}],[\"博客演示\",{\"1\":{\"17\":1}}],[\"empty\",{\"1\":{\"130\":1,\"163\":1}}],[\"else\",{\"1\":{\"110\":1,\"112\":1,\"145\":3,\"163\":2}}],[\"elementdata\",{\"1\":{\"130\":3,\"131\":1}}],[\"elementtype\",{\"1\":{\"81\":6}}],[\"element\",{\"1\":{\"78\":2,\"129\":1}}],[\"each循环遍历键值对\",{\"1\":{\"84\":1}}],[\"each循环遍历键集合或值集合\",{\"1\":{\"84\":1}}],[\"error\",{\"1\":{\"71\":1}}],[\"equals\",{\"0\":{\"96\":1,\"97\":1},\"1\":{\"66\":1,\"96\":2,\"97\":1,\"145\":2,\"146\":2}}],[\"entry为\",{\"1\":{\"109\":1}}],[\"entry数据\",{\"1\":{\"109\":1}}],[\"entry\",{\"1\":{\"108\":1,\"110\":6,\"139\":2}}],[\"entry是threalocal弱引用作为key\",{\"1\":{\"108\":1}}],[\"enum\",{\"1\":{\"54\":1}}],[\"enable\",{\"1\":{\"17\":1}}],[\"existing\",{\"1\":{\"168\":1}}],[\"exit\",{\"1\":{\"73\":2,\"95\":1}}],[\"exception\",{\"1\":{\"71\":2,\"74\":1,\"134\":3}}],[\"extensible\",{\"1\":{\"69\":1}}],[\"expungestaleentries\",{\"1\":{\"110\":1}}],[\"expr还可以是字符串\",{\"1\":{\"54\":1}}],[\"expr\",{\"1\":{\"54\":3}}],[\"export\",{\"1\":{\"17\":1}}],[\"example\",{\"1\":{\"44\":2}}],[\"effective\",{\"1\":{\"32\":1}}],[\"e\",{\"1\":{\"30\":1,\"74\":1,\"78\":1,\"110\":5,\"129\":1,\"145\":7,\"146\":10,\"168\":7}}],[\"esbuild\",{\"1\":{\"11\":2}}],[\"访问修饰符public\",{\"0\":{\"89\":1}}],[\"访问\",{\"0\":{\"12\":1},\"1\":{\"12\":1}}],[\"nt\",{\"1\":{\"163\":2}}],[\"nil节点\",{\"1\":{\"141\":1}}],[\"nio工作原理\",{\"1\":{\"30\":1}}],[\"nio\",{\"0\":{\"30\":1},\"1\":{\"30\":2}}],[\"n\",{\"1\":{\"129\":2,\"142\":2,\"145\":3,\"146\":3,\"157\":2,\"163\":6}}],[\"nanos\",{\"1\":{\"66\":1,\"120\":1,\"127\":1}}],[\"nexttable\",{\"1\":{\"163\":2}}],[\"nexttab\",{\"1\":{\"163\":5}}],[\"next\",{\"1\":{\"134\":1,\"145\":2,\"146\":2}}],[\"nextindex\",{\"1\":{\"110\":1}}],[\"nexthashcode\",{\"1\":{\"108\":2}}],[\"new一个object作为value\",{\"1\":{\"168\":1}}],[\"newnode\",{\"1\":{\"145\":2}}],[\"newcapacity\",{\"1\":{\"130\":6}}],[\"newlen\",{\"1\":{\"110\":5}}],[\"newtab\",{\"1\":{\"110\":7}}],[\"new创建新对象\",{\"1\":{\"100\":1}}],[\"new\",{\"0\":{\"61\":1,\"150\":1},\"1\":{\"36\":1,\"46\":1,\"61\":3,\"102\":1,\"110\":1,\"111\":2,\"121\":1,\"130\":1,\"163\":2}}],[\"network\",{\"1\":{\"11\":1}}],[\"null的槽位才会停止查找\",{\"1\":{\"109\":1}}],[\"null\",{\"1\":{\"35\":2,\"110\":4,\"112\":2,\"145\":8,\"146\":9,\"163\":7,\"168\":2}}],[\"nullpointerexception\",{\"1\":{\"35\":1}}],[\"npm\",{\"1\":{\"14\":1}}],[\"not\",{\"1\":{\"112\":1}}],[\"notifyall\",{\"1\":{\"66\":1,\"120\":5}}],[\"notify\",{\"1\":{\"66\":1,\"120\":6,\"127\":1}}],[\"nonematch\",{\"1\":{\"36\":1}}],[\"nonestartswithz\",{\"1\":{\"36\":1}}],[\"node<\",{\"1\":{\"163\":1}}],[\"node<k\",{\"1\":{\"145\":1,\"146\":4,\"163\":9}}],[\"node\",{\"1\":{\"11\":2,\"146\":1}}],[\"no\",{\"1\":{\"11\":1,\"112\":1,\"163\":1}}],[\"hugecapacity\",{\"1\":{\"130\":1}}],[\"h\",{\"1\":{\"110\":5,\"145\":2}}],[\"hysteresis\",{\"1\":{\"110\":1}}],[\"hash一样就覆盖\",{\"1\":{\"163\":1}}],[\"hashentry本身就是一个链表的结构\",{\"1\":{\"162\":1}}],[\"hash值\",{\"1\":{\"149\":3}}],[\"hash计算后应该落入第\",{\"1\":{\"109\":1}}],[\"hash\",{\"1\":{\"108\":4,\"139\":1,\"145\":10,\"146\":8,\"156\":2,\"163\":2}}],[\"hashset的add方法\",{\"1\":{\"168\":1}}],[\"hashset⾃⼰不得不实现之外\",{\"1\":{\"168\":1}}],[\"hashset\",{\"1\":{\"97\":1,\"168\":2}}],[\"hashtable\",{\"1\":{\"83\":1}}],[\"hashmap采用了\",{\"1\":{\"157\":1}}],[\"hashmap采用了尾插法\",{\"1\":{\"157\":1}}],[\"hashmap会使用更加均匀的哈希函数来计算索引位置\",{\"1\":{\"157\":1}}],[\"hashmap会将链表转换为红黑树\",{\"1\":{\"157\":1}}],[\"hashmap会向上寻找\",{\"1\":{\"150\":1}}],[\"hashmap扩容机制了解吗\",{\"0\":{\"156\":1}}],[\"hashmap里进行了优化改造\",{\"1\":{\"151\":1}}],[\"hashmap<>\",{\"0\":{\"150\":1}}],[\"hashmap的putval\",{\"1\":{\"168\":1}}],[\"hashmap的put流程知道吗\",{\"0\":{\"145\":1}}],[\"hashmap的容量必须是2的倍数\",{\"1\":{\"150\":1}}],[\"hashmap的哈希函数是先通过\",{\"1\":{\"147\":1}}],[\"hashmap的哈希\",{\"0\":{\"147\":1}}],[\"hashmap怎么查找元素的呢\",{\"0\":{\"146\":1}}],[\"hashmap使用头插法插入元素\",{\"1\":{\"159\":1}}],[\"hashmap使用链表或红黑树来解决冲突\",{\"1\":{\"139\":1}}],[\"hashmap使用键的哈希码\",{\"1\":{\"139\":1}}],[\"hashmap内部使用一个数组\",{\"1\":{\"139\":1}}],[\"hashmap\",{\"0\":{\"159\":1,\"164\":1},\"1\":{\"83\":1,\"97\":1,\"164\":2,\"165\":1,\"168\":2}}],[\"hashcode方法用于获取对象的哈希码\",{\"1\":{\"97\":1}}],[\"hashcode与\",{\"0\":{\"97\":1}}],[\"hashcode\",{\"1\":{\"66\":1,\"97\":4,\"145\":1,\"147\":1,\"158\":1}}],[\"helptransfer\",{\"1\":{\"163\":1}}],[\"help\",{\"1\":{\"110\":1}}],[\"hello\",{\"1\":{\"44\":1}}],[\"helloserviceimpl2\",{\"1\":{\"44\":1}}],[\"helloserviceimpl\",{\"1\":{\"44\":3}}],[\"helloservice\",{\"1\":{\"44\":5}}],[\"hessian是一种基于http的轻量级二进制序列化协议\",{\"1\":{\"69\":1}}],[\"hessian序列化\",{\"1\":{\"69\":1}}],[\"http\",{\"1\":{\"11\":2}}],[\"hope\",{\"1\":{\"8\":1,\"10\":1,\"11\":5,\"17\":1}}],[\"➜\",{\"1\":{\"11\":2}}],[\">>>\",{\"1\":{\"145\":1,\"163\":1}}],[\">>\",{\"1\":{\"130\":2}}],[\">=\",{\"1\":{\"110\":4,\"145\":2}}],[\">\",{\"1\":{\"11\":2,\"35\":1,\"36\":8,\"41\":1,\"110\":1,\"112\":1,\"145\":1,\"146\":1,\"163\":2}}],[\"请在浏览器输入给出的开发服务器地址\",{\"1\":{\"11\":1}}],[\"请耐心等待\",{\"1\":{\"11\":1}}],[\"启动时会调用\",{\"1\":{\"126\":1}}],[\"启动\",{\"1\":{\"95\":1}}],[\"启动成功后\",{\"1\":{\"11\":1}}],[\"启动开发服务器\",{\"1\":{\"11\":1}}],[\"模板已成功生成\",{\"1\":{\"11\":1}}],[\"yield\",{\"1\":{\"120\":2,\"125\":1,\"163\":1}}],[\"yml\",{\"0\":{\"16\":1}}],[\"you\",{\"1\":{\"11\":1}}],[\"yes\",{\"1\":{\"11\":3}}],[\"isinterrupted\",{\"1\":{\"120\":2}}],[\"isbooted\",{\"1\":{\"112\":2}}],[\"is\",{\"1\":{\"81\":1}}],[\"ispresent\",{\"1\":{\"35\":1}}],[\"i\",{\"1\":{\"74\":7,\"108\":1,\"110\":1,\"145\":3,\"163\":2}}],[\"implements\",{\"1\":{\"44\":1}}],[\"io\",{\"0\":{\"27\":1,\"28\":1}}],[\"it\",{\"1\":{\"11\":2,\"17\":1}}],[\"ifpresent\",{\"1\":{\"35\":1}}],[\"if\",{\"1\":{\"11\":1,\"110\":4,\"112\":5,\"130\":3,\"145\":9,\"146\":5,\"163\":9,\"168\":2}}],[\"initialization\",{\"1\":{\"163\":1}}],[\"inittable\",{\"1\":{\"163\":2}}],[\"instanceof\",{\"1\":{\"145\":1,\"146\":1,\"163\":1}}],[\"index\",{\"1\":{\"129\":2}}],[\"inheriting\",{\"1\":{\"112\":1}}],[\"inherit\",{\"1\":{\"112\":1}}],[\"inheritablethreadlocals\",{\"1\":{\"112\":5}}],[\"inheritablethreadlocal原理是什么呢\",{\"0\":{\"112\":1}}],[\"inheritablethreadlocaltest\",{\"1\":{\"111\":1}}],[\"inheritablethreadlocal\",{\"1\":{\"111\":2,\"113\":1}}],[\"increment\",{\"1\":{\"108\":2}}],[\"integercache是一个静态内部类\",{\"1\":{\"64\":1}}],[\"integer\",{\"0\":{\"64\":4},\"1\":{\"64\":2,\"65\":2}}],[\"interrupted\",{\"1\":{\"120\":1}}],[\"interrupt\",{\"1\":{\"120\":2}}],[\"intern方法有什么作用\",{\"0\":{\"63\":1}}],[\"interfacename\",{\"1\":{\"77\":1}}],[\"interface\",{\"0\":{\"91\":1},\"1\":{\"44\":3,\"50\":1,\"77\":1,\"81\":2}}],[\"int\",{\"1\":{\"50\":2,\"54\":1,\"65\":1,\"66\":1,\"74\":4,\"108\":3,\"110\":4,\"120\":1,\"127\":1,\"129\":2,\"130\":5,\"145\":1,\"146\":2,\"163\":4}}],[\"inf\",{\"1\":{\"44\":3}}],[\"inputstream\",{\"1\":{\"28\":1}}],[\"in\",{\"1\":{\"11\":3}}],[\"31\",{\"1\":{\"74\":1}}],[\"324\",{\"1\":{\"50\":1}}],[\"32\",{\"1\":{\"50\":2}}],[\"3s\",{\"1\":{\"11\":1}}],[\"3\",{\"1\":{\"11\":2,\"50\":1,\"56\":1,\"74\":6,\"110\":2}}],[\"64\",{\"1\":{\"50\":2}}],[\"6\",{\"1\":{\"11\":1}}],[\"606\",{\"1\":{\"11\":1}}],[\"639\",{\"1\":{\"11\":1}}],[\"61\",{\"1\":{\"11\":1}}],[\"8是基于cas+synchronized\",{\"1\":{\"161\":1}}],[\"8还引入了\",{\"1\":{\"157\":1}}],[\"8对hashmap的扩容操作进行了优化\",{\"1\":{\"157\":1}}],[\"8对hashmap主要做了哪些优化呢\",{\"0\":{\"157\":1}}],[\"8对哈希碰撞的处理进行了优化\",{\"1\":{\"157\":1}}],[\"8开始\",{\"1\":{\"91\":1}}],[\"8的stream\",{\"1\":{\"84\":1}}],[\"8之前\",{\"1\":{\"62\":1}}],[\"8引入了新的日期和时间api\",{\"1\":{\"32\":1}}],[\"8中都存在\",{\"1\":{\"159\":2}}],[\"8中的hashmap改为使用尾插法插入元素\",{\"1\":{\"159\":1}}],[\"8中\",{\"1\":{\"32\":1,\"91\":1,\"157\":2}}],[\"8都有哪些新特性\",{\"0\":{\"32\":1}}],[\"8新特性\",{\"0\":{\"31\":1}}],[\"84\",{\"1\":{\"11\":1}}],[\"8080\",{\"1\":{\"11\":3,\"12\":1}}],[\"825ms\",{\"1\":{\"11\":1}}],[\"8\",{\"0\":{\"163\":1},\"1\":{\"11\":2,\"35\":1,\"50\":3,\"139\":1}}],[\"83\",{\"1\":{\"11\":2}}],[\"1^2\",{\"1\":{\"152\":1}}],[\"1得任意数\",{\"1\":{\"149\":1}}],[\"1st\",{\"1\":{\"145\":2}}],[\"127这种赋值\",{\"1\":{\"64\":1}}],[\"127\",{\"0\":{\"64\":2},\"1\":{\"50\":1,\"64\":1}}],[\"128到127之间\",{\"1\":{\"64\":1}}],[\"128\",{\"0\":{\"64\":1},\"1\":{\"11\":1,\"50\":1,\"64\":1}}],[\"16\",{\"1\":{\"50\":2,\"145\":1}}],[\"10\",{\"1\":{\"11\":2}}],[\"19\",{\"1\":{\"11\":1}}],[\"197\",{\"1\":{\"11\":1}}],[\"1\",{\"1\":{\"11\":1,\"50\":7,\"74\":2,\"108\":1,\"110\":1,\"129\":1,\"130\":2,\"145\":5,\"146\":1,\"148\":1,\"149\":6,\"157\":5,\"163\":4}}],[\"rs\",{\"1\":{\"163\":3}}],[\"race\",{\"1\":{\"163\":1}}],[\"radix\",{\"1\":{\"65\":1}}],[\"runtime\",{\"1\":{\"81\":2}}],[\"runtimeexception\",{\"1\":{\"71\":1}}],[\"runnable\",{\"1\":{\"34\":1,\"117\":1,\"119\":1,\"121\":1}}],[\"running\",{\"1\":{\"11\":2}}],[\"run\",{\"1\":{\"14\":1,\"111\":2}}],[\"rc\",{\"1\":{\"11\":3}}],[\"rollup\",{\"1\":{\"11\":1}}],[\"resizers\",{\"1\":{\"163\":1}}],[\"resizestamp\",{\"1\":{\"163\":1}}],[\"resize\",{\"1\":{\"110\":3,\"145\":2,\"163\":1}}],[\"resolved\",{\"1\":{\"11\":2}}],[\"rehash\",{\"1\":{\"110\":5}}],[\"required\",{\"1\":{\"81\":2}}],[\"retention\",{\"1\":{\"81\":2}}],[\"retentionpolicy\",{\"1\":{\"81\":5}}],[\"returntype\",{\"1\":{\"77\":2}}],[\"return\",{\"0\":{\"55\":1},\"1\":{\"55\":1,\"74\":9,\"108\":1,\"130\":3,\"146\":5,\"163\":3,\"168\":2}}],[\"reduce\",{\"1\":{\"36\":2}}],[\"reduced\",{\"1\":{\"36\":1}}],[\"reduce归约\",{\"1\":{\"36\":1}}],[\"readobject\",{\"1\":{\"168\":1}}],[\"reader\",{\"1\":{\"28\":1}}],[\"reactor\",{\"1\":{\"30\":1}}],[\"reused\",{\"1\":{\"11\":2}}],[\"仓库\",{\"1\":{\"11\":1}}],[\"项目启动命令\",{\"0\":{\"14\":1}}],[\"项目需要用到多语言么\",{\"1\":{\"11\":1}}],[\"项目介绍\",{\"1\":{\"1\":1}}],[\"mincapacity\",{\"1\":{\"130\":6}}],[\"millis\",{\"1\":{\"120\":1,\"127\":2}}],[\"mit\",{\"1\":{\"11\":1}}],[\"method\",{\"1\":{\"46\":1,\"81\":2}}],[\"meta\",{\"1\":{\"44\":1}}],[\"max\",{\"1\":{\"130\":2,\"163\":1}}],[\"math\",{\"1\":{\"130\":1}}],[\"match\",{\"1\":{\"36\":1}}],[\"markup\",{\"1\":{\"69\":1}}],[\"macos\",{\"1\":{\"39\":1}}],[\"machine\",{\"1\":{\"39\":1}}],[\"mapping\",{\"1\":{\"168\":1}}],[\"map\",{\"0\":{\"138\":1},\"1\":{\"36\":2,\"168\":1,\"170\":1}}],[\"main函数所在的钱程就是一个用户线程\",{\"1\":{\"126\":1}}],[\"main\",{\"1\":{\"23\":1,\"74\":3,\"111\":1,\"126\":1}}],[\"master的代码都是ts和一些markdown文件\",{\"1\":{\"22\":1}}],[\"master\",{\"1\":{\"16\":1,\"22\":1}}],[\"manually\",{\"1\":{\"11\":1}}],[\"make\",{\"1\":{\"11\":1}}],[\"modcount\",{\"1\":{\"134\":1}}],[\"modcount变量是否为expectedmodcount值\",{\"1\":{\"134\":1}}],[\"modcount的值\",{\"1\":{\"134\":1}}],[\"modification\",{\"1\":{\"134\":3}}],[\"modules\",{\"1\":{\"11\":2}}],[\"move\",{\"1\":{\"11\":1}}],[\"mybatis\",{\"1\":{\"47\":1}}],[\"my\",{\"1\":{\"10\":1,\"11\":2,\"14\":1,\"17\":1}}],[\"o操作\",{\"1\":{\"125\":1}}],[\"oldvalue\",{\"1\":{\"168\":3}}],[\"oldcapacity\",{\"1\":{\"130\":5}}],[\"oldlen\",{\"1\":{\"110\":2}}],[\"oldtab\",{\"1\":{\"110\":4}}],[\"overflow\",{\"1\":{\"130\":2}}],[\"overload\",{\"0\":{\"88\":1}}],[\"override\",{\"0\":{\"88\":1},\"1\":{\"44\":1,\"81\":1,\"111\":1}}],[\"outofmemoryerror\",{\"1\":{\"130\":1}}],[\"out\",{\"1\":{\"35\":1,\"36\":4,\"44\":1,\"74\":4,\"111\":1}}],[\"outputstream\",{\"1\":{\"28\":1}}],[\"orelse\",{\"1\":{\"35\":1}}],[\"optional<string>\",{\"1\":{\"35\":1,\"36\":1}}],[\"optional了解吗\",{\"0\":{\"35\":1}}],[\"optional类是一个容器类\",{\"1\":{\"32\":1}}],[\"optional\",{\"1\":{\"32\":1,\"35\":9,\"36\":1}}],[\"onlyifabsent\",{\"1\":{\"168\":1}}],[\"on\",{\"1\":{\"16\":1}}],[\"of\",{\"1\":{\"11\":1,\"35\":1}}],[\"obj\",{\"1\":{\"66\":1}}],[\"objectinputstream\",{\"1\":{\"133\":1}}],[\"objectoutputstream\",{\"1\":{\"133\":1}}],[\"object类方法\",{\"1\":{\"120\":1}}],[\"object类提供的clone\",{\"1\":{\"99\":1}}],[\"object作为value的结构\",{\"1\":{\"108\":1}}],[\"object\",{\"0\":{\"66\":1},\"1\":{\"66\":1,\"95\":1,\"146\":2}}],[\"ob\",{\"1\":{\"11\":4}}],[\"2^63\",{\"1\":{\"50\":2}}],[\"2^15\",{\"1\":{\"50\":2}}],[\"2^31\",{\"1\":{\"50\":2}}],[\"246\",{\"1\":{\"11\":1}}],[\"25\",{\"1\":{\"11\":1}}],[\"2\",{\"1\":{\"11\":8,\"50\":2,\"56\":1,\"74\":5,\"110\":2,\"163\":1}}],[\"22\",{\"1\":{\"11\":1}}],[\"len\",{\"1\":{\"110\":1}}],[\"length\",{\"1\":{\"108\":1,\"110\":1,\"130\":1,\"145\":2,\"146\":1,\"163\":4}}],[\"linkedlist每个节点\",{\"1\":{\"129\":1}}],[\"linkedlist基于链表\",{\"1\":{\"129\":2}}],[\"linkedlist基于链表实现\",{\"1\":{\"129\":1}}],[\"linkedlist基于双向链表实现\",{\"1\":{\"129\":1}}],[\"linkedlist更利于增删\",{\"1\":{\"129\":1}}],[\"linkedhashmap在\",{\"1\":{\"165\":1}}],[\"linkedhashmap\",{\"0\":{\"165\":1},\"1\":{\"83\":1,\"164\":1,\"165\":1}}],[\"linux\",{\"1\":{\"39\":1}}],[\"list归约成一个值\",{\"1\":{\"36\":1}}],[\"list\",{\"0\":{\"128\":1},\"1\":{\"36\":3,\"170\":1}}],[\"list<string>\",{\"1\":{\"36\":1}}],[\"listed\",{\"1\":{\"11\":1}}],[\"lock\",{\"1\":{\"163\":1}}],[\"locals\",{\"1\":{\"112\":2}}],[\"localvariable\",{\"1\":{\"102\":3}}],[\"localhost\",{\"1\":{\"11\":2,\"12\":1}}],[\"local\",{\"1\":{\"11\":3}}],[\"lost\",{\"1\":{\"163\":1}}],[\"log\",{\"1\":{\"142\":1,\"157\":1}}],[\"lower\",{\"1\":{\"110\":1}}],[\"lombok\",{\"1\":{\"81\":1}}],[\"load\",{\"1\":{\"44\":2}}],[\"loader\",{\"1\":{\"44\":4,\"112\":1}}],[\"long类型\",{\"1\":{\"36\":1}}],[\"long\",{\"0\":{\"54\":1},\"1\":{\"36\":1,\"50\":2,\"54\":1,\"66\":2,\"120\":4,\"127\":2}}],[\"lambda\",{\"0\":{\"33\":1},\"1\":{\"32\":5,\"33\":2}}],[\"lang\",{\"1\":{\"17\":1,\"95\":1}}],[\"language\",{\"1\":{\"11\":1,\"69\":1}}],[\"afternodeaccess\",{\"1\":{\"168\":1}}],[\"avoid\",{\"1\":{\"110\":1}}],[\"abstract\",{\"0\":{\"91\":1}}],[\"abc\",{\"0\":{\"61\":2},\"1\":{\"61\":6}}],[\"autowired\",{\"1\":{\"81\":1}}],[\"autoboxcachemax=来修改缓存的最大值\",{\"1\":{\"64\":1}}],[\"annotated\",{\"1\":{\"81\":1}}],[\"annotation\",{\"1\":{\"81\":1}}],[\"anymatch\",{\"1\":{\"36\":1}}],[\"anystartswitha\",{\"1\":{\"36\":1}}],[\"aop\",{\"1\":{\"81\":1}}],[\"array\",{\"1\":{\"130\":1}}],[\"arraylist通过两个方法readobject\",{\"1\":{\"133\":1}}],[\"arraylist的序列化不太一样\",{\"1\":{\"131\":1}}],[\"arraylist的扩容机制了解吗\",{\"0\":{\"130\":1}}],[\"arraylist怎么序列化的知道吗\",{\"0\":{\"131\":1}}],[\"arraylist是预先定义好的数组\",{\"1\":{\"129\":1}}],[\"arraylist基于数组\",{\"1\":{\"129\":2}}],[\"arraylist基于数组实现\",{\"1\":{\"129\":2}}],[\"arraylist增删如果是数组末尾的位置\",{\"1\":{\"129\":1}}],[\"arraylist更利于查找\",{\"1\":{\"129\":1}}],[\"arraylist和linkedlist有什么区别\",{\"0\":{\"129\":1}}],[\"arraylist<>\",{\"1\":{\"36\":1}}],[\"arg\",{\"1\":{\"77\":1}}],[\"args\",{\"1\":{\"74\":3,\"111\":1}}],[\"a1==b1的结果是false\",{\"1\":{\"64\":1}}],[\"a=\",{\"0\":{\"64\":1},\"1\":{\"64\":1}}],[\"a+b拼接后的对象位于堆中\",{\"1\":{\"62\":1}}],[\"a和b初始化时位于字符串常量池\",{\"1\":{\"62\":1}}],[\"always\",{\"1\":{\"146\":1}}],[\"allmatch\",{\"1\":{\"36\":1}}],[\"allstartswitha\",{\"1\":{\"36\":2}}],[\"already\",{\"1\":{\"11\":1}}],[\"aaa1\",{\"1\":{\"36\":1}}],[\"aaa2\",{\"1\":{\"36\":1}}],[\"adding\",{\"1\":{\"163\":1}}],[\"add方法有锁\",{\"1\":{\"137\":1}}],[\"add\",{\"1\":{\"36\":8,\"168\":1}}],[\"added\",{\"1\":{\"11\":2}}],[\"api遍历\",{\"1\":{\"84\":1}}],[\"api提供了一种更简洁\",{\"1\":{\"32\":1}}],[\"api\",{\"1\":{\"32\":2}}],[\"aio\",{\"0\":{\"30\":1},\"1\":{\"30\":1}}],[\"attached\",{\"1\":{\"112\":1}}],[\"at\",{\"1\":{\"11\":1}}],[\"a\",{\"1\":{\"11\":3,\"30\":1,\"36\":7}}],[\"shift\",{\"1\":{\"163\":1}}],[\"short\",{\"1\":{\"50\":2,\"54\":1}}],[\"shouldprefetch\",{\"1\":{\"17\":1}}],[\"sc\",{\"1\":{\"163\":13}}],[\"script\",{\"1\":{\"11\":1}}],[\"synchronized\",{\"1\":{\"160\":1}}],[\"synchronizedmap\",{\"1\":{\"160\":1}}],[\"synchronizedlist包装arraylist\",{\"1\":{\"135\":1}}],[\"system\",{\"1\":{\"35\":1,\"36\":4,\"44\":1,\"73\":1,\"74\":4,\"95\":1,\"111\":1,\"112\":1}}],[\"safe\",{\"0\":{\"134\":1},\"1\":{\"134\":1}}],[\"sayhello\",{\"1\":{\"44\":3}}],[\"sleep\",{\"1\":{\"120\":1}}],[\"sizectl\",{\"1\":{\"163\":5}}],[\"size\",{\"1\":{\"110\":3,\"112\":1,\"130\":1}}],[\"sz\",{\"1\":{\"110\":2}}],[\"switch\",{\"0\":{\"54\":1},\"1\":{\"54\":1}}],[\"spring里的很多注解\",{\"1\":{\"47\":1}}],[\"spring\",{\"1\":{\"47\":2}}],[\"spin\",{\"1\":{\"163\":1}}],[\"spi机制的应用场景\",{\"1\":{\"44\":1}}],[\"spi机制的优势\",{\"1\":{\"44\":1}}],[\"spi机制的工作原理如下\",{\"1\":{\"44\":1}}],[\"spi中的几个关键元素\",{\"1\":{\"44\":1}}],[\"sdk\",{\"1\":{\"39\":1}}],[\"s2\",{\"1\":{\"36\":2}}],[\"s1\",{\"1\":{\"36\":2}}],[\"source\",{\"1\":{\"81\":2}}],[\"sourcemap\",{\"1\":{\"11\":1}}],[\"sorted\",{\"1\":{\"36\":4}}],[\"s\",{\"1\":{\"35\":2,\"36\":12,\"61\":1,\"65\":3}}],[\"suppresswarnings\",{\"1\":{\"163\":1}}],[\"supplier\",{\"1\":{\"34\":1}}],[\"super\",{\"1\":{\"111\":1}}],[\"subdependencies\",{\"1\":{\"11\":1}}],[\"segment如果是空就先初始化\",{\"1\":{\"162\":1}}],[\"segment之间相互不会受到影响\",{\"1\":{\"162\":1}}],[\"segment则包含hashentry的数组\",{\"1\":{\"162\":1}}],[\"segment继承于reentrantlock\",{\"1\":{\"162\":1}}],[\"setthreshold\",{\"1\":{\"110\":1}}],[\"set\",{\"0\":{\"167\":1},\"1\":{\"102\":1,\"110\":1,\"111\":1,\"170\":1}}],[\"serialversionuid的值保持不变\",{\"1\":{\"68\":1}}],[\"serialversionuid\",{\"1\":{\"68\":1}}],[\"serializable接口有什么用\",{\"1\":{\"68\":1}}],[\"serviceloader<helloservice>\",{\"1\":{\"44\":2}}],[\"services\",{\"1\":{\"44\":3}}],[\"service\",{\"1\":{\"44\":9}}],[\"server\",{\"1\":{\"11\":1}}],[\"select\",{\"1\":{\"11\":1}}],[\"src\",{\"1\":{\"11\":1}}],[\"stamp\",{\"1\":{\"163\":1}}],[\"static修饰的方法\",{\"1\":{\"93\":1}}],[\"static等修饰符所修饰\",{\"1\":{\"92\":1}}],[\"static\",{\"1\":{\"74\":6,\"77\":1,\"91\":1,\"93\":1,\"102\":1,\"108\":2,\"111\":1}}],[\"start\",{\"1\":{\"111\":1}}],[\"startswithb\",{\"1\":{\"36\":1}}],[\"startswith\",{\"1\":{\"36\":6}}],[\"stars\",{\"1\":{\"4\":1}}],[\"star\",{\"0\":{\"4\":1}}],[\"str2\",{\"0\":{\"61\":1}}],[\"str1\",{\"0\":{\"61\":1},\"1\":{\"61\":1}}],[\"string怎么转成integer的\",{\"0\":{\"65\":1}}],[\"string的确是不可变的\",{\"1\":{\"62\":1}}],[\"string不是不可变类吗\",{\"0\":{\"62\":1}}],[\"string是不可变的\",{\"1\":{\"60\":1}}],[\"string是java基本数据类型吗\",{\"1\":{\"59\":1}}],[\"stringbuilder是stringbuffer的非线程安全版本\",{\"1\":{\"60\":1}}],[\"stringbuilder类\",{\"1\":{\"60\":1}}],[\"stringbuilder\",{\"1\":{\"60\":1}}],[\"stringbuffer的性能相对较低\",{\"1\":{\"60\":1}}],[\"stringbuffer的方法都使用synchronized关键字进行同步\",{\"1\":{\"60\":1}}],[\"stringbuffer是可变的\",{\"1\":{\"60\":1}}],[\"stringbuffer类\",{\"1\":{\"60\":1}}],[\"stringbuffer\",{\"0\":{\"60\":1},\"1\":{\"60\":1}}],[\"string和stringbuilder\",{\"0\":{\"60\":1}}],[\"string类是线程安全的\",{\"1\":{\"60\":1}}],[\"string类\",{\"1\":{\"60\":1}}],[\"string类的不可变性使得它在安全性和可靠性方面更加可靠\",{\"1\":{\"59\":1}}],[\"string类的不可变性使得它可以被安全地用于多线程环境下\",{\"1\":{\"59\":1}}],[\"string类在java中被声明为final类\",{\"1\":{\"59\":1}}],[\"string上\",{\"0\":{\"54\":1}}],[\"string\",{\"0\":{\"59\":1,\"61\":2},\"1\":{\"36\":3,\"54\":1,\"59\":3,\"60\":1,\"61\":5,\"65\":3,\"74\":3,\"111\":1}}],[\"stringcollection\",{\"1\":{\"36\":17}}],[\"stream的常用api\",{\"1\":{\"36\":1}}],[\"stream的常用操作有\",{\"1\":{\"36\":1}}],[\"stream流一般用于集合\",{\"1\":{\"36\":1}}],[\"stream\",{\"0\":{\"36\":1},\"1\":{\"32\":2,\"36\":12}}],[\"store\",{\"1\":{\"11\":2}}],[\"+除留余数法\",{\"1\":{\"158\":1}}],[\"++size\",{\"1\":{\"145\":1}}],[\"++bincount\",{\"1\":{\"145\":1}}],[\"++和\",{\"1\":{\"57\":1}}],[\"++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\",{\"1\":{\"11\":1}}],[\"++++++++\",{\"1\":{\"11\":1}}],[\"+\",{\"1\":{\"11\":4,\"36\":2,\"62\":2,\"92\":1,\"111\":1,\"130\":2,\"139\":3,\"163\":3}}],[\"+606\",{\"1\":{\"11\":1}}],[\"+83\",{\"1\":{\"11\":1}}],[\"ttl通过重写\",{\"1\":{\"113\":1}}],[\"ttl\",{\"0\":{\"113\":1},\"1\":{\"113\":1}}],[\"tabat\",{\"1\":{\"163\":1}}],[\"tab\",{\"1\":{\"145\":8,\"146\":4,\"163\":17}}],[\"table\",{\"1\":{\"108\":2,\"110\":2,\"145\":1,\"146\":1,\"163\":5}}],[\"target\",{\"1\":{\"81\":2}}],[\"type\",{\"1\":{\"78\":1,\"81\":1}}],[\"t\",{\"1\":{\"77\":1,\"78\":1,\"111\":2}}],[\"threshold\",{\"1\":{\"110\":7,\"145\":4}}],[\"thread类中的静态方法\",{\"1\":{\"120\":2}}],[\"thread类的方法\",{\"1\":{\"120\":1}}],[\"thread类适合直接创建新线程\",{\"1\":{\"119\":1}}],[\"thread类有一个类型为threadlocal\",{\"1\":{\"104\":1}}],[\"thread和runnable有什么区别\",{\"0\":{\"119\":1}}],[\"thread\",{\"1\":{\"111\":2,\"112\":2,\"119\":1,\"163\":1}}],[\"threadlocalhashcode\",{\"1\":{\"108\":1,\"110\":1}}],[\"threadlocal本身不存储值\",{\"1\":{\"104\":1}}],[\"threadlocalmap\",{\"1\":{\"112\":2}}],[\"threadlocalmap扩容机制了解吗\",{\"0\":{\"110\":1}}],[\"threadlocalmap怎么解决hash冲突的\",{\"0\":{\"109\":1}}],[\"threadlocalmap用的是哈希取余法\",{\"1\":{\"108\":1}}],[\"threadlocalmap的结构了解吗\",{\"0\":{\"108\":1}}],[\"threadlocalmap的key没了\",{\"1\":{\"105\":1}}],[\"threadlocalmap的key\",{\"1\":{\"105\":1}}],[\"threadlocalmap的实例变量threadlocals\",{\"1\":{\"104\":1}}],[\"threadlocalmap中使用的\",{\"1\":{\"105\":1}}],[\"threadlocalmap内部维护着entry数组\",{\"1\":{\"104\":1}}],[\"threadlocal怎么实现的呢\",{\"0\":{\"104\":1}}],[\"threadlocal<\",{\"1\":{\"110\":1}}],[\"threadlocal<>\",{\"1\":{\"102\":1}}],[\"threadlocal<string>\",{\"1\":{\"102\":1}}],[\"threadlocal是什么\",{\"0\":{\"102\":1}}],[\"threadlocal\",{\"0\":{\"101\":1,\"105\":1},\"1\":{\"102\":1,\"105\":1,\"111\":4,\"112\":3,\"113\":1,\"127\":1}}],[\"throws\",{\"1\":{\"72\":1}}],[\"throw\",{\"1\":{\"72\":1,\"130\":1}}],[\"throwable\",{\"1\":{\"71\":1}}],[\"this\",{\"1\":{\"112\":3,\"145\":1,\"163\":2}}],[\"this相当于是指向当前对象本身\",{\"1\":{\"90\":1}}],[\"this的用法在java中大体可以分为3种\",{\"1\":{\"90\":1}}],[\"this关键字有什么作用\",{\"0\":{\"90\":1}}],[\"then\",{\"1\":{\"11\":1}}],[\"the\",{\"1\":{\"11\":1,\"81\":1,\"110\":1,\"112\":1}}],[\"theme\",{\"1\":{\"8\":1,\"10\":1,\"11\":5,\"17\":2}}],[\"treeifybin\",{\"1\":{\"145\":2}}],[\"treeify\",{\"1\":{\"145\":2}}],[\"treenode<k\",{\"1\":{\"145\":1,\"146\":1}}],[\"treenode\",{\"1\":{\"145\":1,\"146\":1}}],[\"treemap\",{\"0\":{\"166\":1},\"1\":{\"83\":1,\"164\":1,\"166\":2}}],[\"transfer\",{\"1\":{\"163\":1}}],[\"transferindex\",{\"1\":{\"163\":1}}],[\"transmittablethreadlocal\",{\"1\":{\"113\":1}}],[\"transient\",{\"1\":{\"68\":4,\"131\":2}}],[\"try\",{\"1\":{\"72\":1,\"74\":6,\"95\":1,\"163\":1}}],[\"true\",{\"1\":{\"35\":1,\"36\":1,\"81\":2}}],[\"timout\",{\"1\":{\"120\":1}}],[\"time\",{\"1\":{\"121\":1}}],[\"timeout\",{\"1\":{\"66\":2,\"120\":2}}],[\"time包\",{\"1\":{\"32\":1}}],[\"title\",{\"1\":{\"17\":1}}],[\"ts\",{\"0\":{\"17\":1},\"1\":{\"23\":1}}],[\"terminated\",{\"1\":{\"121\":1}}],[\"terser\",{\"1\":{\"11\":1}}],[\"test\",{\"1\":{\"74\":6}}],[\"template\",{\"1\":{\"11\":2}}],[\"tostring\",{\"1\":{\"66\":1}}],[\"touppercase\",{\"1\":{\"36\":1}}],[\"to\",{\"1\":{\"11\":2,\"20\":1,\"81\":1,\"110\":1,\"112\":1,\"163\":1}}],[\"tmp\",{\"1\":{\"11\":2}}],[\"v>\",{\"1\":{\"145\":2,\"146\":5,\"163\":10}}],[\"vector的所有方法都是同步的\",{\"1\":{\"135\":1}}],[\"vector是一个线程安全的动态数组类\",{\"1\":{\"135\":1}}],[\"volatile修饰原数组array\",{\"1\":{\"136\":1}}],[\"volatile和synchronized关键字\",{\"1\":{\"127\":1}}],[\"void\",{\"1\":{\"44\":2,\"74\":3,\"110\":2,\"111\":2,\"120\":1}}],[\"vm\",{\"1\":{\"112\":2}}],[\"v\",{\"1\":{\"78\":1,\"146\":1,\"168\":1}}],[\"value的能力能指向下一个节点的指针\",{\"1\":{\"162\":1}}],[\"value还在\",{\"1\":{\"105\":1}}],[\"value是threadlocal的泛型值\",{\"1\":{\"104\":1}}],[\"valueof\",{\"1\":{\"64\":1,\"65\":1}}],[\"value\",{\"1\":{\"47\":1,\"60\":2,\"78\":2,\"110\":1,\"145\":3,\"146\":1,\"163\":1,\"168\":3}}],[\"virtual\",{\"1\":{\"39\":1}}],[\"visibility\",{\"1\":{\"20\":1}}],[\"vite\",{\"1\":{\"11\":1}}],[\"v5\",{\"1\":{\"11\":1}}],[\"vue\",{\"1\":{\"11\":1}}],[\"vuepress\",{\"1\":{\"10\":1,\"11\":8,\"17\":1}}],[\"v3\",{\"1\":{\"11\":2}}],[\"bin\",{\"1\":{\"163\":1}}],[\"bincount\",{\"1\":{\"145\":3}}],[\"bio\",{\"0\":{\"30\":1},\"1\":{\"30\":1}}],[\"bucket\",{\"1\":{\"139\":1,\"164\":1}}],[\"buffers\",{\"1\":{\"69\":1}}],[\"break\",{\"0\":{\"55\":1},\"1\":{\"55\":1,\"145\":2,\"163\":4}}],[\"branches\",{\"1\":{\"16\":1}}],[\"byte\",{\"0\":{\"54\":1},\"1\":{\"50\":2,\"54\":1}}],[\"boot\",{\"1\":{\"47\":1}}],[\"boolean等\",{\"1\":{\"98\":1}}],[\"boolean\",{\"1\":{\"36\":3,\"50\":2,\"81\":1,\"120\":2,\"168\":1}}],[\"bbb2\",{\"1\":{\"36\":1}}],[\"bbb3\",{\"1\":{\"36\":1}}],[\"bbb1\",{\"1\":{\"36\":1}}],[\"blocked状态表示线程被阻塞\",{\"1\":{\"122\":1}}],[\"blocked和waiting有什么区别\",{\"0\":{\"122\":1}}],[\"blocked\",{\"1\":{\"121\":1}}],[\"bloch\",{\"1\":{\"32\":1}}],[\"blogs\",{\"1\":{\"11\":1}}],[\"blogs>\",{\"1\":{\"11\":1}}],[\"blog\",{\"1\":{\"11\":1}}],[\"b\",{\"0\":{\"64\":1},\"1\":{\"30\":5,\"36\":4}}],[\"bam\",{\"1\":{\"35\":3}}],[\"base\",{\"1\":{\"17\":1}}],[\"baidusyncdisk\",{\"1\":{\"11\":2}}],[\"daemon\",{\"1\":{\"126\":1}}],[\"daiwencheng\",{\"1\":{\"11\":2}}],[\"dubbo等\",{\"1\":{\"69\":1}}],[\"ddd1\",{\"1\":{\"36\":1}}],[\"ddd2\",{\"1\":{\"36\":1}}],[\"d\",{\"0\":{\"64\":1},\"1\":{\"30\":2}}],[\"declares\",{\"1\":{\"81\":1}}],[\"description\",{\"1\":{\"17\":1}}],[\"defineuserconfig\",{\"1\":{\"17\":1}}],[\"defaultcapacity\",{\"1\":{\"130\":1}}],[\"default\",{\"1\":{\"17\":1,\"81\":1,\"89\":1,\"112\":1,\"130\":1,\"163\":1}}],[\"development\",{\"1\":{\"39\":1}}],[\"dev\",{\"1\":{\"11\":3,\"14\":1}}],[\"devdependencies\",{\"1\":{\"11\":2}}],[\"demo\",{\"1\":{\"11\":1}}],[\"deploy\",{\"0\":{\"16\":1}}],[\"dependency\",{\"1\":{\"11\":2,\"81\":1}}],[\"deprecated\",{\"1\":{\"11\":1}}],[\"display\",{\"1\":{\"11\":1}}],[\"do\",{\"1\":{\"146\":1}}],[\"doubling\",{\"1\":{\"110\":1}}],[\"double\",{\"1\":{\"50\":2}}],[\"done\",{\"1\":{\"11\":4}}],[\"downloaded\",{\"1\":{\"11\":2}}],[\"documented\",{\"1\":{\"81\":1}}],[\"documents\",{\"1\":{\"11\":2}}],[\"docsbranch\",{\"1\":{\"23\":1}}],[\"docs的settings项\",{\"1\":{\"21\":1}}],[\"docs\",{\"0\":{\"16\":1},\"1\":{\"10\":1,\"11\":3,\"14\":2,\"17\":1,\"20\":1}}],[\"dlx\",{\"1\":{\"11\":2}}],[\"cpu\",{\"1\":{\"120\":2,\"124\":1,\"125\":4}}],[\"ccl\",{\"1\":{\"112\":1}}],[\"ccc\",{\"1\":{\"36\":1}}],[\"castabat\",{\"1\":{\"163\":1}}],[\"cas操作\",{\"1\":{\"163\":1}}],[\"cas+synchronized\",{\"0\":{\"163\":1}}],[\"capacity\",{\"1\":{\"130\":1,\"163\":1}}],[\"catch\",{\"1\":{\"72\":1,\"74\":2,\"95\":1}}],[\"callable\",{\"1\":{\"34\":1}}],[\"check\",{\"1\":{\"146\":1}}],[\"checkedexception\",{\"1\":{\"71\":1}}],[\"characteristics\",{\"1\":{\"112\":1}}],[\"charat\",{\"1\":{\"35\":1}}],[\"char\",{\"1\":{\"50\":2,\"54\":1,\"60\":2}}],[\"channel代表了服务端与客户端的连接\",{\"1\":{\"30\":1}}],[\"c和d不相等\",{\"1\":{\"64\":1}}],[\"c=\",{\"0\":{\"64\":1}}],[\"cleansomeslots\",{\"1\":{\"110\":1}}],[\"clone\",{\"1\":{\"66\":1}}],[\"classloader\",{\"1\":{\"112\":1}}],[\"classname\",{\"1\":{\"77\":1}}],[\"class\",{\"0\":{\"91\":1},\"1\":{\"41\":2,\"42\":1,\"44\":3,\"46\":1,\"50\":1,\"77\":1,\"81\":4,\"111\":1,\"112\":1}}],[\"class文件\",{\"1\":{\"41\":1}}],[\"client\",{\"1\":{\"11\":1}}],[\"cn\",{\"1\":{\"17\":1}}],[\"collections\",{\"1\":{\"160\":1}}],[\"copyonwrite\",{\"1\":{\"136\":1}}],[\"copyonwritearraylist适合在读多写少的场景中使用\",{\"1\":{\"136\":1}}],[\"copyonwritearraylist通过创建副本的方式实现线程安全\",{\"1\":{\"136\":1}}],[\"copyonwritearraylist就是线程安全版本的arraylist\",{\"1\":{\"136\":1}}],[\"copyonwritearraylist了解多少\",{\"0\":{\"136\":1}}],[\"copyonwritearraylist具有较高的性能\",{\"1\":{\"135\":1}}],[\"copyonwritearraylist是一种线程安全的并发list\",{\"1\":{\"135\":1}}],[\"code\",{\"1\":{\"81\":1,\"130\":1,\"139\":1}}],[\"codec\",{\"1\":{\"11\":1}}],[\"comprator\",{\"1\":{\"166\":1}}],[\"component\",{\"1\":{\"47\":1}}],[\"compareandsetint\",{\"1\":{\"163\":2}}],[\"compareto\",{\"1\":{\"36\":1}}],[\"comparator\",{\"1\":{\"34\":1}}],[\"com\",{\"1\":{\"44\":2}}],[\"count++\",{\"1\":{\"110\":1}}],[\"count\",{\"1\":{\"36\":3,\"110\":2}}],[\"concurrent包下的容器都是安全失败\",{\"1\":{\"134\":1}}],[\"concurrenthashmap线程安全在jdk1\",{\"1\":{\"161\":1}}],[\"concurrenthashmap\",{\"1\":{\"83\":1,\"160\":2}}],[\"contextclassloader\",{\"1\":{\"112\":3}}],[\"continue\",{\"0\":{\"55\":1},\"1\":{\"55\":1}}],[\"conscious\",{\"1\":{\"130\":1}}],[\"constructor\",{\"1\":{\"46\":1,\"81\":1}}],[\"consumer\",{\"1\":{\"34\":1}}],[\"configuration\",{\"1\":{\"44\":1}}],[\"config\",{\"0\":{\"17\":1}}],[\"c\",{\"1\":{\"11\":2,\"30\":1}}],[\"createinheritedmap\",{\"1\":{\"112\":1}}],[\"create\",{\"1\":{\"10\":1,\"11\":1}}],[\"00000006\",{\"1\":{\"153\":1}}],[\"0得0\",{\"1\":{\"149\":1}}],[\"0x61c88647\",{\"1\":{\"108\":2}}],[\"0d\",{\"1\":{\"50\":1}}],[\"0f\",{\"1\":{\"50\":1}}],[\"0l\",{\"1\":{\"50\":1}}],[\"0\",{\"1\":{\"11\":16,\"35\":1,\"50\":5,\"74\":1,\"95\":1,\"110\":1,\"112\":2,\"130\":3,\"145\":3,\"146\":1,\"163\":7}}],[\"4028235e38\",{\"1\":{\"50\":1}}],[\"409\",{\"1\":{\"11\":1}}],[\"45\",{\"1\":{\"50\":1}}],[\"4e\",{\"1\":{\"50\":1}}],[\"4之前的选择\",{\"1\":{\"30\":1}}],[\"4\",{\"1\":{\"11\":2,\"50\":3,\"109\":2,\"110\":3}}],[\"7版本的concurrenthashmap采用分段锁机制\",{\"1\":{\"162\":1}}],[\"7版本是基于\",{\"1\":{\"161\":1}}],[\"7和jdk1\",{\"1\":{\"159\":2}}],[\"7中\",{\"1\":{\"159\":1}}],[\"75作为hashmap的默认加载因子呢\",{\"0\":{\"155\":1}}],[\"75\",{\"0\":{\"154\":1}}],[\"7976931348623157e308\",{\"1\":{\"50\":1}}],[\"7428\",{\"1\":{\"11\":2}}],[\"7\",{\"0\":{\"162\":1},\"1\":{\"11\":2,\"54\":1,\"139\":1}}],[\"创建一个threadlocal变量\",{\"1\":{\"102\":1}}],[\"创建\",{\"1\":{\"102\":1}}],[\"创建了一个threadloca变量localvariable\",{\"1\":{\"102\":1}}],[\"创建了一个threadlocal变量\",{\"1\":{\"102\":1}}],[\"创建了几个对象\",{\"1\":{\"61\":1}}],[\"创建对象有哪几种方式\",{\"0\":{\"100\":1}}],[\"创建对象实例的方式\",{\"1\":{\"46\":1}}],[\"创建类实例\",{\"1\":{\"46\":1}}],[\"创建过程\",{\"0\":{\"11\":1}}],[\"创建项目模板\",{\"0\":{\"10\":1}}],[\"p\",{\"1\":{\"145\":9}}],[\"pipedreader和pipedwriter\",{\"1\":{\"127\":1}}],[\"pipedinputstream\",{\"1\":{\"127\":1}}],[\"pipedoutputstream\",{\"1\":{\"127\":1}}],[\"present\",{\"1\":{\"168\":1}}],[\"predicate\",{\"1\":{\"34\":1}}],[\"print\",{\"1\":{\"74\":1}}],[\"println\",{\"1\":{\"35\":1,\"36\":4,\"44\":1,\"74\":3,\"111\":1}}],[\"private\",{\"0\":{\"89\":1},\"1\":{\"60\":1,\"89\":1,\"92\":1,\"108\":3,\"110\":2,\"130\":1,\"163\":1}}],[\"protected和default修饰符\",{\"1\":{\"91\":1}}],[\"protected\",{\"0\":{\"89\":1},\"1\":{\"89\":1}}],[\"protocol\",{\"1\":{\"69\":1}}],[\"protobuf\",{\"1\":{\"69\":1}}],[\"protobuf序列化\",{\"1\":{\"69\":1}}],[\"provider\",{\"1\":{\"44\":3}}],[\"prod\",{\"1\":{\"11\":1}}],[\"project\",{\"1\":{\"11\":1}}],[\"progress\",{\"1\":{\"11\":2}}],[\"put\",{\"1\":{\"168\":1}}],[\"put流程\",{\"1\":{\"162\":1,\"163\":1}}],[\"put和get并发时\",{\"1\":{\"159\":1}}],[\"puttreeval\",{\"1\":{\"145\":1}}],[\"public\",{\"1\":{\"20\":1,\"44\":3,\"74\":6,\"77\":4,\"81\":2,\"89\":1,\"91\":1,\"102\":1,\"111\":3,\"146\":1,\"168\":1}}],[\"push\",{\"1\":{\"16\":1}}],[\"pwa\",{\"1\":{\"17\":1}}],[\"posts\",{\"0\":{\"171\":1}}],[\"postinstall\",{\"1\":{\"11\":1}}],[\"powershell\",{\"1\":{\"11\":1}}],[\"plugin\",{\"1\":{\"11\":1}}],[\"park\",{\"1\":{\"122\":1}}],[\"parent\",{\"1\":{\"112\":2}}],[\"parentmap\",{\"1\":{\"112\":4}}],[\"parameter\",{\"1\":{\"81\":1}}],[\"parseint\",{\"1\":{\"65\":1}}],[\"pages是发布分支\",{\"1\":{\"22\":1}}],[\"pages分支\",{\"0\":{\"22\":1}}],[\"pages\",{\"0\":{\"19\":1,\"21\":1},\"1\":{\"11\":1,\"21\":1,\"22\":1}}],[\"pages搭建\",{\"1\":{\"8\":1}}],[\"packages\",{\"1\":{\"11\":1}}],[\"package\",{\"1\":{\"11\":1}}],[\"ps\",{\"1\":{\"11\":1}}],[\"pnpm\",{\"1\":{\"10\":1,\"11\":5}}],[\"下载地址\",{\"1\":{\"9\":1}}],[\"准备运行环境\",{\"0\":{\"9\":1}}],[\"和hashmap的get流程基本相同\",{\"1\":{\"163\":1}}],[\"和统计学有关\",{\"1\":{\"153\":1}}],[\"和安全失败\",{\"0\":{\"134\":1}}],[\"和join\",{\"1\":{\"127\":1}}],[\"和引用数据类型变量的地址值\",{\"1\":{\"99\":1}}],[\"和常量\",{\"1\":{\"91\":1}}],[\"和接口\",{\"0\":{\"91\":1}}],[\"和接⼝\",{\"1\":{\"87\":1}}],[\"和重写\",{\"0\":{\"88\":1}}],[\"和string\",{\"0\":{\"61\":1}}],[\"和⼯具\",{\"1\":{\"39\":1}}],[\"和\",{\"0\":{\"39\":1,\"53\":1,\"61\":1},\"1\":{\"8\":1,\"28\":3,\"39\":1,\"126\":1,\"133\":1,\"144\":1,\"157\":1}}],[\"幻灯片页\",{\"0\":{\"6\":1}}],[\"趋势\",{\"0\":{\"4\":1}}],[\"占个位\",{\"0\":{\"3\":1},\"1\":{\"3\":1}}],[\"||\",{\"1\":{\"145\":3,\"146\":2,\"163\":5,\"168\":1}}],[\"|\",{\"1\":{\"1\":1,\"11\":2}}],[\"欢迎来到鱼塘\",{\"1\":{\"1\":1}}],[\"鱼塘\",{\"0\":{\"0\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n}})=>{e==="suggest"?self.postMessage(st(t,v[s],n)):e==="search"?self.postMessage(et(t,v[s],n)):self.postMessage({suggestions:st(t,v[s],n),results:et(t,v[s],n)})};
//# sourceMappingURL=index.js.map
