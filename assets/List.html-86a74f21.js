import{_ as s}from"./plugin-vue_export-helper-c27b6911.js";import{r as i,o as l,c as t,d as e,f as a}from"./app-eb1c8ee4.js";const r={},o=a('<h2 id="arraylist和linkedlist有什么区别" tabindex="-1"><a class="header-anchor" href="#arraylist和linkedlist有什么区别" aria-hidden="true">#</a> ArrayList和LinkedList有什么区别？</h2><ul><li>数据结构不同 <ul><li>ArrayList基于数组实现</li><li>LinkedList基于双向链表实现</li></ul></li><li>多数情况下，ArrayList更利于查找，LinkedList更利于增删 <ul><li>查找速率 <ul><li>ArrayList基于数组实现，get(int index)可以直接通过数组下标获取，时间复杂度是O(1)</li><li>LinkedList基于链表实现，get(int index)需要遍历链表，时间复杂度是O(n)</li><li>get(E element)这种查找，两种集合都需要遍历，时间复杂度都是O(n)</li></ul></li><li>增删速率 <ul><li>ArrayList增删如果是数组末尾的位置，直接插入或者删除就可以了，但是如果插入中间的位置，就需要把插入位置后的元素都向前或者向后移动，甚至还有可能触发扩容</li><li>双向链表的插入和删除只需要改变前驱节点、后继节点和插入节点的指向就行了，不需要移动元素</li></ul></li></ul></li><li>是否支持随机访问 <ul><li>ArrayList基于数组，所以它可以根据下标查找，支持随机访问 <ul><li>它也实现了RandmoAccess 接口，这个接口只是用来标识是否支持随机访问</li></ul></li><li>LinkedList基于链表，所以它没法根据序号直接获取元素，它没有实现RandmoAccess 接口，标记不支持随机访问</li></ul></li><li>内存占用 <ul><li>ArrayList基于数组，是一块连续的内存空间 <ul><li>ArrayList是预先定义好的数组，可能会有空的内存空间，存在一定空间浪费</li></ul></li><li>LinkedList基于链表，内存空间不连续，它们在空间占用上都有一些额外的消耗 <ul><li>LinkedList每个节点，需要存储前驱和后继，所以每个节点会占用更多的空间</li></ul></li></ul></li></ul><h2 id="arraylist的扩容机制了解吗" tabindex="-1"><a class="header-anchor" href="#arraylist的扩容机制了解吗" aria-hidden="true">#</a> ArrayList的扩容机制了解吗？</h2>',3),p=a(`<ol><li><p>数组满了，再插入时，触发扩容</p></li><li><p>计算新数组容量，容量大小为原数组1.5倍</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">newCapacity</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// overflow-conscious code</span>
        <span class="token keyword">int</span> oldCapacity <span class="token operator">=</span> elementData<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> oldCapacity <span class="token operator">+</span> <span class="token punctuation">(</span>oldCapacity <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> minCapacity <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>elementData <span class="token operator">==</span> <span class="token constant">DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token constant">DEFAULT_CAPACITY</span><span class="token punctuation">,</span> minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// overflow</span>
                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">OutOfMemoryError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> minCapacity<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> <span class="token constant">MAX_ARRAY_SIZE</span> <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token operator">?</span> newCapacity
            <span class="token operator">:</span> <span class="token function">hugeCapacity</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</li></ul></li><li><p>复制原数组元素到新数组</p></li></ol><h2 id="arraylist怎么序列化的知道吗-为什么用transient修饰数组" tabindex="-1"><a class="header-anchor" href="#arraylist怎么序列化的知道吗-为什么用transient修饰数组" aria-hidden="true">#</a> ArrayList怎么序列化的知道吗？ 为什么用transient修饰数组？</h2><ul><li>ArrayList的序列化不太一样，它使用 transient 修饰存储元素的 elementData 的数组</li><li>transient 关键字的作用是让被修饰的成员属性不被序列化</li></ul><h3 id="为什么最arraylist不直接序列化元素数组呢" tabindex="-1"><a class="header-anchor" href="#为什么最arraylist不直接序列化元素数组呢" aria-hidden="true">#</a> 为什么最ArrayList不直接序列化元素数组呢？</h3><ul><li>出于效率的考虑 <ul><li>数组可能长度100，但实际只用了50，剩下的50不用其实不用序列化，这样可以提高序列化和反序列化的效率，还可以节省内存空间</li></ul></li></ul><h3 id="那arraylist怎么序列化呢" tabindex="-1"><a class="header-anchor" href="#那arraylist怎么序列化呢" aria-hidden="true">#</a> 那ArrayList怎么序列化呢 ？</h3><ul><li>ArrayList通过两个方法readObject、writeObject自定义序列化和反序列化策略，实际直接使用两个流 ObjectOutputStream 和 ObjectInputStream 来进行序列化和反序列化</li></ul><h2 id="快速失败-fail-fast-和安全失败-fail-safe-了解吗" tabindex="-1"><a class="header-anchor" href="#快速失败-fail-fast-和安全失败-fail-safe-了解吗" aria-hidden="true">#</a> 快速失败(fail-fast)和安全失败(fail-safe)了解吗？</h2><ul><li>快速失败（fail—fast）：快速失败是Java集合的一种错误检测机制 <ul><li>触发 <ul><li>在用迭代器遍历一个集合对象时，如果线程A遍历过程中，线程B对集合对象的内容进行了修改（增加、删除、修改），则会抛出Concurrent Modification Exception</li></ul></li><li>原理 <ul><li>迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个modCount 变量。集合在被遍历期间如果内容发生变化，就会改变 modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测<br> modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。</li></ul></li><li>注意 <ul><li>这里异常的抛出条件是检测到 modCount！=expectedmodCount 这个条件。如果集合发生变化时修改modCount值刚好又设置为了expectedmodCount值，则异常不会抛出。因此，不能依赖于这个异常是否抛出而进行并发操作的编程，这个异常只建议用于检测并发修改的bug</li></ul></li><li>场景 <ul><li>java.util包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改），比如ArrayList 类。</li></ul></li></ul></li><li>安全失败（fail—safe） <ul><li>策略 <ul><li>采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历</li></ul></li><li>原理 <ul><li>由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception</li></ul></li><li>缺点 <ul><li>基于拷贝内容的优点是避免了Concurrent Modification Exception，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的</li></ul></li><li>场景 <ul><li>java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改，比如CopyOnWriteArrayList类</li></ul></li></ul></li></ul><h2 id="实现arraylist线程安全有哪几种方法" tabindex="-1"><a class="header-anchor" href="#实现arraylist线程安全有哪几种方法" aria-hidden="true">#</a> 实现ArrayList线程安全有哪几种方法？</h2><ul><li>用Vector代替ArrayList <ul><li>Vector是一个线程安全的动态数组类，可以直接使用它来替代ArrayList</li><li>Vector的所有方法都是同步的，因此在并发环境下可以安全地进行读写操作。</li><li>但它的性能很低，不推荐使用。</li></ul></li><li>使用Collections.synchronizedList包装ArrayList <ul><li>可以使用Collections工具类的synchronizedList方法将ArrayList转换为线程安全的List</li><li>该方法返回一个包装后的线程安全List，对该List的所有操作都会进行同步处理，确保线程安全</li></ul></li><li>使用CopyOnWriteArrayList代替ArrayList <ul><li>CopyOnWriteArrayList是一种线程安全的并发List</li><li>它通过在修改时创建副本来实现并发访问</li><li>由于读操作不需要加锁，因此在读多写少的场景中，CopyOnWriteArrayList具有较高的性能</li></ul></li><li>使用同步机制控制ArrayList的读写 <ul><li>在使用ArrayList时，可以通过同步机制（如使用synchronized关键字或Lock）来控制对ArrayList的读写操作，以确保线程安全</li></ul></li></ul><h2 id="copyonwritearraylist了解多少" tabindex="-1"><a class="header-anchor" href="#copyonwritearraylist了解多少" aria-hidden="true">#</a> CopyOnWriteArrayList了解多少？</h2><ul><li>CopyOnWriteArrayList就是线程安全版本的ArrayList，它的名字叫 CopyOnWrite，写时复制，已经明示了它的原理</li><li>特点 <ul><li>线程安全性 <ul><li>CopyOnWriteArrayList通过创建副本的方式实现线程安全，因此可以在多线程环境下安全地进行读操作，而不需要额外的同步措施</li></ul></li><li>读写分离 <ul><li>CopyOnWriteArrayList适合在读多写少的场景中使用，因为每次写操作都会创建一个新的副本，会带来一定的内存开销。但在读操作频繁、写操作较少的情况下，可以获得较高的读取性能</li></ul></li><li>迭代器的弱一致性 <ul><li>由于CopyOnWriteArrayList在写操作时会创建副本，因此在遍历集合时使用的迭代器可能不反映最新的修改。迭代器提供的是一个一致性视图，即迭代器创建时的集合状态</li></ul></li></ul></li><li>工作流程 <ol><li>将原数组拷贝一份</li><li>写操作在副本上，加锁</li><li>读操作在原数组上，无锁</li><li>写完将元素数组指向副本</li></ol></li><li>缺点 <ul><li>由于CopyOnWriteArrayList在每次写操作时都会创建副本，因此适用于写操作较少、读操作频繁且对实时性要求不高的场景。如果写操作频繁或对实时性要求较高，可能会带来较高的内存开销和延迟。</li></ul></li><li>volatile修饰原数组array，保证了可见性</li></ul><h4 id="数据拷贝的过程中-有其它线程写入数据怎么办" tabindex="-1"><a class="header-anchor" href="#数据拷贝的过程中-有其它线程写入数据怎么办" aria-hidden="true">#</a> 数据拷贝的过程中，有其它线程写入数据怎么办？</h4><ul><li>阻塞呗，数据拷贝在add方法中进行，add方法有锁</li></ul>`,15);function c(u,d){const n=i("Mermaid");return l(),t("div",null,[o,e(n,{id:"mermaid-126",code:"eJxLL0osyFAIcbHmUgACx2jHoqLESp/M4pJYBV1dOwWn6GeLG57NX/psxvqnE5a9nNPwYlnjs86VT9ftjIXocAIqUwDKglU7Rz/tmP10965n0zY8m7rh+e4WZEVA/WBFLtHPtu9+2rXgaWvz8y0LnnZAlT6bs/rphn1QDc5gla7RT5f0Pu3Y9rRvPkQNQguaBa5g9W7R6OIuYHH3aLgJUHE3sLhH9LPZ+5/1LoLLPtmB4XR3iEprLi4AUeuKOg=="}),p])}const L=s(r,[["render",c],["__file","List.html.vue"]]);export{L as default};
