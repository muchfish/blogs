import{_ as r}from"./plugin-vue_export-helper-c27b6911.js";import{r as n,o as a,c as u,a as i,d as g,f as t,b as l}from"./app-d0d8d1e8.js";const d="/blogs/assets/img-50e00e15.png",s="/blogs/assets/img_1-80748d05.png",o={},c=t('<h2 id="string-是-java-基本数据类型吗-可以被继承吗" tabindex="-1"><a class="header-anchor" href="#string-是-java-基本数据类型吗-可以被继承吗" aria-hidden="true">#</a> String 是 Java 基本数据类型吗？可以被继承吗？</h2><ul><li><p>String是Java基本数据类型吗？</p><ul><li>不是，引用数据类型</li></ul></li><li><p>String 类可以继承吗?</p><ul><li>不行。String类在Java中被声明为final类，这意味着它不能被继承</li></ul></li><li><p>这样设计的原因</p><ul><li><p>字符串的不可变性</p><ul><li><p>String类的不可变性使得它可以被安全地用于多线程环境下，不会出现线程安全问题</p><blockquote><p>任何对 <code>String</code> 对象的操作（如拼接、替换等）都会返回一个新的 <code>String</code> 对象，而不会修改原始对象的值</p></blockquote></li></ul></li><li><p>字符串常量池的优化</p><ul><li>由于字符串是不可变的，Java可以对字符串进行缓存和共享，以提高性能和节省内存</li><li>这就是通过字符串常量池来实现的，它存储了所有字符串字面量的唯一实例</li></ul></li><li><p>安全性和可靠性</p><ul><li>String类的不可变性使得它在安全性和可靠性方面更加可靠。例如，它可以被用作Map的键，因为它的哈希值是固定的</li></ul></li></ul></li></ul><h2 id="string和stringbuilder、stringbuffer" tabindex="-1"><a class="header-anchor" href="#string和stringbuilder、stringbuffer" aria-hidden="true">#</a> String和StringBuilder、StringBuffer？</h2><table><thead><tr><th>类名</th><th>可变性</th><th>线程安全性</th><th>性能</th></tr></thead><tbody><tr><td>String</td><td>不可变</td><td>线程安全</td><td>低</td></tr><tr><td>StringBuffer</td><td>可变</td><td>线程安全</td><td>低</td></tr><tr><td>StringBuilder</td><td>可变</td><td>非线程安全</td><td>高</td></tr></tbody></table><ul><li>String类 <ul><li>String是不可变的，使用 private final char value[] 来存储字符串，一旦创建就不能修改其值 <ul><li>jdk11使用byte[]存储字符串</li></ul></li><li>任何对String的修改都会创建一个新的String对象</li><li>String类是线程安全的，因为它的不可变性保证了多个线程可以安全地共享String对象</li><li>由于不可变性的特性，对于频繁的字符串拼接操作，会产生大量的临时对象，影响性能</li></ul></li><li>StringBuffer类 <ul><li>StringBuffer是可变的，使用 char value[] 存储字符串，它的值可以被修改</li><li>为了保证线程安全性，StringBuffer的方法都使用synchronized关键字进行同步，在多线程环境下，使用StringBuffer可以保证线程安全</li><li>由于同步的开销，StringBuffer的性能相对较低</li></ul></li><li>StringBuilder类 <ul><li>StringBuilder是StringBuffer的非线程安全版本，它的方法没有使用synchronized关键字进行同步</li><li>在单线程环境下，使用StringBuilder可以获得更好的性能</li><li>在多线程环境下使用StringBuilder，需要自行保证线程安全</li></ul></li><li>使用建议 <ul><li>操作的数据量较小，可以使用String类</li><li>多线程环境下操作大量的数据，需要保证线程安全，可以使用StringBuffer类</li><li>单线程环境下操作大量的数据，可以使用StringBuilder类以，性能更好</li></ul></li></ul><h2 id="string-str1-new-string-abc-和string-str2-abc-和-区别" tabindex="-1"><a class="header-anchor" href="#string-str1-new-string-abc-和string-str2-abc-和-区别" aria-hidden="true">#</a> String str1 = new String(&quot;abc&quot;)和String str2 = &quot;abc&quot; 和 区别？</h2><figure><img src="'+d+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li>对象创建过程 <ul><li>两个语句都会去字符串常量池中检查是否已经存在 “abc”，如果有则直接使用，如果没有则会在常量池中创建 “abc” 对象</li><li>String str1 = new String(&quot;abc&quot;) 还会通过 new String() 在堆里创建一个&quot;abc&quot; 字符串对象实例</li></ul></li><li>String s = new String(&quot;abc&quot;)创建了几个对象？ <ul><li>一个或两个 <ul><li>如果字符串常量池已经有“abc”，则是一个；否则，两个</li></ul></li></ul></li></ul><h2 id="string不是不可变类吗-字符串拼接是如何实现的" tabindex="-1"><a class="header-anchor" href="#string不是不可变类吗-字符串拼接是如何实现的" aria-hidden="true">#</a> String不是不可变类吗？字符串拼接是如何实现的？</h2><ul><li>String的确是不可变的，“+”的拼接操作，其实是会生成新的对象</li><li>在jdk1.8之前，那么会生成多个中间对象 <ul><li>a和b初始化时位于字符串常量池，a+b拼接后的对象位于堆中。经过拼接新生成了String对象。如果拼接多次，那么会生成多个中间对象</li></ul></li></ul><figure><img src="'+s+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li>在Java8时JDK对“+”号拼接会编译成StringBuilder的append方法</li></ul><h2 id="intern方法有什么作用" tabindex="-1"><a class="header-anchor" href="#intern方法有什么作用" aria-hidden="true">#</a> intern方法有什么作用？</h2><ul><li>如果当前字符串内容存在于字符串常量池（即equals()方法为true，也就是内容一样），直接返回字符串常量池中的字符串</li><li>否则，将此String对象添加到池中，并返回String对象的引用</li></ul><h2 id="integer-a-127-integer-b-127-integer-c-128-integer-d-128-相等吗" tabindex="-1"><a class="header-anchor" href="#integer-a-127-integer-b-127-integer-c-128-integer-d-128-相等吗" aria-hidden="true">#</a> Integer a= 127，Integer b = 127；Integer c= 128，Integer d =128；相等吗?</h2><ul><li>是a和b相等，c和d不相等 <ul><li>Integer a= 127这种赋值，是用到了Integer自动装箱的机制。自动装箱的时候会去缓存池里取Integer对象，没有取到才会创建新的对象</li><li>如果整型字面量的值在-128到127之间，那么自动装箱时不会new新的Integer对象，而是直接引用缓存池中的Integer对象，超过范围 a1==b1的结果是false</li></ul></li><li>什么是Integer缓存？ <ul><li>因为根据实践发现大部分的数据操作都集中在值比较小的范围，因此 Integer 搞了个缓存池，默认范围是 -128 到 127，可以根据通过设置 JVM-XX:AutoBoxCacheMax=来修改缓存的最大值，最小值改不了</li><li>实现的原理是int 在自动装箱的时候会调用Integer.valueOf，进而用到了IntegerCache</li><li>IntegerCache是一个静态内部类， 在静态块中会初始化好缓存值</li></ul></li></ul><h2 id="string怎么转成integer的-原理" tabindex="-1"><a class="header-anchor" href="#string怎么转成integer的-原理" aria-hidden="true">#</a> String怎么转成Integer的？原理？</h2>',17),h=i("li",null,[i("p",null,"方法"),i("ul",null,[i("li",null,[i("p",null,"Integer.parseInt(String s)")]),i("li",null,[i("p",null,"Integer.valueOf(String s)")])])],-1),S=i("p",null,"原理",-1),b=i("p",null,[l("最终都调用"),i("code",null,"parseInt(String s, int radix) "),l(" 方法")],-1),f=t('<h2 id="object-类的常见方法" tabindex="-1"><a class="header-anchor" href="#object-类的常见方法" aria-hidden="true">#</a> Object 类的常见方法?</h2><ul><li>对象比较 <ul><li>hashCode()</li><li>equals(Object obj)</li></ul></li><li>对象拷贝 <ul><li>clone()</li></ul></li><li>对象转字符串 <ul><li>toString()</li></ul></li><li>多线程调度 <ul><li>wait()</li><li>wait(long timeout)</li><li>wait(long timeout,int nanos)</li><li>notify()</li><li>notifyAll()</li></ul></li><li>反射 <ul><li>getClass()</li></ul></li><li>垃圾回收 <ul><li>finalize</li></ul></li></ul>',2);function p(I,m){const e=n("Mermaid");return a(),u("div",null,[c,i("ul",null,[h,i("li",null,[S,i("ul",null,[i("li",null,[b,g(e,{id:"mermaid-414",code:"eJyVVd1OE0EYvfcp5q5tBOO9RkOgahNEA5qQbIwZu+N24na2mR0qml4QNVIVoYkWSMpPFCwJKjSGaK2kvExnW97C2Z39dZcfe9F25zvnzPm+OZ1qFJYK4N7YlQtAvKYYpCyddj4yGTA8fA2MFlD+ycSMrismsFb3ea3Za3eIeL7+QHJ8gIDbCIeVpdSgivW2wec7EzPFR4jeMGgRsuxsHpUYNgg/fMHb7VFIiMFACVITAVsUmIxioiVJi50DQ5NQxbOKtTVnbX4B1H4Ag4WXvHEQZjogh1ORkKtiHVKYZ4heup2beDg5MpabrkizDngcmebZrqWYLrCAFSBJEj3Vht2DzxiZjtu4SREUxfM60SQ8ZsaTPtVM/1uT16pyeBWQI5hhqOPnSOHVdb7zji8s86XV4/klQJAGGS6jIYCHRPNEvOEiZq54QAwOaRwRxTyuH/FOUyaHb+/0OouXI8kRoHBwnLUprBH3cI+by/z7ijDpZ882vPQrQcILiDPHbLHEnv1nAJHNSUigbUeOLOxG+qiAW5CoOnIs8+1X/drriMGgGm6PaDpyG/T74u/rvfZuvDuJjv24PJFzdliAZQR0gyCQupgCBgWp4VTyLt4Y79ozGTeMksIP50QSBjtb1kaNd3f7i/su04cEhDGsYaa4WGdU/PfPwd6n/t5K/88Ha2MtTHXAwVwk95+xWGtvrHrVqreEWtiwx/Wncr+kil/BJDJndCHSOLCWW5Edo6xIWNyNzxpljpRFwlWg2nBXNbxr0MmdMqKPdeNppBmr81noh914sNjhBvyzPIkSojgPDJdxknzk9swSNeKMV1uDblceV6/9w1r7ylvdsJIgRDwS1Z3z4Ogjb2zE5+wSYlmSkOiF60nK/wxba33T1YpdiRFsCOPHN7Ea5CyhGJpSYt25SU4qJq27T+m0+JbJ+IuhjIgnv/oXQCIQrw=="})])])])]),f])}const _=r(o,[["render",p],["__file","常用类.html.vue"]]);export{_ as default};
