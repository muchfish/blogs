const l=JSON.parse('{"key":"v-308fde42","path":"/Java/JVM/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html","title":"内存管理","lang":"zh-CN","frontmatter":{"title":"内存管理","order":2,"isTimeLine":true,"date":"2024-05-22T00:00:00.000Z","description":"能说一下JVM的内存区域吗？ JVM的内存区域分为多个部分，每个部分有其特定的用途和生命周期。主要的内存区域包括： 方法区（Method Area）： 作用：存储已加载的类信息、常量、静态变量、即时编译器编译后的代码等。 生命周期：在JVM启动时创建，在JVM退出时销毁。 特点：对于HotSpot JVM，它的一部分也被称为永久代（PermGen），从Java 8开始被移除，替换为元空间（Metaspace），元空间使用的是本地内存而不是堆内存。 堆（Heap）： 作用：存储对象实例和数组，所有对象都在堆上分配。 生命周期：在JVM启动时创建，在JVM退出时销毁。 特点：堆是垃圾回收的主要区域，可以分为新生代（Young Generation）和老年代（Old Generation），新生代又可以进一步划分为伊甸园区（Eden Space）和两个幸存者区（Survivor Space）。 Java栈（Java Stack）： 作用：每个线程有一个独立的Java栈，存储方法调用的局部变量、操作数栈、动态链接、方法出口等信息。 生命周期：与线程相同，线程创建时创建，线程结束时销毁。 特点：栈中的变量是线程私有的，不会出现线程间的数据共享问题。 程序计数器（Program Counter Register）： 作用：当前线程执行的字节码的行号指示器。如果当前线程正在执行的是本地方法，这个计数器的值是未定义的。 生命周期：与线程相同，线程创建时创建，线程结束时销毁。 特点：它是线程私有的，每个线程都有独立的程序计数器。 本地方法栈（Native Method Stack）： 作用：与Java栈类似，但为Native方法服务，存储本地方法的调用信息。 生命周期：与线程相同，线程创建时创建，线程结束时销毁。 特点：也是线程私有的，支持Native方法调用。","head":[["meta",{"property":"og:url","content":"https://muchfish.github.io/blogs/blogs/Java/JVM/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html"}],["meta",{"property":"og:site_name","content":"鱼塘"}],["meta",{"property":"og:title","content":"内存管理"}],["meta",{"property":"og:description","content":"能说一下JVM的内存区域吗？ JVM的内存区域分为多个部分，每个部分有其特定的用途和生命周期。主要的内存区域包括： 方法区（Method Area）： 作用：存储已加载的类信息、常量、静态变量、即时编译器编译后的代码等。 生命周期：在JVM启动时创建，在JVM退出时销毁。 特点：对于HotSpot JVM，它的一部分也被称为永久代（PermGen），从Java 8开始被移除，替换为元空间（Metaspace），元空间使用的是本地内存而不是堆内存。 堆（Heap）： 作用：存储对象实例和数组，所有对象都在堆上分配。 生命周期：在JVM启动时创建，在JVM退出时销毁。 特点：堆是垃圾回收的主要区域，可以分为新生代（Young Generation）和老年代（Old Generation），新生代又可以进一步划分为伊甸园区（Eden Space）和两个幸存者区（Survivor Space）。 Java栈（Java Stack）： 作用：每个线程有一个独立的Java栈，存储方法调用的局部变量、操作数栈、动态链接、方法出口等信息。 生命周期：与线程相同，线程创建时创建，线程结束时销毁。 特点：栈中的变量是线程私有的，不会出现线程间的数据共享问题。 程序计数器（Program Counter Register）： 作用：当前线程执行的字节码的行号指示器。如果当前线程正在执行的是本地方法，这个计数器的值是未定义的。 生命周期：与线程相同，线程创建时创建，线程结束时销毁。 特点：它是线程私有的，每个线程都有独立的程序计数器。 本地方法栈（Native Method Stack）： 作用：与Java栈类似，但为Native方法服务，存储本地方法的调用信息。 生命周期：与线程相同，线程创建时创建，线程结束时销毁。 特点：也是线程私有的，支持Native方法调用。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-05-22T15:01:13.000Z"}],["meta",{"property":"article:author","content":"摸鱼散人"}],["meta",{"property":"article:published_time","content":"2024-05-22T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-05-22T15:01:13.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"内存管理\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-05-22T00:00:00.000Z\\",\\"dateModified\\":\\"2024-05-22T15:01:13.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"摸鱼散人\\",\\"url\\":\\"https://github.com/muchfish\\"}]}"]]},"headers":[{"level":2,"title":"能说一下JVM的内存区域吗？","slug":"能说一下jvm的内存区域吗","link":"#能说一下jvm的内存区域吗","children":[]},{"level":2,"title":"说一下JDK1.6、1.7、1.8内存区域的变化？","slug":"说一下jdk1-6、1-7、1-8内存区域的变化","link":"#说一下jdk1-6、1-7、1-8内存区域的变化","children":[{"level":3,"title":"JDK 1.6","slug":"jdk-1-6","link":"#jdk-1-6","children":[]},{"level":3,"title":"JDK 1.7","slug":"jdk-1-7","link":"#jdk-1-7","children":[]},{"level":3,"title":"JDK 1.8","slug":"jdk-1-8","link":"#jdk-1-8","children":[]},{"level":3,"title":"详细变化对比","slug":"详细变化对比","link":"#详细变化对比","children":[]},{"level":3,"title":"总结","slug":"总结","link":"#总结","children":[]}]},{"level":2,"title":"字符串常量池和运行时常量池有啥区别？","slug":"字符串常量池和运行时常量池有啥区别","link":"#字符串常量池和运行时常量池有啥区别","children":[{"level":3,"title":"字符串常量池","slug":"字符串常量池-1","link":"#字符串常量池-1","children":[]},{"level":3,"title":"运行时常量池","slug":"运行时常量池-1","link":"#运行时常量池-1","children":[]},{"level":3,"title":"区别总结","slug":"区别总结","link":"#区别总结","children":[]}]},{"level":2,"title":"上面的代码示例中int a = 10不应该存放在栈中吗？","slug":"上面的代码示例中int-a-10不应该存放在栈中吗","link":"#上面的代码示例中int-a-10不应该存放在栈中吗","children":[{"level":3,"title":"运行时常量池和栈中的局部变量","slug":"运行时常量池和栈中的局部变量","link":"#运行时常量池和栈中的局部变量","children":[]},{"level":3,"title":"解释 int a = 10;","slug":"解释-int-a-10","link":"#解释-int-a-10","children":[]},{"level":3,"title":"修正后的解释和示例代码","slug":"修正后的解释和示例代码","link":"#修正后的解释和示例代码","children":[]},{"level":3,"title":"总结","slug":"总结-1","link":"#总结-1","children":[]}]},{"level":2,"title":"为什么使用元空间替代永久代作为方法区的实现？","slug":"为什么使用元空间替代永久代作为方法区的实现","link":"#为什么使用元空间替代永久代作为方法区的实现","children":[{"level":3,"title":"使用元空间替代永久代的原因","slug":"使用元空间替代永久代的原因","link":"#使用元空间替代永久代的原因","children":[]},{"level":3,"title":"元空间的优势","slug":"元空间的优势","link":"#元空间的优势","children":[]},{"level":3,"title":"总结","slug":"总结-2","link":"#总结-2","children":[]}]},{"level":2,"title":"对象创建的过程了解吗？","slug":"对象创建的过程了解吗","link":"#对象创建的过程了解吗","children":[]},{"level":2,"title":"什么是指针碰撞？什么是空闲列表？","slug":"什么是指针碰撞-什么是空闲列表","link":"#什么是指针碰撞-什么是空闲列表","children":[]},{"level":2,"title":"什么是TLAB（Thread-Local Allocation Buffer）","slug":"什么是tlab-thread-local-allocation-buffer","link":"#什么是tlab-thread-local-allocation-buffer","children":[]},{"level":2,"title":"JVM 里 new 对象时，堆会发生抢占吗？JVM是怎么设计来保证线程安全的？","slug":"jvm-里-new-对象时-堆会发生抢占吗-jvm是怎么设计来保证线程安全的","link":"#jvm-里-new-对象时-堆会发生抢占吗-jvm是怎么设计来保证线程安全的","children":[]},{"level":2,"title":"能说一下对象的内存布局吗？","slug":"能说一下对象的内存布局吗","link":"#能说一下对象的内存布局吗","children":[]},{"level":2,"title":"对象怎么访问定位？","slug":"对象怎么访问定位","link":"#对象怎么访问定位","children":[]},{"level":2,"title":"什么是内存溢出、内存泄漏？","slug":"什么是内存溢出、内存泄漏","link":"#什么是内存溢出、内存泄漏","children":[]},{"level":2,"title":"能手写内存溢出的例子吗？","slug":"能手写内存溢出的例子吗","link":"#能手写内存溢出的例子吗","children":[]},{"level":2,"title":"内存泄漏可能由哪些原因导致呢？","slug":"内存泄漏可能由哪些原因导致呢","link":"#内存泄漏可能由哪些原因导致呢","children":[]},{"level":2,"title":"如何判断对象仍然存活？","slug":"如何判断对象仍然存活","link":"#如何判断对象仍然存活","children":[]},{"level":2,"title":"Java中可作为GC Roots的对象有哪几种？","slug":"java中可作为gc-roots的对象有哪几种","link":"#java中可作为gc-roots的对象有哪几种","children":[]},{"level":2,"title":"说一下对象有哪几种引用？","slug":"说一下对象有哪几种引用","link":"#说一下对象有哪几种引用","children":[]},{"level":2,"title":"finalize()方法了解吗？有什么作用？","slug":"finalize-方法了解吗-有什么作用","link":"#finalize-方法了解吗-有什么作用","children":[]},{"level":2,"title":"Java堆的内存分区了解吗？","slug":"java堆的内存分区了解吗","link":"#java堆的内存分区了解吗","children":[]},{"level":2,"title":"垃圾收集算法了解吗？","slug":"垃圾收集算法了解吗","link":"#垃圾收集算法了解吗","children":[]},{"level":2,"title":"说一下新生代的区域划分？","slug":"说一下新生代的区域划分","link":"#说一下新生代的区域划分","children":[]},{"level":2,"title":"Minor GC/Young GC、Major GC/Old GC、Mixed GC、Full GC都是什么意思？","slug":"minor-gc-young-gc、major-gc-old-gc、mixed-gc、full-gc都是什么意思","link":"#minor-gc-young-gc、major-gc-old-gc、mixed-gc、full-gc都是什么意思","children":[]},{"level":2,"title":"Minor GC/Young GC什么时候触发？","slug":"minor-gc-young-gc什么时候触发","link":"#minor-gc-young-gc什么时候触发","children":[]},{"level":2,"title":"什么时候会触发Full GC？","slug":"什么时候会触发full-gc","link":"#什么时候会触发full-gc","children":[]},{"level":2,"title":"对象什么时候会进入老年代？","slug":"对象什么时候会进入老年代","link":"#对象什么时候会进入老年代","children":[]},{"level":2,"title":"知道有哪些垃圾收集器吗？","slug":"知道有哪些垃圾收集器吗","link":"#知道有哪些垃圾收集器吗","children":[]},{"level":2,"title":"什么是Stop The World ? 什么是 OopMap ？什么是安全点？","slug":"什么是stop-the-world-什么是-oopmap-什么是安全点","link":"#什么是stop-the-world-什么是-oopmap-什么是安全点","children":[]},{"level":2,"title":"能详细说一下CMS收集器的垃圾收集过程吗？","slug":"能详细说一下cms收集器的垃圾收集过程吗","link":"#能详细说一下cms收集器的垃圾收集过程吗","children":[]},{"level":2,"title":"G1垃圾收集器了解吗？","slug":"g1垃圾收集器了解吗","link":"#g1垃圾收集器了解吗","children":[{"level":3,"title":"G1垃圾收集器的关键特点","slug":"g1垃圾收集器的关键特点","link":"#g1垃圾收集器的关键特点","children":[]},{"level":3,"title":"G1垃圾收集器的工作阶段","slug":"g1垃圾收集器的工作阶段","link":"#g1垃圾收集器的工作阶段","children":[]},{"level":3,"title":"G1垃圾收集器的优势","slug":"g1垃圾收集器的优势","link":"#g1垃圾收集器的优势","children":[]},{"level":3,"title":"G1垃圾收集器的配置参数","slug":"g1垃圾收集器的配置参数","link":"#g1垃圾收集器的配置参数","children":[]},{"level":3,"title":"总结","slug":"总结-3","link":"#总结-3","children":[]}]},{"level":2,"title":"有了CMS，为什么还要引入G1？","slug":"有了cms-为什么还要引入g1","link":"#有了cms-为什么还要引入g1","children":[{"level":3,"title":"CMS的局限性","slug":"cms的局限性","link":"#cms的局限性","children":[]},{"level":3,"title":"G1垃圾收集器的优势","slug":"g1垃圾收集器的优势-1","link":"#g1垃圾收集器的优势-1","children":[]},{"level":3,"title":"总结","slug":"总结-4","link":"#总结-4","children":[]}]},{"level":2,"title":"你们线上用的什么垃圾收集器？为什么要用它？","slug":"你们线上用的什么垃圾收集器-为什么要用它","link":"#你们线上用的什么垃圾收集器-为什么要用它","children":[{"level":3,"title":"常见的垃圾收集器","slug":"常见的垃圾收集器","link":"#常见的垃圾收集器","children":[]},{"level":3,"title":"为什么选择某种垃圾收集器","slug":"为什么选择某种垃圾收集器","link":"#为什么选择某种垃圾收集器","children":[]},{"level":3,"title":"大公司和常见应用中的选择","slug":"大公司和常见应用中的选择","link":"#大公司和常见应用中的选择","children":[]},{"level":3,"title":"总结","slug":"总结-5","link":"#总结-5","children":[]}]},{"level":2,"title":"垃圾收集器应该如何选择？","slug":"垃圾收集器应该如何选择","link":"#垃圾收集器应该如何选择","children":[{"level":3,"title":"关键考虑因素","slug":"关键考虑因素","link":"#关键考虑因素","children":[]},{"level":3,"title":"常见垃圾收集器选项","slug":"常见垃圾收集器选项","link":"#常见垃圾收集器选项","children":[]},{"level":3,"title":"选择垃圾收集器的步骤","slug":"选择垃圾收集器的步骤","link":"#选择垃圾收集器的步骤","children":[]},{"level":3,"title":"总结","slug":"总结-6","link":"#总结-6","children":[]}]},{"level":2,"title":"对象一定分配在堆中吗？有没有了解逃逸分析技术？","slug":"对象一定分配在堆中吗-有没有了解逃逸分析技术","link":"#对象一定分配在堆中吗-有没有了解逃逸分析技术","children":[{"level":3,"title":"对象分配的基本概念","slug":"对象分配的基本概念","link":"#对象分配的基本概念","children":[]},{"level":3,"title":"逃逸分析（Escape Analysis）","slug":"逃逸分析-escape-analysis","link":"#逃逸分析-escape-analysis","children":[]},{"level":3,"title":"逃逸分析的应用示例","slug":"逃逸分析的应用示例","link":"#逃逸分析的应用示例","children":[]},{"level":3,"title":"JVM参数和逃逸分析","slug":"jvm参数和逃逸分析","link":"#jvm参数和逃逸分析","children":[]},{"level":3,"title":"逃逸分析的优势","slug":"逃逸分析的优势","link":"#逃逸分析的优势","children":[]},{"level":3,"title":"总结","slug":"总结-7","link":"#总结-7","children":[]}]},{"level":2,"title":"逃逸分析中标量替换的工作原理是怎样的？","slug":"逃逸分析中标量替换的工作原理是怎样的","link":"#逃逸分析中标量替换的工作原理是怎样的","children":[{"level":3,"title":"标量替换的工作原理","slug":"标量替换的工作原理","link":"#标量替换的工作原理","children":[]},{"level":3,"title":"示例代码","slug":"示例代码","link":"#示例代码","children":[]},{"level":3,"title":"JVM参数","slug":"jvm参数","link":"#jvm参数","children":[]},{"level":3,"title":"总结","slug":"总结-8","link":"#总结-8","children":[]}]}],"git":{"createdTime":1716372952000,"updatedTime":1716390073000,"contributors":[{"name":"daiwencheng","email":"1319105206@qq.com","commits":2}]},"readingTime":{"minutes":62.42,"words":18725},"filePathRelative":"Java/JVM/内存管理.md","localizedDate":"2024年5月22日","excerpt":"<h2> 能说一下JVM的内存区域吗？</h2>\\n<p>JVM的内存区域分为多个部分，每个部分有其特定的用途和生命周期。主要的内存区域包括：</p>\\n<ol>\\n<li>\\n<p><strong>方法区（Method Area）</strong>：</p>\\n<ul>\\n<li><strong>作用</strong>：存储已加载的类信息、常量、静态变量、即时编译器编译后的代码等。</li>\\n<li><strong>生命周期</strong>：在JVM启动时创建，在JVM退出时销毁。</li>\\n<li><strong>特点</strong>：对于HotSpot JVM，它的一部分也被称为永久代（PermGen），从Java 8开始被移除，替换为元空间（Metaspace），元空间使用的是本地内存而不是堆内存。</li>\\n</ul>\\n</li>\\n<li>\\n<p><strong>堆（Heap）</strong>：</p>\\n<ul>\\n<li><strong>作用</strong>：存储对象实例和数组，所有对象都在堆上分配。</li>\\n<li><strong>生命周期</strong>：在JVM启动时创建，在JVM退出时销毁。</li>\\n<li><strong>特点</strong>：堆是垃圾回收的主要区域，可以分为新生代（Young Generation）和老年代（Old Generation），新生代又可以进一步划分为伊甸园区（Eden Space）和两个幸存者区（Survivor Space）。</li>\\n</ul>\\n</li>\\n<li>\\n<p><strong>Java栈（Java Stack）</strong>：</p>\\n<ul>\\n<li><strong>作用</strong>：每个线程有一个独立的Java栈，存储方法调用的局部变量、操作数栈、动态链接、方法出口等信息。</li>\\n<li><strong>生命周期</strong>：与线程相同，线程创建时创建，线程结束时销毁。</li>\\n<li><strong>特点</strong>：栈中的变量是线程私有的，不会出现线程间的数据共享问题。</li>\\n</ul>\\n</li>\\n<li>\\n<p><strong>程序计数器（Program Counter Register）</strong>：</p>\\n<ul>\\n<li><strong>作用</strong>：当前线程执行的字节码的行号指示器。如果当前线程正在执行的是本地方法，这个计数器的值是未定义的。</li>\\n<li><strong>生命周期</strong>：与线程相同，线程创建时创建，线程结束时销毁。</li>\\n<li><strong>特点</strong>：它是线程私有的，每个线程都有独立的程序计数器。</li>\\n</ul>\\n</li>\\n<li>\\n<p><strong>本地方法栈（Native Method Stack）</strong>：</p>\\n<ul>\\n<li><strong>作用</strong>：与Java栈类似，但为Native方法服务，存储本地方法的调用信息。</li>\\n<li><strong>生命周期</strong>：与线程相同，线程创建时创建，线程结束时销毁。</li>\\n<li><strong>特点</strong>：也是线程私有的，支持Native方法调用。</li>\\n</ul>\\n</li>\\n</ol>","autoDesc":true}');export{l as data};
