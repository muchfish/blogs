const n=JSON.parse('{"key":"v-6c2a75a6","path":"/Java/concurrent/%E9%94%81.html","title":"锁","lang":"zh-CN","frontmatter":{"title":"锁","order":4,"isTimeLine":true,"date":"2024-05-19T00:00:00.000Z","description":"synchronized用过吗？怎么使用？ 修饰实例方法 作用于当前对象实例加锁，进入同步代码前要获得 当前对象实例的锁 synchronized void method() { \\t//业务代码 } 修饰静态方法 也就是给当前类加锁，会作⽤于类的所有对象实例 ，进⼊同步代码前要获得当前 class 的锁 因为静态成员不属于任何⼀个实例对象，是类成员（ static 表明这是该类的⼀个静态资源，不管 new 了多少个对象，只有⼀份） synchronized void staic method() { //业务代码 } 修饰代码块 指定加锁对象，对给定对象/类加锁。 synchronized(this|object) 表示进⼊同步代码库前要获得给定对象的锁。 synchronized(类.class) 表示进⼊同步代码前要获得 当前 class 的锁 synchronized(this) { //业务代码 }","head":[["meta",{"property":"og:url","content":"https://muchfish.github.io/blogs/blogs/Java/concurrent/%E9%94%81.html"}],["meta",{"property":"og:site_name","content":"鱼塘"}],["meta",{"property":"og:title","content":"锁"}],["meta",{"property":"og:description","content":"synchronized用过吗？怎么使用？ 修饰实例方法 作用于当前对象实例加锁，进入同步代码前要获得 当前对象实例的锁 synchronized void method() { \\t//业务代码 } 修饰静态方法 也就是给当前类加锁，会作⽤于类的所有对象实例 ，进⼊同步代码前要获得当前 class 的锁 因为静态成员不属于任何⼀个实例对象，是类成员（ static 表明这是该类的⼀个静态资源，不管 new 了多少个对象，只有⼀份） synchronized void staic method() { //业务代码 } 修饰代码块 指定加锁对象，对给定对象/类加锁。 synchronized(this|object) 表示进⼊同步代码库前要获得给定对象的锁。 synchronized(类.class) 表示进⼊同步代码前要获得 当前 class 的锁 synchronized(this) { //业务代码 }"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-06-26T12:33:22.000Z"}],["meta",{"property":"article:author","content":"摸鱼散人"}],["meta",{"property":"article:published_time","content":"2024-05-19T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-06-26T12:33:22.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"锁\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-05-19T00:00:00.000Z\\",\\"dateModified\\":\\"2024-06-26T12:33:22.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"摸鱼散人\\",\\"url\\":\\"https://github.com/muchfish\\"}]}"]]},"headers":[{"level":2,"title":"synchronized用过吗？怎么使用？","slug":"synchronized用过吗-怎么使用","link":"#synchronized用过吗-怎么使用","children":[]},{"level":2,"title":"synchronized的实现原理？","slug":"synchronized的实现原理","link":"#synchronized的实现原理","children":[{"level":3,"title":"synchronized是怎么加锁的呢？","slug":"synchronized是怎么加锁的呢","link":"#synchronized是怎么加锁的呢","children":[]},{"level":3,"title":"synchronized锁住的是什么呢？","slug":"synchronized锁住的是什么呢","link":"#synchronized锁住的是什么呢","children":[]}]},{"level":2,"title":"除了原子性，synchronized可见性，有序性，可重入性怎么实现？","slug":"除了原子性-synchronized可见性-有序性-可重入性怎么实现","link":"#除了原子性-synchronized可见性-有序性-可重入性怎么实现","children":[{"level":3,"title":"synchronized怎么保证可见性？","slug":"synchronized怎么保证可见性","link":"#synchronized怎么保证可见性","children":[]},{"level":3,"title":"synchronized怎么保证有序性？","slug":"synchronized怎么保证有序性","link":"#synchronized怎么保证有序性","children":[]},{"level":3,"title":"synchronized怎么实现可重入的呢？","slug":"synchronized怎么实现可重入的呢","link":"#synchronized怎么实现可重入的呢","children":[]}]},{"level":2,"title":"锁升级？synchronized优化了解吗？","slug":"锁升级-synchronized优化了解吗","link":"#锁升级-synchronized优化了解吗","children":[{"level":3,"title":"synchronized做了哪些优化？","slug":"synchronized做了哪些优化","link":"#synchronized做了哪些优化","children":[]},{"level":3,"title":"锁升级的过程是什么样的？","slug":"锁升级的过程是什么样的","link":"#锁升级的过程是什么样的","children":[]},{"level":3,"title":"偏向锁","slug":"偏向锁","link":"#偏向锁","children":[]},{"level":3,"title":"轻量级锁","slug":"轻量级锁","link":"#轻量级锁","children":[]}]},{"level":2,"title":"说说synchronized和ReentrantLock的区别？","slug":"说说synchronized和reentrantlock的区别","link":"#说说synchronized和reentrantlock的区别","children":[]},{"level":2,"title":"AQS了解多少？","slug":"aqs了解多少","link":"#aqs了解多少","children":[]},{"level":2,"title":"ReentrantLock实现原理？","slug":"reentrantlock实现原理","link":"#reentrantlock实现原理","children":[{"level":3,"title":"公平锁 FairSync","slug":"公平锁-fairsync","link":"#公平锁-fairsync","children":[]},{"level":3,"title":"非公平锁 NonfairSync","slug":"非公平锁-nonfairsync","link":"#非公平锁-nonfairsync","children":[]},{"level":3,"title":"Lock()的执行过程","slug":"lock-的执行过程","link":"#lock-的执行过程","children":[]}]},{"level":2,"title":"ReentrantLock怎么实现公平锁的？","slug":"reentrantlock怎么实现公平锁的","link":"#reentrantlock怎么实现公平锁的","children":[]},{"level":2,"title":"什么是CAS?","slug":"什么是cas","link":"#什么是cas","children":[]},{"level":2,"title":"CAS 有什么问题？如何解决？","slug":"cas-有什么问题-如何解决","link":"#cas-有什么问题-如何解决","children":[{"level":3,"title":"ABA 问题","slug":"aba-问题","link":"#aba-问题","children":[]},{"level":3,"title":"循环性能开销","slug":"循环性能开销","link":"#循环性能开销","children":[]},{"level":3,"title":"只能保证一个变量的原子操作","slug":"只能保证一个变量的原子操作","link":"#只能保证一个变量的原子操作","children":[]}]},{"level":2,"title":"Java有哪些保证原子性的方法？如何保证多线程下i++ 结果正确？","slug":"java有哪些保证原子性的方法-如何保证多线程下i-结果正确","link":"#java有哪些保证原子性的方法-如何保证多线程下i-结果正确","children":[]},{"level":2,"title":"原子操作类了解多少？","slug":"原子操作类了解多少","link":"#原子操作类了解多少","children":[]},{"level":2,"title":"AtomicInteger 的原理？","slug":"atomicinteger-的原理","link":"#atomicinteger-的原理","children":[]},{"level":2,"title":"线程死锁了解吗？该如何避免？","slug":"线程死锁了解吗-该如何避免","link":"#线程死锁了解吗-该如何避免","children":[]},{"level":2,"title":"死锁问题怎么排查呢？","slug":"死锁问题怎么排查呢","link":"#死锁问题怎么排查呢","children":[]}],"git":{"createdTime":1719405202000,"updatedTime":1719405202000,"contributors":[{"name":"daiwencheng","email":"1319105206@qq.com","commits":1}]},"readingTime":{"minutes":18.99,"words":5697},"filePathRelative":"Java/concurrent/锁.md","localizedDate":"2024年5月19日","excerpt":"<h2> synchronized用过吗？怎么使用？</h2>\\n<ul>\\n<li>\\n<p>修饰实例方法</p>\\n<ul>\\n<li>\\n<p>作用于当前对象实例加锁，进入同步代码前要获得 当前对象实例的锁</p>\\n<div class=\\"language-java line-numbers-mode\\" data-ext=\\"java\\"><pre class=\\"language-java\\"><code><span class=\\"token keyword\\">synchronized</span> <span class=\\"token keyword\\">void</span> <span class=\\"token function\\">method</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span> <span class=\\"token punctuation\\">{</span>\\n\\t<span class=\\"token comment\\">//业务代码</span>\\n<span class=\\"token punctuation\\">}</span>\\n</code></pre><div class=\\"line-numbers\\" aria-hidden=\\"true\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div></li>\\n</ul>\\n</li>\\n<li>\\n<p>修饰静态方法</p>\\n<ul>\\n<li>\\n<p>也就是给当前类加锁，会作⽤于类的所有对象实例 ，进⼊同步代码前要获得当前 class 的锁</p>\\n</li>\\n<li>\\n<p>因为静态成员不属于任何⼀个实例对象，是类成员（ static 表明这是该类的⼀个静态资源，不管 new 了多少个对象，只有⼀份）</p>\\n<div class=\\"language-java line-numbers-mode\\" data-ext=\\"java\\"><pre class=\\"language-java\\"><code><span class=\\"token keyword\\">synchronized</span> <span class=\\"token keyword\\">void</span> staic <span class=\\"token function\\">method</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span> <span class=\\"token punctuation\\">{</span>\\n<span class=\\"token comment\\">//业务代码</span>\\n<span class=\\"token punctuation\\">}</span>\\n</code></pre><div class=\\"line-numbers\\" aria-hidden=\\"true\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div></li>\\n</ul>\\n</li>\\n<li>\\n<p>修饰代码块</p>\\n<ul>\\n<li>\\n<p>指定加锁对象，对给定对象/类加锁。</p>\\n</li>\\n<li>\\n<p>synchronized(this|object) 表示进⼊同步代码库前要获得给定对象的锁。</p>\\n</li>\\n<li>\\n<p>synchronized(类.class) 表示进⼊同步代码前要获得 当前 class 的锁</p>\\n<div class=\\"language-java line-numbers-mode\\" data-ext=\\"java\\"><pre class=\\"language-java\\"><code><span class=\\"token keyword\\">synchronized</span><span class=\\"token punctuation\\">(</span><span class=\\"token keyword\\">this</span><span class=\\"token punctuation\\">)</span> <span class=\\"token punctuation\\">{</span>\\n  <span class=\\"token comment\\">//业务代码</span>\\n<span class=\\"token punctuation\\">}</span>\\n</code></pre><div class=\\"line-numbers\\" aria-hidden=\\"true\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div></li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true}');export{n as data};
