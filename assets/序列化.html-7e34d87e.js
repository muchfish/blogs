const e=JSON.parse('{"key":"v-5f055112","path":"/Java%E9%9D%A2%E8%AF%95/Java%E5%9F%BA%E7%A1%80/%E5%BA%8F%E5%88%97%E5%8C%96.html","title":"8.序列化","lang":"zh-CN","frontmatter":{"title":"8.序列化","isTimeLine":true,"date":"2024-05-12T00:00:00.000Z","description":"什么是序列化？什么是反序列化？ 序列化 把Java对象转为二进制流，方便存储和传输 反序列化 把二进制流恢复成对象 Serializable接口有什么用？ 用于标识类可以被序列化 实现Serializable接口的类可以将对象转换为字节流进行传输和存储，实现数据的持久化和 跨平台的数据交换 serialVersionUID 又有什么用 版本控制 当一个类被序列化后，如果后续对该类进行了修改，例如添加、删除或修改了类的属性、方法等，那么序列化和反序列化时可能会出现版本不一致的问题。为了避免这种问题，可以在类中显式地定义serialVersionUID字段，并确保在类的修改后，serialVersionUID的值保持不变。当反序列化时，会比较序列化类的版本号和当前类的版本号是否一致，如果不一致，则会抛出InvalidClassException异常 兼容性 当一个类的实例被序列化后，如果在后续的版本中对该类进行了修改，但是仍然希望能够反序列化之前的序列化数据，那么可以通过显式地指定serialVersionUID来保持兼容性。如果新版本的类和旧版本的类具有相同的serialVersionUID，那么即使类的结构发生了变化，仍然可以成功反序列化之前的序列化数据 Java 序列化不包含静态变量 Java序列化只会保存对象的非静态成员变量，不包含静态变量 静态变量属于类的状态信息，在序列化时不需要保存 如果有些变量不想序列化，怎么办？ 使用 transient 关键字修饰 transient 关键字的作用 阻止实例中那些用此关键字修饰的的变量序列化 当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复 transient 只能修饰变量，不能修饰类和方法","head":[["meta",{"property":"og:url","content":"https://muchfish.github.io/blogs/blogs/Java%E9%9D%A2%E8%AF%95/Java%E5%9F%BA%E7%A1%80/%E5%BA%8F%E5%88%97%E5%8C%96.html"}],["meta",{"property":"og:site_name","content":"鱼塘"}],["meta",{"property":"og:title","content":"8.序列化"}],["meta",{"property":"og:description","content":"什么是序列化？什么是反序列化？ 序列化 把Java对象转为二进制流，方便存储和传输 反序列化 把二进制流恢复成对象 Serializable接口有什么用？ 用于标识类可以被序列化 实现Serializable接口的类可以将对象转换为字节流进行传输和存储，实现数据的持久化和 跨平台的数据交换 serialVersionUID 又有什么用 版本控制 当一个类被序列化后，如果后续对该类进行了修改，例如添加、删除或修改了类的属性、方法等，那么序列化和反序列化时可能会出现版本不一致的问题。为了避免这种问题，可以在类中显式地定义serialVersionUID字段，并确保在类的修改后，serialVersionUID的值保持不变。当反序列化时，会比较序列化类的版本号和当前类的版本号是否一致，如果不一致，则会抛出InvalidClassException异常 兼容性 当一个类的实例被序列化后，如果在后续的版本中对该类进行了修改，但是仍然希望能够反序列化之前的序列化数据，那么可以通过显式地指定serialVersionUID来保持兼容性。如果新版本的类和旧版本的类具有相同的serialVersionUID，那么即使类的结构发生了变化，仍然可以成功反序列化之前的序列化数据 Java 序列化不包含静态变量 Java序列化只会保存对象的非静态成员变量，不包含静态变量 静态变量属于类的状态信息，在序列化时不需要保存 如果有些变量不想序列化，怎么办？ 使用 transient 关键字修饰 transient 关键字的作用 阻止实例中那些用此关键字修饰的的变量序列化 当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复 transient 只能修饰变量，不能修饰类和方法"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-05-12T10:47:10.000Z"}],["meta",{"property":"article:author","content":"摸鱼散人"}],["meta",{"property":"article:published_time","content":"2024-05-12T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-05-12T10:47:10.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"8.序列化\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-05-12T00:00:00.000Z\\",\\"dateModified\\":\\"2024-05-12T10:47:10.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"摸鱼散人\\",\\"url\\":\\"https://github.com/muchfish\\"}]}"]]},"headers":[{"level":2,"title":"什么是序列化？什么是反序列化？","slug":"什么是序列化-什么是反序列化","link":"#什么是序列化-什么是反序列化","children":[]},{"level":2,"title":"说说有哪些常见的序列化方式？","slug":"说说有哪些常见的序列化方式","link":"#说说有哪些常见的序列化方式","children":[]}],"git":{"createdTime":1715510830000,"updatedTime":1715510830000,"contributors":[{"name":"daiwencheng","email":"1319105206@qq.com","commits":1}]},"readingTime":{"minutes":3.13,"words":939},"filePathRelative":"Java面试/Java基础/序列化.md","localizedDate":"2024年5月12日","excerpt":"<h2> 什么是序列化？什么是反序列化？</h2>\\n<ul>\\n<li>序列化\\n<ul>\\n<li>把Java对象转为二进制流，方便存储和传输</li>\\n</ul>\\n</li>\\n<li>反序列化\\n<ul>\\n<li>把二进制流恢复成对象</li>\\n</ul>\\n</li>\\n<li>Serializable接口有什么用？\\n<ul>\\n<li>用于标识类可以被序列化</li>\\n<li>实现Serializable接口的类可以将对象转换为字节流进行传输和存储，实现数据的持久化和<br>\\n跨平台的数据交换</li>\\n</ul>\\n</li>\\n<li>serialVersionUID 又有什么用\\n<ul>\\n<li>版本控制\\n<ul>\\n<li>当一个类被序列化后，如果后续对该类进行了修改，例如添加、删除或修改了类的属性、方法等，那么序列化和反序列化时可能会出现版本不一致的问题。为了避免这种问题，可以在类中显式地定义serialVersionUID字段，并确保在类的修改后，serialVersionUID的值保持不变。当反序列化时，会比较序列化类的版本号和当前类的版本号是否一致，如果不一致，则会抛出InvalidClassException异常</li>\\n</ul>\\n</li>\\n<li>兼容性\\n<ul>\\n<li>当一个类的实例被序列化后，如果在后续的版本中对该类进行了修改，但是仍然希望能够反序列化之前的序列化数据，那么可以通过显式地指定serialVersionUID来保持兼容性。如果新版本的类和旧版本的类具有相同的serialVersionUID，那么即使类的结构发生了变化，仍然可以成功反序列化之前的序列化数据</li>\\n</ul>\\n</li>\\n</ul>\\n</li>\\n<li>Java 序列化不包含静态变量\\n<ul>\\n<li>Java序列化只会保存对象的非静态成员变量，不包含静态变量</li>\\n<li>静态变量属于类的状态信息，在序列化时不需要保存</li>\\n</ul>\\n</li>\\n<li>如果有些变量不想序列化，怎么办？\\n<ul>\\n<li>使用 transient 关键字修饰</li>\\n<li>transient 关键字的作用\\n<ul>\\n<li>阻止实例中那些用此关键字修饰的的变量序列化</li>\\n<li>当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复</li>\\n</ul>\\n</li>\\n<li>transient 只能修饰变量，不能修饰类和方法</li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true}');export{e as data};
