const l=JSON.parse('{"key":"v-0a5fb23e","path":"/Java/JVM/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%89%A7%E8%A1%8C.html","title":"虚拟机执行","lang":"zh-CN","frontmatter":{"title":"虚拟机执行","order":4,"isTimeLine":true,"date":"2024-05-23T00:00:00.000Z","description":"能说一下类的生命周期吗？ 是的，一个类在Java虚拟机（JVM）中从加载到卸载整个生命周期包括以下七个阶段：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）。其中，验证、准备和解析三个阶段合称为连接（Linking）。以下是对每个阶段的详细解释： 1. 加载（Loading） 描述：将类的字节码文件加载到内存中，并创建一个代表该类的Class对象。 细节：JVM通过类加载器（ClassLoader）读取字节码文件（.class文件），将其转换为内存中的数据结构，并生成一个Class对象来表示该类。","head":[["meta",{"property":"og:url","content":"https://muchfish.github.io/blogs/blogs/Java/JVM/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%89%A7%E8%A1%8C.html"}],["meta",{"property":"og:site_name","content":"鱼塘"}],["meta",{"property":"og:title","content":"虚拟机执行"}],["meta",{"property":"og:description","content":"能说一下类的生命周期吗？ 是的，一个类在Java虚拟机（JVM）中从加载到卸载整个生命周期包括以下七个阶段：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）。其中，验证、准备和解析三个阶段合称为连接（Linking）。以下是对每个阶段的详细解释： 1. 加载（Loading） 描述：将类的字节码文件加载到内存中，并创建一个代表该类的Class对象。 细节：JVM通过类加载器（ClassLoader）读取字节码文件（.class文件），将其转换为内存中的数据结构，并生成一个Class对象来表示该类。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-05-23T03:11:08.000Z"}],["meta",{"property":"article:author","content":"摸鱼散人"}],["meta",{"property":"article:published_time","content":"2024-05-23T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-05-23T03:11:08.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"虚拟机执行\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-05-23T00:00:00.000Z\\",\\"dateModified\\":\\"2024-05-23T03:11:08.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"摸鱼散人\\",\\"url\\":\\"https://github.com/muchfish\\"}]}"]]},"headers":[{"level":2,"title":"能说一下类的生命周期吗？","slug":"能说一下类的生命周期吗","link":"#能说一下类的生命周期吗","children":[{"level":3,"title":"1. 加载（Loading）","slug":"_1-加载-loading","link":"#_1-加载-loading","children":[]},{"level":3,"title":"2. 验证（Verification）","slug":"_2-验证-verification","link":"#_2-验证-verification","children":[]},{"level":3,"title":"3. 准备（Preparation）","slug":"_3-准备-preparation","link":"#_3-准备-preparation","children":[]},{"level":3,"title":"4. 解析（Resolution）","slug":"_4-解析-resolution","link":"#_4-解析-resolution","children":[]},{"level":3,"title":"5. 初始化（Initialization）","slug":"_5-初始化-initialization","link":"#_5-初始化-initialization","children":[]},{"level":3,"title":"6. 使用（Using）","slug":"_6-使用-using","link":"#_6-使用-using","children":[]},{"level":3,"title":"7. 卸载（Unloading）","slug":"_7-卸载-unloading","link":"#_7-卸载-unloading","children":[]}]},{"level":2,"title":"类加载的过程知道吗？","slug":"类加载的过程知道吗","link":"#类加载的过程知道吗","children":[{"level":3,"title":"1. 获取二进制字节流","slug":"_1-获取二进制字节流","link":"#_1-获取二进制字节流","children":[]},{"level":3,"title":"2. 转换为方法区的运行时数据结构","slug":"_2-转换为方法区的运行时数据结构","link":"#_2-转换为方法区的运行时数据结构","children":[]},{"level":3,"title":"3. 创建Class对象","slug":"_3-创建class对象","link":"#_3-创建class对象","children":[]},{"level":3,"title":"详细描述","slug":"详细描述","link":"#详细描述","children":[]},{"level":3,"title":"加载阶段结束后","slug":"加载阶段结束后","link":"#加载阶段结束后","children":[]},{"level":3,"title":"小结","slug":"小结","link":"#小结","children":[]}]},{"level":2,"title":"类加载器有哪些？","slug":"类加载器有哪些","link":"#类加载器有哪些","children":[{"level":3,"title":"1. 启动类加载器（Bootstrap ClassLoader）","slug":"_1-启动类加载器-bootstrap-classloader","link":"#_1-启动类加载器-bootstrap-classloader","children":[]},{"level":3,"title":"2. 扩展类加载器（Extension ClassLoader）","slug":"_2-扩展类加载器-extension-classloader","link":"#_2-扩展类加载器-extension-classloader","children":[]},{"level":3,"title":"3. 应用程序类加载器（Application ClassLoader）","slug":"_3-应用程序类加载器-application-classloader","link":"#_3-应用程序类加载器-application-classloader","children":[]},{"level":3,"title":"4. 自定义类加载器（Custom ClassLoader）","slug":"_4-自定义类加载器-custom-classloader","link":"#_4-自定义类加载器-custom-classloader","children":[]},{"level":3,"title":"类加载器的层次结构","slug":"类加载器的层次结构","link":"#类加载器的层次结构","children":[]},{"level":3,"title":"示例代码","slug":"示例代码","link":"#示例代码","children":[]}]},{"level":2,"title":"什么是双亲委派机制？","slug":"什么是双亲委派机制","link":"#什么是双亲委派机制","children":[{"level":3,"title":"工作原理","slug":"工作原理","link":"#工作原理","children":[]},{"level":3,"title":"双亲委派机制的优点","slug":"双亲委派机制的优点","link":"#双亲委派机制的优点","children":[]}]},{"level":2,"title":"为什么要用双亲委派机制？","slug":"为什么要用双亲委派机制","link":"#为什么要用双亲委派机制","children":[{"level":3,"title":"1. 确保类的唯一性和一致性","slug":"_1-确保类的唯一性和一致性","link":"#_1-确保类的唯一性和一致性","children":[]},{"level":3,"title":"2. 避免重复加载类","slug":"_2-避免重复加载类","link":"#_2-避免重复加载类","children":[]},{"level":3,"title":"3. 加载类的安全性","slug":"_3-加载类的安全性","link":"#_3-加载类的安全性","children":[]},{"level":3,"title":"4. 统一类加载规则","slug":"_4-统一类加载规则","link":"#_4-统一类加载规则","children":[]},{"level":3,"title":"5. 支持模块化开发和扩展性","slug":"_5-支持模块化开发和扩展性","link":"#_5-支持模块化开发和扩展性","children":[]}]},{"level":2,"title":"如何破坏双亲委派机制？","slug":"如何破坏双亲委派机制","link":"#如何破坏双亲委派机制","children":[{"level":3,"title":"1. 自定义类加载器","slug":"_1-自定义类加载器","link":"#_1-自定义类加载器","children":[]},{"level":3,"title":"2. 直接调用ClassLoader.loadClass方法","slug":"_2-直接调用classloader-loadclass方法","link":"#_2-直接调用classloader-loadclass方法","children":[]},{"level":3,"title":"3. 修改ClassLoader类的defineClass方法","slug":"_3-修改classloader类的defineclass方法","link":"#_3-修改classloader类的defineclass方法","children":[]},{"level":3,"title":"4. OSGi等框架","slug":"_4-osgi等框架","link":"#_4-osgi等框架","children":[]},{"level":3,"title":"5. 应用服务器（如Tomcat）的类加载策略","slug":"_5-应用服务器-如tomcat-的类加载策略","link":"#_5-应用服务器-如tomcat-的类加载策略","children":[]},{"level":3,"title":"6.Thread.currentThread().setContextClassLoader","slug":"_6-thread-currentthread-setcontextclassloader","link":"#_6-thread-currentthread-setcontextclassloader","children":[]}]},{"level":2,"title":"历史上有哪几次双亲委派机制的破坏？","slug":"历史上有哪几次双亲委派机制的破坏","link":"#历史上有哪几次双亲委派机制的破坏","children":[{"level":3,"title":"第一次破坏","slug":"第一次破坏","link":"#第一次破坏","children":[]},{"level":3,"title":"第二次破坏","slug":"第二次破坏","link":"#第二次破坏","children":[]},{"level":3,"title":"第三次破坏","slug":"第三次破坏","link":"#第三次破坏","children":[]}]},{"level":2,"title":"你觉得应该怎么实现一个热部署功能？","slug":"你觉得应该怎么实现一个热部署功能","link":"#你觉得应该怎么实现一个热部署功能","children":[{"level":3,"title":"1. 使用合适的类加载器","slug":"_1-使用合适的类加载器","link":"#_1-使用合适的类加载器","children":[]},{"level":3,"title":"2. 监视类文件的变化","slug":"_2-监视类文件的变化","link":"#_2-监视类文件的变化","children":[]},{"level":3,"title":"3. 动态加载新的类","slug":"_3-动态加载新的类","link":"#_3-动态加载新的类","children":[]},{"level":3,"title":"4. 更新已加载类的实例","slug":"_4-更新已加载类的实例","link":"#_4-更新已加载类的实例","children":[]},{"level":3,"title":"5. 卸载旧的类","slug":"_5-卸载旧的类","link":"#_5-卸载旧的类","children":[]},{"level":3,"title":"6. 错误处理和回滚","slug":"_6-错误处理和回滚","link":"#_6-错误处理和回滚","children":[]},{"level":3,"title":"7. 测试和验证","slug":"_7-测试和验证","link":"#_7-测试和验证","children":[]}]},{"level":2,"title":"为什么自定义类加载器，有时是重写loadclass方法，有时是重写findClass方法，有时是重写defineClass方法？","slug":"为什么自定义类加载器-有时是重写loadclass方法-有时是重写findclass方法-有时是重写defineclass方法","link":"#为什么自定义类加载器-有时是重写loadclass方法-有时是重写findclass方法-有时是重写defineclass方法","children":[]},{"level":2,"title":"Tomcat的类加载机制了解吗？","slug":"tomcat的类加载机制了解吗","link":"#tomcat的类加载机制了解吗","children":[]}],"git":{"createdTime":1716433868000,"updatedTime":1716433868000,"contributors":[{"name":"daiwencheng","email":"1319105206@qq.com","commits":1}]},"readingTime":{"minutes":25.13,"words":7538},"filePathRelative":"Java/JVM/虚拟机执行.md","localizedDate":"2024年5月23日","excerpt":"<h2> 能说一下类的生命周期吗？</h2>\\n<p>是的，一个类在Java虚拟机（JVM）中从加载到卸载整个生命周期包括以下七个阶段：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）。其中，验证、准备和解析三个阶段合称为连接（Linking）。以下是对每个阶段的详细解释：</p>\\n<h3> 1. 加载（Loading）</h3>\\n<ul>\\n<li><strong>描述</strong>：将类的字节码文件加载到内存中，并创建一个代表该类的<code>Class</code>对象。</li>\\n<li><strong>细节</strong>：JVM通过类加载器（ClassLoader）读取字节码文件（.class文件），将其转换为内存中的数据结构，并生成一个<code>Class</code>对象来表示该类。</li>\\n</ul>","autoDesc":true}');export{l as data};
